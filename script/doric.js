(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.testing = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 */

var emptyFunction = require('./emptyFunction');

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if ("production" !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
},{"./emptyFunction":9}],3:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;
},{}],4:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;
},{}],5:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

var camelize = require('./camelize');

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;
},{"./camelize":4}],6:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var isTextNode = require('./isTextNode');

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;
},{"./isTextNode":19}],7:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var invariant = require('./invariant');

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
  // in old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? "production" !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

  !(typeof length === 'number') ? "production" !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

  !(length === 0 || length - 1 in obj) ? "production" !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

  !(typeof obj.callee !== 'function') ? "production" !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
},{"./invariant":17}],8:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

var ExecutionEnvironment = require('./ExecutionEnvironment');

var createArrayFromMixed = require('./createArrayFromMixed');
var getMarkupWrap = require('./getMarkupWrap');
var invariant = require('./invariant');

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? "production" !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? "production" !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = Array.from(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
},{"./ExecutionEnvironment":3,"./createArrayFromMixed":7,"./getMarkupWrap":13,"./invariant":17}],9:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],10:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyObject = {};

if ("production" !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
},{}],11:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;
},{}],12:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 */
function getActiveElement() /*?DOMElement*/{
  if (typeof document === 'undefined') {
    return null;
  }
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;
},{}],13:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/*eslint-disable fb-www/unsafe-html */

var ExecutionEnvironment = require('./ExecutionEnvironment');

var invariant = require('./invariant');

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? "production" !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
},{"./ExecutionEnvironment":3,"./invariant":17}],14:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;
},{}],15:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;
},{}],16:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

var hyphenate = require('./hyphenate');

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;
},{"./hyphenate":15}],17:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if ("production" !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
},{}],18:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;
},{}],19:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var isNode = require('./isNode');

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;
},{"./isNode":18}],20:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @typechecks static-only
 */

'use strict';

/**
 * Memoizes the return value of a function that accepts one string argument.
 */

function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;
},{}],21:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};
},{"./ExecutionEnvironment":3}],22:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var performance = require('./performance');

var performanceNow;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance.now) {
  performanceNow = function performanceNow() {
    return performance.now();
  };
} else {
  performanceNow = function performanceNow() {
    return Date.now();
  };
}

module.exports = performanceNow;
},{"./performance":21}],23:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;
},{}],24:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ("production" !== 'production') {
  (function () {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  })();
}

module.exports = warning;
},{"./emptyFunction":9}],25:[function(require,module,exports){
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    arguments: true,
    arity: true
};

var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
        var keys = Object.getOwnPropertyNames(sourceComponent);

        /* istanbul ignore else */
        if (isGetOwnPropertySymbolsAvailable) {
            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
                try {
                    targetComponent[keys[i]] = sourceComponent[keys[i]];
                } catch (error) {

                }
            }
        }
    }

    return targetComponent;
};

},{}],26:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("production" !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

},{}],27:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],28:[function(require,module,exports){
'use strict';
var strictUriEncode = require('strict-uri-encode');
var objectAssign = require('object-assign');

function encoderForArrayFormat(opts) {
	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, index) {
				return value === null ? [
					encode(key, opts),
					'[',
					index,
					']'
				].join('') : [
					encode(key, opts),
					'[',
					encode(index, opts),
					']=',
					encode(value, opts)
				].join('');
			};

		case 'bracket':
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'[]=',
					encode(value, opts)
				].join('');
			};

		default:
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'=',
					encode(value, opts)
				].join('');
			};
	}
}

function parserForArrayFormat(opts) {
	var result;

	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, accumulator) {
				result = /\[(\d*)]$/.exec(key);

				key = key.replace(/\[\d*]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return function (key, value, accumulator) {
				result = /(\[])$/.exec(key);

				key = key.replace(/\[]$/, '');

				if (!result || accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		default:
			return function (key, value, accumulator) {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function encode(value, opts) {
	if (opts.encode) {
		return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	} else if (typeof input === 'object') {
		return keysSorter(Object.keys(input)).sort(function (a, b) {
			return Number(a) - Number(b);
		}).map(function (key) {
			return input[key];
		});
	}

	return input;
}

exports.extract = function (str) {
	return str.split('?')[1] || '';
};

exports.parse = function (str, opts) {
	opts = objectAssign({arrayFormat: 'none'}, opts);

	var formatter = parserForArrayFormat(opts);

	// Create an object with no prototype
	// https://github.com/sindresorhus/query-string/issues/47
	var ret = Object.create(null);

	if (typeof str !== 'string') {
		return ret;
	}

	str = str.trim().replace(/^(\?|#|&)/, '');

	if (!str) {
		return ret;
	}

	str.split('&').forEach(function (param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeURIComponent(val);

		formatter(decodeURIComponent(key), val, ret);
	});

	return Object.keys(ret).sort().reduce(function (result, key) {
		var val = ret[key];
		if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
			// Sort object keys, not values
			result[key] = keysSorter(val);
		} else {
			result[key] = val;
		}

		return result;
	}, Object.create(null));
};

exports.stringify = function (obj, opts) {
	var defaults = {
		encode: true,
		strict: true,
		arrayFormat: 'none'
	};

	opts = objectAssign(defaults, opts);

	var formatter = encoderForArrayFormat(opts);

	return obj ? Object.keys(obj).sort().map(function (key) {
		var val = obj[key];

		if (val === undefined) {
			return '';
		}

		if (val === null) {
			return encode(key, opts);
		}

		if (Array.isArray(val)) {
			var result = [];

			val.slice().forEach(function (val2) {
				if (val2 === undefined) {
					return;
				}

				result.push(formatter(key, val2, result.length));
			});

			return result.join('&');
		}

		return encode(key, opts) + '=' + encode(val, opts);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};

},{"object-assign":27,"strict-uri-encode":231}],29:[function(require,module,exports){
'use strict';

module.exports = require('./lib/ReactDOM');

},{"./lib/ReactDOM":59}],30:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ARIADOMPropertyConfig = {
  Properties: {
    // Global States and Properties
    'aria-current': 0, // state
    'aria-details': 0,
    'aria-disabled': 0, // state
    'aria-hidden': 0, // state
    'aria-invalid': 0, // state
    'aria-keyshortcuts': 0,
    'aria-label': 0,
    'aria-roledescription': 0,
    // Widget Attributes
    'aria-autocomplete': 0,
    'aria-checked': 0,
    'aria-expanded': 0,
    'aria-haspopup': 0,
    'aria-level': 0,
    'aria-modal': 0,
    'aria-multiline': 0,
    'aria-multiselectable': 0,
    'aria-orientation': 0,
    'aria-placeholder': 0,
    'aria-pressed': 0,
    'aria-readonly': 0,
    'aria-required': 0,
    'aria-selected': 0,
    'aria-sort': 0,
    'aria-valuemax': 0,
    'aria-valuemin': 0,
    'aria-valuenow': 0,
    'aria-valuetext': 0,
    // Live Region Attributes
    'aria-atomic': 0,
    'aria-busy': 0,
    'aria-live': 0,
    'aria-relevant': 0,
    // Drag-and-Drop Attributes
    'aria-dropeffect': 0,
    'aria-grabbed': 0,
    // Relationship Attributes
    'aria-activedescendant': 0,
    'aria-colcount': 0,
    'aria-colindex': 0,
    'aria-colspan': 0,
    'aria-controls': 0,
    'aria-describedby': 0,
    'aria-errormessage': 0,
    'aria-flowto': 0,
    'aria-labelledby': 0,
    'aria-owns': 0,
    'aria-posinset': 0,
    'aria-rowcount': 0,
    'aria-rowindex': 0,
    'aria-rowspan': 0,
    'aria-setsize': 0
  },
  DOMAttributeNames: {},
  DOMPropertyNames: {}
};

module.exports = ARIADOMPropertyConfig;
},{}],31:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var focusNode = require('fbjs/lib/focusNode');

var AutoFocusUtils = {
  focusDOMComponent: function () {
    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
  }
};

module.exports = AutoFocusUtils;
},{"./ReactDOMComponentTree":62,"fbjs/lib/focusNode":11}],32:[function(require,module,exports){
/**
 * Copyright 2013-present Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var FallbackCompositionState = require('./FallbackCompositionState');
var SyntheticCompositionEvent = require('./SyntheticCompositionEvent');
var SyntheticInputEvent = require('./SyntheticInputEvent');

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (currentComposition) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;
},{"./EventPropagators":48,"./FallbackCompositionState":49,"./SyntheticCompositionEvent":113,"./SyntheticInputEvent":117,"fbjs/lib/ExecutionEnvironment":3}],33:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * CSS properties which accept numbers but are not in units of "px".
 */

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridColumn: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;
},{}],34:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactInstrumentation = require('./ReactInstrumentation');

var camelizeStyleName = require('fbjs/lib/camelizeStyleName');
var dangerousStyleValue = require('./dangerousStyleValue');
var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');
var memoizeStringOnly = require('fbjs/lib/memoizeStringOnly');
var warning = require('fbjs/lib/warning');

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if ("production" !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;

  var warnHyphenatedStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    "production" !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
  };

  var warnBadVendoredStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    "production" !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
  };

  var warnStyleValueWithSemicolon = function (name, value, owner) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    "production" !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
  };

  var warnStyleValueIsNaN = function (name, value, owner) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    "production" !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
  };

  var checkRenderMessage = function (owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  };

  /**
   * @param {string} name
   * @param {*} value
   * @param {ReactDOMComponent} component
   */
  var warnValidStyle = function (name, value, component) {
    var owner;
    if (component) {
      owner = component._currentElement._owner;
    }
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, owner);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, owner);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, owner);
    }

    if (typeof value === 'number' && isNaN(value)) {
      warnStyleValueIsNaN(name, value, owner);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @param {ReactDOMComponent} component
   * @return {?string}
   */
  createMarkupForStyles: function (styles, component) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if ("production" !== 'production') {
        warnValidStyle(styleName, styleValue, component);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: component._debugID,
        type: 'update styles',
        payload: styles
      });
    }

    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if ("production" !== 'production') {
        warnValidStyle(styleName, styles[styleName], component);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
      if (styleName === 'float' || styleName === 'cssFloat') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

module.exports = CSSPropertyOperations;
},{"./CSSProperty":33,"./ReactInstrumentation":91,"./dangerousStyleValue":130,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/camelizeStyleName":5,"fbjs/lib/hyphenateStyleName":16,"fbjs/lib/memoizeStringOnly":20,"fbjs/lib/warning":24}],35:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PooledClass = require('./PooledClass');

var invariant = require('fbjs/lib/invariant');

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
  function CallbackQueue(arg) {
    _classCallCheck(this, CallbackQueue);

    this._callbacks = null;
    this._contexts = null;
    this._arg = arg;
  }

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */


  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
    this._callbacks = this._callbacks || [];
    this._callbacks.push(callback);
    this._contexts = this._contexts || [];
    this._contexts.push(context);
  };

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */


  CallbackQueue.prototype.notifyAll = function notifyAll() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    var arg = this._arg;
    if (callbacks && contexts) {
      !(callbacks.length === contexts.length) ? "production" !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i], arg);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  };

  CallbackQueue.prototype.checkpoint = function checkpoint() {
    return this._callbacks ? this._callbacks.length : 0;
  };

  CallbackQueue.prototype.rollback = function rollback(len) {
    if (this._callbacks && this._contexts) {
      this._callbacks.length = len;
      this._contexts.length = len;
    }
  };

  /**
   * Resets the internal queue.
   *
   * @internal
   */


  CallbackQueue.prototype.reset = function reset() {
    this._callbacks = null;
    this._contexts = null;
  };

  /**
   * `PooledClass` looks for this.
   */


  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.addPoolingTo(CallbackQueue);
},{"./PooledClass":53,"./reactProdInvariant":149,"fbjs/lib/invariant":17}],36:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');
var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');
var isEventSupported = require('./isEventSupported');
var isTextInputElement = require('./isTextInputElement');

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementInst = null;
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}
function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  // IE10+ fire input events to often, such when a placeholder
  // changes or when an input with a placeholder is focused.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
}

/**
 * (For IE <=11) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For IE <=11) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
  // on DOM elements
  Object.defineProperty(activeElement, 'value', newValueProp);
  if (activeElement.attachEvent) {
    activeElement.attachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.addEventListener('propertychange', handlePropertyChange, false);
  }
}

/**
 * (For IE <=11) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;

  if (activeElement.detachEvent) {
    activeElement.detachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
  }

  activeElement = null;
  activeElementInst = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For IE <=11) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetInstForInputEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput') {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return targetInst;
  }
}

function handleEventsForInputEventIE(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9-11, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventIE(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementInst;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return targetInst;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      if (doesChangeEventBubble) {
        getTargetInstFunc = getTargetInstForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
        event.type = 'change';
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }
  }

};

module.exports = ChangeEventPlugin;
},{"./EventPluginHub":45,"./EventPropagators":48,"./ReactDOMComponentTree":62,"./ReactUpdates":106,"./SyntheticEvent":115,"./getEventTarget":138,"./isEventSupported":146,"./isTextInputElement":147,"fbjs/lib/ExecutionEnvironment":3}],37:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMLazyTree = require('./DOMLazyTree');
var Danger = require('./Danger');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstrumentation = require('./ReactInstrumentation');

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
var setInnerHTML = require('./setInnerHTML');
var setTextContent = require('./setTextContent');

function getNodeAfter(parentNode, node) {
  // Special case for text components, which return [open, close] comments
  // from getHostNode.
  if (Array.isArray(node)) {
    node = node[1];
  }
  return node ? node.nextSibling : parentNode.firstChild;
}

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
  // We rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
  // we are careful to use `null`.)
  parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
  if (Array.isArray(childNode)) {
    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
  } else {
    insertChildAt(parentNode, childNode, referenceNode);
  }
}

function removeChild(parentNode, childNode) {
  if (Array.isArray(childNode)) {
    var closingComment = childNode[1];
    childNode = childNode[0];
    removeDelimitedText(parentNode, childNode, closingComment);
    parentNode.removeChild(closingComment);
  }
  parentNode.removeChild(childNode);
}

function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
  var node = openingComment;
  while (true) {
    var nextNode = node.nextSibling;
    insertChildAt(parentNode, node, referenceNode);
    if (node === closingComment) {
      break;
    }
    node = nextNode;
  }
}

function removeDelimitedText(parentNode, startNode, closingComment) {
  while (true) {
    var node = startNode.nextSibling;
    if (node === closingComment) {
      // The closing comment is removed by ReactMultiChild.
      break;
    } else {
      parentNode.removeChild(node);
    }
  }
}

function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn't empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if ("production" !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
      type: 'replace text',
      payload: stringText
    });
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if ("production" !== 'production') {
  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
    if (prevInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: prevInstance._debugID,
        type: 'replace with',
        payload: markup.toString()
      });
    } else {
      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
      if (nextInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: nextInstance._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

  replaceDelimitedText: replaceDelimitedText,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  processUpdates: function (parentNode, updates) {
    if ("production" !== 'production') {
      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
    }

    for (var k = 0; k < updates.length; k++) {
      var update = updates[k];
      switch (update.type) {
        case 'INSERT_MARKUP':
          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'insert child',
              payload: { toIndex: update.toIndex, content: update.content.toString() }
            });
          }
          break;
        case 'MOVE_EXISTING':
          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'move child',
              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
            });
          }
          break;
        case 'SET_MARKUP':
          setInnerHTML(parentNode, update.content);
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace children',
              payload: update.content.toString()
            });
          }
          break;
        case 'TEXT_CONTENT':
          setTextContent(parentNode, update.content);
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace text',
              payload: update.content.toString()
            });
          }
          break;
        case 'REMOVE_NODE':
          removeChild(parentNode, update.fromNode);
          if ("production" !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'remove child',
              payload: { fromIndex: update.fromIndex }
            });
          }
          break;
      }
    }
  }

};

module.exports = DOMChildrenOperations;
},{"./DOMLazyTree":38,"./Danger":42,"./ReactDOMComponentTree":62,"./ReactInstrumentation":91,"./createMicrosoftUnsafeLocalFunction":129,"./setInnerHTML":151,"./setTextContent":152}],38:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMNamespaces = require('./DOMNamespaces');
var setInnerHTML = require('./setInnerHTML');

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
var setTextContent = require('./setTextContent');

var ELEMENT_NODE_TYPE = 1;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * In IE (8-11) and Edge, appending nodes with no children is dramatically
 * faster than appending a full subtree, so we essentially queue up the
 * .appendChild calls here and apply them so each node is added to its parent
 * before any children are added.
 *
 * In other browsers, doing so is slower or neutral compared to the other order
 * (in Firefox, twice as slow) so we only do this inversion in IE.
 *
 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
 */
var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

function insertTreeChildren(tree) {
  if (!enableLazy) {
    return;
  }
  var node = tree.node;
  var children = tree.children;
  if (children.length) {
    for (var i = 0; i < children.length; i++) {
      insertTreeBefore(node, children[i], null);
    }
  } else if (tree.html != null) {
    setInnerHTML(node, tree.html);
  } else if (tree.text != null) {
    setTextContent(node, tree.text);
  }
}

var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
  // DocumentFragments aren't actually part of the DOM after insertion so
  // appending children won't update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some <object> plugins (like Flash Player) will read
  // <param> nodes immediately upon insertion into the DOM, so <object>
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
});

function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}

function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}

function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    setInnerHTML(tree.node, html);
  }
}

function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent(tree.node, text);
  }
}

function toString() {
  return this.node.nodeName;
}

function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}

DOMLazyTree.insertTreeBefore = insertTreeBefore;
DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
DOMLazyTree.queueChild = queueChild;
DOMLazyTree.queueHTML = queueHTML;
DOMLazyTree.queueText = queueText;

module.exports = DOMLazyTree;
},{"./DOMNamespaces":39,"./createMicrosoftUnsafeLocalFunction":129,"./setInnerHTML":151,"./setTextContent":152}],39:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMNamespaces = {
  html: 'http://www.w3.org/1999/xhtml',
  mathml: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg'
};

module.exports = DOMNamespaces;
},{}],40:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? "production" !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? "production" !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

      if ("production" !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if ("production" !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',
  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   *
   * autofocus is predefined, because adding it to the property whitelist
   * causes unintended side effects.
   *
   * @type {Object}
   */
  getPossibleStandardName: "production" !== 'production' ? { autofocus: 'autoFocus' } : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
},{"./reactProdInvariant":149,"fbjs/lib/invariant":17}],41:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstrumentation = require('./ReactInstrumentation');

var quoteAttributeValueForBrowser = require('./quoteAttributeValueForBrowser');
var warning = require('fbjs/lib/warning');

var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  "production" !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  createMarkupForRoot: function () {
    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
  },

  setAttributeForRoot: function (node) {
    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
        return;
      } else if (propertyInfo.mustUseProperty) {
        // Contrary to `setAttribute`, object properties are properly
        // `toString`ed by IE8/9.
        node[propertyInfo.propertyName] = value;
      } else {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
      return;
    }

    if ("production" !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }

    if ("production" !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  /**
   * Deletes an attributes from a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForAttribute: function (node, name) {
    node.removeAttribute(name);
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        if (propertyInfo.hasBooleanValue) {
          node[propName] = false;
        } else {
          node[propName] = '';
        }
      } else {
        node.removeAttribute(propertyInfo.attributeName);
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    }

    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  }

};

module.exports = DOMPropertyOperations;
},{"./DOMProperty":40,"./ReactDOMComponentTree":62,"./ReactInstrumentation":91,"./quoteAttributeValueForBrowser":148,"fbjs/lib/warning":24}],42:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMLazyTree = require('./DOMLazyTree');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var createNodesFromMarkup = require('fbjs/lib/createNodesFromMarkup');
var emptyFunction = require('fbjs/lib/emptyFunction');
var invariant = require('fbjs/lib/invariant');

var Danger = {

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
    !markup ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
    !(oldChild.nodeName !== 'HTML') ? "production" !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

    if (typeof markup === 'string') {
      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree.replaceChildWithTree(oldChild, markup);
    }
  }

};

module.exports = Danger;
},{"./DOMLazyTree":38,"./reactProdInvariant":149,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/createNodesFromMarkup":8,"fbjs/lib/emptyFunction":9,"fbjs/lib/invariant":17}],43:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */

var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

module.exports = DefaultEventPluginOrder;
},{}],44:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');

var eventTypes = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }

};

module.exports = EnterLeaveEventPlugin;
},{"./EventPropagators":48,"./ReactDOMComponentTree":62,"./SyntheticMouseEvent":119}],45:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var EventPluginRegistry = require('./EventPluginRegistry');
var EventPluginUtils = require('./EventPluginUtils');
var ReactErrorUtils = require('./ReactErrorUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var invariant = require('fbjs/lib/invariant');

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

var getDictionaryKey = function (inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  /**
   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {function} listener The callback to store.
   */
  putListener: function (inst, registrationName, listener) {
    !(typeof listener === 'function') ? "production" !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[key] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

  /**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (inst, registrationName) {
    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
    // live here; needs to be moved to a better place soon
    var bankForRegistrationName = listenerBank[registrationName];
    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
      return null;
    }
    var key = getDictionaryKey(inst);
    return bankForRegistrationName && bankForRegistrationName[key];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (inst, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      var key = getDictionaryKey(inst);
      delete bankForRegistrationName[key];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {object} inst The instance, which is the source of events.
   */
  deleteAllListeners: function (inst) {
    var key = getDictionaryKey(inst);
    for (var registrationName in listenerBank) {
      if (!listenerBank.hasOwnProperty(registrationName)) {
        continue;
      }

      if (!listenerBank[registrationName][key]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }

      delete listenerBank[registrationName][key];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? "production" !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

module.exports = EventPluginHub;
},{"./EventPluginRegistry":46,"./EventPluginUtils":47,"./ReactErrorUtils":82,"./accumulateInto":126,"./forEachAccumulated":134,"./reactProdInvariant":149,"fbjs/lib/invariant":17}],46:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? "production" !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? "production" !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  if ("production" !== 'production') {
    var lowerCasedName = registrationName.toLowerCase();
    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in __DEV__.
   * @type {Object}
   */
  possibleRegistrationNames: "production" !== 'production' ? {} : null,
  // Trust the developer to only use possibleRegistrationNames in __DEV__

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (injectedEventPluginOrder) {
    !!eventPluginOrder ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
    // Clone the ordering so it cannot be dynamically mutated.
    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var pluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
        !!namesToPlugins[pluginName] ? "production" !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
        namesToPlugins[pluginName] = pluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    if (dispatchConfig.phasedRegistrationNames !== undefined) {
      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
      // that it is not undefined.
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

      for (var phase in phasedRegistrationNames) {
        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
          continue;
        }
        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
        if (pluginModule) {
          return pluginModule;
        }
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    eventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }

    if ("production" !== 'production') {
      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
      for (var lowerCasedName in possibleRegistrationNames) {
        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
          delete possibleRegistrationNames[lowerCasedName];
        }
      }
    }
  }

};

module.exports = EventPluginRegistry;
},{"./reactProdInvariant":149,"fbjs/lib/invariant":17}],47:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactErrorUtils = require('./ReactErrorUtils');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Injected dependencies:
 */

/**
 * - `ComponentTree`: [required] Module that can convert between React instances
 *   and actual node references.
 */
var ComponentTree;
var TreeTraversal;
var injection = {
  injectComponentTree: function (Injected) {
    ComponentTree = Injected;
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
    }
  },
  injectTreeTraversal: function (Injected) {
    TreeTraversal = Injected;
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
    }
  }
};

function isEndish(topLevelType) {
  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
}

function isMoveish(topLevelType) {
  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
}
function isStartish(topLevelType) {
  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
}

var validateEventDispatches;
if ("production" !== 'production') {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    "production" !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if ("production" !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if ("production" !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchInstances[i])) {
        return dispatchInstances[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchInstances)) {
      return dispatchInstances;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if ("production" !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? "production" !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getInstanceFromNode: function (node) {
    return ComponentTree.getInstanceFromNode(node);
  },
  getNodeFromInstance: function (node) {
    return ComponentTree.getNodeFromInstance(node);
  },
  isAncestor: function (a, b) {
    return TreeTraversal.isAncestor(a, b);
  },
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
},{"./ReactErrorUtils":82,"./reactProdInvariant":149,"fbjs/lib/invariant":17,"fbjs/lib/warning":24}],48:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');
var EventPluginUtils = require('./EventPluginUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var warning = require('fbjs/lib/warning');

var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  if ("production" !== 'production') {
    "production" !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
},{"./EventPluginHub":45,"./EventPluginUtils":47,"./accumulateInto":126,"./forEachAccumulated":134,"fbjs/lib/warning":24}],49:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');

var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

_assign(FallbackCompositionState.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;
},{"./PooledClass":53,"./getTextContentAccessor":143,"object-assign":27}],50:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');

var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
  Properties: {
    /**
     * Standard Properties
     */
    accept: 0,
    acceptCharset: 0,
    accessKey: 0,
    action: 0,
    allowFullScreen: HAS_BOOLEAN_VALUE,
    allowTransparency: 0,
    alt: 0,
    // specifies target context for links with `preload` type
    as: 0,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: 0,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_BOOLEAN_VALUE,
    cellPadding: 0,
    cellSpacing: 0,
    charSet: 0,
    challenge: 0,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cite: 0,
    classID: 0,
    className: 0,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: 0,
    content: 0,
    contentEditable: 0,
    contextMenu: 0,
    controls: HAS_BOOLEAN_VALUE,
    coords: 0,
    crossOrigin: 0,
    data: 0, // For `<object />` acts as `src`.
    dateTime: 0,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: 0,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: 0,
    encType: 0,
    form: 0,
    formAction: 0,
    formEncType: 0,
    formMethod: 0,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: 0,
    frameBorder: 0,
    headers: 0,
    height: 0,
    hidden: HAS_BOOLEAN_VALUE,
    high: 0,
    href: 0,
    hrefLang: 0,
    htmlFor: 0,
    httpEquiv: 0,
    icon: 0,
    id: 0,
    inputMode: 0,
    integrity: 0,
    is: 0,
    keyParams: 0,
    keyType: 0,
    kind: 0,
    label: 0,
    lang: 0,
    list: 0,
    loop: HAS_BOOLEAN_VALUE,
    low: 0,
    manifest: 0,
    marginHeight: 0,
    marginWidth: 0,
    max: 0,
    maxLength: 0,
    media: 0,
    mediaGroup: 0,
    method: 0,
    min: 0,
    minLength: 0,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: 0,
    nonce: 0,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: 0,
    pattern: 0,
    placeholder: 0,
    playsInline: HAS_BOOLEAN_VALUE,
    poster: 0,
    preload: 0,
    profile: 0,
    radioGroup: 0,
    readOnly: HAS_BOOLEAN_VALUE,
    referrerPolicy: 0,
    rel: 0,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: 0,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    sandbox: 0,
    scope: 0,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: 0,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: 0,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    sizes: 0,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: 0,
    src: 0,
    srcDoc: 0,
    srcLang: 0,
    srcSet: 0,
    start: HAS_NUMERIC_VALUE,
    step: 0,
    style: 0,
    summary: 0,
    tabIndex: 0,
    target: 0,
    title: 0,
    // Setting .type throws on non-<input> tags
    type: 0,
    useMap: 0,
    value: 0,
    width: 0,
    wmode: 0,
    wrap: 0,

    /**
     * RDFa Properties
     */
    about: 0,
    datatype: 0,
    inlist: 0,
    prefix: 0,
    // property is also supported for OpenGraph in meta tags.
    property: 0,
    resource: 0,
    'typeof': 0,
    vocab: 0,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: 0,
    autoCorrect: 0,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: 0,
    // color is for Safari mask-icon link
    color: 0,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: 0,
    itemScope: HAS_BOOLEAN_VALUE,
    itemType: 0,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: 0,
    itemRef: 0,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: 0,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: 0,
    // IE-only attribute that controls focus behavior
    unselectable: 0
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {}
};

module.exports = HTMLDOMPropertyConfig;
},{"./DOMProperty":40}],51:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;
},{}],52:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var React = require('react/lib/React');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? "production" !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: React.PropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        "production" !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
},{"./ReactPropTypesSecret":99,"./reactProdInvariant":149,"fbjs/lib/invariant":17,"fbjs/lib/warning":24,"react/lib/React":208}],53:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? "production" !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
},{"./reactProdInvariant":149,"fbjs/lib/invariant":17}],54:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var EventPluginRegistry = require('./EventPluginRegistry');
var ReactEventEmitterMixin = require('./ReactEventEmitterMixin');
var ViewportMetrics = require('./ViewportMetrics');

var getVendorPrefixedEventName = require('./getVendorPrefixedEventName');
var isEventSupported = require('./isEventSupported');

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var hasEventPageXY;
var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === 'topWheel') {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === 'topScroll') {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening.topBlur = true;
          isListening.topFocus = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Protect against document.createEvent() returning null
   * Some popup blocker extensions appear to do this:
   * https://github.com/facebook/react/issues/6887
   */
  supportsEventPageXY: function () {
    if (!document.createEvent) {
      return false;
    }
    var ev = document.createEvent('MouseEvent');
    return ev != null && 'pageX' in ev;
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
   * pageX/pageY isn't supported (legacy browsers).
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
    }
    if (!hasEventPageXY && !isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  }

});

module.exports = ReactBrowserEventEmitter;
},{"./EventPluginRegistry":46,"./ReactEventEmitterMixin":83,"./ViewportMetrics":125,"./getVendorPrefixedEventName":144,"./isEventSupported":146,"object-assign":27}],55:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactReconciler = require('./ReactReconciler');

var instantiateReactComponent = require('./instantiateReactComponent');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
}

function instantiateChild(childInstances, child, name, selfDebugID) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if ("production" !== 'production') {
    if (!ReactComponentTreeHook) {
      ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
    }
    if (!keyUnique) {
      "production" !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
    }
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, true);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
  ) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};

    if ("production" !== 'production') {
      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
        return instantiateChild(childInsts, child, name, selfDebugID);
      }, childInstances);
    } else {
      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    }
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
  ) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return;
    }
    var name;
    var prevChild;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
          ReactReconciler.unmountComponent(prevChild, false);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, true);
        nextChildren[name] = nextChildInstance;
        // Creating mount image now ensures refs are resolved in right order
        // (see https://github.com/facebook/react/pull/7101 for explanation).
        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
        mountImages.push(nextChildMountImage);
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        prevChild = prevChildren[name];
        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
        ReactReconciler.unmountComponent(prevChild, false);
      }
    }
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren, safely) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild, safely);
      }
    }
  }

};

module.exports = ReactChildReconciler;
}).call(this,require('_process'))

},{"./KeyEscapeUtils":51,"./ReactReconciler":101,"./instantiateReactComponent":145,"./shouldUpdateReactComponent":153,"./traverseAllChildren":154,"_process":1,"fbjs/lib/warning":24,"react/lib/ReactComponentTreeHook":212}],56:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var ReactDOMIDOperations = require('./ReactDOMIDOperations');

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup

};

module.exports = ReactComponentBrowserEnvironment;
},{"./DOMChildrenOperations":37,"./ReactDOMIDOperations":66}],57:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkup: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? "production" !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;
},{"./reactProdInvariant":149,"fbjs/lib/invariant":17}],58:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var React = require('react/lib/React');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactErrorUtils = require('./ReactErrorUtils');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactNodeTypes = require('./ReactNodeTypes');
var ReactReconciler = require('./ReactReconciler');

if ("production" !== 'production') {
  var checkReactTypeSpec = require('./checkReactTypeSpec');
}

var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var shallowEqual = require('fbjs/lib/shallowEqual');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

var CompositeTypes = {
  ImpureClass: 0,
  PureClass: 1,
  StatelessFunctional: 2
};

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  var element = Component(this.props, this.context, this.updater);
  warnIfInvalidElement(Component, element);
  return element;
};

function warnIfInvalidElement(Component, element) {
  if ("production" !== 'production') {
    "production" !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
    "production" !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
  }
}

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

function isPureComponent(Component) {
  return !!(Component.prototype && Component.prototype.isPureReactComponent);
}

// Separated into a function to contain deoptimizations caused by try/finally.
function measureLifeCyclePerf(fn, debugID, timerType) {
  if (debugID === 0) {
    // Top-level wrappers (see ReactMount) and empty components (see
    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
    // Both are implementation details that should go away in the future.
    return fn();
  }

  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponent = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = 0;
    this._compositeType = null;
    this._instance = null;
    this._hostParent = null;
    this._hostContainerInfo = null;

    // See ReactUpdateQueue
    this._updateBatchNumber = null;
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;

    // ComponentWillUnmount shall only be called once
    this._calledComponentWillUnmount = false;

    if ("production" !== 'production') {
      this._warnedAboutRefsInRender = false;
    }
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} hostParent
   * @param {?object} hostContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var _this = this;

    this._context = context;
    this._mountOrder = nextMountID++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var publicProps = this._currentElement.props;
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    var updateQueue = transaction.getUpdateQueue();

    // Initialize the public class
    var doConstruct = shouldConstruct(Component);
    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
    var renderedElement;

    // Support functional components
    if (!doConstruct && (inst == null || inst.render == null)) {
      renderedElement = inst;
      warnIfInvalidElement(Component, renderedElement);
      !(inst === null || inst === false || React.isValidElement(inst)) ? "production" !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
      inst = new StatelessComponent(Component);
      this._compositeType = CompositeTypes.StatelessFunctional;
    } else {
      if (isPureComponent(Component)) {
        this._compositeType = CompositeTypes.PureClass;
      } else {
        this._compositeType = CompositeTypes.ImpureClass;
      }
    }

    if ("production" !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        "production" !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
      }

      var propsMutated = inst.props !== publicProps;
      var componentName = Component.displayName || Component.name || 'Component';

      "production" !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = updateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if ("production" !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      "production" !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
      "production" !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
      "production" !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
      "production" !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? "production" !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } else {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }

    if (inst.componentDidMount) {
      if ("production" !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(function () {
            return inst.componentDidMount();
          }, _this._debugID, 'componentDidMount');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
      }
    }

    return markup;
  },

  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
    if ("production" !== 'production') {
      ReactCurrentOwner.current = this;
      try {
        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
    }
  },

  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
    var Component = this._currentElement.type;

    if (doConstruct) {
      if ("production" !== 'production') {
        return measureLifeCyclePerf(function () {
          return new Component(publicProps, publicContext, updateQueue);
        }, this._debugID, 'ctor');
      } else {
        return new Component(publicProps, publicContext, updateQueue);
      }
    }

    // This can still be an instance in case of factory components
    // but we'll count this as time spent rendering as the more common case.
    if ("production" !== 'production') {
      return measureLifeCyclePerf(function () {
        return Component(publicProps, publicContext, updateQueue);
      }, this._debugID, 'render');
    } else {
      return Component(publicProps, publicContext, updateQueue);
    }
  },

  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
      transaction.rollback(checkpoint);
      this._instance.unstable_handleError(e);
      if (this._pendingStateQueue) {
        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
      }
      checkpoint = transaction.checkpoint();

      this._renderedComponent.unmountComponent(true);
      transaction.rollback(checkpoint);

      // Try again - we've informed the component about the error, so they can render an error message this time.
      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }
    return markup;
  },

  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var inst = this._instance;

    var debugID = 0;
    if ("production" !== 'production') {
      debugID = this._debugID;
    }

    if (inst.componentWillMount) {
      if ("production" !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillMount();
        }, debugID, 'componentWillMount');
      } else {
        inst.componentWillMount();
      }
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    var nodeType = ReactNodeTypes.getType(renderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
    );
    this._renderedComponent = child;

    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

    if ("production" !== 'production') {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    return markup;
  },

  getHostNode: function () {
    return ReactReconciler.getHostNode(this._renderedComponent);
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (safely) {
    if (!this._renderedComponent) {
      return;
    }

    var inst = this._instance;

    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
      inst._calledComponentWillUnmount = true;

      if (safely) {
        var name = this.getName() + '.componentWillUnmount()';
        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
      } else {
        if ("production" !== 'production') {
          measureLifeCyclePerf(function () {
            return inst.componentWillUnmount();
          }, this._debugID, 'componentWillUnmount');
        } else {
          inst.componentWillUnmount();
        }
      }
    }

    if (this._renderedComponent) {
      ReactReconciler.unmountComponent(this._renderedComponent, safely);
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._instance = null;
    }

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = 0;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    var maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if ("production" !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext;

    if (inst.getChildContext) {
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
        try {
          childContext = inst.getChildContext();
        } finally {
          ReactInstrumentation.debugTool.onEndProcessingChildContext();
        }
      } else {
        childContext = inst.getChildContext();
      }
    }

    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? "production" !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
      if ("production" !== 'production') {
        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? "production" !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
      }
      return _assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Assert that the context types are valid
   *
   * @param {object} typeSpecs Map of context field to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkContextTypes: function (typeSpecs, values, location) {
    if ("production" !== 'production') {
      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    } else {
      this._updateBatchNumber = null;
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;
    !(inst != null) ? "production" !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

    var willReceive = false;
    var nextContext;

    // Determine if the context has changed or not
    if (this._context === nextUnmaskedContext) {
      nextContext = inst.context;
    } else {
      nextContext = this._processContext(nextUnmaskedContext);
      willReceive = true;
    }

    var prevProps = prevParentElement.props;
    var nextProps = nextParentElement.props;

    // Not a simple state update but a props update
    if (prevParentElement !== nextParentElement) {
      willReceive = true;
    }

    // An update here will schedule an update but immediately set
    // _pendingStateQueue which will ensure that any state updates gets
    // immediately reconciled instead of waiting for the next batch.
    if (willReceive && inst.componentWillReceiveProps) {
      if ("production" !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillReceiveProps(nextProps, nextContext);
        }, this._debugID, 'componentWillReceiveProps');
      } else {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);
    var shouldUpdate = true;

    if (!this._pendingForceUpdate) {
      if (inst.shouldComponentUpdate) {
        if ("production" !== 'production') {
          shouldUpdate = measureLifeCyclePerf(function () {
            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
          }, this._debugID, 'shouldComponentUpdate');
        } else {
          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        }
      } else {
        if (this._compositeType === CompositeTypes.PureClass) {
          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
        }
      }
    }

    if ("production" !== 'production') {
      "production" !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
    }

    this._updateBatchNumber = null;
    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var _this2 = this;

    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      if ("production" !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillUpdate(nextProps, nextState, nextContext);
        }, this._debugID, 'componentWillUpdate');
      } else {
        inst.componentWillUpdate(nextProps, nextState, nextContext);
      }
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      if ("production" !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
      }
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();

    var debugID = 0;
    if ("production" !== 'production') {
      debugID = this._debugID;
    }

    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
      ReactReconciler.unmountComponent(prevComponentInstance, false);

      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
      );
      this._renderedComponent = child;

      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

      if ("production" !== 'production') {
        if (debugID !== 0) {
          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
        }
      }

      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
    }
  },

  /**
   * Overridden in shallow rendering.
   *
   * @protected
   */
  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedElement;

    if ("production" !== 'production') {
      renderedElement = measureLifeCyclePerf(function () {
        return inst.render();
      }, this._debugID, 'render');
    } else {
      renderedElement = inst.render();
    }

    if ("production" !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (renderedElement === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedElement = null;
      }
    }

    return renderedElement;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedElement;
    if ("production" !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
      ReactCurrentOwner.current = this;
      try {
        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? "production" !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

    return renderedElement;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? "production" !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
    var publicComponentInstance = component.getPublicInstance();
    if ("production" !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      "production" !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (this._compositeType === CompositeTypes.StatelessFunctional) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null

};

module.exports = ReactCompositeComponent;
},{"./ReactComponentEnvironment":57,"./ReactErrorUtils":82,"./ReactInstanceMap":90,"./ReactInstrumentation":91,"./ReactNodeTypes":96,"./ReactReconciler":101,"./checkReactTypeSpec":128,"./reactProdInvariant":149,"./shouldUpdateReactComponent":153,"fbjs/lib/emptyObject":10,"fbjs/lib/invariant":17,"fbjs/lib/shallowEqual":23,"fbjs/lib/warning":24,"object-assign":27,"react/lib/React":208,"react/lib/ReactCurrentOwner":213}],59:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

'use strict';

var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactMount = require('./ReactMount');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdates = require('./ReactUpdates');
var ReactVersion = require('./ReactVersion');

var findDOMNode = require('./findDOMNode');
var getHostComponentFromComposite = require('./getHostComponentFromComposite');
var renderSubtreeIntoContainer = require('./renderSubtreeIntoContainer');
var warning = require('fbjs/lib/warning');

ReactDefaultInjection.inject();

var ReactDOM = {
  findDOMNode: findDOMNode,
  render: ReactMount.render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    ComponentTree: {
      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
      getNodeFromInstance: function (inst) {
        // inst is an internal instance (but could be a composite)
        if (inst._renderedComponent) {
          inst = getHostComponentFromComposite(inst);
        }
        if (inst) {
          return ReactDOMComponentTree.getNodeFromInstance(inst);
        } else {
          return null;
        }
      }
    },
    Mount: ReactMount,
    Reconciler: ReactReconciler
  });
}

if ("production" !== 'production') {
  var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        // Firefox does not have the issue with devtools loaded over file://
        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    var testFunc = function testFn() {};
    "production" !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    "production" !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        "production" !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
        break;
      }
    }
  }
}

if ("production" !== 'production') {
  var ReactInstrumentation = require('./ReactInstrumentation');
  var ReactDOMUnknownPropertyHook = require('./ReactDOMUnknownPropertyHook');
  var ReactDOMNullInputValuePropHook = require('./ReactDOMNullInputValuePropHook');
  var ReactDOMInvalidARIAHook = require('./ReactDOMInvalidARIAHook');

  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
}

module.exports = ReactDOM;
},{"./ReactDOMComponentTree":62,"./ReactDOMInvalidARIAHook":68,"./ReactDOMNullInputValuePropHook":69,"./ReactDOMUnknownPropertyHook":76,"./ReactDefaultInjection":79,"./ReactInstrumentation":91,"./ReactMount":94,"./ReactReconciler":101,"./ReactUpdates":106,"./ReactVersion":107,"./findDOMNode":132,"./getHostComponentFromComposite":139,"./renderSubtreeIntoContainer":150,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/warning":24}],60:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* global hasOwnProperty:true */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var AutoFocusUtils = require('./AutoFocusUtils');
var CSSPropertyOperations = require('./CSSPropertyOperations');
var DOMLazyTree = require('./DOMLazyTree');
var DOMNamespaces = require('./DOMNamespaces');
var DOMProperty = require('./DOMProperty');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var EventPluginHub = require('./EventPluginHub');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMInput = require('./ReactDOMInput');
var ReactDOMOption = require('./ReactDOMOption');
var ReactDOMSelect = require('./ReactDOMSelect');
var ReactDOMTextarea = require('./ReactDOMTextarea');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactMultiChild = require('./ReactMultiChild');
var ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');

var emptyFunction = require('fbjs/lib/emptyFunction');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var isEventSupported = require('./isEventSupported');
var shallowEqual = require('fbjs/lib/shallowEqual');
var validateDOMNesting = require('./validateDOMNesting');
var warning = require('fbjs/lib/warning');

var Flags = ReactDOMComponentFlags;
var deleteListener = EventPluginHub.deleteListener;
var getNode = ReactDOMComponentTree.getNodeFromInstance;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = EventPluginRegistry.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var STYLE = 'style';
var HTML = '__html';
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null
};

// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
var DOC_FRAGMENT_TYPE = 11;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined because undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  "production" !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[component._tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? "production" !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? "production" !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? "production" !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
  }
  if ("production" !== 'production') {
    "production" !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
    "production" !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
    "production" !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
  }
  !(props.style == null || typeof props.style === 'object') ? "production" !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
}

function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  if ("production" !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    "production" !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  listenTo(registrationName, doc);
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.postMountWrapper(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}

function optionPostMount() {
  var inst = this;
  ReactDOMOption.postMountWrapper(inst);
}

var setAndValidateContentChildDev = emptyFunction;
if ("production" !== 'production') {
  setAndValidateContentChildDev = function (content) {
    var hasExistingContent = this._contentDebugID != null;
    var debugID = this._debugID;
    // This ID represents the inlined child that has no backing instance:
    var contentDebugID = -debugID;

    if (content == null) {
      if (hasExistingContent) {
        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
      }
      this._contentDebugID = null;
      return;
    }

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? "production" !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
  var node = getNode(inst);
  !node ? "production" !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

  switch (inst._tag) {
    case 'iframe':
    case 'object':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'video':
    case 'audio':

      inst._wrapperState.listeners = [];
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
        }
      }
      break;
    case 'source':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
      break;
    case 'input':
    case 'select':
    case 'textarea':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
      break;
  }
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? "production" !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
    validatedTagCache[tag] = true;
  }
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

var globalIdCounter = 1;

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if ("production" !== 'production') {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?ReactDOMComponent} the parent component instance
   * @param {?object} info about the host container
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    this._rootNodeID = globalIdCounter++;
    this._domID = hostContainerInfo._idCounter++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, hostParent);
        props = ReactDOMInput.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, hostParent);
        props = ReactDOMOption.getHostProps(this, props);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, hostParent);
        props = ReactDOMSelect.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, hostParent);
        props = ReactDOMTextarea.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
    }

    assertValidProps(this, props);

    // We create tags in the namespace of their parent container, except HTML
    // tags get no namespace.
    var namespaceURI;
    var parentTag;
    if (hostParent != null) {
      namespaceURI = hostParent._namespaceURI;
      parentTag = hostParent._tag;
    } else if (hostContainerInfo._tag) {
      namespaceURI = hostContainerInfo._namespaceURI;
      parentTag = hostContainerInfo._tag;
    }
    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
      namespaceURI = DOMNamespaces.html;
    }
    if (namespaceURI === DOMNamespaces.html) {
      if (this._tag === 'svg') {
        namespaceURI = DOMNamespaces.svg;
      } else if (this._tag === 'math') {
        namespaceURI = DOMNamespaces.mathml;
      }
    }
    this._namespaceURI = namespaceURI;

    if ("production" !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo._tag) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(this._tag, null, this, parentInfo);
      }
      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var el;
      if (namespaceURI === DOMNamespaces.html) {
        if (this._tag === 'script') {
          // Create the script via .innerHTML so its "parser-inserted" flag is
          // set to true and it does not execute
          var div = ownerDocument.createElement('div');
          var type = this._currentElement.type;
          div.innerHTML = '<' + type + '></' + type + '>';
          el = div.removeChild(div.firstChild);
        } else if (props.is) {
          el = ownerDocument.createElement(this._currentElement.type, props.is);
        } else {
          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
          // See discussion in https://github.com/facebook/react/pull/6896
          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
          el = ownerDocument.createElement(this._currentElement.type);
        }
      } else {
        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
      }
      ReactDOMComponentTree.precacheNode(this, el);
      this._flags |= Flags.hasCachedChildNodes;
      if (!this._hostParent) {
        DOMPropertyOperations.setAttributeForRoot(el);
      }
      this._updateDOMProperties(null, props, transaction);
      var lazyTree = DOMLazyTree(el);
      this._createInitialChildren(transaction, props, context, lazyTree);
      mountImage = lazyTree;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(inputPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'textarea':
        transaction.getReactMountReady().enqueue(textareaPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'select':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'button':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'option':
        transaction.getReactMountReady().enqueue(optionPostMount, this);
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if ("production" !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = _assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    if (!this._hostParent) {
      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
    }
    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
    return ret;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
        if ("production" !== 'production') {
          setAndValidateContentChildDev.call(this, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, lazyTree) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      // TODO: Validate that text is allowed as a child of this node
      if (contentToUse != null) {
        // Avoid setting textContent when the text is empty. In IE11 setting
        // textContent on a text area will cause the placeholder to not
        // show within the textarea until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        if (contentToUse !== '') {
          if ("production" !== 'production') {
            setAndValidateContentChildDev.call(this, contentToUse);
          }
          DOMLazyTree.queueText(lazyTree, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'input':
        lastProps = ReactDOMInput.getHostProps(this, lastProps);
        nextProps = ReactDOMInput.getHostProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getHostProps(this, lastProps);
        nextProps = ReactDOMOption.getHostProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
        break;
      case 'textarea':
        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
        break;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    switch (this._tag) {
      case 'input':
        // Update the wrapper around inputs *after* updating props. This has to
        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
        // raise warnings and prevent the new value from being assigned.
        ReactDOMInput.updateWrapper(this);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        break;
      case 'select':
        // <select> value update needs to occur after <option> children
        // reconciliation
        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
        break;
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, lastProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if ("production" !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = _assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        var node = getNode(this);
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
        if ("production" !== 'production') {
          setAndValidateContentChildDev.call(this, nextContent);
        }
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
      if ("production" !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    } else if (nextChildren != null) {
      if ("production" !== 'production') {
        setAndValidateContentChildDev.call(this, null);
      }

      this.updateChildren(nextChildren, transaction, context);
    }
  },

  getHostNode: function () {
    return getNode(this);
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function (safely) {
    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
        !false ? "production" !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
        break;
    }

    this.unmountChildren(safely);
    ReactDOMComponentTree.uncacheNode(this);
    EventPluginHub.deleteAllListeners(this);
    this._rootNodeID = 0;
    this._domID = 0;
    this._wrapperState = null;

    if ("production" !== 'production') {
      setAndValidateContentChildDev.call(this, null);
    }
  },

  getPublicInstance: function () {
    return getNode(this);
  }

};

_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
},{"./AutoFocusUtils":31,"./CSSPropertyOperations":34,"./DOMLazyTree":38,"./DOMNamespaces":39,"./DOMProperty":40,"./DOMPropertyOperations":41,"./EventPluginHub":45,"./EventPluginRegistry":46,"./ReactBrowserEventEmitter":54,"./ReactDOMComponentFlags":61,"./ReactDOMComponentTree":62,"./ReactDOMInput":67,"./ReactDOMOption":70,"./ReactDOMSelect":71,"./ReactDOMTextarea":74,"./ReactInstrumentation":91,"./ReactMultiChild":95,"./ReactServerRenderingTransaction":103,"./escapeTextContentForBrowser":131,"./isEventSupported":146,"./reactProdInvariant":149,"./validateDOMNesting":155,"fbjs/lib/emptyFunction":9,"fbjs/lib/invariant":17,"fbjs/lib/shallowEqual":23,"fbjs/lib/warning":24,"object-assign":27}],61:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMComponentFlags = {
  hasCachedChildNodes: 1 << 0
};

module.exports = ReactDOMComponentFlags;
},{}],62:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMProperty = require('./DOMProperty');
var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');

var invariant = require('fbjs/lib/invariant');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var Flags = ReactDOMComponentFlags;

var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

/**
 * Check if a given node should be cached.
 */
function shouldPrecacheNode(node, nodeID) {
  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
}

/**
 * Drill down (through composites and empty components) until we get a host or
 * host text component.
 *
 * This is pretty polymorphic but unavoidable with the current structure we have
 * for `_renderedChildren`.
 */
function getRenderedHostOrTextFromComponent(component) {
  var rendered;
  while (rendered = component._renderedComponent) {
    component = rendered;
  }
  return component;
}

/**
 * Populate `_hostNode` on the rendered host/text component with the given
 * DOM node. The passed `inst` can be a composite.
 */
function precacheNode(inst, node) {
  var hostInst = getRenderedHostOrTextFromComponent(inst);
  hostInst._hostNode = node;
  node[internalInstanceKey] = hostInst;
}

function uncacheNode(inst) {
  var node = inst._hostNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._hostNode = null;
  }
}

/**
 * Populate `_hostNode` on each child of `inst`, assuming that the children
 * match up with the DOM (element) children of `node`.
 *
 * We cache entire levels at once to avoid an n^2 problem where we access the
 * children of a node sequentially and have to walk from the start to our target
 * node every time.
 *
 * Since we update `_renderedChildren` and the actual DOM at (slightly)
 * different times, we could race here and see a newer `_renderedChildren` than
 * the DOM nodes we see. To avoid this, ReactMultiChild calls
 * `prepareToManageChildren` before we change `_renderedChildren`, at which
 * time the container's child nodes are always cached (until it unmounts).
 */
function precacheChildNodes(inst, node) {
  if (inst._flags & Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
    if (childID === 0) {
      // We're currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (shouldPrecacheNode(childNode, childID)) {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
    !false ? "production" !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
  }
  inst._flags |= Flags.hasCachedChildNodes;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null && inst._hostNode === node) {
    return inst;
  } else {
    return null;
  }
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._hostNode !== undefined) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  if (inst._hostNode) {
    return inst._hostNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._hostNode) {
    parents.push(inst);
    !inst._hostParent ? "production" !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
    inst = inst._hostParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._hostNode);
  }

  return inst._hostNode;
}

var ReactDOMComponentTree = {
  getClosestInstanceFromNode: getClosestInstanceFromNode,
  getInstanceFromNode: getInstanceFromNode,
  getNodeFromInstance: getNodeFromInstance,
  precacheChildNodes: precacheChildNodes,
  precacheNode: precacheNode,
  uncacheNode: uncacheNode
};

module.exports = ReactDOMComponentTree;
},{"./DOMProperty":40,"./ReactDOMComponentFlags":61,"./reactProdInvariant":149,"fbjs/lib/invariant":17}],63:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var validateDOMNesting = require('./validateDOMNesting');

var DOC_NODE_TYPE = 9;

function ReactDOMContainerInfo(topLevelWrapper, node) {
  var info = {
    _topLevelWrapper: topLevelWrapper,
    _idCounter: 1,
    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
    _node: node,
    _tag: node ? node.nodeName.toLowerCase() : null,
    _namespaceURI: node ? node.namespaceURI : null
  };
  if ("production" !== 'production') {
    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
  }
  return info;
}

module.exports = ReactDOMContainerInfo;
},{"./validateDOMNesting":155}],64:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var DOMLazyTree = require('./DOMLazyTree');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
};
_assign(ReactDOMEmptyComponent.prototype, {
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var domID = hostContainerInfo._idCounter++;
    this._domID = domID;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var nodeValue = ' react-empty: ' + this._domID + ' ';
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var node = ownerDocument.createComment(nodeValue);
      ReactDOMComponentTree.precacheNode(this, node);
      return DOMLazyTree(node);
    } else {
      if (transaction.renderToStaticMarkup) {
        // Normally we'd insert a comment node, but since this is a situation
        // where React won't take over (static pages), we can simply return
        // nothing.
        return '';
      }
      return '<!--' + nodeValue + '-->';
    }
  },
  receiveComponent: function () {},
  getHostNode: function () {
    return ReactDOMComponentTree.getNodeFromInstance(this);
  },
  unmountComponent: function () {
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMEmptyComponent;
},{"./DOMLazyTree":38,"./ReactDOMComponentTree":62,"object-assign":27}],65:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMFeatureFlags = {
  useCreateElement: true,
  useFiber: false
};

module.exports = ReactDOMFeatureFlags;
},{}],66:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
    DOMChildrenOperations.processUpdates(node, updates);
  }
};

module.exports = ReactDOMIDOperations;
},{"./DOMChildrenOperations":37,"./ReactDOMComponentTree":62}],67:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var DOMPropertyOperations = require('./DOMPropertyOperations');
var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnCheckedLink = false;
var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function (inst, props) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var hostProps = _assign({
      // Make sure we set .type before any other properties (setting .value
      // before .type means .value is lost in IE11 and below)
      type: undefined,
      // Make sure we set .step before .value (setting .value before .step
      // means .value is rounded on mount, based upon step precision)
      step: undefined,
      // Make sure we set .min & .max before .value (to ensure proper order
      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
      min: undefined,
      max: undefined
    }, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if ("production" !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

      var owner = inst._currentElement._owner;

      if (props.valueLink !== undefined && !didWarnValueLink) {
        "production" !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
        "production" !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnCheckedLink = true;
      }
      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
        "production" !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnCheckedDefaultChecked = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        "production" !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnValueDefaultValue = true;
      }
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
      initialValue: props.value != null ? props.value : defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };

    if ("production" !== 'production') {
      inst._wrapperState.controlled = isControlled(props);
    }
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    if ("production" !== 'production') {
      var controlled = isControlled(props);
      var owner = inst._currentElement._owner;

      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
        "production" !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnUncontrolledToControlled = true;
      }
      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
        "production" !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnControlledToUncontrolled = true;
      }
    }

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
    }

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {

      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
    } else {
      if (props.value == null && props.defaultValue != null) {
        // In Chrome, assigning defaultValue to certain input types triggers input validation.
        // For number inputs, the display value loses trailing decimal points. For email inputs,
        // Chrome raises "The specified value <x> is not a valid email address".
        //
        // Here we check to see if the defaultValue has actually changed, avoiding these problems
        // when the user is inputting text
        //
        // https://github.com/facebook/react/issues/7253
        if (node.defaultValue !== '' + props.defaultValue) {
          node.defaultValue = '' + props.defaultValue;
        }
      }
      if (props.checked == null && props.defaultChecked != null) {
        node.defaultChecked = !!props.defaultChecked;
      }
    }
  },

  postMountWrapper: function (inst) {
    var props = inst._currentElement.props;

    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

    // Detach value from defaultValue. We won't do anything if we're working on
    // submit or reset inputs as those values & defaultValues are linked. They
    // are not resetable nodes so this operation doesn't matter and actually
    // removes browser-default values (eg "Submit Query") when no value is
    // provided.

    switch (props.type) {
      case 'submit':
      case 'reset':
        break;
      case 'color':
      case 'date':
      case 'datetime':
      case 'datetime-local':
      case 'month':
      case 'time':
      case 'week':
        // This fixes the no-show issue on iOS Safari and Android Chrome:
        // https://github.com/facebook/react/issues/7233
        node.value = '';
        node.value = node.defaultValue;
        break;
      default:
        node.value = node.value;
        break;
    }

    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
    // this is needed to work around a chrome bug where setting defaultChecked
    // will sometimes influence the value of checked (even after detachment).
    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
    // We need to temporarily unset name to avoid disrupting radio button groups.
    var name = node.name;
    if (name !== '') {
      node.name = '';
    }
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !node.defaultChecked;
    if (name !== '') {
      node.name = name;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
      !otherInstance ? "production" !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
},{"./DOMPropertyOperations":41,"./LinkedValueUtils":52,"./ReactDOMComponentTree":62,"./ReactUpdates":106,"./reactProdInvariant":149,"fbjs/lib/invariant":17,"fbjs/lib/warning":24,"object-assign":27}],68:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');

var warning = require('fbjs/lib/warning');

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

function validateProperty(tagName, name, debugID) {
  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
    return true;
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      "production" !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(debugID, element) {
  var invalidProps = [];

  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    "production" !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (invalidProps.length > 1) {
    "production" !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
}

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }

  warnInvalidARIAProps(debugID, element);
}

var ReactDOMInvalidARIAHook = {
  onBeforeMountComponent: function (debugID, element) {
    if ("production" !== 'production') {
      handleElement(debugID, element);
    }
  },
  onBeforeUpdateComponent: function (debugID, element) {
    if ("production" !== 'production') {
      handleElement(debugID, element);
    }
  }
};

module.exports = ReactDOMInvalidARIAHook;
},{"./DOMProperty":40,"fbjs/lib/warning":24,"react/lib/ReactComponentTreeHook":212}],69:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');

var warning = require('fbjs/lib/warning');

var didWarnValueNull = false;

function handleElement(debugID, element) {
  if (element == null) {
    return;
  }
  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
    return;
  }
  if (element.props != null && element.props.value === null && !didWarnValueNull) {
    "production" !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

    didWarnValueNull = true;
  }
}

var ReactDOMNullInputValuePropHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMNullInputValuePropHook;
},{"fbjs/lib/warning":24,"react/lib/ReactComponentTreeHook":212}],70:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var React = require('react/lib/React');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMSelect = require('./ReactDOMSelect');

var warning = require('fbjs/lib/warning');
var didWarnInvalidOptionChildren = false;

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    } else if (!didWarnInvalidOptionChildren) {
      didWarnInvalidOptionChildren = true;
      "production" !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function (inst, props, hostParent) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if ("production" !== 'production') {
      "production" !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
    }

    // Look up whether this option is 'selected'
    var selectValue = null;
    if (hostParent != null) {
      var selectParent = hostParent;

      if (selectParent._tag === 'optgroup') {
        selectParent = selectParent._hostParent;
      }

      if (selectParent != null && selectParent._tag === 'select') {
        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
      }
    }

    // If the value is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      var value;
      if (props.value != null) {
        value = props.value + '';
      } else {
        value = flattenChildren(props.children);
      }
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  postMountWrapper: function (inst) {
    // value="" should make a value attribute (#6219)
    var props = inst._currentElement.props;
    if (props.value != null) {
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      node.setAttribute('value', props.value);
    }
  },

  getHostProps: function (inst, props) {
    var hostProps = _assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      hostProps.selected = inst._wrapperState.selected;
    }

    var content = flattenChildren(props.children);

    if (content) {
      hostProps.children = content;
    }

    return hostProps;
  }

};

module.exports = ReactDOMOption;
},{"./ReactDOMComponentTree":62,"./ReactDOMSelect":71,"fbjs/lib/warning":24,"object-assign":27,"react/lib/React":208}],71:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnValueDefaultValue = false;

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  if (props.valueLink !== undefined && !didWarnValueLink) {
    "production" !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
    didWarnValueLink = true;
  }

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      "production" !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    } else if (!props.multiple && isArray) {
      "production" !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  getHostProps: function (inst, props) {
    return _assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    if ("production" !== 'production') {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      "production" !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
      didWarnValueDefaultValue = true;
    }
  },

  getSelectValueContext: function (inst) {
    // ReactDOMOption looks at this initial value so the initial generated
    // markup has correct `selected` attributes
    return inst._wrapperState.initialValue;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // this value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  if (this._rootNodeID) {
    this._wrapperState.pendingUpdate = true;
  }
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
},{"./LinkedValueUtils":52,"./ReactDOMComponentTree":62,"./ReactUpdates":106,"fbjs/lib/warning":24,"object-assign":27}],72:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var getNodeForCharacterOffset = require('./getNodeForCharacterOffset');
var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (offsets.end === undefined) {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;
},{"./getNodeForCharacterOffset":142,"./getTextContentAccessor":143,"fbjs/lib/ExecutionEnvironment":3}],73:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var DOMChildrenOperations = require('./DOMChildrenOperations');
var DOMLazyTree = require('./DOMLazyTree');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var validateDOMNesting = require('./validateDOMNesting');

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings between comment nodes so that they
 * can undergo the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
};

_assign(ReactDOMTextComponent.prototype, {

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    if ("production" !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo != null) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(null, this._stringText, this, parentInfo);
      }
    }

    var domID = hostContainerInfo._idCounter++;
    var openingValue = ' react-text: ' + domID + ' ';
    var closingValue = ' /react-text ';
    this._domID = domID;
    this._hostParent = hostParent;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var openingComment = ownerDocument.createComment(openingValue);
      var closingComment = ownerDocument.createComment(closingValue);
      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
      if (this._stringText) {
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
      }
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
      ReactDOMComponentTree.precacheNode(this, openingComment);
      this._closingComment = closingComment;
      return lazyTree;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this between comment nodes for the reasons stated
        // above, but since this is a situation where React won't take over
        // (static pages), we can simply return the text as it is.
        return escapedText;
      }

      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var commentNodes = this.getHostNode();
        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
      }
    }
  },

  getHostNode: function () {
    var hostNode = this._commentNodes;
    if (hostNode) {
      return hostNode;
    }
    if (!this._closingComment) {
      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
      var node = openingComment.nextSibling;
      while (true) {
        !(node != null) ? "production" !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
          this._closingComment = node;
          break;
        }
        node = node.nextSibling;
      }
    }
    hostNode = [this._hostNode, this._closingComment];
    this._commentNodes = hostNode;
    return hostNode;
  },

  unmountComponent: function () {
    this._closingComment = null;
    this._commentNodes = null;
    ReactDOMComponentTree.uncacheNode(this);
  }

});

module.exports = ReactDOMTextComponent;
},{"./DOMChildrenOperations":37,"./DOMLazyTree":38,"./ReactDOMComponentTree":62,"./escapeTextContentForBrowser":131,"./reactProdInvariant":149,"./validateDOMNesting":155,"fbjs/lib/invariant":17,"object-assign":27}],74:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnValDefaultVal = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getHostProps: function (inst, props) {
    !(props.dangerouslySetInnerHTML == null) ? "production" !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.  We could add a check in setTextContent
    // to only set the value if/when the value differs from the node value (which would
    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
    // The value can be a boolean or object so that's why it's forced to be a string.
    var hostProps = _assign({}, props, {
      value: undefined,
      defaultValue: undefined,
      children: '' + inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if ("production" !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
      if (props.valueLink !== undefined && !didWarnValueLink) {
        "production" !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
        "production" !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
        didWarnValDefaultVal = true;
      }
    }

    var value = LinkedValueUtils.getValue(props);
    var initialValue = value;

    // Only bother fetching default value if we're going to use it
    if (value == null) {
      var defaultValue = props.defaultValue;
      // TODO (yungsters): Remove support for children content in <textarea>.
      var children = props.children;
      if (children != null) {
        if ("production" !== 'production') {
          "production" !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
        }
        !(defaultValue == null) ? "production" !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
        if (Array.isArray(children)) {
          !(children.length <= 1) ? "production" !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
          children = children[0];
        }

        defaultValue = '' + children;
      }
      if (defaultValue == null) {
        defaultValue = '';
      }
      initialValue = defaultValue;
    }

    inst._wrapperState = {
      initialValue: '' + initialValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
      if (props.defaultValue == null) {
        node.defaultValue = newValue;
      }
    }
    if (props.defaultValue != null) {
      node.defaultValue = props.defaultValue;
    }
  },

  postMountWrapper: function (inst) {
    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var textContent = node.textContent;

    // Only set node.value if textContent is equal to the expected
    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
    // will populate textContent as well.
    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
    if (textContent === inst._wrapperState.initialValue) {
      node.value = textContent;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
},{"./LinkedValueUtils":52,"./ReactDOMComponentTree":62,"./ReactUpdates":106,"./reactProdInvariant":149,"fbjs/lib/invariant":17,"fbjs/lib/warning":24,"object-assign":27}],75:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  !('_hostNode' in instA) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
  !('_hostNode' in instB) ? "production" !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = instA._hostParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = instB._hostParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._hostParent;
    instB = instB._hostParent;
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */
function isAncestor(instA, instB) {
  !('_hostNode' in instA) ? "production" !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
  !('_hostNode' in instB) ? "production" !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._hostParent;
  }
  return false;
}

/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  !('_hostNode' in inst) ? "production" !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

  return inst._hostParent;
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._hostParent;
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from && from !== common) {
    pathFrom.push(from);
    from = from._hostParent;
  }
  var pathTo = [];
  while (to && to !== common) {
    pathTo.push(to);
    to = to._hostParent;
  }
  var i;
  for (i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (i = pathTo.length; i-- > 0;) {
    fn(pathTo[i], 'captured', argTo);
  }
}

module.exports = {
  isAncestor: isAncestor,
  getLowestCommonAncestor: getLowestCommonAncestor,
  getParentInstance: getParentInstance,
  traverseTwoPhase: traverseTwoPhase,
  traverseEnterLeave: traverseEnterLeave
};
},{"./reactProdInvariant":149,"fbjs/lib/invariant":17}],76:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');

var warning = require('fbjs/lib/warning');

if ("production" !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true,

    autoFocus: true,
    defaultValue: true,
    valueLink: true,
    defaultChecked: true,
    checkedLink: true,
    innerHTML: true,
    suppressContentEditableWarning: true,
    onFocusIn: true,
    onFocusOut: true
  };
  var warnedProperties = {};

  var validateProperty = function (tagName, name, debugID) {
    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
      return true;
    }
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return true;
    }
    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
      return true;
    }
    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

    if (standardName != null) {
      "production" !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else if (registrationName != null) {
      "production" !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else {
      // We were unable to guess which prop the user intended.
      // It is likely that the user was just blindly spreading/forwarding props
      // Components should be careful to only render valid props/attributes.
      // Warning will be invoked in warnUnknownProperties to allow grouping.
      return false;
    }
  };
}

var warnUnknownProperties = function (debugID, element) {
  var unknownProps = [];
  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (unknownProps.length === 1) {
    "production" !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (unknownProps.length > 1) {
    "production" !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
};

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }
  warnUnknownProperties(debugID, element);
}

var ReactDOMUnknownPropertyHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMUnknownPropertyHook;
},{"./DOMProperty":40,"./EventPluginRegistry":46,"fbjs/lib/warning":24,"react/lib/ReactComponentTreeHook":212}],77:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactInvalidSetStateWarningHook = require('./ReactInvalidSetStateWarningHook');
var ReactHostOperationHistoryHook = require('./ReactHostOperationHistoryHook');
var ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var performanceNow = require('fbjs/lib/performanceNow');
var warning = require('fbjs/lib/warning');

var hooks = [];
var didHookThrowForEvent = {};

function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
  try {
    fn.call(context, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
    "production" !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
    didHookThrowForEvent[event] = true;
  }
}

function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];
    var fn = hook[event];
    if (fn) {
      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
    }
  }
}

var isProfiling = false;
var flushHistory = [];
var lifeCycleTimerStack = [];
var currentFlushNesting = 0;
var currentFlushMeasurements = [];
var currentFlushStartTime = 0;
var currentTimerDebugID = null;
var currentTimerStartTime = 0;
var currentTimerNestedFlushDuration = 0;
var currentTimerType = null;

var lifeCycleTimerHasWarned = false;

function clearHistory() {
  ReactComponentTreeHook.purgeUnmountedComponents();
  ReactHostOperationHistoryHook.clearHistory();
}

function getTreeSnapshot(registeredIDs) {
  return registeredIDs.reduce(function (tree, id) {
    var ownerID = ReactComponentTreeHook.getOwnerID(id);
    var parentID = ReactComponentTreeHook.getParentID(id);
    tree[id] = {
      displayName: ReactComponentTreeHook.getDisplayName(id),
      text: ReactComponentTreeHook.getText(id),
      updateCount: ReactComponentTreeHook.getUpdateCount(id),
      childIDs: ReactComponentTreeHook.getChildIDs(id),
      // Text nodes don't have owners but this is close enough.
      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
      parentID: parentID
    };
    return tree;
  }, {});
}

function resetMeasurements() {
  var previousStartTime = currentFlushStartTime;
  var previousMeasurements = currentFlushMeasurements;
  var previousOperations = ReactHostOperationHistoryHook.getHistory();

  if (currentFlushNesting === 0) {
    currentFlushStartTime = 0;
    currentFlushMeasurements = [];
    clearHistory();
    return;
  }

  if (previousMeasurements.length || previousOperations.length) {
    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
    flushHistory.push({
      duration: performanceNow() - previousStartTime,
      measurements: previousMeasurements || [],
      operations: previousOperations || [],
      treeSnapshot: getTreeSnapshot(registeredIDs)
    });
  }

  clearHistory();
  currentFlushStartTime = performanceNow();
  currentFlushMeasurements = [];
}

function checkDebugID(debugID) {
  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (allowRoot && debugID === 0) {
    return;
  }
  if (!debugID) {
    "production" !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
  }
}

function beginLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType && !lifeCycleTimerHasWarned) {
    "production" !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  currentTimerStartTime = performanceNow();
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

function endLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
    "production" !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  if (isProfiling) {
    currentFlushMeasurements.push({
      timerType: timerType,
      instanceID: debugID,
      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
    });
  }
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function pauseCurrentLifeCycleTimer() {
  var currentTimer = {
    startTime: currentTimerStartTime,
    nestedFlushStartTime: performanceNow(),
    debugID: currentTimerDebugID,
    timerType: currentTimerType
  };
  lifeCycleTimerStack.push(currentTimer);
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function resumeCurrentLifeCycleTimer() {
  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
      startTime = _lifeCycleTimerStack$.startTime,
      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
      debugID = _lifeCycleTimerStack$.debugID,
      timerType = _lifeCycleTimerStack$.timerType;

  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
  currentTimerStartTime = startTime;
  currentTimerNestedFlushDuration += nestedFlushDuration;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

var lastMarkTimeStamp = 0;
var canUsePerformanceMeasure =
// $FlowFixMe https://github.com/facebook/flow/issues/2345
typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

function shouldMark(debugID) {
  if (!isProfiling || !canUsePerformanceMeasure) {
    return false;
  }
  var element = ReactComponentTreeHook.getElement(debugID);
  if (element == null || typeof element !== 'object') {
    return false;
  }
  var isHostElement = typeof element.type === 'string';
  if (isHostElement) {
    return false;
  }
  return true;
}

function markBegin(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  lastMarkTimeStamp = performanceNow();
  performance.mark(markName);
}

function markEnd(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

  // Chrome has an issue of dropping markers recorded too fast:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
  // To work around this, we will not report very small measurements.
  // I determined the magic number by tweaking it back and forth.
  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
  // When the bug is fixed, we can `measure()` unconditionally if we want to.
  var timeStamp = performanceNow();
  if (timeStamp - lastMarkTimeStamp > 0.1) {
    var measurementName = displayName + ' [' + markType + ']';
    performance.measure(measurementName, markName);
  }

  performance.clearMarks(markName);
  performance.clearMeasures(measurementName);
}

var ReactDebugTool = {
  addHook: function (hook) {
    hooks.push(hook);
  },
  removeHook: function (hook) {
    for (var i = 0; i < hooks.length; i++) {
      if (hooks[i] === hook) {
        hooks.splice(i, 1);
        i--;
      }
    }
  },
  isProfiling: function () {
    return isProfiling;
  },
  beginProfiling: function () {
    if (isProfiling) {
      return;
    }

    isProfiling = true;
    flushHistory.length = 0;
    resetMeasurements();
    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
  },
  endProfiling: function () {
    if (!isProfiling) {
      return;
    }

    isProfiling = false;
    resetMeasurements();
    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
  },
  getFlushHistory: function () {
    return flushHistory;
  },
  onBeginFlush: function () {
    currentFlushNesting++;
    resetMeasurements();
    pauseCurrentLifeCycleTimer();
    emitEvent('onBeginFlush');
  },
  onEndFlush: function () {
    resetMeasurements();
    currentFlushNesting--;
    resumeCurrentLifeCycleTimer();
    emitEvent('onEndFlush');
  },
  onBeginLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
    markBegin(debugID, timerType);
    beginLifeCycleTimer(debugID, timerType);
  },
  onEndLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    endLifeCycleTimer(debugID, timerType);
    markEnd(debugID, timerType);
    emitEvent('onEndLifeCycleTimer', debugID, timerType);
  },
  onBeginProcessingChildContext: function () {
    emitEvent('onBeginProcessingChildContext');
  },
  onEndProcessingChildContext: function () {
    emitEvent('onEndProcessingChildContext');
  },
  onHostOperation: function (operation) {
    checkDebugID(operation.instanceID);
    emitEvent('onHostOperation', operation);
  },
  onSetState: function () {
    emitEvent('onSetState');
  },
  onSetChildren: function (debugID, childDebugIDs) {
    checkDebugID(debugID);
    childDebugIDs.forEach(checkDebugID);
    emitEvent('onSetChildren', debugID, childDebugIDs);
  },
  onBeforeMountComponent: function (debugID, element, parentDebugID) {
    checkDebugID(debugID);
    checkDebugID(parentDebugID, true);
    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
    markBegin(debugID, 'mount');
  },
  onMountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'mount');
    emitEvent('onMountComponent', debugID);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    checkDebugID(debugID);
    emitEvent('onBeforeUpdateComponent', debugID, element);
    markBegin(debugID, 'update');
  },
  onUpdateComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'update');
    emitEvent('onUpdateComponent', debugID);
  },
  onBeforeUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onBeforeUnmountComponent', debugID);
    markBegin(debugID, 'unmount');
  },
  onUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'unmount');
    emitEvent('onUnmountComponent', debugID);
  },
  onTestEvent: function () {
    emitEvent('onTestEvent');
  }
};

// TODO remove these when RN/www gets updated
ReactDebugTool.addDevtool = ReactDebugTool.addHook;
ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
ReactDebugTool.addHook(ReactComponentTreeHook);
var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
if (/[?&]react_perf\b/.test(url)) {
  ReactDebugTool.beginProfiling();
}

module.exports = ReactDebugTool;
},{"./ReactHostOperationHistoryHook":87,"./ReactInvalidSetStateWarningHook":92,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/performanceNow":22,"fbjs/lib/warning":24,"react/lib/ReactComponentTreeHook":212}],78:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactUpdates = require('./ReactUpdates');
var Transaction = require('./Transaction');

var emptyFunction = require('fbjs/lib/emptyFunction');

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
},{"./ReactUpdates":106,"./Transaction":124,"fbjs/lib/emptyFunction":9,"object-assign":27}],79:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ARIADOMPropertyConfig = require('./ARIADOMPropertyConfig');
var BeforeInputEventPlugin = require('./BeforeInputEventPlugin');
var ChangeEventPlugin = require('./ChangeEventPlugin');
var DefaultEventPluginOrder = require('./DefaultEventPluginOrder');
var EnterLeaveEventPlugin = require('./EnterLeaveEventPlugin');
var HTMLDOMPropertyConfig = require('./HTMLDOMPropertyConfig');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDOMComponent = require('./ReactDOMComponent');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMEmptyComponent = require('./ReactDOMEmptyComponent');
var ReactDOMTreeTraversal = require('./ReactDOMTreeTraversal');
var ReactDOMTextComponent = require('./ReactDOMTextComponent');
var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactEventListener = require('./ReactEventListener');
var ReactInjection = require('./ReactInjection');
var ReactReconcileTransaction = require('./ReactReconcileTransaction');
var SVGDOMPropertyConfig = require('./SVGDOMPropertyConfig');
var SelectEventPlugin = require('./SelectEventPlugin');
var SimpleEventPlugin = require('./SimpleEventPlugin');

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}

module.exports = {
  inject: inject
};
},{"./ARIADOMPropertyConfig":30,"./BeforeInputEventPlugin":32,"./ChangeEventPlugin":36,"./DefaultEventPluginOrder":43,"./EnterLeaveEventPlugin":44,"./HTMLDOMPropertyConfig":50,"./ReactComponentBrowserEnvironment":56,"./ReactDOMComponent":60,"./ReactDOMComponentTree":62,"./ReactDOMEmptyComponent":64,"./ReactDOMTextComponent":73,"./ReactDOMTreeTraversal":75,"./ReactDefaultBatchingStrategy":78,"./ReactEventListener":84,"./ReactInjection":88,"./ReactReconcileTransaction":100,"./SVGDOMPropertyConfig":108,"./SelectEventPlugin":109,"./SimpleEventPlugin":110}],80:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;
},{}],81:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyComponentFactory;

var ReactEmptyComponentInjection = {
  injectEmptyComponentFactory: function (factory) {
    emptyComponentFactory = factory;
  }
};

var ReactEmptyComponent = {
  create: function (instantiate) {
    return emptyComponentFactory(instantiate);
  }
};

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;
},{}],82:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if ("production" !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
      var boundFunc = func.bind(null, a);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      // $FlowFixMe https://github.com/facebook/flow/issues/2336
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
},{}],83:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;
},{"./EventPluginHub":45}],84:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var EventListener = require('fbjs/lib/EventListener');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var PooledClass = require('./PooledClass');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var getEventTarget = require('./getEventTarget');
var getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findParent(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst._hostParent) {
    inst = inst._hostParent;
  }
  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
  var container = rootNode.parentNode;
  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
_assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor && findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;
},{"./PooledClass":53,"./ReactDOMComponentTree":62,"./ReactUpdates":106,"./getEventTarget":138,"fbjs/lib/EventListener":2,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/getUnboundedScrollPosition":14,"object-assign":27}],85:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactFeatureFlags = {
  // When true, call console.time() before and .timeEnd() after each top-level
  // render (both initial renders and updates). Useful when looking at prod-mode
  // timeline profiles in Chrome, for example.
  logTopLevelRenders: false
};

module.exports = ReactFeatureFlags;
},{}],86:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

var genericComponentClass = null;
var textComponentClass = null;

var ReactHostComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  }
};

/**
 * Get a host internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? "production" !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
  return new genericComponentClass(element);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactHostComponent = {
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactHostComponentInjection
};

module.exports = ReactHostComponent;
},{"./reactProdInvariant":149,"fbjs/lib/invariant":17}],87:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var history = [];

var ReactHostOperationHistoryHook = {
  onHostOperation: function (operation) {
    history.push(operation);
  },
  clearHistory: function () {
    if (ReactHostOperationHistoryHook._preventClearing) {
      // Should only be used for tests.
      return;
    }

    history = [];
  },
  getHistory: function () {
    return history;
  }
};

module.exports = ReactHostOperationHistoryHook;
},{}],88:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginHub = require('./EventPluginHub');
var EventPluginUtils = require('./EventPluginUtils');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactHostComponent = require('./ReactHostComponent');
var ReactUpdates = require('./ReactUpdates');

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventPluginUtils: EventPluginUtils.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  HostComponent: ReactHostComponent.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;
},{"./DOMProperty":40,"./EventPluginHub":45,"./EventPluginUtils":47,"./ReactBrowserEventEmitter":54,"./ReactComponentEnvironment":57,"./ReactEmptyComponent":81,"./ReactHostComponent":86,"./ReactUpdates":106}],89:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMSelection = require('./ReactDOMSelection');

var containsNode = require('fbjs/lib/containsNode');
var focusNode = require('fbjs/lib/focusNode');
var getActiveElement = require('fbjs/lib/getActiveElement');

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (end === undefined) {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
},{"./ReactDOMSelection":72,"fbjs/lib/containsNode":6,"fbjs/lib/focusNode":11,"fbjs/lib/getActiveElement":12}],90:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;
},{}],91:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

// Trust the developer to only use ReactInstrumentation with a __DEV__ check

var debugTool = null;

if ("production" !== 'production') {
  var ReactDebugTool = require('./ReactDebugTool');
  debugTool = ReactDebugTool;
}

module.exports = { debugTool: debugTool };
},{"./ReactDebugTool":77}],92:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var warning = require('fbjs/lib/warning');

if ("production" !== 'production') {
  var processingChildContext = false;

  var warnInvalidSetState = function () {
    "production" !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
  };
}

var ReactInvalidSetStateWarningHook = {
  onBeginProcessingChildContext: function () {
    processingChildContext = true;
  },
  onEndProcessingChildContext: function () {
    processingChildContext = false;
  },
  onSetState: function () {
    warnInvalidSetState();
  }
};

module.exports = ReactInvalidSetStateWarningHook;
},{"fbjs/lib/warning":24}],93:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var adler32 = require('./adler32');

var TAG_END = /\/?>/;
var COMMENT_START = /^<\!\-\-/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags, comments and self-closing tags)
    if (COMMENT_START.test(markup)) {
      return markup;
    } else {
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    }
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;
},{"./adler32":127}],94:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMLazyTree = require('./DOMLazyTree');
var DOMProperty = require('./DOMProperty');
var React = require('react/lib/React');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMContainerInfo = require('./ReactDOMContainerInfo');
var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
var ReactFeatureFlags = require('./ReactFeatureFlags');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');
var ReactUpdates = require('./ReactUpdates');

var emptyObject = require('fbjs/lib/emptyObject');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');
var setInnerHTML = require('./setInnerHTML');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var instancesByReactRootID = {};

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
  var markerName;
  if (ReactFeatureFlags.logTopLevelRenders) {
    var wrappedElement = wrapperInstance._currentElement.props.child;
    var type = wrappedElement.type;
    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
    console.time(markerName);
  }

  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
  );

  if (markerName) {
    console.timeEnd(markerName);
  }

  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */
  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
  if ("production" !== 'production') {
    ReactInstrumentation.debugTool.onBeginFlush();
  }
  ReactReconciler.unmountComponent(instance, safely);
  if ("production" !== 'production') {
    ReactInstrumentation.debugTool.onEndFlush();
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(container) {
  var rootEl = getReactRootElementInContainer(container);
  if (rootEl) {
    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
    return !!(inst && inst._hostParent);
  }
}

/**
 * True if the supplied DOM node is a React DOM element and
 * it has been rendered by another copy of React.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM has been rendered by another copy of React
 * @internal
 */
function nodeIsRenderedByOtherInstance(container) {
  var rootEl = getReactRootElementInContainer(container);
  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
}

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
}

/**
 * True if the supplied DOM node is a valid React node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid React DOM node.
 * @internal
 */
function isReactNode(node) {
  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
}

function getHostRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
}

function getTopLevelWrapperInContainer(container) {
  var root = getHostRootInstanceInContainer(container);
  return root ? root._hostContainerInfo._topLevelWrapper : null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var topLevelRootCounter = 1;
var TopLevelWrapper = function () {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
if ("production" !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  return this.props.child;
};
TopLevelWrapper.isReactTopLevelWrapper = true;

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {

  TopLevelWrapper: TopLevelWrapper,

  /**
   * Used by devtools. The keys are not important.
   */
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    return prevComponent;
  },

  /**
   * Render a new component into the DOM. Hooked by hooks!
   *
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    "production" !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? "production" !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
    var componentInstance = instantiateReactComponent(nextElement, false);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? "production" !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
    !React.isValidElement(nextElement) ? "production" !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

    "production" !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

    var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

    var nextContext;
    if (parentComponent) {
      var parentInst = ReactInstanceMap.get(parentComponent);
      nextContext = parentInst._processChildContext(parentInst._context);
    } else {
      nextContext = emptyObject;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props.child;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if ("production" !== 'production') {
      "production" !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            "production" !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    "production" !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? "production" !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

    if ("production" !== 'production') {
      "production" !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);
    if (!prevComponent) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

      if ("production" !== 'production') {
        "production" !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
      }

      return false;
    }
    delete instancesByReactRootID[prevComponent._instance.rootID];
    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
    return true;
  },

  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
    !isValidContainer(container) ? "production" !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        ReactDOMComponentTree.precacheNode(instance, rootElement);
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if ("production" !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? "production" !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

        if ("production" !== 'production') {
          "production" !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? "production" !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      DOMLazyTree.insertTreeBefore(container, markup, null);
    } else {
      setInnerHTML(container, markup);
      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
    }

    if ("production" !== 'production') {
      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
      if (hostNode._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: hostNode._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  }
};

module.exports = ReactMount;
},{"./DOMLazyTree":38,"./DOMProperty":40,"./ReactBrowserEventEmitter":54,"./ReactDOMComponentTree":62,"./ReactDOMContainerInfo":63,"./ReactDOMFeatureFlags":65,"./ReactFeatureFlags":85,"./ReactInstanceMap":90,"./ReactInstrumentation":91,"./ReactMarkupChecksum":93,"./ReactReconciler":101,"./ReactUpdateQueue":105,"./ReactUpdates":106,"./instantiateReactComponent":145,"./reactProdInvariant":149,"./setInnerHTML":151,"./shouldUpdateReactComponent":153,"fbjs/lib/emptyObject":10,"fbjs/lib/invariant":17,"fbjs/lib/warning":24,"react/lib/React":208,"react/lib/ReactCurrentOwner":213}],95:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactReconciler = require('./ReactReconciler');
var ReactChildReconciler = require('./ReactChildReconciler');

var emptyFunction = require('fbjs/lib/emptyFunction');
var flattenChildren = require('./flattenChildren');
var invariant = require('fbjs/lib/invariant');

/**
 * Make an update for markup to be rendered and inserted at a supplied index.
 *
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function makeInsertMarkup(markup, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'INSERT_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for moving an existing element to another index.
 *
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function makeMove(child, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'MOVE_EXISTING',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: ReactReconciler.getHostNode(child),
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for removing an element at an index.
 *
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function makeRemove(child, node) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'REMOVE_NODE',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: node,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the markup of a node.
 *
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function makeSetMarkup(markup) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'SET_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the text content.
 *
 * @param {string} textContent Text content to set.
 * @private
 */
function makeTextContent(textContent) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'TEXT_CONTENT',
    content: textContent,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Push an update, if any, onto the queue. Creates a new queue if none is
 * passed and always returns the queue. Mutative.
 */
function enqueue(queue, update) {
  if (update) {
    queue = queue || [];
    queue.push(update);
  }
  return queue;
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if ("production" !== 'production') {
  var getDebugID = function (inst) {
    if (!inst._debugID) {
      // Check for ART-like instances. TODO: This is silly/gross.
      var internal;
      if (internal = ReactInstanceMap.get(inst)) {
        inst = internal;
      }
    }
    return inst._debugID;
  };
  setChildrenForInstrumentation = function (children) {
    var debugID = getDebugID(this);
    // TODO: React Native empty components are also multichild.
    // This means they still get into this method but don't have _debugID.
    if (debugID !== 0) {
      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
        return children[key]._debugID;
      }) : []);
    }
  };
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      if ("production" !== 'production') {
        var selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
      var nextChildren;
      var selfDebugID = 0;
      if ("production" !== 'production') {
        selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
          return nextChildren;
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;

      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var selfDebugID = 0;
          if ("production" !== 'production') {
            selfDebugID = getDebugID(this);
          }
          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }

      if ("production" !== 'production') {
        setChildrenForInstrumentation.call(this, children);
      }

      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          !false ? "production" !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      // Set new text content.
      var updates = [makeTextContent(nextContent)];
      processQueue(this, updates);
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          !false ? "production" !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      var updates = [makeSetMarkup(nextMarkup)];
      processQueue(this, updates);
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      // Hook used by React ART
      this._updateChildren(nextNestedChildrenElements, transaction, context);
    },

    /**
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var mountImages = [];
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var nextIndex = 0;
      var lastIndex = 0;
      // `nextMountIndex` will increment for each newly mounted child.
      var nextMountIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            // The `removedNodes` loop below will actually remove the child.
          }
          // The child must be instantiated before it's mounted.
          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
          nextMountIndex++;
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
      }
      // Remove children that are no longer present.
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;

      if ("production" !== 'production') {
        setChildrenForInstrumentation.call(this, nextChildren);
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted. It does not actually perform any
     * backend operations.
     *
     * @internal
     */
    unmountChildren: function (safely) {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren, safely);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, afterNode, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        return makeMove(child, afterNode, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, afterNode, mountImage) {
      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child, node) {
      return makeRemove(child, node);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
      child._mountIndex = index;
      return this.createChild(child, afterNode, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child, node) {
      var update = this.removeChild(child, node);
      child._mountIndex = null;
      return update;
    }

  }

};

module.exports = ReactMultiChild;
},{"./ReactChildReconciler":55,"./ReactComponentEnvironment":57,"./ReactInstanceMap":90,"./ReactInstrumentation":91,"./ReactReconciler":101,"./flattenChildren":133,"./reactProdInvariant":149,"fbjs/lib/emptyFunction":9,"fbjs/lib/invariant":17,"react/lib/ReactCurrentOwner":213}],96:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var React = require('react/lib/React');

var invariant = require('fbjs/lib/invariant');

var ReactNodeTypes = {
  HOST: 0,
  COMPOSITE: 1,
  EMPTY: 2,

  getType: function (node) {
    if (node === null || node === false) {
      return ReactNodeTypes.EMPTY;
    } else if (React.isValidElement(node)) {
      if (typeof node.type === 'function') {
        return ReactNodeTypes.COMPOSITE;
      } else {
        return ReactNodeTypes.HOST;
      }
    }
    !false ? "production" !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
  }
};

module.exports = ReactNodeTypes;
},{"./reactProdInvariant":149,"fbjs/lib/invariant":17,"react/lib/React":208}],97:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid owner.
 * @final
 */
function isValidOwner(object) {
  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
}

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {
  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !isValidOwner(owner) ? "production" !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !isValidOwner(owner) ? "production" !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`'s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;
},{"./reactProdInvariant":149,"fbjs/lib/invariant":17}],98:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactPropTypeLocationNames = {};

if ("production" !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
},{}],99:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;
},{}],100:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactInputSelection = require('./ReactInputSelection');
var ReactInstrumentation = require('./ReactInstrumentation');
var Transaction = require('./Transaction');
var ReactUpdateQueue = require('./ReactUpdateQueue');

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

if ("production" !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return ReactUpdateQueue;
  },

  /**
   * Save current transaction state -- if the return value from this method is
   * passed to `rollback`, the transaction will be reset to that state.
   */
  checkpoint: function () {
    // reactMountReady is the our only stateful wrapper
    return this.reactMountReady.checkpoint();
  },

  rollback: function (checkpoint) {
    this.reactMountReady.rollback(checkpoint);
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
},{"./CallbackQueue":35,"./PooledClass":53,"./ReactBrowserEventEmitter":54,"./ReactInputSelection":89,"./ReactInstrumentation":91,"./ReactUpdateQueue":105,"./Transaction":124,"object-assign":27}],101:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactRef = require('./ReactRef');
var ReactInstrumentation = require('./ReactInstrumentation');

var warning = require('fbjs/lib/warning');

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} the containing host component instance
   * @param {?object} info about the host container
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
  ) {
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
      }
    }
    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
      }
    }
    return markup;
  },

  /**
   * Returns a value that can be passed to
   * ReactComponentEnvironment.replaceNodeWithMarkup.
   */
  getHostNode: function (internalInstance) {
    return internalInstance.getHostNode();
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance, safely) {
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
      }
    }
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
      }
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }

    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
      // The component's enqueued batch number should always be the current
      // batch or the following one.
      "production" !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
      return;
    }
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
      }
    }
    internalInstance.performUpdateIfNecessary(transaction);
    if ("production" !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  }

};

module.exports = ReactReconciler;
},{"./ReactInstrumentation":91,"./ReactRef":102,"fbjs/lib/warning":24}],102:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactOwner = require('./ReactOwner');

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null && typeof prevElement === 'object') {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }

  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null && typeof nextElement === 'object') {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }

  return prevRef !== nextRef ||
  // If owner changes but we have an unchanged function ref, don't update refs
  typeof nextRef === 'string' && nextOwner !== prevOwner;
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;
},{"./ReactOwner":97}],103:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');
var Transaction = require('./Transaction');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactServerUpdateQueue = require('./ReactServerUpdateQueue');

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [];

if ("production" !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

var noopCallbackQueue = {
  enqueue: function () {}
};

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return noopCallbackQueue;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return this.updateQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {},

  checkpoint: function () {},

  rollback: function () {}
};

_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
},{"./PooledClass":53,"./ReactInstrumentation":91,"./ReactServerUpdateQueue":104,"./Transaction":124,"object-assign":27}],104:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReactUpdateQueue = require('./ReactUpdateQueue');

var warning = require('fbjs/lib/warning');

function warnNoop(publicInstance, callerName) {
  if ("production" !== 'production') {
    var constructor = publicInstance.constructor;
    "production" !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the update queue used for server rendering.
 * It delegates to ReactUpdateQueue while server rendering is in progress and
 * switches to ReactNoopUpdateQueue after the transaction has completed.
 * @class ReactServerUpdateQueue
 * @param {Transaction} transaction
 */

var ReactServerUpdateQueue = function () {
  function ReactServerUpdateQueue(transaction) {
    _classCallCheck(this, ReactServerUpdateQueue);

    this.transaction = transaction;
  }

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */


  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
    return false;
  };

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
    }
  };

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
    } else {
      warnNoop(publicInstance, 'forceUpdate');
    }
  };

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} completeState Next state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
    } else {
      warnNoop(publicInstance, 'replaceState');
    }
  };

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, 'setState');
    }
  };

  return ReactServerUpdateQueue;
}();

module.exports = ReactServerUpdateQueue;
},{"./ReactUpdateQueue":105,"fbjs/lib/warning":24}],105:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function formatUnexpectedArgument(arg) {
  var type = typeof arg;
  if (type !== 'object') {
    return type;
  }
  var displayName = arg.constructor && arg.constructor.name || type;
  var keys = Object.keys(arg);
  if (keys.length > 0 && keys.length < 20) {
    return displayName + ' (keys: ' + keys.join(', ') + ')';
  }
  return displayName;
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if ("production" !== 'production') {
      var ctor = publicInstance.constructor;
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      "production" !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
    }
    return null;
  }

  if ("production" !== 'production') {
    "production" !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    if ("production" !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        "production" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback, callerName) {
    ReactUpdateQueue.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    if ("production" !== 'production') {
      ReactInstrumentation.debugTool.onSetState();
      "production" !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
    }

    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
    internalInstance._pendingElement = nextElement;
    // TODO: introduce _pendingContext instead of setting it directly.
    internalInstance._context = nextContext;
    enqueueUpdate(internalInstance);
  },

  validateCallback: function (callback, callerName) {
    !(!callback || typeof callback === 'function') ? "production" !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
  }

};

module.exports = ReactUpdateQueue;
},{"./ReactInstanceMap":90,"./ReactInstrumentation":91,"./ReactUpdates":106,"./reactProdInvariant":149,"fbjs/lib/invariant":17,"fbjs/lib/warning":24,"react/lib/ReactCurrentOwner":213}],106:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactFeatureFlags = require('./ReactFeatureFlags');
var ReactReconciler = require('./ReactReconciler');
var Transaction = require('./Transaction');

var invariant = require('fbjs/lib/invariant');

var dirtyComponents = [];
var updateBatchNumber = 0;
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */true);
}

_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? "production" !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  // Any updates enqueued while reconciling must be performed after this entire
  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
  // C, B could update twice in a single batch if C's render enqueues an update
  // to B (since B would have already updated, we should skip it, and the only
  // way we can know to do so is by checking the batch counter).
  updateBatchNumber++;

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var namedComponent = component;
      // Duck type TopLevelWrapper. This is probably always true.
      if (component._currentElement.type.isReactTopLevelWrapper) {
        namedComponent = component._renderedComponent;
      }
      markerName = 'React update: ' + namedComponent.getName();
      console.time(markerName);
    }

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

    if (markerName) {
      console.timeEnd(markerName);
    }

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? "production" !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? "production" !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
},{"./CallbackQueue":35,"./PooledClass":53,"./ReactFeatureFlags":85,"./ReactReconciler":101,"./Transaction":124,"./reactProdInvariant":149,"fbjs/lib/invariant":17,"object-assign":27}],107:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

module.exports = '15.4.2';
},{}],108:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

// We use attributes for everything SVG so let's avoid some duplication and run
// code instead.
// The following are all specified in the HTML config already so we exclude here.
// - class (as className)
// - color
// - height
// - id
// - lang
// - max
// - media
// - method
// - min
// - name
// - style
// - target
// - type
// - width
var ATTRS = {
  accentHeight: 'accent-height',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 'alignment-baseline',
  allowReorder: 'allowReorder',
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 'arabic-form',
  ascent: 0,
  attributeName: 'attributeName',
  attributeType: 'attributeType',
  autoReverse: 'autoReverse',
  azimuth: 0,
  baseFrequency: 'baseFrequency',
  baseProfile: 'baseProfile',
  baselineShift: 'baseline-shift',
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 'calcMode',
  capHeight: 'cap-height',
  clip: 0,
  clipPath: 'clip-path',
  clipRule: 'clip-rule',
  clipPathUnits: 'clipPathUnits',
  colorInterpolation: 'color-interpolation',
  colorInterpolationFilters: 'color-interpolation-filters',
  colorProfile: 'color-profile',
  colorRendering: 'color-rendering',
  contentScriptType: 'contentScriptType',
  contentStyleType: 'contentStyleType',
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 'diffuseConstant',
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 'dominant-baseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 'edgeMode',
  elevation: 0,
  enableBackground: 'enable-background',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 'externalResourcesRequired',
  fill: 0,
  fillOpacity: 'fill-opacity',
  fillRule: 'fill-rule',
  filter: 0,
  filterRes: 'filterRes',
  filterUnits: 'filterUnits',
  floodColor: 'flood-color',
  floodOpacity: 'flood-opacity',
  focusable: 0,
  fontFamily: 'font-family',
  fontSize: 'font-size',
  fontSizeAdjust: 'font-size-adjust',
  fontStretch: 'font-stretch',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 'glyph-name',
  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
  glyphOrientationVertical: 'glyph-orientation-vertical',
  glyphRef: 'glyphRef',
  gradientTransform: 'gradientTransform',
  gradientUnits: 'gradientUnits',
  hanging: 0,
  horizAdvX: 'horiz-adv-x',
  horizOriginX: 'horiz-origin-x',
  ideographic: 0,
  imageRendering: 'image-rendering',
  'in': 0,
  in2: 0,
  intercept: 0,
  k: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  kernelMatrix: 'kernelMatrix',
  kernelUnitLength: 'kernelUnitLength',
  kerning: 0,
  keyPoints: 'keyPoints',
  keySplines: 'keySplines',
  keyTimes: 'keyTimes',
  lengthAdjust: 'lengthAdjust',
  letterSpacing: 'letter-spacing',
  lightingColor: 'lighting-color',
  limitingConeAngle: 'limitingConeAngle',
  local: 0,
  markerEnd: 'marker-end',
  markerMid: 'marker-mid',
  markerStart: 'marker-start',
  markerHeight: 'markerHeight',
  markerUnits: 'markerUnits',
  markerWidth: 'markerWidth',
  mask: 0,
  maskContentUnits: 'maskContentUnits',
  maskUnits: 'maskUnits',
  mathematical: 0,
  mode: 0,
  numOctaves: 'numOctaves',
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 'overline-position',
  overlineThickness: 'overline-thickness',
  paintOrder: 'paint-order',
  panose1: 'panose-1',
  pathLength: 'pathLength',
  patternContentUnits: 'patternContentUnits',
  patternTransform: 'patternTransform',
  patternUnits: 'patternUnits',
  pointerEvents: 'pointer-events',
  points: 0,
  pointsAtX: 'pointsAtX',
  pointsAtY: 'pointsAtY',
  pointsAtZ: 'pointsAtZ',
  preserveAlpha: 'preserveAlpha',
  preserveAspectRatio: 'preserveAspectRatio',
  primitiveUnits: 'primitiveUnits',
  r: 0,
  radius: 0,
  refX: 'refX',
  refY: 'refY',
  renderingIntent: 'rendering-intent',
  repeatCount: 'repeatCount',
  repeatDur: 'repeatDur',
  requiredExtensions: 'requiredExtensions',
  requiredFeatures: 'requiredFeatures',
  restart: 0,
  result: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  seed: 0,
  shapeRendering: 'shape-rendering',
  slope: 0,
  spacing: 0,
  specularConstant: 'specularConstant',
  specularExponent: 'specularExponent',
  speed: 0,
  spreadMethod: 'spreadMethod',
  startOffset: 'startOffset',
  stdDeviation: 'stdDeviation',
  stemh: 0,
  stemv: 0,
  stitchTiles: 'stitchTiles',
  stopColor: 'stop-color',
  stopOpacity: 'stop-opacity',
  strikethroughPosition: 'strikethrough-position',
  strikethroughThickness: 'strikethrough-thickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 'stroke-dasharray',
  strokeDashoffset: 'stroke-dashoffset',
  strokeLinecap: 'stroke-linecap',
  strokeLinejoin: 'stroke-linejoin',
  strokeMiterlimit: 'stroke-miterlimit',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  surfaceScale: 'surfaceScale',
  systemLanguage: 'systemLanguage',
  tableValues: 'tableValues',
  targetX: 'targetX',
  targetY: 'targetY',
  textAnchor: 'text-anchor',
  textDecoration: 'text-decoration',
  textRendering: 'text-rendering',
  textLength: 'textLength',
  to: 0,
  transform: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 'underline-position',
  underlineThickness: 'underline-thickness',
  unicode: 0,
  unicodeBidi: 'unicode-bidi',
  unicodeRange: 'unicode-range',
  unitsPerEm: 'units-per-em',
  vAlphabetic: 'v-alphabetic',
  vHanging: 'v-hanging',
  vIdeographic: 'v-ideographic',
  vMathematical: 'v-mathematical',
  values: 0,
  vectorEffect: 'vector-effect',
  version: 0,
  vertAdvY: 'vert-adv-y',
  vertOriginX: 'vert-origin-x',
  vertOriginY: 'vert-origin-y',
  viewBox: 'viewBox',
  viewTarget: 'viewTarget',
  visibility: 0,
  widths: 0,
  wordSpacing: 'word-spacing',
  writingMode: 'writing-mode',
  x: 0,
  xHeight: 'x-height',
  x1: 0,
  x2: 0,
  xChannelSelector: 'xChannelSelector',
  xlinkActuate: 'xlink:actuate',
  xlinkArcrole: 'xlink:arcrole',
  xlinkHref: 'xlink:href',
  xlinkRole: 'xlink:role',
  xlinkShow: 'xlink:show',
  xlinkTitle: 'xlink:title',
  xlinkType: 'xlink:type',
  xmlBase: 'xml:base',
  xmlns: 0,
  xmlnsXlink: 'xmlns:xlink',
  xmlLang: 'xml:lang',
  xmlSpace: 'xml:space',
  y: 0,
  y1: 0,
  y2: 0,
  yChannelSelector: 'yChannelSelector',
  z: 0,
  zoomAndPan: 'zoomAndPan'
};

var SVGDOMPropertyConfig = {
  Properties: {},
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {}
};

Object.keys(ATTRS).forEach(function (key) {
  SVGDOMPropertyConfig.Properties[key] = 0;
  if (ATTRS[key]) {
    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
  }
});

module.exports = SVGDOMPropertyConfig;
},{}],109:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInputSelection = require('./ReactInputSelection');
var SyntheticEvent = require('./SyntheticEvent');

var getActiveElement = require('fbjs/lib/getActiveElement');
var isTextInputElement = require('./isTextInputElement');
var shallowEqual = require('fbjs/lib/shallowEqual');

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement = null;
var activeElementInst = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events. See #3639.
var hasListener = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement = targetNode;
          activeElementInst = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement = null;
        activeElementInst = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (inst, registrationName, listener) {
    if (registrationName === 'onSelect') {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;
},{"./EventPropagators":48,"./ReactDOMComponentTree":62,"./ReactInputSelection":89,"./SyntheticEvent":115,"./isTextInputElement":147,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/getActiveElement":12,"fbjs/lib/shallowEqual":23}],110:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var EventListener = require('fbjs/lib/EventListener');
var EventPropagators = require('./EventPropagators');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var SyntheticAnimationEvent = require('./SyntheticAnimationEvent');
var SyntheticClipboardEvent = require('./SyntheticClipboardEvent');
var SyntheticEvent = require('./SyntheticEvent');
var SyntheticFocusEvent = require('./SyntheticFocusEvent');
var SyntheticKeyboardEvent = require('./SyntheticKeyboardEvent');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');
var SyntheticDragEvent = require('./SyntheticDragEvent');
var SyntheticTouchEvent = require('./SyntheticTouchEvent');
var SyntheticTransitionEvent = require('./SyntheticTransitionEvent');
var SyntheticUIEvent = require('./SyntheticUIEvent');
var SyntheticWheelEvent = require('./SyntheticWheelEvent');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getEventCharCode = require('./getEventCharCode');
var invariant = require('fbjs/lib/invariant');

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

var onClickListeners = {};

function getDictionaryKey(inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topAbort':
      case 'topCanPlay':
      case 'topCanPlayThrough':
      case 'topDurationChange':
      case 'topEmptied':
      case 'topEncrypted':
      case 'topEnded':
      case 'topError':
      case 'topInput':
      case 'topInvalid':
      case 'topLoad':
      case 'topLoadedData':
      case 'topLoadedMetadata':
      case 'topLoadStart':
      case 'topPause':
      case 'topPlay':
      case 'topPlaying':
      case 'topProgress':
      case 'topRateChange':
      case 'topReset':
      case 'topSeeked':
      case 'topSeeking':
      case 'topStalled':
      case 'topSubmit':
      case 'topSuspend':
      case 'topTimeUpdate':
      case 'topVolumeChange':
      case 'topWaiting':
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? "production" !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (inst, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      if (!onClickListeners[key]) {
        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (inst, registrationName) {
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      onClickListeners[key].remove();
      delete onClickListeners[key];
    }
  }

};

module.exports = SimpleEventPlugin;
},{"./EventPropagators":48,"./ReactDOMComponentTree":62,"./SyntheticAnimationEvent":111,"./SyntheticClipboardEvent":112,"./SyntheticDragEvent":114,"./SyntheticEvent":115,"./SyntheticFocusEvent":116,"./SyntheticKeyboardEvent":118,"./SyntheticMouseEvent":119,"./SyntheticTouchEvent":120,"./SyntheticTransitionEvent":121,"./SyntheticUIEvent":122,"./SyntheticWheelEvent":123,"./getEventCharCode":135,"./reactProdInvariant":149,"fbjs/lib/EventListener":2,"fbjs/lib/emptyFunction":9,"fbjs/lib/invariant":17}],111:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

module.exports = SyntheticAnimationEvent;
},{"./SyntheticEvent":115}],112:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;
},{"./SyntheticEvent":115}],113:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;
},{"./SyntheticEvent":115}],114:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;
},{"./SyntheticMouseEvent":119}],115:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');

var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  if ("production" !== 'production') {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    if ("production" !== 'production') {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      // eslint-disable-line valid-typeof
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // eslint-disable-line valid-typeof
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if ("production" !== 'production') {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      } else {
        this[propName] = null;
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    if ("production" !== 'production') {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }

});

SyntheticEvent.Interface = EventInterface;

if ("production" !== 'production') {
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              "production" !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}
/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;

/**
  * Helper to nullify syntheticEvent instance properties when destructing
  *
  * @param {object} SyntheticEvent
  * @param {String} propName
  * @return {object} defineProperty object
  */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    "production" !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
  }
}
},{"./PooledClass":53,"fbjs/lib/emptyFunction":9,"fbjs/lib/warning":24,"object-assign":27}],116:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;
},{"./SyntheticUIEvent":122}],117:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;
},{"./SyntheticEvent":115}],118:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventCharCode = require('./getEventCharCode');
var getEventKey = require('./getEventKey');
var getEventModifierState = require('./getEventModifierState');

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;
},{"./SyntheticUIEvent":122,"./getEventCharCode":135,"./getEventKey":136,"./getEventModifierState":137}],119:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');
var ViewportMetrics = require('./ViewportMetrics');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;
},{"./SyntheticUIEvent":122,"./ViewportMetrics":125,"./getEventModifierState":137}],120:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;
},{"./SyntheticUIEvent":122,"./getEventModifierState":137}],121:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

module.exports = SyntheticTransitionEvent;
},{"./SyntheticEvent":115}],122:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;
},{"./SyntheticEvent":115,"./getEventTarget":138}],123:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;
},{"./SyntheticMouseEvent":119}],124:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

var OBSERVED_ERROR = {};

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var TransactionImpl = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? "production" !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? "production" !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

module.exports = TransactionImpl;
},{"./reactProdInvariant":149,"fbjs/lib/invariant":17}],125:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;
},{}],126:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? "production" !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
},{"./reactProdInvariant":149,"fbjs/lib/invariant":17}],127:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    var n = Math.min(i + 4096, m);
    for (; i < n; i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;
},{}],128:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? "production" !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      "production" !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if ("production" !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        "production" !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
}).call(this,require('_process'))

},{"./ReactPropTypeLocationNames":98,"./ReactPropTypesSecret":99,"./reactProdInvariant":149,"_process":1,"fbjs/lib/invariant":17,"fbjs/lib/warning":24,"react/lib/ReactComponentTreeHook":212}],129:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals MSApp */

'use strict';

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */

var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

module.exports = createMicrosoftUnsafeLocalFunction;
},{}],130:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var warning = require('fbjs/lib/warning');

var isUnitlessNumber = CSSProperty.isUnitlessNumber;
var styleWarnings = {};

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @param {ReactDOMComponent} component
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, component) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    if ("production" !== 'production') {
      // Allow '0' to pass through without warning. 0 is already special and
      // doesn't require units, so we don't need to warn about it.
      if (component && value !== '0') {
        var owner = component._currentElement._owner;
        var ownerName = owner ? owner.getName() : null;
        if (ownerName && !styleWarnings[ownerName]) {
          styleWarnings[ownerName] = {};
        }
        var warned = false;
        if (ownerName) {
          var warnings = styleWarnings[ownerName];
          warned = warnings[name];
          if (!warned) {
            warnings[name] = true;
          }
        }
        if (!warned) {
          "production" !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
        }
      }
    }
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
},{"./CSSProperty":33,"fbjs/lib/warning":24}],131:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * Based on the escape-html library, which is used under the MIT License below:
 *
 * Copyright (c) 2012-2013 TJ Holowaychuk
 * Copyright (c) 2015 Andreas Lubbe
 * Copyright (c) 2015 Tiancheng "Timothy" Gu
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

'use strict';

// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;
      case 38:
        // &
        escape = '&amp;';
        break;
      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
        break;
      case 60:
        // <
        escape = '&lt;';
        break;
      case 62:
        // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// end code copied and modified from escape-html


/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }
  return escapeHtml(text);
}

module.exports = escapeTextContentForBrowser;
},{}],132:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstanceMap = require('./ReactInstanceMap');

var getHostComponentFromComposite = require('./getHostComponentFromComposite');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Returns the DOM node rendered by this element.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if ("production" !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      "production" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap.get(componentOrElement);
  if (inst) {
    inst = getHostComponentFromComposite(inst);
    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === 'function') {
    !false ? "production" !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
  } else {
    !false ? "production" !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
  }
}

module.exports = findDOMNode;
},{"./ReactDOMComponentTree":62,"./ReactInstanceMap":90,"./getHostComponentFromComposite":139,"./reactProdInvariant":149,"fbjs/lib/invariant":17,"fbjs/lib/warning":24,"react/lib/ReactCurrentOwner":213}],133:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var KeyEscapeUtils = require('./KeyEscapeUtils');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
}

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 * @param {number=} selfDebugID Optional debugID of the current internal instance.
 */
function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
  // We found a component instance.
  if (traverseContext && typeof traverseContext === 'object') {
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    if ("production" !== 'production') {
      if (!ReactComponentTreeHook) {
        ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
      }
      if (!keyUnique) {
        "production" !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
      }
    }
    if (keyUnique && child != null) {
      result[name] = child;
    }
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children, selfDebugID) {
  if (children == null) {
    return children;
  }
  var result = {};

  if ("production" !== 'production') {
    traverseAllChildren(children, function (traverseContext, child, name) {
      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
    }, result);
  } else {
    traverseAllChildren(children, flattenSingleChildIntoContext, result);
  }
  return result;
}

module.exports = flattenChildren;
}).call(this,require('_process'))

},{"./KeyEscapeUtils":51,"./traverseAllChildren":154,"_process":1,"fbjs/lib/warning":24,"react/lib/ReactComponentTreeHook":212}],134:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */

function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

module.exports = forEachAccumulated;
},{}],135:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;
},{}],136:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var getEventCharCode = require('./getEventCharCode');

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;
},{"./getEventCharCode":135}],137:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;
},{}],138:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;
},{}],139:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactNodeTypes = require('./ReactNodeTypes');

function getHostComponentFromComposite(inst) {
  var type;

  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
    inst = inst._renderedComponent;
  }

  if (type === ReactNodeTypes.HOST) {
    return inst._renderedComponent;
  } else if (type === ReactNodeTypes.EMPTY) {
    return null;
  }
}

module.exports = getHostComponentFromComposite;
},{"./ReactNodeTypes":96}],140:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;
},{}],141:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var nextDebugID = 1;

function getNextDebugID() {
  return nextDebugID++;
}

module.exports = getNextDebugID;
},{}],142:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;
},{}],143:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;
},{"fbjs/lib/ExecutionEnvironment":3}],144:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

module.exports = getVendorPrefixedEventName;
},{"fbjs/lib/ExecutionEnvironment":3}],145:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var ReactCompositeComponent = require('./ReactCompositeComponent');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactHostComponent = require('./ReactHostComponent');

var getNextDebugID = require('./getNextDebugID');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function (element) {
  this.construct(element);
};
_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
  _instantiateReactComponent: instantiateReactComponent
});

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @param {boolean} shouldHaveDebugID
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node, shouldHaveDebugID) {
  var instance;

  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;
    var type = element.type;
    if (typeof type !== 'function' && typeof type !== 'string') {
      var info = '';
      if ("production" !== 'production') {
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }
      }
      info += getDeclarationErrorAddendum(element._owner);
      !false ? "production" !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
    }

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactHostComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);

      // We renamed this. Allow the old name for compat. :(
      if (!instance.getHostNode) {
        instance.getHostNode = instance.getNativeNode;
      }
    } else {
      instance = new ReactCompositeComponentWrapper(element);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactHostComponent.createInstanceForText(node);
  } else {
    !false ? "production" !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
  }

  if ("production" !== 'production') {
    "production" !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if ("production" !== 'production') {
    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if ("production" !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

module.exports = instantiateReactComponent;
},{"./ReactCompositeComponent":58,"./ReactEmptyComponent":81,"./ReactHostComponent":86,"./getNextDebugID":141,"./reactProdInvariant":149,"fbjs/lib/invariant":17,"fbjs/lib/warning":24,"object-assign":27}],146:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;
},{"fbjs/lib/ExecutionEnvironment":3}],147:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

module.exports = isTextInputElement;
},{}],148:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;
},{"./escapeTextContentForBrowser":131}],149:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */
'use strict';

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;
},{}],150:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactMount = require('./ReactMount');

module.exports = ReactMount.renderSubtreeIntoContainer;
},{"./ReactMount":94}],151:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var DOMNamespaces = require('./DOMNamespaces');

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node
  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xFEFF) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
  testElement = null;
}

module.exports = setInnerHTML;
},{"./DOMNamespaces":39,"./createMicrosoftUnsafeLocalFunction":129,"fbjs/lib/ExecutionEnvironment":3}],152:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var setInnerHTML = require('./setInnerHTML');

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      if (node.nodeType === 3) {
        node.nodeValue = text;
        return;
      }
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;
},{"./escapeTextContentForBrowser":131,"./setInnerHTML":151,"fbjs/lib/ExecutionEnvironment":3}],153:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}

module.exports = shouldUpdateReactComponent;
},{}],154:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var warning = require('fbjs/lib/warning');

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if ("production" !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          "production" !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if ("production" !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? "production" !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
},{"./KeyEscapeUtils":51,"./ReactElementSymbol":80,"./getIteratorFn":140,"./reactProdInvariant":149,"fbjs/lib/invariant":17,"fbjs/lib/warning":24,"react/lib/ReactCurrentOwner":213}],155:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var validateDOMNesting = emptyFunction;

if ("production" !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':

      case 'pre':
      case 'listing':

      case 'table':

      case 'hr':

      case 'xmp':

      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    do {
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      "production" !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      var tagDisplayName = childTag;
      var whitespaceInfo = '';
      if (childTag === '#text') {
        if (/\S/.test(childText)) {
          tagDisplayName = 'Text nodes';
        } else {
          tagDisplayName = 'Whitespace text nodes';
          whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
        }
      } else {
        tagDisplayName = '<' + childTag + '>';
      }

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        "production" !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
      } else {
        "production" !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
      }
    }
  };

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
},{"fbjs/lib/emptyFunction":9,"fbjs/lib/warning":24,"object-assign":27}],156:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.loopAsync = loopAsync;
exports.mapAsync = mapAsync;
function loopAsync(turns, work, callback) {
  var currentTurn = 0,
      isDone = false;
  var sync = false,
      hasNext = false,
      doneArgs = void 0;

  function done() {
    isDone = true;
    if (sync) {
      // Iterate instead of recursing if possible.
      doneArgs = [].concat(Array.prototype.slice.call(arguments));
      return;
    }

    callback.apply(this, arguments);
  }

  function next() {
    if (isDone) {
      return;
    }

    hasNext = true;
    if (sync) {
      // Iterate instead of recursing if possible.
      return;
    }

    sync = true;

    while (!isDone && currentTurn < turns && hasNext) {
      hasNext = false;
      work.call(this, currentTurn++, next, done);
    }

    sync = false;

    if (isDone) {
      // This means the loop finished synchronously.
      callback.apply(this, doneArgs);
      return;
    }

    if (currentTurn >= turns && hasNext) {
      isDone = true;
      callback();
    }
  }

  next();
}

function mapAsync(array, work, callback) {
  var length = array.length;
  var values = [];

  if (length === 0) return callback(null, values);

  var isDone = false,
      doneCount = 0;

  function done(index, error, value) {
    if (isDone) return;

    if (error) {
      isDone = true;
      callback(error);
    } else {
      values[index] = value;

      isDone = ++doneCount === length;

      if (isDone) callback(null, values);
    }
  }

  array.forEach(function (item, index) {
    work(item, index, function (error, value) {
      done(index, error, value);
    });
  });
}
},{}],157:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.ContextProvider = ContextProvider;
exports.ContextSubscriber = ContextSubscriber;

var _react = require('react');

// Works around issues with context updates failing to propagate.
// Caveat: the context value is expected to never change its identity.
// https://github.com/facebook/react/issues/2517
// https://github.com/reactjs/react-router/issues/470

var contextProviderShape = _react.PropTypes.shape({
  subscribe: _react.PropTypes.func.isRequired,
  eventIndex: _react.PropTypes.number.isRequired
});

function makeContextName(name) {
  return '@@contextSubscriber/' + name;
}

function ContextProvider(name) {
  var _childContextTypes, _ref2;

  var contextName = makeContextName(name);
  var listenersKey = contextName + '/listeners';
  var eventIndexKey = contextName + '/eventIndex';
  var subscribeKey = contextName + '/subscribe';

  return _ref2 = {
    childContextTypes: (_childContextTypes = {}, _childContextTypes[contextName] = contextProviderShape.isRequired, _childContextTypes),

    getChildContext: function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextName] = {
        eventIndex: this[eventIndexKey],
        subscribe: this[subscribeKey]
      }, _ref;
    },
    componentWillMount: function componentWillMount() {
      this[listenersKey] = [];
      this[eventIndexKey] = 0;
    },
    componentWillReceiveProps: function componentWillReceiveProps() {
      this[eventIndexKey]++;
    },
    componentDidUpdate: function componentDidUpdate() {
      var _this = this;

      this[listenersKey].forEach(function (listener) {
        return listener(_this[eventIndexKey]);
      });
    }
  }, _ref2[subscribeKey] = function (listener) {
    var _this2 = this;

    // No need to immediately call listener here.
    this[listenersKey].push(listener);

    return function () {
      _this2[listenersKey] = _this2[listenersKey].filter(function (item) {
        return item !== listener;
      });
    };
  }, _ref2;
}

function ContextSubscriber(name) {
  var _contextTypes, _ref4;

  var contextName = makeContextName(name);
  var lastRenderedEventIndexKey = contextName + '/lastRenderedEventIndex';
  var handleContextUpdateKey = contextName + '/handleContextUpdate';
  var unsubscribeKey = contextName + '/unsubscribe';

  return _ref4 = {
    contextTypes: (_contextTypes = {}, _contextTypes[contextName] = contextProviderShape, _contextTypes),

    getInitialState: function getInitialState() {
      var _ref3;

      if (!this.context[contextName]) {
        return {};
      }

      return _ref3 = {}, _ref3[lastRenderedEventIndexKey] = this.context[contextName].eventIndex, _ref3;
    },
    componentDidMount: function componentDidMount() {
      if (!this.context[contextName]) {
        return;
      }

      this[unsubscribeKey] = this.context[contextName].subscribe(this[handleContextUpdateKey]);
    },
    componentWillReceiveProps: function componentWillReceiveProps() {
      var _setState;

      if (!this.context[contextName]) {
        return;
      }

      this.setState((_setState = {}, _setState[lastRenderedEventIndexKey] = this.context[contextName].eventIndex, _setState));
    },
    componentWillUnmount: function componentWillUnmount() {
      if (!this[unsubscribeKey]) {
        return;
      }

      this[unsubscribeKey]();
      this[unsubscribeKey] = null;
    }
  }, _ref4[handleContextUpdateKey] = function (eventIndex) {
    if (eventIndex !== this.state[lastRenderedEventIndexKey]) {
      var _setState2;

      this.setState((_setState2 = {}, _setState2[lastRenderedEventIndexKey] = eventIndex, _setState2));
    }
  }, _ref4;
}
},{"react":230}],158:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Link = require('./Link');

var _Link2 = _interopRequireDefault(_Link);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An <IndexLink> is used to link to an <IndexRoute>.
 */
var IndexLink = _react2.default.createClass({
  displayName: 'IndexLink',
  render: function render() {
    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
  }
});

exports.default = IndexLink;
module.exports = exports['default'];
},{"./Link":162,"react":230}],159:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _Redirect = require('./Redirect');

var _Redirect2 = _interopRequireDefault(_Redirect);

var _InternalPropTypes = require('./InternalPropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _React$PropTypes = _react2.default.PropTypes,
    string = _React$PropTypes.string,
    object = _React$PropTypes.object;

/**
 * An <IndexRedirect> is used to redirect from an indexRoute.
 */
/* eslint-disable react/require-render-return */

var IndexRedirect = _react2.default.createClass({
  displayName: 'IndexRedirect',


  statics: {
    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
      /* istanbul ignore else: sanity check */
      if (parentRoute) {
        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
      } else {
        "production" !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
      }
    }
  },

  propTypes: {
    to: string.isRequired,
    query: object,
    state: object,
    onEnter: _InternalPropTypes.falsy,
    children: _InternalPropTypes.falsy
  },

  /* istanbul ignore next: sanity check */
  render: function render() {
    !false ? "production" !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
  }
});

exports.default = IndexRedirect;
module.exports = exports['default'];
},{"./InternalPropTypes":161,"./Redirect":166,"./routerWarning":186,"invariant":26,"react":230}],160:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _RouteUtils = require('./RouteUtils');

var _InternalPropTypes = require('./InternalPropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var func = _react2.default.PropTypes.func;

/**
 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
 * a JSX route config.
 */
/* eslint-disable react/require-render-return */

var IndexRoute = _react2.default.createClass({
  displayName: 'IndexRoute',


  statics: {
    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
      /* istanbul ignore else: sanity check */
      if (parentRoute) {
        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
      } else {
        "production" !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
      }
    }
  },

  propTypes: {
    path: _InternalPropTypes.falsy,
    component: _InternalPropTypes.component,
    components: _InternalPropTypes.components,
    getComponent: func,
    getComponents: func
  },

  /* istanbul ignore next: sanity check */
  render: function render() {
    !false ? "production" !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
  }
});

exports.default = IndexRoute;
module.exports = exports['default'];
},{"./InternalPropTypes":161,"./RouteUtils":168,"./routerWarning":186,"invariant":26,"react":230}],161:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
exports.falsy = falsy;

var _react = require('react');

var func = _react.PropTypes.func,
    object = _react.PropTypes.object,
    arrayOf = _react.PropTypes.arrayOf,
    oneOfType = _react.PropTypes.oneOfType,
    element = _react.PropTypes.element,
    shape = _react.PropTypes.shape,
    string = _react.PropTypes.string;
function falsy(props, propName, componentName) {
  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
}

var history = exports.history = shape({
  listen: func.isRequired,
  push: func.isRequired,
  replace: func.isRequired,
  go: func.isRequired,
  goBack: func.isRequired,
  goForward: func.isRequired
});

var component = exports.component = oneOfType([func, string]);
var components = exports.components = oneOfType([component, object]);
var route = exports.route = oneOfType([object, element]);
var routes = exports.routes = oneOfType([route, arrayOf(route)]);
},{"react":230}],162:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _PropTypes = require('./PropTypes');

var _ContextUtils = require('./ContextUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var _React$PropTypes = _react2.default.PropTypes,
    bool = _React$PropTypes.bool,
    object = _React$PropTypes.object,
    string = _React$PropTypes.string,
    func = _React$PropTypes.func,
    oneOfType = _React$PropTypes.oneOfType;


function isLeftClickEvent(event) {
  return event.button === 0;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
function isEmptyObject(object) {
  for (var p in object) {
    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
  }return true;
}

function resolveToLocation(to, router) {
  return typeof to === 'function' ? to(router.location) : to;
}

/**
 * A <Link> is used to create an <a> element that links to a route.
 * When that route is active, the link gets the value of its
 * activeClassName prop.
 *
 * For example, assuming you have the following route:
 *
 *   <Route path="/posts/:postID" component={Post} />
 *
 * You could use the following component to link to that route:
 *
 *   <Link to={`/posts/${post.id}`} />
 *
 * Links may pass along location state and/or query string parameters
 * in the state/query props, respectively.
 *
 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
 */
var Link = _react2.default.createClass({
  displayName: 'Link',


  mixins: [(0, _ContextUtils.ContextSubscriber)('router')],

  contextTypes: {
    router: _PropTypes.routerShape
  },

  propTypes: {
    to: oneOfType([string, object, func]),
    query: object,
    hash: string,
    state: object,
    activeStyle: object,
    activeClassName: string,
    onlyActiveOnIndex: bool.isRequired,
    onClick: func,
    target: string
  },

  getDefaultProps: function getDefaultProps() {
    return {
      onlyActiveOnIndex: false,
      style: {}
    };
  },
  handleClick: function handleClick(event) {
    if (this.props.onClick) this.props.onClick(event);

    if (event.defaultPrevented) return;

    var router = this.context.router;

    !router ? "production" !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;

    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;

    // If target prop is set (e.g. to "_blank"), let browser handle link.
    /* istanbul ignore if: untestable with Karma */
    if (this.props.target) return;

    event.preventDefault();

    router.push(resolveToLocation(this.props.to, router));
  },
  render: function render() {
    var _props = this.props,
        to = _props.to,
        activeClassName = _props.activeClassName,
        activeStyle = _props.activeStyle,
        onlyActiveOnIndex = _props.onlyActiveOnIndex,
        props = _objectWithoutProperties(_props, ['to', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);

    // Ignore if rendered outside the context of router to simplify unit testing.


    var router = this.context.router;


    if (router) {
      // If user does not specify a `to` prop, return an empty anchor tag.
      if (!to) {
        return _react2.default.createElement('a', props);
      }

      var toLocation = resolveToLocation(to, router);
      props.href = router.createHref(toLocation);

      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
        if (router.isActive(toLocation, onlyActiveOnIndex)) {
          if (activeClassName) {
            if (props.className) {
              props.className += ' ' + activeClassName;
            } else {
              props.className = activeClassName;
            }
          }

          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
        }
      }
    }

    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
  }
});

exports.default = Link;
module.exports = exports['default'];
},{"./ContextUtils":157,"./PropTypes":165,"invariant":26,"react":230}],163:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.compilePattern = compilePattern;
exports.matchPattern = matchPattern;
exports.getParamNames = getParamNames;
exports.getParams = getParams;
exports.formatPattern = formatPattern;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function _compilePattern(pattern) {
  var regexpSource = '';
  var paramNames = [];
  var tokens = [];

  var match = void 0,
      lastIndex = 0,
      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)|\\\(|\\\)/g;
  while (match = matcher.exec(pattern)) {
    if (match.index !== lastIndex) {
      tokens.push(pattern.slice(lastIndex, match.index));
      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
    }

    if (match[1]) {
      regexpSource += '([^/]+)';
      paramNames.push(match[1]);
    } else if (match[0] === '**') {
      regexpSource += '(.*)';
      paramNames.push('splat');
    } else if (match[0] === '*') {
      regexpSource += '(.*?)';
      paramNames.push('splat');
    } else if (match[0] === '(') {
      regexpSource += '(?:';
    } else if (match[0] === ')') {
      regexpSource += ')?';
    } else if (match[0] === '\\(') {
      regexpSource += '\\(';
    } else if (match[0] === '\\)') {
      regexpSource += '\\)';
    }

    tokens.push(match[0]);

    lastIndex = matcher.lastIndex;
  }

  if (lastIndex !== pattern.length) {
    tokens.push(pattern.slice(lastIndex, pattern.length));
    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
  }

  return {
    pattern: pattern,
    regexpSource: regexpSource,
    paramNames: paramNames,
    tokens: tokens
  };
}

var CompiledPatternsCache = Object.create(null);

function compilePattern(pattern) {
  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);

  return CompiledPatternsCache[pattern];
}

/**
 * Attempts to match a pattern on the given pathname. Patterns may use
 * the following special characters:
 *
 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
 *                  captured string is considered a "param"
 * - ()             Wraps a segment of the URL that is optional
 * - *              Consumes (non-greedy) all characters up to the next
 *                  character in the pattern, or to the end of the URL if
 *                  there is none
 * - **             Consumes (greedy) all characters up to the next character
 *                  in the pattern, or to the end of the URL if there is none
 *
 *  The function calls callback(error, matched) when finished.
 * The return value is an object with the following properties:
 *
 * - remainingPathname
 * - paramNames
 * - paramValues
 */
function matchPattern(pattern, pathname) {
  // Ensure pattern starts with leading slash for consistency with pathname.
  if (pattern.charAt(0) !== '/') {
    pattern = '/' + pattern;
  }

  var _compilePattern2 = compilePattern(pattern),
      regexpSource = _compilePattern2.regexpSource,
      paramNames = _compilePattern2.paramNames,
      tokens = _compilePattern2.tokens;

  if (pattern.charAt(pattern.length - 1) !== '/') {
    regexpSource += '/?'; // Allow optional path separator at end.
  }

  // Special-case patterns like '*' for catch-all routes.
  if (tokens[tokens.length - 1] === '*') {
    regexpSource += '$';
  }

  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
  if (match == null) {
    return null;
  }

  var matchedPath = match[0];
  var remainingPathname = pathname.substr(matchedPath.length);

  if (remainingPathname) {
    // Require that the match ends at a path separator, if we didn't match
    // the full path, so any remaining pathname is a new path segment.
    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
      return null;
    }

    // If there is a remaining pathname, treat the path separator as part of
    // the remaining pathname for properly continuing the match.
    remainingPathname = '/' + remainingPathname;
  }

  return {
    remainingPathname: remainingPathname,
    paramNames: paramNames,
    paramValues: match.slice(1).map(function (v) {
      return v && decodeURIComponent(v);
    })
  };
}

function getParamNames(pattern) {
  return compilePattern(pattern).paramNames;
}

function getParams(pattern, pathname) {
  var match = matchPattern(pattern, pathname);
  if (!match) {
    return null;
  }

  var paramNames = match.paramNames,
      paramValues = match.paramValues;

  var params = {};

  paramNames.forEach(function (paramName, index) {
    params[paramName] = paramValues[index];
  });

  return params;
}

/**
 * Returns a version of the given pattern with params interpolated. Throws
 * if there is a dynamic segment of the pattern for which there is no param.
 */
function formatPattern(pattern, params) {
  params = params || {};

  var _compilePattern3 = compilePattern(pattern),
      tokens = _compilePattern3.tokens;

  var parenCount = 0,
      pathname = '',
      splatIndex = 0,
      parenHistory = [];

  var token = void 0,
      paramName = void 0,
      paramValue = void 0;
  for (var i = 0, len = tokens.length; i < len; ++i) {
    token = tokens[i];

    if (token === '*' || token === '**') {
      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;

      !(paramValue != null || parenCount > 0) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;

      if (paramValue != null) pathname += encodeURI(paramValue);
    } else if (token === '(') {
      parenHistory[parenCount] = '';
      parenCount += 1;
    } else if (token === ')') {
      var parenText = parenHistory.pop();
      parenCount -= 1;

      if (parenCount) parenHistory[parenCount - 1] += parenText;else pathname += parenText;
    } else if (token === '\\(') {
      pathname += '(';
    } else if (token === '\\)') {
      pathname += ')';
    } else if (token.charAt(0) === ':') {
      paramName = token.substring(1);
      paramValue = params[paramName];

      !(paramValue != null || parenCount > 0) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;

      if (paramValue == null) {
        if (parenCount) {
          parenHistory[parenCount - 1] = '';

          var curTokenIdx = tokens.indexOf(token);
          var tokensSubset = tokens.slice(curTokenIdx, tokens.length);
          var nextParenIdx = -1;

          for (var _i = 0; _i < tokensSubset.length; _i++) {
            if (tokensSubset[_i] == ')') {
              nextParenIdx = _i;
              break;
            }
          }

          !(nextParenIdx > 0) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'Path "%s" is missing end paren at segment "%s"', pattern, tokensSubset.join('')) : (0, _invariant2.default)(false) : void 0;

          // jump to ending paren
          i = curTokenIdx + nextParenIdx - 1;
        }
      } else if (parenCount) parenHistory[parenCount - 1] += encodeURIComponent(paramValue);else pathname += encodeURIComponent(paramValue);
    } else {
      if (parenCount) parenHistory[parenCount - 1] += token;else pathname += token;
    }
  }

  !(parenCount <= 0) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'Path "%s" is missing end paren', pattern) : (0, _invariant2.default)(false) : void 0;

  return pathname.replace(/\/+/g, '/');
}
},{"invariant":26}],164:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.isPromise = isPromise;
function isPromise(obj) {
  return obj && typeof obj.then === 'function';
}
},{}],165:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.locationShape = exports.routerShape = undefined;

var _react = require('react');

var func = _react.PropTypes.func,
    object = _react.PropTypes.object,
    shape = _react.PropTypes.shape,
    string = _react.PropTypes.string;
var routerShape = exports.routerShape = shape({
  push: func.isRequired,
  replace: func.isRequired,
  go: func.isRequired,
  goBack: func.isRequired,
  goForward: func.isRequired,
  setRouteLeaveHook: func.isRequired,
  isActive: func.isRequired
});

var locationShape = exports.locationShape = shape({
  pathname: string.isRequired,
  search: string.isRequired,
  state: object,
  action: string.isRequired,
  key: string
});
},{"react":230}],166:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _RouteUtils = require('./RouteUtils');

var _PatternUtils = require('./PatternUtils');

var _InternalPropTypes = require('./InternalPropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _React$PropTypes = _react2.default.PropTypes,
    string = _React$PropTypes.string,
    object = _React$PropTypes.object;

/**
 * A <Redirect> is used to declare another URL path a client should
 * be sent to when they request a given URL.
 *
 * Redirects are placed alongside routes in the route configuration
 * and are traversed in the same manner.
 */
/* eslint-disable react/require-render-return */

var Redirect = _react2.default.createClass({
  displayName: 'Redirect',


  statics: {
    createRouteFromReactElement: function createRouteFromReactElement(element) {
      var route = (0, _RouteUtils.createRouteFromReactElement)(element);

      if (route.from) route.path = route.from;

      route.onEnter = function (nextState, replace) {
        var location = nextState.location,
            params = nextState.params;


        var pathname = void 0;
        if (route.to.charAt(0) === '/') {
          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
        } else if (!route.to) {
          pathname = location.pathname;
        } else {
          var routeIndex = nextState.routes.indexOf(route);
          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
        }

        replace({
          pathname: pathname,
          query: route.query || location.query,
          state: route.state || location.state
        });
      };

      return route;
    },
    getRoutePattern: function getRoutePattern(routes, routeIndex) {
      var parentPattern = '';

      for (var i = routeIndex; i >= 0; i--) {
        var route = routes[i];
        var pattern = route.path || '';

        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;

        if (pattern.indexOf('/') === 0) break;
      }

      return '/' + parentPattern;
    }
  },

  propTypes: {
    path: string,
    from: string, // Alias for path
    to: string.isRequired,
    query: object,
    state: object,
    onEnter: _InternalPropTypes.falsy,
    children: _InternalPropTypes.falsy
  },

  /* istanbul ignore next: sanity check */
  render: function render() {
    !false ? "production" !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
  }
});

exports.default = Redirect;
module.exports = exports['default'];
},{"./InternalPropTypes":161,"./PatternUtils":163,"./RouteUtils":168,"invariant":26,"react":230}],167:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _RouteUtils = require('./RouteUtils');

var _InternalPropTypes = require('./InternalPropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _React$PropTypes = _react2.default.PropTypes,
    string = _React$PropTypes.string,
    func = _React$PropTypes.func;

/**
 * A <Route> is used to declare which components are rendered to the
 * page when the URL matches a given pattern.
 *
 * Routes are arranged in a nested tree structure. When a new URL is
 * requested, the tree is searched depth-first to find a route whose
 * path matches the URL.  When one is found, all routes in the tree
 * that lead to it are considered "active" and their components are
 * rendered into the DOM, nested in the same order as in the tree.
 */
/* eslint-disable react/require-render-return */

var Route = _react2.default.createClass({
  displayName: 'Route',


  statics: {
    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
  },

  propTypes: {
    path: string,
    component: _InternalPropTypes.component,
    components: _InternalPropTypes.components,
    getComponent: func,
    getComponents: func
  },

  /* istanbul ignore next: sanity check */
  render: function render() {
    !false ? "production" !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
  }
});

exports.default = Route;
module.exports = exports['default'];
},{"./InternalPropTypes":161,"./RouteUtils":168,"invariant":26,"react":230}],168:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.isReactChildren = isReactChildren;
exports.createRouteFromReactElement = createRouteFromReactElement;
exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
exports.createRoutes = createRoutes;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isValidChild(object) {
  return object == null || _react2.default.isValidElement(object);
}

function isReactChildren(object) {
  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
}

function createRoute(defaultProps, props) {
  return _extends({}, defaultProps, props);
}

function createRouteFromReactElement(element) {
  var type = element.type;
  var route = createRoute(type.defaultProps, element.props);

  if (route.children) {
    var childRoutes = createRoutesFromReactChildren(route.children, route);

    if (childRoutes.length) route.childRoutes = childRoutes;

    delete route.children;
  }

  return route;
}

/**
 * Creates and returns a routes object from the given ReactChildren. JSX
 * provides a convenient way to visualize how routes in the hierarchy are
 * nested.
 *
 *   import { Route, createRoutesFromReactChildren } from 'react-router'
 *
 *   const routes = createRoutesFromReactChildren(
 *     <Route component={App}>
 *       <Route path="home" component={Dashboard}/>
 *       <Route path="news" component={NewsFeed}/>
 *     </Route>
 *   )
 *
 * Note: This method is automatically used when you provide <Route> children
 * to a <Router> component.
 */
function createRoutesFromReactChildren(children, parentRoute) {
  var routes = [];

  _react2.default.Children.forEach(children, function (element) {
    if (_react2.default.isValidElement(element)) {
      // Component classes may have a static create* method.
      if (element.type.createRouteFromReactElement) {
        var route = element.type.createRouteFromReactElement(element, parentRoute);

        if (route) routes.push(route);
      } else {
        routes.push(createRouteFromReactElement(element));
      }
    }
  });

  return routes;
}

/**
 * Creates and returns an array of routes from the given object which
 * may be a JSX route, a plain object route, or an array of either.
 */
function createRoutes(routes) {
  if (isReactChildren(routes)) {
    routes = createRoutesFromReactChildren(routes);
  } else if (routes && !Array.isArray(routes)) {
    routes = [routes];
  }

  return routes;
}
},{"react":230}],169:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _createTransitionManager2 = require('./createTransitionManager');

var _createTransitionManager3 = _interopRequireDefault(_createTransitionManager2);

var _InternalPropTypes = require('./InternalPropTypes');

var _RouterContext = require('./RouterContext');

var _RouterContext2 = _interopRequireDefault(_RouterContext);

var _RouteUtils = require('./RouteUtils');

var _RouterUtils = require('./RouterUtils');

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var _React$PropTypes = _react2.default.PropTypes,
    func = _React$PropTypes.func,
    object = _React$PropTypes.object;

/**
 * A <Router> is a high-level API for automatically setting up
 * a router that renders a <RouterContext> with all the props
 * it needs each time the URL changes.
 */

var Router = _react2.default.createClass({
  displayName: 'Router',


  propTypes: {
    history: object,
    children: _InternalPropTypes.routes,
    routes: _InternalPropTypes.routes, // alias for children
    render: func,
    createElement: func,
    onError: func,
    onUpdate: func,

    // PRIVATE: For client-side rehydration of server match.
    matchContext: object
  },

  getDefaultProps: function getDefaultProps() {
    return {
      render: function render(props) {
        return _react2.default.createElement(_RouterContext2.default, props);
      }
    };
  },
  getInitialState: function getInitialState() {
    return {
      location: null,
      routes: null,
      params: null,
      components: null
    };
  },
  handleError: function handleError(error) {
    if (this.props.onError) {
      this.props.onError.call(this, error);
    } else {
      // Throw errors by default so we don't silently swallow them!
      throw error; // This error probably occurred in getChildRoutes or getComponents.
    }
  },
  createRouterObject: function createRouterObject(state) {
    var matchContext = this.props.matchContext;

    if (matchContext) {
      return matchContext.router;
    }

    var history = this.props.history;

    return (0, _RouterUtils.createRouterObject)(history, this.transitionManager, state);
  },
  createTransitionManager: function createTransitionManager() {
    var matchContext = this.props.matchContext;

    if (matchContext) {
      return matchContext.transitionManager;
    }

    var history = this.props.history;
    var _props = this.props,
        routes = _props.routes,
        children = _props.children;


    !history.getCurrentLocation ? "production" !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v2.x or ' + 'earlier. This version of React Router is only compatible with v3 ' + 'history objects. Please upgrade to history v3.x.') : (0, _invariant2.default)(false) : void 0;

    return (0, _createTransitionManager3.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
  },
  componentWillMount: function componentWillMount() {
    var _this = this;

    this.transitionManager = this.createTransitionManager();
    this.router = this.createRouterObject(this.state);

    this._unlisten = this.transitionManager.listen(function (error, state) {
      if (error) {
        _this.handleError(error);
      } else {
        // Keep the identity of this.router because of a caveat in ContextUtils:
        // they only work if the object identity is preserved.
        (0, _RouterUtils.assignRouterState)(_this.router, state);
        _this.setState(state, _this.props.onUpdate);
      }
    });
  },


  /* istanbul ignore next: sanity check */
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    "production" !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;

    "production" !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
  },
  componentWillUnmount: function componentWillUnmount() {
    if (this._unlisten) this._unlisten();
  },
  render: function render() {
    var _state = this.state,
        location = _state.location,
        routes = _state.routes,
        params = _state.params,
        components = _state.components;

    var _props2 = this.props,
        createElement = _props2.createElement,
        render = _props2.render,
        props = _objectWithoutProperties(_props2, ['createElement', 'render']);

    if (location == null) return null; // Async match

    // Only forward non-Router-specific props to routing context, as those are
    // the only ones that might be custom routing context props.
    Object.keys(Router.propTypes).forEach(function (propType) {
      return delete props[propType];
    });

    return render(_extends({}, props, {
      router: this.router,
      location: location,
      routes: routes,
      params: params,
      components: components,
      createElement: createElement
    }));
  }
});

exports.default = Router;
module.exports = exports['default'];
},{"./InternalPropTypes":161,"./RouteUtils":168,"./RouterContext":170,"./RouterUtils":171,"./createTransitionManager":178,"./routerWarning":186,"invariant":26,"react":230}],170:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _getRouteParams = require('./getRouteParams');

var _getRouteParams2 = _interopRequireDefault(_getRouteParams);

var _ContextUtils = require('./ContextUtils');

var _RouteUtils = require('./RouteUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _React$PropTypes = _react2.default.PropTypes,
    array = _React$PropTypes.array,
    func = _React$PropTypes.func,
    object = _React$PropTypes.object;

/**
 * A <RouterContext> renders the component tree for a given router state
 * and sets the history object and the current location in context.
 */

var RouterContext = _react2.default.createClass({
  displayName: 'RouterContext',


  mixins: [(0, _ContextUtils.ContextProvider)('router')],

  propTypes: {
    router: object.isRequired,
    location: object.isRequired,
    routes: array.isRequired,
    params: object.isRequired,
    components: array.isRequired,
    createElement: func.isRequired
  },

  getDefaultProps: function getDefaultProps() {
    return {
      createElement: _react2.default.createElement
    };
  },


  childContextTypes: {
    router: object.isRequired
  },

  getChildContext: function getChildContext() {
    return {
      router: this.props.router
    };
  },
  createElement: function createElement(component, props) {
    return component == null ? null : this.props.createElement(component, props);
  },
  render: function render() {
    var _this = this;

    var _props = this.props,
        location = _props.location,
        routes = _props.routes,
        params = _props.params,
        components = _props.components,
        router = _props.router;

    var element = null;

    if (components) {
      element = components.reduceRight(function (element, components, index) {
        if (components == null) return element; // Don't create new children; use the grandchildren.

        var route = routes[index];
        var routeParams = (0, _getRouteParams2.default)(route, params);
        var props = {
          location: location,
          params: params,
          route: route,
          router: router,
          routeParams: routeParams,
          routes: routes
        };

        if ((0, _RouteUtils.isReactChildren)(element)) {
          props.children = element;
        } else if (element) {
          for (var prop in element) {
            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
          }
        }

        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
          var elements = {};

          for (var key in components) {
            if (Object.prototype.hasOwnProperty.call(components, key)) {
              // Pass through the key as a prop to createElement to allow
              // custom createElement functions to know which named component
              // they're rendering, for e.g. matching up to fetched data.
              elements[key] = _this.createElement(components[key], _extends({
                key: key }, props));
            }
          }

          return elements;
        }

        return _this.createElement(components, props);
      }, element);
    }

    !(element === null || element === false || _react2.default.isValidElement(element)) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;

    return element;
  }
});

exports.default = RouterContext;
module.exports = exports['default'];
},{"./ContextUtils":157,"./RouteUtils":168,"./getRouteParams":180,"invariant":26,"react":230}],171:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createRouterObject = createRouterObject;
exports.assignRouterState = assignRouterState;
function createRouterObject(history, transitionManager, state) {
  var router = _extends({}, history, {
    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
    isActive: transitionManager.isActive
  });

  return assignRouterState(router, state);
}

function assignRouterState(router, _ref) {
  var location = _ref.location,
      params = _ref.params,
      routes = _ref.routes;

  router.location = location;
  router.params = params;
  router.routes = routes;

  return router;
}
},{}],172:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.runEnterHooks = runEnterHooks;
exports.runChangeHooks = runChangeHooks;
exports.runLeaveHooks = runLeaveHooks;

var _AsyncUtils = require('./AsyncUtils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PendingHooks = function PendingHooks() {
  var _this = this;

  _classCallCheck(this, PendingHooks);

  this.hooks = [];

  this.add = function (hook) {
    return _this.hooks.push(hook);
  };

  this.remove = function (hook) {
    return _this.hooks = _this.hooks.filter(function (h) {
      return h !== hook;
    });
  };

  this.has = function (hook) {
    return _this.hooks.indexOf(hook) !== -1;
  };

  this.clear = function () {
    return _this.hooks = [];
  };
};

var enterHooks = new PendingHooks();
var changeHooks = new PendingHooks();

function createTransitionHook(hook, route, asyncArity, pendingHooks) {
  var isSync = hook.length < asyncArity;

  var transitionHook = function transitionHook() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    hook.apply(route, args);

    if (isSync) {
      var callback = args[args.length - 1];
      // Assume hook executes synchronously and
      // automatically call the callback.
      callback();
    }
  };

  pendingHooks.add(transitionHook);

  return transitionHook;
}

function getEnterHooks(routes) {
  return routes.reduce(function (hooks, route) {
    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3, enterHooks));
    return hooks;
  }, []);
}

function getChangeHooks(routes) {
  return routes.reduce(function (hooks, route) {
    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4, changeHooks));
    return hooks;
  }, []);
}

function runTransitionHooks(length, iter, callback) {
  if (!length) {
    callback();
    return;
  }

  var redirectInfo = void 0;
  function replace(location) {
    redirectInfo = location;
  }

  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
    iter(index, replace, function (error) {
      if (error || redirectInfo) {
        done(error, redirectInfo); // No need to continue.
      } else {
        next();
      }
    });
  }, callback);
}

/**
 * Runs all onEnter hooks in the given array of routes in order
 * with onEnter(nextState, replace, callback) and calls
 * callback(error, redirectInfo) when finished. The first hook
 * to use replace short-circuits the loop.
 *
 * If a hook needs to run asynchronously, it may use the callback
 * function. However, doing so will cause the transition to pause,
 * which could lead to a non-responsive UI if the hook is slow.
 */
function runEnterHooks(routes, nextState, callback) {
  enterHooks.clear();
  var hooks = getEnterHooks(routes);
  return runTransitionHooks(hooks.length, function (index, replace, next) {
    var wrappedNext = function wrappedNext() {
      if (enterHooks.has(hooks[index])) {
        next.apply(undefined, arguments);
        enterHooks.remove(hooks[index]);
      }
    };
    hooks[index](nextState, replace, wrappedNext);
  }, callback);
}

/**
 * Runs all onChange hooks in the given array of routes in order
 * with onChange(prevState, nextState, replace, callback) and calls
 * callback(error, redirectInfo) when finished. The first hook
 * to use replace short-circuits the loop.
 *
 * If a hook needs to run asynchronously, it may use the callback
 * function. However, doing so will cause the transition to pause,
 * which could lead to a non-responsive UI if the hook is slow.
 */
function runChangeHooks(routes, state, nextState, callback) {
  changeHooks.clear();
  var hooks = getChangeHooks(routes);
  return runTransitionHooks(hooks.length, function (index, replace, next) {
    var wrappedNext = function wrappedNext() {
      if (changeHooks.has(hooks[index])) {
        next.apply(undefined, arguments);
        changeHooks.remove(hooks[index]);
      }
    };
    hooks[index](state, nextState, replace, wrappedNext);
  }, callback);
}

/**
 * Runs all onLeave hooks in the given array of routes in order.
 */
function runLeaveHooks(routes, prevState) {
  for (var i = 0, len = routes.length; i < len; ++i) {
    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
  }
}
},{"./AsyncUtils":156}],173:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _RouterContext = require('./RouterContext');

var _RouterContext2 = _interopRequireDefault(_RouterContext);

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  if ("production" !== 'production') {
    middlewares.forEach(function (middleware, index) {
      "production" !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
    });
  }

  var withContext = middlewares.map(function (middleware) {
    return middleware.renderRouterContext;
  }).filter(Boolean);
  var withComponent = middlewares.map(function (middleware) {
    return middleware.renderRouteComponent;
  }).filter(Boolean);

  var makeCreateElement = function makeCreateElement() {
    var baseCreateElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _react.createElement;
    return function (Component, props) {
      return withComponent.reduceRight(function (previous, renderRouteComponent) {
        return renderRouteComponent(previous, props);
      }, baseCreateElement(Component, props));
    };
  };

  return function (renderProps) {
    return withContext.reduceRight(function (previous, renderRouterContext) {
      return renderRouterContext(previous, renderProps);
    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
      createElement: makeCreateElement(renderProps.createElement)
    })));
  };
};

module.exports = exports['default'];
},{"./RouterContext":170,"./routerWarning":186,"react":230}],174:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createBrowserHistory = require('history/lib/createBrowserHistory');

var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);

var _createRouterHistory = require('./createRouterHistory');

var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
module.exports = exports['default'];
},{"./createRouterHistory":177,"history/lib/createBrowserHistory":199}],175:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _PatternUtils = require('./PatternUtils');

function routeParamsChanged(route, prevState, nextState) {
  if (!route.path) return false;

  var paramNames = (0, _PatternUtils.getParamNames)(route.path);

  return paramNames.some(function (paramName) {
    return prevState.params[paramName] !== nextState.params[paramName];
  });
}

/**
 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
 * the change from prevState to nextState. We leave routes if either
 * 1) they are not in the next state or 2) they are in the next state
 * but their params have changed (i.e. /users/123 => /users/456).
 *
 * leaveRoutes are ordered starting at the leaf route of the tree
 * we're leaving up to the common parent route. enterRoutes are ordered
 * from the top of the tree we're entering down to the leaf route.
 *
 * changeRoutes are any routes that didn't leave or enter during
 * the transition.
 */
function computeChangedRoutes(prevState, nextState) {
  var prevRoutes = prevState && prevState.routes;
  var nextRoutes = nextState.routes;

  var leaveRoutes = void 0,
      changeRoutes = void 0,
      enterRoutes = void 0;
  if (prevRoutes) {
    (function () {
      var parentIsLeaving = false;
      leaveRoutes = prevRoutes.filter(function (route) {
        if (parentIsLeaving) {
          return true;
        } else {
          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
          if (isLeaving) parentIsLeaving = true;
          return isLeaving;
        }
      });

      // onLeave hooks start at the leaf route.
      leaveRoutes.reverse();

      enterRoutes = [];
      changeRoutes = [];

      nextRoutes.forEach(function (route) {
        var isNew = prevRoutes.indexOf(route) === -1;
        var paramsChanged = leaveRoutes.indexOf(route) !== -1;

        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
      });
    })();
  } else {
    leaveRoutes = [];
    changeRoutes = [];
    enterRoutes = nextRoutes;
  }

  return {
    leaveRoutes: leaveRoutes,
    changeRoutes: changeRoutes,
    enterRoutes: enterRoutes
  };
}

exports.default = computeChangedRoutes;
module.exports = exports['default'];
},{"./PatternUtils":163}],176:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = createMemoryHistory;

var _useQueries = require('history/lib/useQueries');

var _useQueries2 = _interopRequireDefault(_useQueries);

var _useBasename = require('history/lib/useBasename');

var _useBasename2 = _interopRequireDefault(_useBasename);

var _createMemoryHistory = require('history/lib/createMemoryHistory');

var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createMemoryHistory(options) {
  // signatures and type checking differ between `useQueries` and
  // `createMemoryHistory`, have to create `memoryHistory` first because
  // `useQueries` doesn't understand the signature
  var memoryHistory = (0, _createMemoryHistory2.default)(options);
  var createHistory = function createHistory() {
    return memoryHistory;
  };
  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
  return history;
}
module.exports = exports['default'];
},{"history/lib/createMemoryHistory":202,"history/lib/useBasename":204,"history/lib/useQueries":205}],177:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports.default = function (createHistory) {
  var history = void 0;
  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
  return history;
};

var _useRouterHistory = require('./useRouterHistory');

var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

module.exports = exports['default'];
},{"./useRouterHistory":187}],178:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = createTransitionManager;

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _computeChangedRoutes2 = require('./computeChangedRoutes');

var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);

var _TransitionUtils = require('./TransitionUtils');

var _isActive2 = require('./isActive');

var _isActive3 = _interopRequireDefault(_isActive2);

var _getComponents = require('./getComponents');

var _getComponents2 = _interopRequireDefault(_getComponents);

var _matchRoutes = require('./matchRoutes');

var _matchRoutes2 = _interopRequireDefault(_matchRoutes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hasAnyProperties(object) {
  for (var p in object) {
    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
  }return false;
}

function createTransitionManager(history, routes) {
  var state = {};

  // Signature should be (location, indexOnly), but needs to support (path,
  // query, indexOnly)
  function isActive(location, indexOnly) {
    location = history.createLocation(location);

    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
  }

  var partialNextState = void 0;

  function match(location, callback) {
    if (partialNextState && partialNextState.location === location) {
      // Continue from where we left off.
      finishMatch(partialNextState, callback);
    } else {
      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
        if (error) {
          callback(error);
        } else if (nextState) {
          finishMatch(_extends({}, nextState, { location: location }), callback);
        } else {
          callback();
        }
      });
    }
  }

  function finishMatch(nextState, callback) {
    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState),
        leaveRoutes = _computeChangedRoutes.leaveRoutes,
        changeRoutes = _computeChangedRoutes.changeRoutes,
        enterRoutes = _computeChangedRoutes.enterRoutes;

    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);

    // Tear down confirmation hooks for left routes
    leaveRoutes.filter(function (route) {
      return enterRoutes.indexOf(route) === -1;
    }).forEach(removeListenBeforeHooksForRoute);

    // change and enter hooks are run in series
    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);

      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
    });

    function finishEnterHooks(error, redirectInfo) {
      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);

      // TODO: Fetch components after state is updated.
      (0, _getComponents2.default)(nextState, function (error, components) {
        if (error) {
          callback(error);
        } else {
          // TODO: Make match a pure function and have some other API
          // for "match and update state".
          callback(null, null, state = _extends({}, nextState, { components: components }));
        }
      });
    }

    function handleErrorOrRedirect(error, redirectInfo) {
      if (error) callback(error);else callback(null, redirectInfo);
    }
  }

  var RouteGuid = 1;

  function getRouteID(route) {
    var create = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    return route.__id__ || create && (route.__id__ = RouteGuid++);
  }

  var RouteHooks = Object.create(null);

  function getRouteHooksForRoutes(routes) {
    return routes.map(function (route) {
      return RouteHooks[getRouteID(route)];
    }).filter(function (hook) {
      return hook;
    });
  }

  function transitionHook(location, callback) {
    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
      if (nextState == null) {
        // TODO: We didn't actually match anything, but hang
        // onto error/nextState so we don't have to matchRoutes
        // again in the listen callback.
        callback();
        return;
      }

      // Cache some state here so we don't have to
      // matchRoutes() again in the listen callback.
      partialNextState = _extends({}, nextState, { location: location });

      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);

      var result = void 0;
      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
        // Passing the location arg here indicates to
        // the user that this is a transition hook.
        result = hooks[i](location);
      }

      callback(result);
    });
  }

  /* istanbul ignore next: untestable with Karma */
  function beforeUnloadHook() {
    // Synchronously check to see if any route hooks want
    // to prevent the current window/tab from closing.
    if (state.routes) {
      var hooks = getRouteHooksForRoutes(state.routes);

      var message = void 0;
      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
        // Passing no args indicates to the user that this is a
        // beforeunload hook. We don't know the next location.
        message = hooks[i]();
      }

      return message;
    }
  }

  var unlistenBefore = void 0,
      unlistenBeforeUnload = void 0;

  function removeListenBeforeHooksForRoute(route) {
    var routeID = getRouteID(route);
    if (!routeID) {
      return;
    }

    delete RouteHooks[routeID];

    if (!hasAnyProperties(RouteHooks)) {
      // teardown transition & beforeunload hooks
      if (unlistenBefore) {
        unlistenBefore();
        unlistenBefore = null;
      }

      if (unlistenBeforeUnload) {
        unlistenBeforeUnload();
        unlistenBeforeUnload = null;
      }
    }
  }

  /**
   * Registers the given hook function to run before leaving the given route.
   *
   * During a normal transition, the hook function receives the next location
   * as its only argument and can return either a prompt message (string) to show the user,
   * to make sure they want to leave the page; or `false`, to prevent the transition.
   * Any other return value will have no effect.
   *
   * During the beforeunload event (in browsers) the hook receives no arguments.
   * In this case it must return a prompt message to prevent the transition.
   *
   * Returns a function that may be used to unbind the listener.
   */
  function listenBeforeLeavingRoute(route, hook) {
    var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
    var routeID = getRouteID(route, true);

    RouteHooks[routeID] = hook;

    if (thereWereNoRouteHooks) {
      // setup transition & beforeunload hooks
      unlistenBefore = history.listenBefore(transitionHook);

      if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
    }

    return function () {
      removeListenBeforeHooksForRoute(route);
    };
  }

  /**
   * This is the API for stateful environments. As the location
   * changes, we update state and call the listener. We can also
   * gracefully handle errors and redirects.
   */
  function listen(listener) {
    function historyListener(location) {
      if (state.location === location) {
        listener(null, state);
      } else {
        match(location, function (error, redirectLocation, nextState) {
          if (error) {
            listener(error);
          } else if (redirectLocation) {
            history.replace(redirectLocation);
          } else if (nextState) {
            listener(null, nextState);
          } else {
            "production" !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
          }
        });
      }
    }

    // TODO: Only use a single history listener. Otherwise we'll end up with
    // multiple concurrent calls to match.

    // Set up the history listener first in case the initial match redirects.
    var unsubscribe = history.listen(historyListener);

    if (state.location) {
      // Picking up on a matchContext.
      listener(null, state);
    } else {
      historyListener(history.getCurrentLocation());
    }

    return unsubscribe;
  }

  return {
    isActive: isActive,
    match: match,
    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
    listen: listen
  };
}
module.exports = exports['default'];
},{"./TransitionUtils":172,"./computeChangedRoutes":175,"./getComponents":179,"./isActive":183,"./matchRoutes":185,"./routerWarning":186}],179:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _AsyncUtils = require('./AsyncUtils');

var _PromiseUtils = require('./PromiseUtils');

function getComponentsForRoute(nextState, route, callback) {
  if (route.component || route.components) {
    callback(null, route.component || route.components);
    return;
  }

  var getComponent = route.getComponent || route.getComponents;
  if (getComponent) {
    var componentReturn = getComponent.call(route, nextState, callback);
    if ((0, _PromiseUtils.isPromise)(componentReturn)) componentReturn.then(function (component) {
      return callback(null, component);
    }, callback);
  } else {
    callback();
  }
}

/**
 * Asynchronously fetches all components needed for the given router
 * state and calls callback(error, components) when finished.
 *
 * Note: This operation may finish synchronously if no routes have an
 * asynchronous getComponents method.
 */
function getComponents(nextState, callback) {
  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
    getComponentsForRoute(nextState, route, callback);
  }, callback);
}

exports.default = getComponents;
module.exports = exports['default'];
},{"./AsyncUtils":156,"./PromiseUtils":164}],180:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _PatternUtils = require('./PatternUtils');

/**
 * Extracts an object of params the given route cares about from
 * the given params object.
 */
function getRouteParams(route, params) {
  var routeParams = {};

  if (!route.path) return routeParams;

  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
    if (Object.prototype.hasOwnProperty.call(params, p)) {
      routeParams[p] = params[p];
    }
  });

  return routeParams;
}

exports.default = getRouteParams;
module.exports = exports['default'];
},{"./PatternUtils":163}],181:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createHashHistory = require('history/lib/createHashHistory');

var _createHashHistory2 = _interopRequireDefault(_createHashHistory);

var _createRouterHistory = require('./createRouterHistory');

var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
module.exports = exports['default'];
},{"./createRouterHistory":177,"history/lib/createHashHistory":200}],182:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.RouterContext = exports.createRoutes = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;

var _RouteUtils = require('./RouteUtils');

Object.defineProperty(exports, 'createRoutes', {
  enumerable: true,
  get: function get() {
    return _RouteUtils.createRoutes;
  }
});

var _PropTypes = require('./PropTypes');

Object.defineProperty(exports, 'locationShape', {
  enumerable: true,
  get: function get() {
    return _PropTypes.locationShape;
  }
});
Object.defineProperty(exports, 'routerShape', {
  enumerable: true,
  get: function get() {
    return _PropTypes.routerShape;
  }
});

var _PatternUtils = require('./PatternUtils');

Object.defineProperty(exports, 'formatPattern', {
  enumerable: true,
  get: function get() {
    return _PatternUtils.formatPattern;
  }
});

var _Router2 = require('./Router');

var _Router3 = _interopRequireDefault(_Router2);

var _Link2 = require('./Link');

var _Link3 = _interopRequireDefault(_Link2);

var _IndexLink2 = require('./IndexLink');

var _IndexLink3 = _interopRequireDefault(_IndexLink2);

var _withRouter2 = require('./withRouter');

var _withRouter3 = _interopRequireDefault(_withRouter2);

var _IndexRedirect2 = require('./IndexRedirect');

var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);

var _IndexRoute2 = require('./IndexRoute');

var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);

var _Redirect2 = require('./Redirect');

var _Redirect3 = _interopRequireDefault(_Redirect2);

var _Route2 = require('./Route');

var _Route3 = _interopRequireDefault(_Route2);

var _RouterContext2 = require('./RouterContext');

var _RouterContext3 = _interopRequireDefault(_RouterContext2);

var _match2 = require('./match');

var _match3 = _interopRequireDefault(_match2);

var _useRouterHistory2 = require('./useRouterHistory');

var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);

var _applyRouterMiddleware2 = require('./applyRouterMiddleware');

var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);

var _browserHistory2 = require('./browserHistory');

var _browserHistory3 = _interopRequireDefault(_browserHistory2);

var _hashHistory2 = require('./hashHistory');

var _hashHistory3 = _interopRequireDefault(_hashHistory2);

var _createMemoryHistory2 = require('./createMemoryHistory');

var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Router = _Router3.default; /* components */

exports.Link = _Link3.default;
exports.IndexLink = _IndexLink3.default;
exports.withRouter = _withRouter3.default;

/* components (configuration) */

exports.IndexRedirect = _IndexRedirect3.default;
exports.IndexRoute = _IndexRoute3.default;
exports.Redirect = _Redirect3.default;
exports.Route = _Route3.default;

/* utils */

exports.RouterContext = _RouterContext3.default;
exports.match = _match3.default;
exports.useRouterHistory = _useRouterHistory3.default;
exports.applyRouterMiddleware = _applyRouterMiddleware3.default;

/* histories */

exports.browserHistory = _browserHistory3.default;
exports.hashHistory = _hashHistory3.default;
exports.createMemoryHistory = _createMemoryHistory3.default;
},{"./IndexLink":158,"./IndexRedirect":159,"./IndexRoute":160,"./Link":162,"./PatternUtils":163,"./PropTypes":165,"./Redirect":166,"./Route":167,"./RouteUtils":168,"./Router":169,"./RouterContext":170,"./applyRouterMiddleware":173,"./browserHistory":174,"./createMemoryHistory":176,"./hashHistory":181,"./match":184,"./useRouterHistory":187,"./withRouter":188}],183:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = isActive;

var _PatternUtils = require('./PatternUtils');

function deepEqual(a, b) {
  if (a == b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return deepEqual(item, b[index]);
    });
  }

  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
    for (var p in a) {
      if (!Object.prototype.hasOwnProperty.call(a, p)) {
        continue;
      }

      if (a[p] === undefined) {
        if (b[p] !== undefined) {
          return false;
        }
      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
        return false;
      } else if (!deepEqual(a[p], b[p])) {
        return false;
      }
    }

    return true;
  }

  return String(a) === String(b);
}

/**
 * Returns true if the current pathname matches the supplied one, net of
 * leading and trailing slash normalization. This is sufficient for an
 * indexOnly route match.
 */
function pathIsActive(pathname, currentPathname) {
  // Normalize leading slash for consistency. Leading slash on pathname has
  // already been normalized in isActive. See caveat there.
  if (currentPathname.charAt(0) !== '/') {
    currentPathname = '/' + currentPathname;
  }

  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
  // `/foo` as active, but in this case, we would already have failed the
  // match.
  if (pathname.charAt(pathname.length - 1) !== '/') {
    pathname += '/';
  }
  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
    currentPathname += '/';
  }

  return currentPathname === pathname;
}

/**
 * Returns true if the given pathname matches the active routes and params.
 */
function routeIsActive(pathname, routes, params) {
  var remainingPathname = pathname,
      paramNames = [],
      paramValues = [];

  // for...of would work here but it's probably slower post-transpilation.
  for (var i = 0, len = routes.length; i < len; ++i) {
    var route = routes[i];
    var pattern = route.path || '';

    if (pattern.charAt(0) === '/') {
      remainingPathname = pathname;
      paramNames = [];
      paramValues = [];
    }

    if (remainingPathname !== null && pattern) {
      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
      if (matched) {
        remainingPathname = matched.remainingPathname;
        paramNames = [].concat(paramNames, matched.paramNames);
        paramValues = [].concat(paramValues, matched.paramValues);
      } else {
        remainingPathname = null;
      }

      if (remainingPathname === '') {
        // We have an exact match on the route. Just check that all the params
        // match.
        // FIXME: This doesn't work on repeated params.
        return paramNames.every(function (paramName, index) {
          return String(paramValues[index]) === String(params[paramName]);
        });
      }
    }
  }

  return false;
}

/**
 * Returns true if all key/value pairs in the given query are
 * currently active.
 */
function queryIsActive(query, activeQuery) {
  if (activeQuery == null) return query == null;

  if (query == null) return true;

  return deepEqual(query, activeQuery);
}

/**
 * Returns true if a <Link> to the given pathname/query combination is
 * currently active.
 */
function isActive(_ref, indexOnly, currentLocation, routes, params) {
  var pathname = _ref.pathname,
      query = _ref.query;

  if (currentLocation == null) return false;

  // TODO: This is a bit ugly. It keeps around support for treating pathnames
  // without preceding slashes as absolute paths, but possibly also works
  // around the same quirks with basenames as in matchRoutes.
  if (pathname.charAt(0) !== '/') {
    pathname = '/' + pathname;
  }

  if (!pathIsActive(pathname, currentLocation.pathname)) {
    // The path check is necessary and sufficient for indexOnly, but otherwise
    // we still need to check the routes.
    if (indexOnly || !routeIsActive(pathname, routes, params)) {
      return false;
    }
  }

  return queryIsActive(query, currentLocation.query);
}
module.exports = exports['default'];
},{"./PatternUtils":163}],184:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _Actions = require('history/lib/Actions');

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _createMemoryHistory = require('./createMemoryHistory');

var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);

var _createTransitionManager = require('./createTransitionManager');

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _RouteUtils = require('./RouteUtils');

var _RouterUtils = require('./RouterUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

/**
 * A high-level API to be used for server-side rendering.
 *
 * This function matches a location to a set of routes and calls
 * callback(error, redirectLocation, renderProps) when finished.
 *
 * Note: You probably don't want to use this in a browser unless you're using
 * server-side rendering with async routes.
 */
function match(_ref, callback) {
  var history = _ref.history,
      routes = _ref.routes,
      location = _ref.location,
      options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);

  !(history || location) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;

  history = history ? history : (0, _createMemoryHistory2.default)(options);
  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));

  if (location) {
    // Allow match({ location: '/the/path', ... })
    location = history.createLocation(location);
  } else {
    location = history.getCurrentLocation();
  }

  transitionManager.match(location, function (error, redirectLocation, nextState) {
    var renderProps = void 0;

    if (nextState) {
      var router = (0, _RouterUtils.createRouterObject)(history, transitionManager, nextState);
      renderProps = _extends({}, nextState, {
        router: router,
        matchContext: { transitionManager: transitionManager, router: router }
      });
    }

    callback(error, redirectLocation && history.createLocation(redirectLocation, _Actions.REPLACE), renderProps);
  });
}

exports.default = match;
module.exports = exports['default'];
},{"./RouteUtils":168,"./RouterUtils":171,"./createMemoryHistory":176,"./createTransitionManager":178,"history/lib/Actions":189,"invariant":26}],185:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = matchRoutes;

var _AsyncUtils = require('./AsyncUtils');

var _PromiseUtils = require('./PromiseUtils');

var _PatternUtils = require('./PatternUtils');

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _RouteUtils = require('./RouteUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getChildRoutes(route, location, paramNames, paramValues, callback) {
  if (route.childRoutes) {
    return [null, route.childRoutes];
  }
  if (!route.getChildRoutes) {
    return [];
  }

  var sync = true,
      result = void 0;

  var partialNextState = {
    location: location,
    params: createParams(paramNames, paramValues)
  };

  var childRoutesReturn = route.getChildRoutes(partialNextState, function (error, childRoutes) {
    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
    if (sync) {
      result = [error, childRoutes];
      return;
    }

    callback(error, childRoutes);
  });

  if ((0, _PromiseUtils.isPromise)(childRoutesReturn)) childRoutesReturn.then(function (childRoutes) {
    return callback(null, (0, _RouteUtils.createRoutes)(childRoutes));
  }, callback);

  sync = false;
  return result; // Might be undefined.
}

function getIndexRoute(route, location, paramNames, paramValues, callback) {
  if (route.indexRoute) {
    callback(null, route.indexRoute);
  } else if (route.getIndexRoute) {
    var partialNextState = {
      location: location,
      params: createParams(paramNames, paramValues)
    };

    var indexRoutesReturn = route.getIndexRoute(partialNextState, function (error, indexRoute) {
      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
    });

    if ((0, _PromiseUtils.isPromise)(indexRoutesReturn)) indexRoutesReturn.then(function (indexRoute) {
      return callback(null, (0, _RouteUtils.createRoutes)(indexRoute)[0]);
    }, callback);
  } else if (route.childRoutes || route.getChildRoutes) {
    var onChildRoutes = function onChildRoutes(error, childRoutes) {
      if (error) {
        callback(error);
        return;
      }

      var pathless = childRoutes.filter(function (childRoute) {
        return !childRoute.path;
      });

      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
          if (error || indexRoute) {
            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
            done(error, routes);
          } else {
            next();
          }
        });
      }, function (err, routes) {
        callback(null, routes);
      });
    };

    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
    if (result) {
      onChildRoutes.apply(undefined, result);
    }
  } else {
    callback();
  }
}

function assignParams(params, paramNames, paramValues) {
  return paramNames.reduce(function (params, paramName, index) {
    var paramValue = paramValues && paramValues[index];

    if (Array.isArray(params[paramName])) {
      params[paramName].push(paramValue);
    } else if (paramName in params) {
      params[paramName] = [params[paramName], paramValue];
    } else {
      params[paramName] = paramValue;
    }

    return params;
  }, params);
}

function createParams(paramNames, paramValues) {
  return assignParams({}, paramNames, paramValues);
}

function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
  var pattern = route.path || '';

  if (pattern.charAt(0) === '/') {
    remainingPathname = location.pathname;
    paramNames = [];
    paramValues = [];
  }

  // Only try to match the path if the route actually has a pattern, and if
  // we're not just searching for potential nested absolute paths.
  if (remainingPathname !== null && pattern) {
    try {
      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
      if (matched) {
        remainingPathname = matched.remainingPathname;
        paramNames = [].concat(paramNames, matched.paramNames);
        paramValues = [].concat(paramValues, matched.paramValues);
      } else {
        remainingPathname = null;
      }
    } catch (error) {
      callback(error);
    }

    // By assumption, pattern is non-empty here, which is the prerequisite for
    // actually terminating a match.
    if (remainingPathname === '') {
      var _ret = function () {
        var match = {
          routes: [route],
          params: createParams(paramNames, paramValues)
        };

        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
          if (error) {
            callback(error);
          } else {
            if (Array.isArray(indexRoute)) {
              var _match$routes;

              "production" !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
                return !route.path;
              }), 'Index routes should not have paths') : void 0;
              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
            } else if (indexRoute) {
              "production" !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
              match.routes.push(indexRoute);
            }

            callback(null, match);
          }
        });

        return {
          v: void 0
        };
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }
  }

  if (remainingPathname != null || route.childRoutes) {
    // Either a) this route matched at least some of the path or b)
    // we don't have to load this route's children asynchronously. In
    // either case continue checking for matches in the subtree.
    var onChildRoutes = function onChildRoutes(error, childRoutes) {
      if (error) {
        callback(error);
      } else if (childRoutes) {
        // Check the child routes to see if any of them match.
        matchRoutes(childRoutes, location, function (error, match) {
          if (error) {
            callback(error);
          } else if (match) {
            // A child route matched! Augment the match and pass it up the stack.
            match.routes.unshift(route);
            callback(null, match);
          } else {
            callback();
          }
        }, remainingPathname, paramNames, paramValues);
      } else {
        callback();
      }
    };

    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
    if (result) {
      onChildRoutes.apply(undefined, result);
    }
  } else {
    callback();
  }
}

/**
 * Asynchronously matches the given location to a set of routes and calls
 * callback(error, state) when finished. The state object will have the
 * following properties:
 *
 * - routes       An array of routes that matched, in hierarchical order
 * - params       An object of URL parameters
 *
 * Note: This operation may finish synchronously if no routes have an
 * asynchronous getChildRoutes method.
 */
function matchRoutes(routes, location, callback, remainingPathname) {
  var paramNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var paramValues = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];

  if (remainingPathname === undefined) {
    // TODO: This is a little bit ugly, but it works around a quirk in history
    // that strips the leading slash from pathnames when using basenames with
    // trailing slashes.
    if (location.pathname.charAt(0) !== '/') {
      location = _extends({}, location, {
        pathname: '/' + location.pathname
      });
    }
    remainingPathname = location.pathname;
  }

  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
      if (error || match) {
        done(error, match);
      } else {
        next();
      }
    });
  }, callback);
}
module.exports = exports['default'];
},{"./AsyncUtils":156,"./PatternUtils":163,"./PromiseUtils":164,"./RouteUtils":168,"./routerWarning":186}],186:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = routerWarning;
exports._resetWarned = _resetWarned;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var warned = {};

function routerWarning(falseToWarn, message) {
  // Only issue deprecation warnings once.
  if (message.indexOf('deprecated') !== -1) {
    if (warned[message]) {
      return;
    }

    warned[message] = true;
  }

  message = '[react-router] ' + message;

  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
}

function _resetWarned() {
  warned = {};
}
},{"warning":232}],187:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = useRouterHistory;

var _useQueries = require('history/lib/useQueries');

var _useQueries2 = _interopRequireDefault(_useQueries);

var _useBasename = require('history/lib/useBasename');

var _useBasename2 = _interopRequireDefault(_useBasename);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function useRouterHistory(createHistory) {
  return function (options) {
    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
    return history;
  };
}
module.exports = exports['default'];
},{"history/lib/useBasename":204,"history/lib/useQueries":205}],188:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = withRouter;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _ContextUtils = require('./ContextUtils');

var _PropTypes = require('./PropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

function withRouter(WrappedComponent, options) {
  var withRef = options && options.withRef;

  var WithRouter = _react2.default.createClass({
    displayName: 'WithRouter',

    mixins: [(0, _ContextUtils.ContextSubscriber)('router')],

    contextTypes: { router: _PropTypes.routerShape },
    propTypes: { router: _PropTypes.routerShape },

    getWrappedInstance: function getWrappedInstance() {
      !withRef ? "production" !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;

      return this.wrappedInstance;
    },
    render: function render() {
      var _this = this;

      var router = this.props.router || this.context.router;
      if (!router) {
        return _react2.default.createElement(WrappedComponent, this.props);
      }

      var params = router.params,
          location = router.location,
          routes = router.routes;

      var props = _extends({}, this.props, { router: router, params: params, location: location, routes: routes });

      if (withRef) {
        props.ref = function (c) {
          _this.wrappedInstance = c;
        };
      }

      return _react2.default.createElement(WrappedComponent, props);
    }
  });

  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
  WithRouter.WrappedComponent = WrappedComponent;

  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
}
module.exports = exports['default'];
},{"./ContextUtils":157,"./PropTypes":165,"hoist-non-react-statics":25,"invariant":26,"react":230}],189:[function(require,module,exports){
'use strict';

exports.__esModule = true;
/**
 * Indicates that navigation was caused by a call to history.push.
 */
var PUSH = exports.PUSH = 'PUSH';

/**
 * Indicates that navigation was caused by a call to history.replace.
 */
var REPLACE = exports.REPLACE = 'REPLACE';

/**
 * Indicates that navigation was caused by some other action such
 * as using a browser's back/forward buttons and/or manually manipulating
 * the URL in a browser's location bar. This is the default.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
 * for more information.
 */
var POP = exports.POP = 'POP';
},{}],190:[function(require,module,exports){
"use strict";

exports.__esModule = true;
var loopAsync = exports.loopAsync = function loopAsync(turns, work, callback) {
  var currentTurn = 0,
      isDone = false;
  var isSync = false,
      hasNext = false,
      doneArgs = void 0;

  var done = function done() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    isDone = true;

    if (isSync) {
      // Iterate instead of recursing if possible.
      doneArgs = args;
      return;
    }

    callback.apply(undefined, args);
  };

  var next = function next() {
    if (isDone) return;

    hasNext = true;

    if (isSync) return; // Iterate instead of recursing if possible.

    isSync = true;

    while (!isDone && currentTurn < turns && hasNext) {
      hasNext = false;
      work(currentTurn++, next, done);
    }

    isSync = false;

    if (isDone) {
      // This means the loop finished synchronously.
      callback.apply(undefined, doneArgs);
      return;
    }

    if (currentTurn >= turns && hasNext) {
      isDone = true;
      callback();
    }
  };

  next();
};
},{}],191:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.go = exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getUserConfirmation = exports.getCurrentLocation = undefined;

var _LocationUtils = require('./LocationUtils');

var _DOMUtils = require('./DOMUtils');

var _DOMStateStorage = require('./DOMStateStorage');

var _PathUtils = require('./PathUtils');

var _ExecutionEnvironment = require('./ExecutionEnvironment');

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var needsHashchangeListener = _ExecutionEnvironment.canUseDOM && !(0, _DOMUtils.supportsPopstateOnHashchange)();

var _createLocation = function _createLocation(historyState) {
  var key = historyState && historyState.key;

  return (0, _LocationUtils.createLocation)({
    pathname: window.location.pathname,
    search: window.location.search,
    hash: window.location.hash,
    state: key ? (0, _DOMStateStorage.readState)(key) : undefined
  }, undefined, key);
};

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
  var historyState = void 0;
  try {
    historyState = window.history.state || {};
  } catch (error) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    historyState = {};
  }

  return _createLocation(historyState);
};

var getUserConfirmation = exports.getUserConfirmation = function getUserConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

var startListener = exports.startListener = function startListener(listener) {
  var handlePopState = function handlePopState(event) {
    if (event.state !== undefined) // Ignore extraneous popstate events in WebKit
      listener(_createLocation(event.state));
  };

  (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

  var handleUnpoppedHashChange = function handleUnpoppedHashChange() {
    return listener(getCurrentLocation());
  };

  if (needsHashchangeListener) {
    (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleUnpoppedHashChange);
  }

  return function () {
    (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

    if (needsHashchangeListener) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleUnpoppedHashChange);
    }
  };
};

var updateLocation = function updateLocation(location, updateState) {
  var state = location.state;
  var key = location.key;


  if (state !== undefined) (0, _DOMStateStorage.saveState)(key, state);

  updateState({ key: key }, (0, _PathUtils.createPath)(location));
};

var pushLocation = exports.pushLocation = function pushLocation(location) {
  return updateLocation(location, function (state, path) {
    return window.history.pushState(state, null, path);
  });
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
  return updateLocation(location, function (state, path) {
    return window.history.replaceState(state, null, path);
  });
};

var go = exports.go = function go(n) {
  if (n) window.history.go(n);
};
},{"./DOMStateStorage":192,"./DOMUtils":193,"./ExecutionEnvironment":194,"./LocationUtils":196,"./PathUtils":197}],192:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.readState = exports.saveState = undefined;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QuotaExceededErrors = {
  QuotaExceededError: true,
  QUOTA_EXCEEDED_ERR: true
};

var SecurityErrors = {
  SecurityError: true
};

var KeyPrefix = '@@History/';

var createKey = function createKey(key) {
  return KeyPrefix + key;
};

var saveState = exports.saveState = function saveState(key, state) {
  if (!window.sessionStorage) {
    // Session storage is not available or hidden.
    // sessionStorage is undefined in Internet Explorer when served via file protocol.
    "production" !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available') : void 0;

    return;
  }

  try {
    if (state == null) {
      window.sessionStorage.removeItem(createKey(key));
    } else {
      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
    }
  } catch (error) {
    if (SecurityErrors[error.name]) {
      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
      // attempt to access window.sessionStorage.
      "production" !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available due to security settings') : void 0;

      return;
    }

    if (QuotaExceededErrors[error.name] && window.sessionStorage.length === 0) {
      // Safari "private mode" throws QuotaExceededError.
      "production" !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : void 0;

      return;
    }

    throw error;
  }
};

var readState = exports.readState = function readState(key) {
  var json = void 0;
  try {
    json = window.sessionStorage.getItem(createKey(key));
  } catch (error) {
    if (SecurityErrors[error.name]) {
      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
      // attempt to access window.sessionStorage.
      "production" !== 'production' ? (0, _warning2.default)(false, '[history] Unable to read state; sessionStorage is not available due to security settings') : void 0;

      return undefined;
    }
  }

  if (json) {
    try {
      return JSON.parse(json);
    } catch (error) {
      // Ignore invalid JSON.
    }
  }

  return undefined;
};
},{"warning":232}],193:[function(require,module,exports){
'use strict';

exports.__esModule = true;
var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopstateOnHashchange = exports.supportsPopstateOnHashchange = function supportsPopstateOnHashchange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};
},{}],194:[function(require,module,exports){
'use strict';

exports.__esModule = true;
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
},{}],195:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;

var _BrowserProtocol = require('./BrowserProtocol');

Object.defineProperty(exports, 'getUserConfirmation', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.getUserConfirmation;
  }
});
Object.defineProperty(exports, 'go', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.go;
  }
});

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _LocationUtils = require('./LocationUtils');

var _DOMUtils = require('./DOMUtils');

var _DOMStateStorage = require('./DOMStateStorage');

var _PathUtils = require('./PathUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HashChangeEvent = 'hashchange';

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation(pathCoder, queryKey) {
  var path = pathCoder.decodePath(getHashPath());
  var key = (0, _PathUtils.getQueryStringValueFromPath)(path, queryKey);

  var state = void 0;
  if (key) {
    path = (0, _PathUtils.stripQueryStringValueFromPath)(path, queryKey);
    state = (0, _DOMStateStorage.readState)(key);
  }

  var init = (0, _PathUtils.parsePath)(path);
  init.state = state;

  return (0, _LocationUtils.createLocation)(init, undefined, key);
};

var prevLocation = void 0;

var startListener = exports.startListener = function startListener(listener, pathCoder, queryKey) {
  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = pathCoder.encodePath(path);

    if (path !== encodedPath) {
      // Always be sure we have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var currentLocation = getCurrentLocation(pathCoder, queryKey);

      if (prevLocation && currentLocation.key && prevLocation.key === currentLocation.key) return; // Ignore extraneous hashchange events

      prevLocation = currentLocation;

      listener(currentLocation);
    }
  };

  // Ensure the hash is encoded properly.
  var path = getHashPath();
  var encodedPath = pathCoder.encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);

  return function () {
    return (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
  };
};

var updateLocation = function updateLocation(location, pathCoder, queryKey, updateHash) {
  var state = location.state;
  var key = location.key;


  var path = pathCoder.encodePath((0, _PathUtils.createPath)(location));

  if (state !== undefined) {
    path = (0, _PathUtils.addQueryStringValueToPath)(path, queryKey, key);
    (0, _DOMStateStorage.saveState)(key, state);
  }

  prevLocation = location;

  updateHash(path);
};

var pushLocation = exports.pushLocation = function pushLocation(location, pathCoder, queryKey) {
  return updateLocation(location, pathCoder, queryKey, function (path) {
    if (getHashPath() !== path) {
      pushHashPath(path);
    } else {
      "production" !== 'production' ? (0, _warning2.default)(false, 'You cannot PUSH the same path using hash history') : void 0;
    }
  });
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location, pathCoder, queryKey) {
  return updateLocation(location, pathCoder, queryKey, function (path) {
    if (getHashPath() !== path) replaceHashPath(path);
  });
};
},{"./BrowserProtocol":191,"./DOMStateStorage":192,"./DOMUtils":193,"./LocationUtils":196,"./PathUtils":197,"warning":232}],196:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.locationsAreEqual = exports.statesAreEqual = exports.createLocation = exports.createQuery = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = require('./PathUtils');

var _Actions = require('./Actions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createQuery = exports.createQuery = function createQuery(props) {
  return _extends(Object.create(null), props);
};

var createLocation = exports.createLocation = function createLocation() {
  var input = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var object = typeof input === 'string' ? (0, _PathUtils.parsePath)(input) : input;

  "production" !== 'production' ? (0, _warning2.default)(!object.path, 'Location descriptor objects should have a `pathname`, not a `path`.') : void 0;

  var pathname = object.pathname || '/';
  var search = object.search || '';
  var hash = object.hash || '';
  var state = object.state;

  return {
    pathname: pathname,
    search: search,
    hash: hash,
    state: state,
    action: action,
    key: key
  };
};

var isDate = function isDate(object) {
  return Object.prototype.toString.call(object) === '[object Date]';
};

var statesAreEqual = exports.statesAreEqual = function statesAreEqual(a, b) {
  if (a === b) return true;

  var typeofA = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var typeofB = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (typeofA !== typeofB) return false;

  !(typeofA !== 'function') ? "production" !== 'production' ? (0, _invariant2.default)(false, 'You must not store functions in location state') : (0, _invariant2.default)(false) : void 0;

  // Not the same object, but same type.
  if (typeofA === 'object') {
    !!(isDate(a) && isDate(b)) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'You must not store Date objects in location state') : (0, _invariant2.default)(false) : void 0;

    if (!Array.isArray(a)) {
      var keysofA = Object.keys(a);
      var keysofB = Object.keys(b);
      return keysofA.length === keysofB.length && keysofA.every(function (key) {
        return statesAreEqual(a[key], b[key]);
      });
    }

    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return statesAreEqual(item, b[index]);
    });
  }

  // All other serializable types (string, number, boolean)
  // should be strict equal.
  return false;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.key === b.key &&
  // a.action === b.action && // Different action !== location change.
  a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && statesAreEqual(a.state, b.state);
};
},{"./Actions":189,"./PathUtils":197,"invariant":26,"warning":232}],197:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.createPath = exports.parsePath = exports.getQueryStringValueFromPath = exports.stripQueryStringValueFromPath = exports.addQueryStringValueToPath = undefined;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var addQueryStringValueToPath = exports.addQueryStringValueToPath = function addQueryStringValueToPath(path, key, value) {
  var _parsePath = parsePath(path);

  var pathname = _parsePath.pathname;
  var search = _parsePath.search;
  var hash = _parsePath.hash;


  return createPath({
    pathname: pathname,
    search: search + (search.indexOf('?') === -1 ? '?' : '&') + key + '=' + value,
    hash: hash
  });
};

var stripQueryStringValueFromPath = exports.stripQueryStringValueFromPath = function stripQueryStringValueFromPath(path, key) {
  var _parsePath2 = parsePath(path);

  var pathname = _parsePath2.pathname;
  var search = _parsePath2.search;
  var hash = _parsePath2.hash;


  return createPath({
    pathname: pathname,
    search: search.replace(new RegExp('([?&])' + key + '=[a-zA-Z0-9]+(&?)'), function (match, prefix, suffix) {
      return prefix === '?' ? prefix : suffix;
    }),
    hash: hash
  });
};

var getQueryStringValueFromPath = exports.getQueryStringValueFromPath = function getQueryStringValueFromPath(path, key) {
  var _parsePath3 = parsePath(path);

  var search = _parsePath3.search;

  var match = search.match(new RegExp('[?&]' + key + '=([a-zA-Z0-9]+)'));
  return match && match[1];
};

var extractPath = function extractPath(string) {
  var match = string.match(/^(https?:)?\/\/[^\/]*/);
  return match == null ? string : string.substring(match[0].length);
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = extractPath(path);
  var search = '';
  var hash = '';

  "production" !== 'production' ? (0, _warning2.default)(path === pathname, 'A path must be pathname + search + hash only, not a full URL like "%s"', path) : void 0;

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substring(hashIndex);
    pathname = pathname.substring(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substring(searchIndex);
    pathname = pathname.substring(0, searchIndex);
  }

  if (pathname === '') pathname = '/';

  return {
    pathname: pathname,
    search: search,
    hash: hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  if (location == null || typeof location === 'string') return location;

  var basename = location.basename;
  var pathname = location.pathname;
  var search = location.search;
  var hash = location.hash;

  var path = (basename || '') + pathname;

  if (search && search !== '?') path += search;

  if (hash) path += hash;

  return path;
};
},{"warning":232}],198:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.replaceLocation = exports.pushLocation = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;

var _BrowserProtocol = require('./BrowserProtocol');

Object.defineProperty(exports, 'getUserConfirmation', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.getUserConfirmation;
  }
});
Object.defineProperty(exports, 'go', {
  enumerable: true,
  get: function get() {
    return _BrowserProtocol.go;
  }
});

var _LocationUtils = require('./LocationUtils');

var _PathUtils = require('./PathUtils');

var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
  return (0, _LocationUtils.createLocation)(window.location);
};

var pushLocation = exports.pushLocation = function pushLocation(location) {
  window.location.href = (0, _PathUtils.createPath)(location);
  return false; // Don't update location
};

var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
  window.location.replace((0, _PathUtils.createPath)(location));
  return false; // Don't update location
};
},{"./BrowserProtocol":191,"./LocationUtils":196,"./PathUtils":197}],199:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _ExecutionEnvironment = require('./ExecutionEnvironment');

var _BrowserProtocol = require('./BrowserProtocol');

var BrowserProtocol = _interopRequireWildcard(_BrowserProtocol);

var _RefreshProtocol = require('./RefreshProtocol');

var RefreshProtocol = _interopRequireWildcard(_RefreshProtocol);

var _DOMUtils = require('./DOMUtils');

var _createHistory = require('./createHistory');

var _createHistory2 = _interopRequireDefault(_createHistory);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates and returns a history object that uses HTML5's history API
 * (pushState, replaceState, and the popstate event) to manage history.
 * This is the recommended method of managing history in browsers because
 * it provides the cleanest URLs.
 *
 * Note: In browsers that do not support the HTML5 history API full
 * page reloads will be used to preserve clean URLs. You can force this
 * behavior using { forceRefresh: true } in options.
 */
var createBrowserHistory = function createBrowserHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  !_ExecutionEnvironment.canUseDOM ? "production" !== 'production' ? (0, _invariant2.default)(false, 'Browser history needs a DOM') : (0, _invariant2.default)(false) : void 0;

  var useRefresh = options.forceRefresh || !(0, _DOMUtils.supportsHistory)();
  var Protocol = useRefresh ? RefreshProtocol : BrowserProtocol;

  var getUserConfirmation = Protocol.getUserConfirmation;
  var getCurrentLocation = Protocol.getCurrentLocation;
  var pushLocation = Protocol.pushLocation;
  var replaceLocation = Protocol.replaceLocation;
  var go = Protocol.go;


  var history = (0, _createHistory2.default)(_extends({
    getUserConfirmation: getUserConfirmation }, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: go
  }));

  var listenerCount = 0,
      stopListener = void 0;

  var startListener = function startListener(listener, before) {
    if (++listenerCount === 1) stopListener = BrowserProtocol.startListener(history.transitionTo);

    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopListener();
    };
  };

  var listenBefore = function listenBefore(listener) {
    return startListener(listener, true);
  };

  var listen = function listen(listener) {
    return startListener(listener, false);
  };

  return _extends({}, history, {
    listenBefore: listenBefore,
    listen: listen
  });
};

exports.default = createBrowserHistory;
},{"./BrowserProtocol":191,"./DOMUtils":193,"./ExecutionEnvironment":194,"./RefreshProtocol":198,"./createHistory":201,"invariant":26}],200:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _ExecutionEnvironment = require('./ExecutionEnvironment');

var _DOMUtils = require('./DOMUtils');

var _HashProtocol = require('./HashProtocol');

var HashProtocol = _interopRequireWildcard(_HashProtocol);

var _createHistory = require('./createHistory');

var _createHistory2 = _interopRequireDefault(_createHistory);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DefaultQueryKey = '_k';

var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!' + path;
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substring(1) : path;
    }
  },
  noslash: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '/' ? path.substring(1) : path;
    },
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};

var createHashHistory = function createHashHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  !_ExecutionEnvironment.canUseDOM ? "production" !== 'production' ? (0, _invariant2.default)(false, 'Hash history needs a DOM') : (0, _invariant2.default)(false) : void 0;

  var queryKey = options.queryKey;
  var hashType = options.hashType;


  "production" !== 'production' ? (0, _warning2.default)(queryKey !== false, 'Using { queryKey: false } no longer works. Instead, just don\'t ' + 'use location state if you don\'t want a key in your URL query string') : void 0;

  if (typeof queryKey !== 'string') queryKey = DefaultQueryKey;

  if (hashType == null) hashType = 'slash';

  if (!(hashType in HashPathCoders)) {
    "production" !== 'production' ? (0, _warning2.default)(false, 'Invalid hash type: %s', hashType) : void 0;

    hashType = 'slash';
  }

  var pathCoder = HashPathCoders[hashType];

  var getUserConfirmation = HashProtocol.getUserConfirmation;


  var getCurrentLocation = function getCurrentLocation() {
    return HashProtocol.getCurrentLocation(pathCoder, queryKey);
  };

  var pushLocation = function pushLocation(location) {
    return HashProtocol.pushLocation(location, pathCoder, queryKey);
  };

  var replaceLocation = function replaceLocation(location) {
    return HashProtocol.replaceLocation(location, pathCoder, queryKey);
  };

  var history = (0, _createHistory2.default)(_extends({
    getUserConfirmation: getUserConfirmation }, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: HashProtocol.go
  }));

  var listenerCount = 0,
      stopListener = void 0;

  var startListener = function startListener(listener, before) {
    if (++listenerCount === 1) stopListener = HashProtocol.startListener(history.transitionTo, pathCoder, queryKey);

    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopListener();
    };
  };

  var listenBefore = function listenBefore(listener) {
    return startListener(listener, true);
  };

  var listen = function listen(listener) {
    return startListener(listener, false);
  };

  var goIsSupportedWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var go = function go(n) {
    "production" !== 'production' ? (0, _warning2.default)(goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;

    history.go(n);
  };

  var createHref = function createHref(path) {
    return '#' + pathCoder.encodePath(history.createHref(path));
  };

  return _extends({}, history, {
    listenBefore: listenBefore,
    listen: listen,
    go: go,
    createHref: createHref
  });
};

exports.default = createHashHistory;
},{"./DOMUtils":193,"./ExecutionEnvironment":194,"./HashProtocol":195,"./createHistory":201,"invariant":26,"warning":232}],201:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _AsyncUtils = require('./AsyncUtils');

var _PathUtils = require('./PathUtils');

var _runTransitionHook = require('./runTransitionHook');

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _Actions = require('./Actions');

var _LocationUtils = require('./LocationUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createHistory = function createHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var getCurrentLocation = options.getCurrentLocation;
  var getUserConfirmation = options.getUserConfirmation;
  var pushLocation = options.pushLocation;
  var replaceLocation = options.replaceLocation;
  var go = options.go;
  var keyLength = options.keyLength;


  var currentLocation = void 0;
  var pendingLocation = void 0;
  var beforeListeners = [];
  var listeners = [];
  var allKeys = [];

  var getCurrentIndex = function getCurrentIndex() {
    if (pendingLocation && pendingLocation.action === _Actions.POP) return allKeys.indexOf(pendingLocation.key);

    if (currentLocation) return allKeys.indexOf(currentLocation.key);

    return -1;
  };

  var updateLocation = function updateLocation(nextLocation) {
    var currentIndex = getCurrentIndex();

    currentLocation = nextLocation;

    if (currentLocation.action === _Actions.PUSH) {
      allKeys = [].concat(allKeys.slice(0, currentIndex + 1), [currentLocation.key]);
    } else if (currentLocation.action === _Actions.REPLACE) {
      allKeys[currentIndex] = currentLocation.key;
    }

    listeners.forEach(function (listener) {
      return listener(currentLocation);
    });
  };

  var listenBefore = function listenBefore(listener) {
    beforeListeners.push(listener);

    return function () {
      return beforeListeners = beforeListeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var listen = function listen(listener) {
    listeners.push(listener);

    return function () {
      return listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, callback) {
    (0, _AsyncUtils.loopAsync)(beforeListeners.length, function (index, next, done) {
      (0, _runTransitionHook2.default)(beforeListeners[index], location, function (result) {
        return result != null ? done(result) : next();
      });
    }, function (message) {
      if (getUserConfirmation && typeof message === 'string') {
        getUserConfirmation(message, function (ok) {
          return callback(ok !== false);
        });
      } else {
        callback(message !== false);
      }
    });
  };

  var transitionTo = function transitionTo(nextLocation) {
    if (currentLocation && (0, _LocationUtils.locationsAreEqual)(currentLocation, nextLocation) || pendingLocation && (0, _LocationUtils.locationsAreEqual)(pendingLocation, nextLocation)) return; // Nothing to do

    pendingLocation = nextLocation;

    confirmTransitionTo(nextLocation, function (ok) {
      if (pendingLocation !== nextLocation) return; // Transition was interrupted during confirmation

      pendingLocation = null;

      if (ok) {
        // Treat PUSH to same path like REPLACE to be consistent with browsers
        if (nextLocation.action === _Actions.PUSH) {
          var prevPath = (0, _PathUtils.createPath)(currentLocation);
          var nextPath = (0, _PathUtils.createPath)(nextLocation);

          if (nextPath === prevPath && (0, _LocationUtils.statesAreEqual)(currentLocation.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
        }

        if (nextLocation.action === _Actions.POP) {
          updateLocation(nextLocation);
        } else if (nextLocation.action === _Actions.PUSH) {
          if (pushLocation(nextLocation) !== false) updateLocation(nextLocation);
        } else if (nextLocation.action === _Actions.REPLACE) {
          if (replaceLocation(nextLocation) !== false) updateLocation(nextLocation);
        }
      } else if (currentLocation && nextLocation.action === _Actions.POP) {
        var prevIndex = allKeys.indexOf(currentLocation.key);
        var nextIndex = allKeys.indexOf(nextLocation.key);

        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL
      }
    });
  };

  var push = function push(input) {
    return transitionTo(createLocation(input, _Actions.PUSH));
  };

  var replace = function replace(input) {
    return transitionTo(createLocation(input, _Actions.REPLACE));
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength || 6);
  };

  var createHref = function createHref(location) {
    return (0, _PathUtils.createPath)(location);
  };

  var createLocation = function createLocation(location, action) {
    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
    return (0, _LocationUtils.createLocation)(location, action, key);
  };

  return {
    getCurrentLocation: getCurrentLocation,
    listenBefore: listenBefore,
    listen: listen,
    transitionTo: transitionTo,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    createKey: createKey,
    createPath: _PathUtils.createPath,
    createHref: createHref,
    createLocation: createLocation
  };
};

exports.default = createHistory;
},{"./Actions":189,"./AsyncUtils":190,"./LocationUtils":196,"./PathUtils":197,"./runTransitionHook":203}],202:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = require('./LocationUtils');

var _PathUtils = require('./PathUtils');

var _createHistory = require('./createHistory');

var _createHistory2 = _interopRequireDefault(_createHistory);

var _Actions = require('./Actions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createStateStorage = function createStateStorage(entries) {
  return entries.filter(function (entry) {
    return entry.state;
  }).reduce(function (memo, entry) {
    memo[entry.key] = entry.state;
    return memo;
  }, {});
};

var createMemoryHistory = function createMemoryHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  if (Array.isArray(options)) {
    options = { entries: options };
  } else if (typeof options === 'string') {
    options = { entries: [options] };
  }

  var getCurrentLocation = function getCurrentLocation() {
    var entry = entries[current];
    var path = (0, _PathUtils.createPath)(entry);

    var key = void 0,
        state = void 0;
    if (entry.key) {
      key = entry.key;
      state = readState(key);
    }

    var init = (0, _PathUtils.parsePath)(path);

    return (0, _LocationUtils.createLocation)(_extends({}, init, { state: state }), undefined, key);
  };

  var canGo = function canGo(n) {
    var index = current + n;
    return index >= 0 && index < entries.length;
  };

  var go = function go(n) {
    if (!n) return;

    if (!canGo(n)) {
      "production" !== 'production' ? (0, _warning2.default)(false, 'Cannot go(%s) there is not enough history', n) : void 0;

      return;
    }

    current += n;
    var currentLocation = getCurrentLocation();

    // Change action to POP
    history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
  };

  var pushLocation = function pushLocation(location) {
    current += 1;

    if (current < entries.length) entries.splice(current);

    entries.push(location);

    saveState(location.key, location.state);
  };

  var replaceLocation = function replaceLocation(location) {
    entries[current] = location;
    saveState(location.key, location.state);
  };

  var history = (0, _createHistory2.default)(_extends({}, options, {
    getCurrentLocation: getCurrentLocation,
    pushLocation: pushLocation,
    replaceLocation: replaceLocation,
    go: go
  }));

  var _options = options;
  var entries = _options.entries;
  var current = _options.current;


  if (typeof entries === 'string') {
    entries = [entries];
  } else if (!Array.isArray(entries)) {
    entries = ['/'];
  }

  entries = entries.map(function (entry) {
    return (0, _LocationUtils.createLocation)(entry);
  });

  if (current == null) {
    current = entries.length - 1;
  } else {
    !(current >= 0 && current < entries.length) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : (0, _invariant2.default)(false) : void 0;
  }

  var storage = createStateStorage(entries);

  var saveState = function saveState(key, state) {
    return storage[key] = state;
  };

  var readState = function readState(key) {
    return storage[key];
  };

  return _extends({}, history, {
    canGo: canGo
  });
};

exports.default = createMemoryHistory;
},{"./Actions":189,"./LocationUtils":196,"./PathUtils":197,"./createHistory":201,"invariant":26,"warning":232}],203:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var runTransitionHook = function runTransitionHook(hook, location, callback) {
  var result = hook(location, callback);

  if (hook.length < 2) {
    // Assume the hook runs synchronously and automatically
    // call the callback with the return value.
    callback(result);
  } else {
    "production" !== 'production' ? (0, _warning2.default)(result === undefined, 'You should not "return" in a transition hook with a callback argument; ' + 'call the callback instead') : void 0;
  }
};

exports.default = runTransitionHook;
},{"warning":232}],204:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _runTransitionHook = require('./runTransitionHook');

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _PathUtils = require('./PathUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var useBasename = function useBasename(createHistory) {
  return function () {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var history = createHistory(options);
    var basename = options.basename;


    var addBasename = function addBasename(location) {
      if (!location) return location;

      if (basename && location.basename == null) {
        if (location.pathname.indexOf(basename) === 0) {
          location.pathname = location.pathname.substring(basename.length);
          location.basename = basename;

          if (location.pathname === '') location.pathname = '/';
        } else {
          location.basename = '';
        }
      }

      return location;
    };

    var prependBasename = function prependBasename(location) {
      if (!basename) return location;

      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
      var pname = object.pathname;
      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
      var pathname = normalizedBasename + normalizedPathname;

      return _extends({}, object, {
        pathname: pathname
      });
    };

    // Override all read methods with basename-aware versions.
    var getCurrentLocation = function getCurrentLocation() {
      return addBasename(history.getCurrentLocation());
    };

    var listenBefore = function listenBefore(hook) {
      return history.listenBefore(function (location, callback) {
        return (0, _runTransitionHook2.default)(hook, addBasename(location), callback);
      });
    };

    var listen = function listen(listener) {
      return history.listen(function (location) {
        return listener(addBasename(location));
      });
    };

    // Override all write methods with basename-aware versions.
    var push = function push(location) {
      return history.push(prependBasename(location));
    };

    var replace = function replace(location) {
      return history.replace(prependBasename(location));
    };

    var createPath = function createPath(location) {
      return history.createPath(prependBasename(location));
    };

    var createHref = function createHref(location) {
      return history.createHref(prependBasename(location));
    };

    var createLocation = function createLocation(location) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
    };

    return _extends({}, history, {
      getCurrentLocation: getCurrentLocation,
      listenBefore: listenBefore,
      listen: listen,
      push: push,
      replace: replace,
      createPath: createPath,
      createHref: createHref,
      createLocation: createLocation
    });
  };
};

exports.default = useBasename;
},{"./PathUtils":197,"./runTransitionHook":203}],205:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _queryString = require('query-string');

var _runTransitionHook = require('./runTransitionHook');

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _LocationUtils = require('./LocationUtils');

var _PathUtils = require('./PathUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultStringifyQuery = function defaultStringifyQuery(query) {
  return (0, _queryString.stringify)(query).replace(/%20/g, '+');
};

var defaultParseQueryString = _queryString.parse;

/**
 * Returns a new createHistory function that may be used to create
 * history objects that know how to handle URL queries.
 */
var useQueries = function useQueries(createHistory) {
  return function () {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var history = createHistory(options);
    var stringifyQuery = options.stringifyQuery;
    var parseQueryString = options.parseQueryString;


    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;

    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;

    var decodeQuery = function decodeQuery(location) {
      if (!location) return location;

      if (location.query == null) location.query = parseQueryString(location.search.substring(1));

      return location;
    };

    var encodeQuery = function encodeQuery(location, query) {
      if (query == null) return location;

      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
      var queryString = stringifyQuery(query);
      var search = queryString ? '?' + queryString : '';

      return _extends({}, object, {
        search: search
      });
    };

    // Override all read methods with query-aware versions.
    var getCurrentLocation = function getCurrentLocation() {
      return decodeQuery(history.getCurrentLocation());
    };

    var listenBefore = function listenBefore(hook) {
      return history.listenBefore(function (location, callback) {
        return (0, _runTransitionHook2.default)(hook, decodeQuery(location), callback);
      });
    };

    var listen = function listen(listener) {
      return history.listen(function (location) {
        return listener(decodeQuery(location));
      });
    };

    // Override all write methods with query-aware versions.
    var push = function push(location) {
      return history.push(encodeQuery(location, location.query));
    };

    var replace = function replace(location) {
      return history.replace(encodeQuery(location, location.query));
    };

    var createPath = function createPath(location) {
      return history.createPath(encodeQuery(location, location.query));
    };

    var createHref = function createHref(location) {
      return history.createHref(encodeQuery(location, location.query));
    };

    var createLocation = function createLocation(location) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var newLocation = history.createLocation.apply(history, [encodeQuery(location, location.query)].concat(args));

      if (location.query) newLocation.query = (0, _LocationUtils.createQuery)(location.query);

      return decodeQuery(newLocation);
    };

    return _extends({}, history, {
      getCurrentLocation: getCurrentLocation,
      listenBefore: listenBefore,
      listen: listen,
      push: push,
      replace: replace,
      createPath: createPath,
      createHref: createHref,
      createLocation: createLocation
    });
  };
};

exports.default = useQueries;
},{"./LocationUtils":196,"./PathUtils":197,"./runTransitionHook":203,"query-string":28}],206:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51}],207:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"./reactProdInvariant":228,"dup":53,"fbjs/lib/invariant":17}],208:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactChildren = require('./ReactChildren');
var ReactComponent = require('./ReactComponent');
var ReactPureComponent = require('./ReactPureComponent');
var ReactClass = require('./ReactClass');
var ReactDOMFactories = require('./ReactDOMFactories');
var ReactElement = require('./ReactElement');
var ReactPropTypes = require('./ReactPropTypes');
var ReactVersion = require('./ReactVersion');

var onlyChild = require('./onlyChild');
var warning = require('fbjs/lib/warning');

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if ("production" !== 'production') {
  var ReactElementValidator = require('./ReactElementValidator');
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;

if ("production" !== 'production') {
  var warned = false;
  __spread = function () {
    "production" !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
    warned = true;
    return _assign.apply(null, arguments);
  };
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,
  PureComponent: ReactPureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

module.exports = React;
},{"./ReactChildren":209,"./ReactClass":210,"./ReactComponent":211,"./ReactDOMFactories":214,"./ReactElement":215,"./ReactElementValidator":217,"./ReactPropTypes":220,"./ReactPureComponent":222,"./ReactVersion":223,"./onlyChild":227,"fbjs/lib/warning":24,"object-assign":27}],209:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var PooledClass = require('./PooledClass');
var ReactElement = require('./ReactElement');

var emptyFunction = require('fbjs/lib/emptyFunction');
var traverseAllChildren = require('./traverseAllChildren');

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;
},{"./PooledClass":207,"./ReactElement":215,"./traverseAllChildren":229,"fbjs/lib/emptyFunction":9}],210:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var ReactComponent = require('./ReactComponent');
var ReactElement = require('./ReactElement');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

/**
 * Policies that describe methods in `ReactClassInterface`.
 */


var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or host components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: 'DEFINE_MANY',

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: 'DEFINE_MANY',

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: 'DEFINE_MANY',

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: 'DEFINE_MANY',

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: 'DEFINE_MANY',

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: 'DEFINE_MANY_MERGED',

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: 'DEFINE_MANY_MERGED',

  /**
   * @return {object}
   * @optional
   */
  getChildContext: 'DEFINE_MANY_MERGED',

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: 'DEFINE_ONCE',

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: 'DEFINE_MANY',

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: 'DEFINE_MANY',

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: 'DEFINE_MANY',

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: 'DEFINE_ONCE',

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: 'DEFINE_MANY',

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: 'OVERRIDE_BASE'

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if ("production" !== 'production') {
      validateTypeDef(Constructor, childContextTypes, 'childContext');
    }
    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if ("production" !== 'production') {
      validateTypeDef(Constructor, contextTypes, 'context');
    }
    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if ("production" !== 'production') {
      validateTypeDef(Constructor, propTypes, 'prop');
    }
    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but only in __DEV__
      "production" !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
    }
  }
}

function validateMethodOverride(isAlreadyDefined, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === 'OVERRIDE_BASE') ? "production" !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (isAlreadyDefined) {
    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? "production" !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classes.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    if ("production" !== 'production') {
      var typeofSpec = typeof spec;
      var isMixinValid = typeofSpec === 'object' && spec !== null;

      "production" !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
    }

    return;
  }

  !(typeof spec !== 'function') ? "production" !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
  !!ReactElement.isValidElement(spec) ? "production" !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

  var proto = Constructor.prototype;
  var autoBindPairs = proto.__reactAutoBindPairs;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    var isAlreadyDefined = proto.hasOwnProperty(name);
    validateMethodOverride(isAlreadyDefined, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        autoBindPairs.push(name, property);
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? "production" !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === 'DEFINE_MANY_MERGED') {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === 'DEFINE_MANY') {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if ("production" !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? "production" !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

    var isInherited = name in Constructor;
    !!isInherited ? "production" !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? "production" !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? "production" !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if ("production" !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        "production" !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
      } else if (!args.length) {
        "production" !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  var pairs = component.__reactAutoBindPairs;
  for (var i = 0; i < pairs.length; i += 2) {
    var autoBindKey = pairs[i];
    var method = pairs[i + 1];
    component[autoBindKey] = bindAutoBindMethod(component, method);
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'replaceState');
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  }
};

var ReactClassComponent = function () {};
_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function (props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if ("production" !== 'production') {
        "production" !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if ("production" !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? "production" !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if ("production" !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? "production" !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

    if ("production" !== 'production') {
      "production" !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
      "production" !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
},{"./ReactComponent":211,"./ReactElement":215,"./ReactNoopUpdateQueue":218,"./ReactPropTypeLocationNames":219,"./reactProdInvariant":228,"fbjs/lib/emptyObject":10,"fbjs/lib/invariant":17,"fbjs/lib/warning":24,"object-assign":27}],211:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var canDefineProperty = require('./canDefineProperty');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? "production" !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if ("production" !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          "production" !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;
},{"./ReactNoopUpdateQueue":218,"./canDefineProperty":224,"./reactProdInvariant":228,"fbjs/lib/emptyObject":10,"fbjs/lib/invariant":17,"fbjs/lib/warning":24}],212:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('./ReactCurrentOwner');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty)
  // Strip regex characters so we can use it for regex
  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  // Remove hasOwnProperty from the template to make it generic
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function (id, item) {
    itemMap.set(id, item);
  };
  getItem = function (id) {
    return itemMap.get(id);
  };
  removeItem = function (id) {
    itemMap['delete'](id);
  };
  getItemIDs = function () {
    return Array.from(itemMap.keys());
  };

  addRoot = function (id) {
    rootIDSet.add(id);
  };
  removeRoot = function (id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function () {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function (id) {
    return '.' + id;
  };
  var getIDFromKey = function (key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function (id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function (id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function (id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function () {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function (id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function (id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function () {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
  "production" !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function (id, nextChildIDs) {
    var item = getItem(id);
    !item ? "production" !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? "production" !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? "production" !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
      !nextChild.isMounted ? "production" !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ? "production" !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = getItem(id);
    !item ? "production" !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var name = getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },


  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs
};

module.exports = ReactComponentTreeHook;
},{"./ReactCurrentOwner":213,"./reactProdInvariant":228,"fbjs/lib/invariant":17,"fbjs/lib/warning":24}],213:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;
},{}],214:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactElement = require('./ReactElement');

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;
if ("production" !== 'production') {
  var ReactElementValidator = require('./ReactElementValidator');
  createDOMFactory = ReactElementValidator.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;
},{"./ReactElement":215,"./ReactElementValidator":217}],215:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactCurrentOwner = require('./ReactCurrentOwner');

var warning = require('fbjs/lib/warning');
var canDefineProperty = require('./canDefineProperty');
var hasOwnProperty = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  if ("production" !== 'production') {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if ("production" !== 'production') {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      "production" !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      "production" !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if ("production" !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if ("production" !== 'production') {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if ("production" !== 'production') {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
},{"./ReactCurrentOwner":213,"./ReactElementSymbol":216,"./canDefineProperty":224,"fbjs/lib/warning":24,"object-assign":27}],216:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"dup":80}],217:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactComponentTreeHook = require('./ReactComponentTreeHook');
var ReactElement = require('./ReactElement');

var checkReactTypeSpec = require('./checkReactTypeSpec');

var canDefineProperty = require('./canDefineProperty');
var getIteratorFn = require('./getIteratorFn');
var warning = require('fbjs/lib/warning');

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  "production" !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    "production" !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {

  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      if (typeof type !== 'function' && typeof type !== 'string') {
        var info = '';
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }
        info += getDeclarationErrorAddendum();
        "production" !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
      }
    }

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if ("production" !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            "production" !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;
},{"./ReactComponentTreeHook":212,"./ReactCurrentOwner":213,"./ReactElement":215,"./canDefineProperty":224,"./checkReactTypeSpec":225,"./getIteratorFn":226,"fbjs/lib/warning":24}],218:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var warning = require('fbjs/lib/warning');

function warnNoop(publicInstance, callerName) {
  if ("production" !== 'production') {
    var constructor = publicInstance.constructor;
    "production" !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
},{"fbjs/lib/warning":24}],219:[function(require,module,exports){
arguments[4][98][0].apply(exports,arguments)
},{"dup":98}],220:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getIteratorFn = require('./getIteratorFn');
var warning = require('fbjs/lib/warning');

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),
  symbol: createPrimitiveTypeChecker('symbol'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
/*eslint-disable no-self-compare*/
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return x !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}
/*eslint-enable no-self-compare*/

/**
 * We use an Error-like object for backward compatibility as people may call
 * PropTypes directly and inspect their output. However we don't use real
 * Errors anymore. We don't inspect their stack anyway, and creating them
 * is prohibitively expensive if they are created too often, such as what
 * happens in oneOfType() for any type before the one that matched.
 */
function PropTypeError(message) {
  this.message = message;
  this.stack = '';
}
// Make `instanceof Error` still work for returned errors.
PropTypeError.prototype = Error.prototype;

function createChainableTypeChecker(validate) {
  if ("production" !== 'production') {
    var manualPropTypeCallCache = {};
  }
  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if ("production" !== 'production') {
      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
        var cacheKey = componentName + ':' + propName;
        if (!manualPropTypeCallCache[cacheKey]) {
          "production" !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
          manualPropTypeCallCache[cacheKey] = true;
        }
      }
    }
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        if (props[propName] === null) {
          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
        }
        return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName, secret) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
    }
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!ReactElement.isValidElement(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    "production" !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
    return emptyFunction.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (is(propValue, expectedValues[i])) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
    }
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    "production" !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
    return emptyFunction.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }

      var iteratorFn = getIteratorFn(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }

      return true;
    default:
      return false;
  }
}

function isSymbol(propType, propValue) {
  // Native Symbol.
  if (propType === 'symbol') {
    return true;
  }

  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
  if (propValue['@@toStringTag'] === 'Symbol') {
    return true;
  }

  // Fallback for non-spec compliant Symbols which are polyfilled.
  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
    return true;
  }

  return false;
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  if (isSymbol(propType, propValue)) {
    return 'symbol';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

// Returns class name of the object, if any.
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return ANONYMOUS;
  }
  return propValue.constructor.name;
}

module.exports = ReactPropTypes;
},{"./ReactElement":215,"./ReactPropTypeLocationNames":219,"./ReactPropTypesSecret":221,"./getIteratorFn":226,"fbjs/lib/emptyFunction":9,"fbjs/lib/warning":24}],221:[function(require,module,exports){
arguments[4][99][0].apply(exports,arguments)
},{"dup":99}],222:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactComponent = require('./ReactComponent');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var emptyObject = require('fbjs/lib/emptyObject');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = ReactPureComponent;
},{"./ReactComponent":211,"./ReactNoopUpdateQueue":218,"fbjs/lib/emptyObject":10,"object-assign":27}],223:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"dup":107}],224:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var canDefineProperty = false;
if ("production" !== 'production') {
  try {
    // $FlowFixMe https://github.com/facebook/flow/issues/285
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
},{}],225:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('./ReactComponentTreeHook');
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? "production" !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      "production" !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if ("production" !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = require('./ReactComponentTreeHook');
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        "production" !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
}).call(this,require('_process'))

},{"./ReactComponentTreeHook":212,"./ReactPropTypeLocationNames":219,"./ReactPropTypesSecret":221,"./reactProdInvariant":228,"_process":1,"fbjs/lib/invariant":17,"fbjs/lib/warning":24}],226:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"dup":140}],227:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */
'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactElement = require('./ReactElement');

var invariant = require('fbjs/lib/invariant');

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? "production" !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;
},{"./ReactElement":215,"./reactProdInvariant":228,"fbjs/lib/invariant":17}],228:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"dup":149}],229:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('./ReactCurrentOwner');
var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var warning = require('fbjs/lib/warning');

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if ("production" !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          "production" !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if ("production" !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? "production" !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
},{"./KeyEscapeUtils":206,"./ReactCurrentOwner":213,"./ReactElementSymbol":216,"./getIteratorFn":226,"./reactProdInvariant":228,"fbjs/lib/invariant":17,"fbjs/lib/warning":24}],230:[function(require,module,exports){
'use strict';

module.exports = require('./lib/React');

},{"./lib/React":208}],231:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
	});
};

},{}],232:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if ("production" !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

},{}],233:[function(require,module,exports){
/*!
 * XRegExp.build 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2012-2016 MIT License
 * Inspired by Lea Verou's RegExp.create <lea.verou.me>
 */

module.exports = function(XRegExp) {
    'use strict';

    var REGEX_DATA = 'xregexp';
    var subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g;
    var parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], 'g');

    /**
     * Strips a leading `^` and trailing unescaped `$`, if both are present.
     *
     * @param {String} pattern Pattern to process.
     * @returns {String} Pattern with edge anchors removed.
     */
    function deanchor(pattern) {
        // Allow any number of empty noncapturing groups before/after anchors, because regexes
        // built/generated by XRegExp sometimes include them
        var leadingAnchor = /^(?:\(\?:\))*\^/,
            trailingAnchor = /\$(?:\(\?:\))*$/;

        if (
            leadingAnchor.test(pattern) &&
            trailingAnchor.test(pattern) &&
            // Ensure that the trailing `$` isn't escaped
            trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ''))
        ) {
            return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');
        }

        return pattern;
    }

    /**
     * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.
     *
     * @param {String|RegExp} value Value to convert.
     * @returns {RegExp} XRegExp object with XRegExp syntax applied.
     */
    function asXRegExp(value) {
        return XRegExp.isRegExp(value) ?
            (value[REGEX_DATA] && value[REGEX_DATA].captureNames ?
                // Don't recompile, to preserve capture names
                value :
                // Recompile as XRegExp
                XRegExp(value.source)
            ) :
            // Compile string as XRegExp
            XRegExp(value);
    }

    /**
     * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in
     * the outer pattern and provided subpatterns are automatically renumbered to work correctly.
     * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.
     *
     * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows
     *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within
     *   character classes.
     * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A
     *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.
     * @param {String} [flags] Any combination of XRegExp flags.
     * @returns {RegExp} Regex with interpolated subpatterns.
     * @example
     *
     * var time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {
     *   hours: XRegExp.build('{{h12}} : | {{h24}}', {
     *     h12: /1[0-2]|0?[1-9]/,
     *     h24: /2[0-3]|[01][0-9]/
     *   }, 'x'),
     *   minutes: /^[0-5][0-9]$/
     * });
     * time.test('10:59'); // -> true
     * XRegExp.exec('10:59', time).minutes; // -> '59'
     */
    XRegExp.build = function(pattern, subs, flags) {
        var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern),
            data = {},
            numCaps = 0, // 'Caps' is short for captures
            numPriorCaps,
            numOuterCaps = 0,
            outerCapsMap = [0],
            outerCapNames,
            sub,
            p;

        // Add flags within a leading mode modifier to the overall pattern's flags
        if (inlineFlags) {
            flags = flags || '';
            inlineFlags[1].replace(/./g, function(flag) {
                // Don't add duplicates
                flags += (flags.indexOf(flag) > -1 ? '' : flag);
            });
        }

        for (p in subs) {
            if (subs.hasOwnProperty(p)) {
                // Passing to XRegExp enables extended syntax and ensures independent validity,
                // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
                // subpatterns provided as native regexes, it dies on octals and adds the property
                // used to hold extended regex instance data, for simplicity
                sub = asXRegExp(subs[p]);
                data[p] = {
                    // Deanchoring allows embedding independently useful anchored regexes. If you
                    // really need to keep your anchors, double them (i.e., `^^...$$`)
                    pattern: deanchor(sub.source),
                    names: sub[REGEX_DATA].captureNames || []
                };
            }
        }

        // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
        // helps keep this simple. Named captures will be put back
        pattern = asXRegExp(pattern);
        outerCapNames = pattern[REGEX_DATA].captureNames || [];
        pattern = pattern.source.replace(parts, function($0, $1, $2, $3, $4) {
            var subName = $1 || $2,
                capName,
                intro,
                localCapIndex;
            // Named subpattern
            if (subName) {
                if (!data.hasOwnProperty(subName)) {
                    throw new ReferenceError('Undefined property ' + $0);
                }
                // Named subpattern was wrapped in a capturing group
                if ($1) {
                    capName = outerCapNames[numOuterCaps];
                    outerCapsMap[++numOuterCaps] = ++numCaps;
                    // If it's a named group, preserve the name. Otherwise, use the subpattern name
                    // as the capture name
                    intro = '(?<' + (capName || subName) + '>';
                } else {
                    intro = '(?:';
                }
                numPriorCaps = numCaps;
                return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                    // Capturing group
                    if (paren) {
                        capName = data[subName].names[numCaps - numPriorCaps];
                        ++numCaps;
                        // If the current capture has a name, preserve the name
                        if (capName) {
                            return '(?<' + capName + '>';
                        }
                    // Backreference
                    } else if (backref) {
                        localCapIndex = +backref - 1;
                        // Rewrite the backreference
                        return data[subName].names[localCapIndex] ?
                            // Need to preserve the backreference name in case using flag `n`
                            '\\k<' + data[subName].names[localCapIndex] + '>' :
                            '\\' + (+backref + numPriorCaps);
                    }
                    return match;
                }) + ')';
            }
            // Capturing group
            if ($3) {
                capName = outerCapNames[numOuterCaps];
                outerCapsMap[++numOuterCaps] = ++numCaps;
                // If the current capture has a name, preserve the name
                if (capName) {
                    return '(?<' + capName + '>';
                }
            // Backreference
            } else if ($4) {
                localCapIndex = +$4 - 1;
                // Rewrite the backreference
                return outerCapNames[localCapIndex] ?
                    // Need to preserve the backreference name in case using flag `n`
                    '\\k<' + outerCapNames[localCapIndex] + '>' :
                    '\\' + outerCapsMap[+$4];
            }
            return $0;
        });

        return XRegExp(pattern, flags);
    };

};

},{}],234:[function(require,module,exports){
/*!
 * XRegExp.matchRecursive 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2009-2016 MIT License
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Returns a match detail object composed of the provided values.
     */
    function row(name, value, start, end) {
        return {
            name: name,
            value: value,
            start: start,
            end: end
        };
    }

    /**
     * Returns an array of match strings between outermost left and right delimiters, or an array of
     * objects with detailed match parts and position data. An error is thrown if delimiters are
     * unbalanced within the data.
     *
     * @param {String} str String to search.
     * @param {String} left Left delimiter as an XRegExp pattern.
     * @param {String} right Right delimiter as an XRegExp pattern.
     * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.
     * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.
     * @returns {Array} Array of matches, or an empty array.
     * @example
     *
     * // Basic usage
     * var str = '(t((e))s)t()(ing)';
     * XRegExp.matchRecursive(str, '\\(', '\\)', 'g');
     * // -> ['t((e))s', '', 'ing']
     *
     * // Extended information mode with valueNames
     * str = 'Here is <div> <div>an</div></div> example';
     * XRegExp.matchRecursive(str, '<div\\s*>', '</div>', 'gi', {
     *   valueNames: ['between', 'left', 'match', 'right']
     * });
     * // -> [
     * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},
     * // {name: 'left',    value: '<div>',          start: 8,  end: 13},
     * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},
     * // {name: 'right',   value: '</div>',         start: 27, end: 33},
     * // {name: 'between', value: ' example',       start: 33, end: 41}
     * // ]
     *
     * // Omitting unneeded parts with null valueNames, and using escapeChar
     * str = '...{1}.\\{{function(x,y){return {y:x}}}';
     * XRegExp.matchRecursive(str, '{', '}', 'g', {
     *   valueNames: ['literal', null, 'value', null],
     *   escapeChar: '\\'
     * });
     * // -> [
     * // {name: 'literal', value: '...',  start: 0, end: 3},
     * // {name: 'value',   value: '1',    start: 4, end: 5},
     * // {name: 'literal', value: '.\\{', start: 6, end: 9},
     * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}
     * // ]
     *
     * // Sticky mode via flag y
     * str = '<1><<<2>>><3>4<5>';
     * XRegExp.matchRecursive(str, '<', '>', 'gy');
     * // -> ['1', '<<2>>', '3']
     */
    XRegExp.matchRecursive = function(str, left, right, flags, options) {
        flags = flags || '';
        options = options || {};
        var global = flags.indexOf('g') > -1,
            sticky = flags.indexOf('y') > -1,
            // Flag `y` is controlled internally
            basicFlags = flags.replace(/y/g, ''),
            escapeChar = options.escapeChar,
            vN = options.valueNames,
            output = [],
            openTokens = 0,
            delimStart = 0,
            delimEnd = 0,
            lastOuterEnd = 0,
            outerStart,
            innerStart,
            leftMatch,
            rightMatch,
            esc;
        left = XRegExp(left, basicFlags);
        right = XRegExp(right, basicFlags);

        if (escapeChar) {
            if (escapeChar.length > 1) {
                throw new Error('Cannot use more than one escape character');
            }
            escapeChar = XRegExp.escape(escapeChar);
            // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`
            esc = new RegExp(
                '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
                    XRegExp.union([left, right]).source +
                    ')[^' + escapeChar + '])+)+',
                // Flags `gy` not needed here
                flags.replace(/[^imu]+/g, '')
            );
        }

        while (true) {
            // If using an escape character, advance to the delimiter's next starting position,
            // skipping any escaped characters in between
            if (escapeChar) {
                delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
            }
            leftMatch = XRegExp.exec(str, left, delimEnd);
            rightMatch = XRegExp.exec(str, right, delimEnd);
            // Keep the leftmost match only
            if (leftMatch && rightMatch) {
                if (leftMatch.index <= rightMatch.index) {
                    rightMatch = null;
                } else {
                    leftMatch = null;
                }
            }
            // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
            // LM | RM | OT | Result
            // 1  | 0  | 1  | loop
            // 1  | 0  | 0  | loop
            // 0  | 1  | 1  | loop
            // 0  | 1  | 0  | throw
            // 0  | 0  | 1  | throw
            // 0  | 0  | 0  | break
            // The paths above don't include the sticky mode special case. The loop ends after the
            // first completed match if not `global`.
            if (leftMatch || rightMatch) {
                delimStart = (leftMatch || rightMatch).index;
                delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
            } else if (!openTokens) {
                break;
            }
            if (sticky && !openTokens && delimStart > lastOuterEnd) {
                break;
            }
            if (leftMatch) {
                if (!openTokens) {
                    outerStart = delimStart;
                    innerStart = delimEnd;
                }
                ++openTokens;
            } else if (rightMatch && openTokens) {
                if (!--openTokens) {
                    if (vN) {
                        if (vN[0] && outerStart > lastOuterEnd) {
                            output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                        }
                        if (vN[1]) {
                            output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                        }
                        if (vN[2]) {
                            output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                        }
                        if (vN[3]) {
                            output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
                        }
                    } else {
                        output.push(str.slice(innerStart, delimStart));
                    }
                    lastOuterEnd = delimEnd;
                    if (!global) {
                        break;
                    }
                }
            } else {
                throw new Error('Unbalanced delimiter found in string');
            }
            // If the delimiter matched an empty string, avoid an infinite loop
            if (delimStart === delimEnd) {
                ++delimEnd;
            }
        }

        if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
            output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
        }

        return output;
    };

};

},{}],235:[function(require,module,exports){
/*!
 * XRegExp Unicode Base 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2008-2016 MIT License
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds base support for Unicode matching:
     * - Adds syntax `\p{..}` for matching Unicode tokens. Tokens can be inverted using `\P{..}` or
     *   `\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the
     *   braces for token names that are a single letter (e.g. `\pL` or `PL`).
     * - Adds flag A (astral), which enables 21-bit Unicode support.
     * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.
     *
     * Unicode Base relies on externally provided Unicode character data. Official addons are
     * available to provide data for Unicode categories, scripts, blocks, and properties.
     *
     * @requires XRegExp
     */

    // ==--------------------------==
    // Private stuff
    // ==--------------------------==

    // Storage for Unicode data
    var unicode = {};

    // Reuse utils
    var dec = XRegExp._dec;
    var hex = XRegExp._hex;
    var pad4 = XRegExp._pad4;

    // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed
    function normalize(name) {
        return name.replace(/[- _]+/g, '').toLowerCase();
    }

    // Gets the decimal code of a literal code unit, \xHH, \uHHHH, or a backslash-escaped literal
    function charCode(chr) {
        var esc = /^\\[xu](.+)/.exec(chr);
        return esc ?
            dec(esc[1]) :
            chr.charCodeAt(chr.charAt(0) === '\\' ? 1 : 0);
    }

    // Inverts a list of ordered BMP characters and ranges
    function invertBmp(range) {
        var output = '';
        var lastEnd = -1;
        XRegExp.forEach(
            range,
            /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/,
            function(m) {
                var start = charCode(m[1]);
                if (start > (lastEnd + 1)) {
                    output += '\\u' + pad4(hex(lastEnd + 1));
                    if (start > (lastEnd + 2)) {
                        output += '-\\u' + pad4(hex(start - 1));
                    }
                }
                lastEnd = charCode(m[2] || m[1]);
            }
        );
        if (lastEnd < 0xFFFF) {
            output += '\\u' + pad4(hex(lastEnd + 1));
            if (lastEnd < 0xFFFE) {
                output += '-\\uFFFF';
            }
        }
        return output;
    }

    // Generates an inverted BMP range on first use
    function cacheInvertedBmp(slug) {
        var prop = 'b!';
        return unicode[slug][prop] || (
            unicode[slug][prop] = invertBmp(unicode[slug].bmp)
        );
    }

    // Combines and optionally negates BMP and astral data
    function buildAstral(slug, isNegated) {
        var item = unicode[slug],
            combined = '';
        if (item.bmp && !item.isBmpLast) {
            combined = '[' + item.bmp + ']' + (item.astral ? '|' : '');
        }
        if (item.astral) {
            combined += item.astral;
        }
        if (item.isBmpLast && item.bmp) {
            combined += (item.astral ? '|' : '') + '[' + item.bmp + ']';
        }
        // Astral Unicode tokens always match a code point, never a code unit
        return isNegated ?
            '(?:(?!' + combined + ')(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-\uFFFF]))' :
            '(?:' + combined + ')';
    }

    // Builds a complete astral pattern on first use
    function cacheAstral(slug, isNegated) {
        var prop = isNegated ? 'a!' : 'a=';
        return unicode[slug][prop] || (
            unicode[slug][prop] = buildAstral(slug, isNegated)
        );
    }

    // ==--------------------------==
    // Core functionality
    // ==--------------------------==

    /*
     * Add Unicode token syntax: \p{..}, \P{..}, \p{^..}. Also add astral mode (flag A).
     */
    XRegExp.addToken(
        // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
        /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
        function(match, scope, flags) {
            var ERR_DOUBLE_NEG = 'Invalid double negation ',
                ERR_UNKNOWN_NAME = 'Unknown Unicode token ',
                ERR_UNKNOWN_REF = 'Unicode token missing data ',
                ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ',
                ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes',
                // Negated via \P{..} or \p{^..}
                isNegated = match[1] === 'P' || !!match[2],
                // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A
                isAstralMode = flags.indexOf('A') > -1,
                // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\p{}`
                slug = normalize(match[4] || match[3]),
                // Token data object
                item = unicode[slug];

            if (match[1] === 'P' && match[2]) {
                throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
            }
            if (!unicode.hasOwnProperty(slug)) {
                throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
            }

            // Switch to the negated form of the referenced Unicode token
            if (item.inverseOf) {
                slug = normalize(item.inverseOf);
                if (!unicode.hasOwnProperty(slug)) {
                    throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + ' -> ' + item.inverseOf);
                }
                item = unicode[slug];
                isNegated = !isNegated;
            }

            if (!(item.bmp || isAstralMode)) {
                throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
            }
            if (isAstralMode) {
                if (scope === 'class') {
                    throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
                }

                return cacheAstral(slug, isNegated);
            }

            return scope === 'class' ?
                (isNegated ? cacheInvertedBmp(slug) : item.bmp) :
                (isNegated ? '[^' : '[') + item.bmp + ']';
        },
        {
            scope: 'all',
            optionalFlags: 'A',
            leadChar: '\\'
        }
    );

    /**
     * Adds to the list of Unicode tokens that XRegExp regexes can match via `\p` or `\P`.
     *
     * @param {Array} data Objects with named character ranges. Each object may have properties
     *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are
     *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If
     *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,
     *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are
     *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and
     *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan
     *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and
     *   `astral` data should be a combination of literal characters and `\xHH` or `\uHHHH` escape
     *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be
     *   escaped, apart from range-creating hyphens. The `astral` data can additionally use
     *   character classes and alternation, and should use surrogate pairs to represent astral code
     *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is
     *   defined as the exact inverse of another token.
     * @example
     *
     * // Basic use
     * XRegExp.addUnicodeData([{
     *   name: 'XDigit',
     *   alias: 'Hexadecimal',
     *   bmp: '0-9A-Fa-f'
     * }]);
     * XRegExp('\\p{XDigit}:\\p{Hexadecimal}+').test('0:3D'); // -> true
     */
    XRegExp.addUnicodeData = function(data) {
        var ERR_NO_NAME = 'Unicode token requires name',
            ERR_NO_DATA = 'Unicode token has no character data ',
            item,
            i;

        for (i = 0; i < data.length; ++i) {
            item = data[i];
            if (!item.name) {
                throw new Error(ERR_NO_NAME);
            }
            if (!(item.inverseOf || item.bmp || item.astral)) {
                throw new Error(ERR_NO_DATA + item.name);
            }
            unicode[normalize(item.name)] = item;
            if (item.alias) {
                unicode[normalize(item.alias)] = item;
            }
        }

        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
        // flags might now produce different results
        XRegExp.cache.flush('patterns');
    };

};

},{}],236:[function(require,module,exports){
/*!
 * XRegExp Unicode Blocks 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2010-2016 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds support for all Unicode blocks. Block names use the prefix 'In'. E.g.,
     * `\p{InBasicLatin}`. Token names are case insensitive, and any spaces, hyphens, and
     * underscores are ignored.
     *
     * Uses Unicode 8.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Blocks');
    }

    XRegExp.addUnicodeData([
        {
            name: 'InAegean_Numbers',
            astral: '\uD800[\uDD00-\uDD3F]'
        },
        {
            name: 'InAhom',
            astral: '\uD805[\uDF00-\uDF3F]'
        },
        {
            name: 'InAlchemical_Symbols',
            astral: '\uD83D[\uDF00-\uDF7F]'
        },
        {
            name: 'InAlphabetic_Presentation_Forms',
            bmp: '\uFB00-\uFB4F'
        },
        {
            name: 'InAnatolian_Hieroglyphs',
            astral: '\uD811[\uDC00-\uDE7F]'
        },
        {
            name: 'InAncient_Greek_Musical_Notation',
            astral: '\uD834[\uDE00-\uDE4F]'
        },
        {
            name: 'InAncient_Greek_Numbers',
            astral: '\uD800[\uDD40-\uDD8F]'
        },
        {
            name: 'InAncient_Symbols',
            astral: '\uD800[\uDD90-\uDDCF]'
        },
        {
            name: 'InArabic',
            bmp: '\u0600-\u06FF'
        },
        {
            name: 'InArabic_Extended_A',
            bmp: '\u08A0-\u08FF'
        },
        {
            name: 'InArabic_Mathematical_Alphabetic_Symbols',
            astral: '\uD83B[\uDE00-\uDEFF]'
        },
        {
            name: 'InArabic_Presentation_Forms_A',
            bmp: '\uFB50-\uFDFF'
        },
        {
            name: 'InArabic_Presentation_Forms_B',
            bmp: '\uFE70-\uFEFF'
        },
        {
            name: 'InArabic_Supplement',
            bmp: '\u0750-\u077F'
        },
        {
            name: 'InArmenian',
            bmp: '\u0530-\u058F'
        },
        {
            name: 'InArrows',
            bmp: '\u2190-\u21FF'
        },
        {
            name: 'InAvestan',
            astral: '\uD802[\uDF00-\uDF3F]'
        },
        {
            name: 'InBalinese',
            bmp: '\u1B00-\u1B7F'
        },
        {
            name: 'InBamum',
            bmp: '\uA6A0-\uA6FF'
        },
        {
            name: 'InBamum_Supplement',
            astral: '\uD81A[\uDC00-\uDE3F]'
        },
        {
            name: 'InBasic_Latin',
            bmp: '\0-\x7F'
        },
        {
            name: 'InBassa_Vah',
            astral: '\uD81A[\uDED0-\uDEFF]'
        },
        {
            name: 'InBatak',
            bmp: '\u1BC0-\u1BFF'
        },
        {
            name: 'InBengali',
            bmp: '\u0980-\u09FF'
        },
        {
            name: 'InBlock_Elements',
            bmp: '\u2580-\u259F'
        },
        {
            name: 'InBopomofo',
            bmp: '\u3100-\u312F'
        },
        {
            name: 'InBopomofo_Extended',
            bmp: '\u31A0-\u31BF'
        },
        {
            name: 'InBox_Drawing',
            bmp: '\u2500-\u257F'
        },
        {
            name: 'InBrahmi',
            astral: '\uD804[\uDC00-\uDC7F]'
        },
        {
            name: 'InBraille_Patterns',
            bmp: '\u2800-\u28FF'
        },
        {
            name: 'InBuginese',
            bmp: '\u1A00-\u1A1F'
        },
        {
            name: 'InBuhid',
            bmp: '\u1740-\u175F'
        },
        {
            name: 'InByzantine_Musical_Symbols',
            astral: '\uD834[\uDC00-\uDCFF]'
        },
        {
            name: 'InCJK_Compatibility',
            bmp: '\u3300-\u33FF'
        },
        {
            name: 'InCJK_Compatibility_Forms',
            bmp: '\uFE30-\uFE4F'
        },
        {
            name: 'InCJK_Compatibility_Ideographs',
            bmp: '\uF900-\uFAFF'
        },
        {
            name: 'InCJK_Compatibility_Ideographs_Supplement',
            astral: '\uD87E[\uDC00-\uDE1F]'
        },
        {
            name: 'InCJK_Radicals_Supplement',
            bmp: '\u2E80-\u2EFF'
        },
        {
            name: 'InCJK_Strokes',
            bmp: '\u31C0-\u31EF'
        },
        {
            name: 'InCJK_Symbols_and_Punctuation',
            bmp: '\u3000-\u303F'
        },
        {
            name: 'InCJK_Unified_Ideographs',
            bmp: '\u4E00-\u9FFF'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_A',
            bmp: '\u3400-\u4DBF'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_B',
            astral: '[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_C',
            astral: '\uD86D[\uDC00-\uDF3F]|[\uD86A-\uD86C][\uDC00-\uDFFF]|\uD869[\uDF00-\uDFFF]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_D',
            astral: '\uD86D[\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1F]'
        },
        {
            name: 'InCJK_Unified_Ideographs_Extension_E',
            astral: '[\uD86F-\uD872][\uDC00-\uDFFF]|\uD873[\uDC00-\uDEAF]|\uD86E[\uDC20-\uDFFF]'
        },
        {
            name: 'InCarian',
            astral: '\uD800[\uDEA0-\uDEDF]'
        },
        {
            name: 'InCaucasian_Albanian',
            astral: '\uD801[\uDD30-\uDD6F]'
        },
        {
            name: 'InChakma',
            astral: '\uD804[\uDD00-\uDD4F]'
        },
        {
            name: 'InCham',
            bmp: '\uAA00-\uAA5F'
        },
        {
            name: 'InCherokee',
            bmp: '\u13A0-\u13FF'
        },
        {
            name: 'InCherokee_Supplement',
            bmp: '\uAB70-\uABBF'
        },
        {
            name: 'InCombining_Diacritical_Marks',
            bmp: '\u0300-\u036F'
        },
        {
            name: 'InCombining_Diacritical_Marks_Extended',
            bmp: '\u1AB0-\u1AFF'
        },
        {
            name: 'InCombining_Diacritical_Marks_Supplement',
            bmp: '\u1DC0-\u1DFF'
        },
        {
            name: 'InCombining_Diacritical_Marks_for_Symbols',
            bmp: '\u20D0-\u20FF'
        },
        {
            name: 'InCombining_Half_Marks',
            bmp: '\uFE20-\uFE2F'
        },
        {
            name: 'InCommon_Indic_Number_Forms',
            bmp: '\uA830-\uA83F'
        },
        {
            name: 'InControl_Pictures',
            bmp: '\u2400-\u243F'
        },
        {
            name: 'InCoptic',
            bmp: '\u2C80-\u2CFF'
        },
        {
            name: 'InCoptic_Epact_Numbers',
            astral: '\uD800[\uDEE0-\uDEFF]'
        },
        {
            name: 'InCounting_Rod_Numerals',
            astral: '\uD834[\uDF60-\uDF7F]'
        },
        {
            name: 'InCuneiform',
            astral: '\uD808[\uDC00-\uDFFF]'
        },
        {
            name: 'InCuneiform_Numbers_and_Punctuation',
            astral: '\uD809[\uDC00-\uDC7F]'
        },
        {
            name: 'InCurrency_Symbols',
            bmp: '\u20A0-\u20CF'
        },
        {
            name: 'InCypriot_Syllabary',
            astral: '\uD802[\uDC00-\uDC3F]'
        },
        {
            name: 'InCyrillic',
            bmp: '\u0400-\u04FF'
        },
        {
            name: 'InCyrillic_Extended_A',
            bmp: '\u2DE0-\u2DFF'
        },
        {
            name: 'InCyrillic_Extended_B',
            bmp: '\uA640-\uA69F'
        },
        {
            name: 'InCyrillic_Supplement',
            bmp: '\u0500-\u052F'
        },
        {
            name: 'InDeseret',
            astral: '\uD801[\uDC00-\uDC4F]'
        },
        {
            name: 'InDevanagari',
            bmp: '\u0900-\u097F'
        },
        {
            name: 'InDevanagari_Extended',
            bmp: '\uA8E0-\uA8FF'
        },
        {
            name: 'InDingbats',
            bmp: '\u2700-\u27BF'
        },
        {
            name: 'InDomino_Tiles',
            astral: '\uD83C[\uDC30-\uDC9F]'
        },
        {
            name: 'InDuployan',
            astral: '\uD82F[\uDC00-\uDC9F]'
        },
        {
            name: 'InEarly_Dynastic_Cuneiform',
            astral: '\uD809[\uDC80-\uDD4F]'
        },
        {
            name: 'InEgyptian_Hieroglyphs',
            astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F]'
        },
        {
            name: 'InElbasan',
            astral: '\uD801[\uDD00-\uDD2F]'
        },
        {
            name: 'InEmoticons',
            astral: '\uD83D[\uDE00-\uDE4F]'
        },
        {
            name: 'InEnclosed_Alphanumeric_Supplement',
            astral: '\uD83C[\uDD00-\uDDFF]'
        },
        {
            name: 'InEnclosed_Alphanumerics',
            bmp: '\u2460-\u24FF'
        },
        {
            name: 'InEnclosed_CJK_Letters_and_Months',
            bmp: '\u3200-\u32FF'
        },
        {
            name: 'InEnclosed_Ideographic_Supplement',
            astral: '\uD83C[\uDE00-\uDEFF]'
        },
        {
            name: 'InEthiopic',
            bmp: '\u1200-\u137F'
        },
        {
            name: 'InEthiopic_Extended',
            bmp: '\u2D80-\u2DDF'
        },
        {
            name: 'InEthiopic_Extended_A',
            bmp: '\uAB00-\uAB2F'
        },
        {
            name: 'InEthiopic_Supplement',
            bmp: '\u1380-\u139F'
        },
        {
            name: 'InGeneral_Punctuation',
            bmp: '\u2000-\u206F'
        },
        {
            name: 'InGeometric_Shapes',
            bmp: '\u25A0-\u25FF'
        },
        {
            name: 'InGeometric_Shapes_Extended',
            astral: '\uD83D[\uDF80-\uDFFF]'
        },
        {
            name: 'InGeorgian',
            bmp: '\u10A0-\u10FF'
        },
        {
            name: 'InGeorgian_Supplement',
            bmp: '\u2D00-\u2D2F'
        },
        {
            name: 'InGlagolitic',
            bmp: '\u2C00-\u2C5F'
        },
        {
            name: 'InGothic',
            astral: '\uD800[\uDF30-\uDF4F]'
        },
        {
            name: 'InGrantha',
            astral: '\uD804[\uDF00-\uDF7F]'
        },
        {
            name: 'InGreek_Extended',
            bmp: '\u1F00-\u1FFF'
        },
        {
            name: 'InGreek_and_Coptic',
            bmp: '\u0370-\u03FF'
        },
        {
            name: 'InGujarati',
            bmp: '\u0A80-\u0AFF'
        },
        {
            name: 'InGurmukhi',
            bmp: '\u0A00-\u0A7F'
        },
        {
            name: 'InHalfwidth_and_Fullwidth_Forms',
            bmp: '\uFF00-\uFFEF'
        },
        {
            name: 'InHangul_Compatibility_Jamo',
            bmp: '\u3130-\u318F'
        },
        {
            name: 'InHangul_Jamo',
            bmp: '\u1100-\u11FF'
        },
        {
            name: 'InHangul_Jamo_Extended_A',
            bmp: '\uA960-\uA97F'
        },
        {
            name: 'InHangul_Jamo_Extended_B',
            bmp: '\uD7B0-\uD7FF'
        },
        {
            name: 'InHangul_Syllables',
            bmp: '\uAC00-\uD7AF'
        },
        {
            name: 'InHanunoo',
            bmp: '\u1720-\u173F'
        },
        {
            name: 'InHatran',
            astral: '\uD802[\uDCE0-\uDCFF]'
        },
        {
            name: 'InHebrew',
            bmp: '\u0590-\u05FF'
        },
        {
            name: 'InHigh_Private_Use_Surrogates',
            bmp: '\uDB80-\uDBFF'
        },
        {
            name: 'InHigh_Surrogates',
            bmp: '\uD800-\uDB7F'
        },
        {
            name: 'InHiragana',
            bmp: '\u3040-\u309F'
        },
        {
            name: 'InIPA_Extensions',
            bmp: '\u0250-\u02AF'
        },
        {
            name: 'InIdeographic_Description_Characters',
            bmp: '\u2FF0-\u2FFF'
        },
        {
            name: 'InImperial_Aramaic',
            astral: '\uD802[\uDC40-\uDC5F]'
        },
        {
            name: 'InInscriptional_Pahlavi',
            astral: '\uD802[\uDF60-\uDF7F]'
        },
        {
            name: 'InInscriptional_Parthian',
            astral: '\uD802[\uDF40-\uDF5F]'
        },
        {
            name: 'InJavanese',
            bmp: '\uA980-\uA9DF'
        },
        {
            name: 'InKaithi',
            astral: '\uD804[\uDC80-\uDCCF]'
        },
        {
            name: 'InKana_Supplement',
            astral: '\uD82C[\uDC00-\uDCFF]'
        },
        {
            name: 'InKanbun',
            bmp: '\u3190-\u319F'
        },
        {
            name: 'InKangxi_Radicals',
            bmp: '\u2F00-\u2FDF'
        },
        {
            name: 'InKannada',
            bmp: '\u0C80-\u0CFF'
        },
        {
            name: 'InKatakana',
            bmp: '\u30A0-\u30FF'
        },
        {
            name: 'InKatakana_Phonetic_Extensions',
            bmp: '\u31F0-\u31FF'
        },
        {
            name: 'InKayah_Li',
            bmp: '\uA900-\uA92F'
        },
        {
            name: 'InKharoshthi',
            astral: '\uD802[\uDE00-\uDE5F]'
        },
        {
            name: 'InKhmer',
            bmp: '\u1780-\u17FF'
        },
        {
            name: 'InKhmer_Symbols',
            bmp: '\u19E0-\u19FF'
        },
        {
            name: 'InKhojki',
            astral: '\uD804[\uDE00-\uDE4F]'
        },
        {
            name: 'InKhudawadi',
            astral: '\uD804[\uDEB0-\uDEFF]'
        },
        {
            name: 'InLao',
            bmp: '\u0E80-\u0EFF'
        },
        {
            name: 'InLatin_Extended_Additional',
            bmp: '\u1E00-\u1EFF'
        },
        {
            name: 'InLatin_Extended_A',
            bmp: '\u0100-\u017F'
        },
        {
            name: 'InLatin_Extended_B',
            bmp: '\u0180-\u024F'
        },
        {
            name: 'InLatin_Extended_C',
            bmp: '\u2C60-\u2C7F'
        },
        {
            name: 'InLatin_Extended_D',
            bmp: '\uA720-\uA7FF'
        },
        {
            name: 'InLatin_Extended_E',
            bmp: '\uAB30-\uAB6F'
        },
        {
            name: 'InLatin_1_Supplement',
            bmp: '\x80-\xFF'
        },
        {
            name: 'InLepcha',
            bmp: '\u1C00-\u1C4F'
        },
        {
            name: 'InLetterlike_Symbols',
            bmp: '\u2100-\u214F'
        },
        {
            name: 'InLimbu',
            bmp: '\u1900-\u194F'
        },
        {
            name: 'InLinear_A',
            astral: '\uD801[\uDE00-\uDF7F]'
        },
        {
            name: 'InLinear_B_Ideograms',
            astral: '\uD800[\uDC80-\uDCFF]'
        },
        {
            name: 'InLinear_B_Syllabary',
            astral: '\uD800[\uDC00-\uDC7F]'
        },
        {
            name: 'InLisu',
            bmp: '\uA4D0-\uA4FF'
        },
        {
            name: 'InLow_Surrogates',
            bmp: '\uDC00-\uDFFF'
        },
        {
            name: 'InLycian',
            astral: '\uD800[\uDE80-\uDE9F]'
        },
        {
            name: 'InLydian',
            astral: '\uD802[\uDD20-\uDD3F]'
        },
        {
            name: 'InMahajani',
            astral: '\uD804[\uDD50-\uDD7F]'
        },
        {
            name: 'InMahjong_Tiles',
            astral: '\uD83C[\uDC00-\uDC2F]'
        },
        {
            name: 'InMalayalam',
            bmp: '\u0D00-\u0D7F'
        },
        {
            name: 'InMandaic',
            bmp: '\u0840-\u085F'
        },
        {
            name: 'InManichaean',
            astral: '\uD802[\uDEC0-\uDEFF]'
        },
        {
            name: 'InMathematical_Alphanumeric_Symbols',
            astral: '\uD835[\uDC00-\uDFFF]'
        },
        {
            name: 'InMathematical_Operators',
            bmp: '\u2200-\u22FF'
        },
        {
            name: 'InMeetei_Mayek',
            bmp: '\uABC0-\uABFF'
        },
        {
            name: 'InMeetei_Mayek_Extensions',
            bmp: '\uAAE0-\uAAFF'
        },
        {
            name: 'InMende_Kikakui',
            astral: '\uD83A[\uDC00-\uDCDF]'
        },
        {
            name: 'InMeroitic_Cursive',
            astral: '\uD802[\uDDA0-\uDDFF]'
        },
        {
            name: 'InMeroitic_Hieroglyphs',
            astral: '\uD802[\uDD80-\uDD9F]'
        },
        {
            name: 'InMiao',
            astral: '\uD81B[\uDF00-\uDF9F]'
        },
        {
            name: 'InMiscellaneous_Mathematical_Symbols_A',
            bmp: '\u27C0-\u27EF'
        },
        {
            name: 'InMiscellaneous_Mathematical_Symbols_B',
            bmp: '\u2980-\u29FF'
        },
        {
            name: 'InMiscellaneous_Symbols',
            bmp: '\u2600-\u26FF'
        },
        {
            name: 'InMiscellaneous_Symbols_and_Arrows',
            bmp: '\u2B00-\u2BFF'
        },
        {
            name: 'InMiscellaneous_Symbols_and_Pictographs',
            astral: '\uD83D[\uDC00-\uDDFF]|\uD83C[\uDF00-\uDFFF]'
        },
        {
            name: 'InMiscellaneous_Technical',
            bmp: '\u2300-\u23FF'
        },
        {
            name: 'InModi',
            astral: '\uD805[\uDE00-\uDE5F]'
        },
        {
            name: 'InModifier_Tone_Letters',
            bmp: '\uA700-\uA71F'
        },
        {
            name: 'InMongolian',
            bmp: '\u1800-\u18AF'
        },
        {
            name: 'InMro',
            astral: '\uD81A[\uDE40-\uDE6F]'
        },
        {
            name: 'InMultani',
            astral: '\uD804[\uDE80-\uDEAF]'
        },
        {
            name: 'InMusical_Symbols',
            astral: '\uD834[\uDD00-\uDDFF]'
        },
        {
            name: 'InMyanmar',
            bmp: '\u1000-\u109F'
        },
        {
            name: 'InMyanmar_Extended_A',
            bmp: '\uAA60-\uAA7F'
        },
        {
            name: 'InMyanmar_Extended_B',
            bmp: '\uA9E0-\uA9FF'
        },
        {
            name: 'InNKo',
            bmp: '\u07C0-\u07FF'
        },
        {
            name: 'InNabataean',
            astral: '\uD802[\uDC80-\uDCAF]'
        },
        {
            name: 'InNew_Tai_Lue',
            bmp: '\u1980-\u19DF'
        },
        {
            name: 'InNumber_Forms',
            bmp: '\u2150-\u218F'
        },
        {
            name: 'InOgham',
            bmp: '\u1680-\u169F'
        },
        {
            name: 'InOl_Chiki',
            bmp: '\u1C50-\u1C7F'
        },
        {
            name: 'InOld_Hungarian',
            astral: '\uD803[\uDC80-\uDCFF]'
        },
        {
            name: 'InOld_Italic',
            astral: '\uD800[\uDF00-\uDF2F]'
        },
        {
            name: 'InOld_North_Arabian',
            astral: '\uD802[\uDE80-\uDE9F]'
        },
        {
            name: 'InOld_Permic',
            astral: '\uD800[\uDF50-\uDF7F]'
        },
        {
            name: 'InOld_Persian',
            astral: '\uD800[\uDFA0-\uDFDF]'
        },
        {
            name: 'InOld_South_Arabian',
            astral: '\uD802[\uDE60-\uDE7F]'
        },
        {
            name: 'InOld_Turkic',
            astral: '\uD803[\uDC00-\uDC4F]'
        },
        {
            name: 'InOptical_Character_Recognition',
            bmp: '\u2440-\u245F'
        },
        {
            name: 'InOriya',
            bmp: '\u0B00-\u0B7F'
        },
        {
            name: 'InOrnamental_Dingbats',
            astral: '\uD83D[\uDE50-\uDE7F]'
        },
        {
            name: 'InOsmanya',
            astral: '\uD801[\uDC80-\uDCAF]'
        },
        {
            name: 'InPahawh_Hmong',
            astral: '\uD81A[\uDF00-\uDF8F]'
        },
        {
            name: 'InPalmyrene',
            astral: '\uD802[\uDC60-\uDC7F]'
        },
        {
            name: 'InPau_Cin_Hau',
            astral: '\uD806[\uDEC0-\uDEFF]'
        },
        {
            name: 'InPhags_pa',
            bmp: '\uA840-\uA87F'
        },
        {
            name: 'InPhaistos_Disc',
            astral: '\uD800[\uDDD0-\uDDFF]'
        },
        {
            name: 'InPhoenician',
            astral: '\uD802[\uDD00-\uDD1F]'
        },
        {
            name: 'InPhonetic_Extensions',
            bmp: '\u1D00-\u1D7F'
        },
        {
            name: 'InPhonetic_Extensions_Supplement',
            bmp: '\u1D80-\u1DBF'
        },
        {
            name: 'InPlaying_Cards',
            astral: '\uD83C[\uDCA0-\uDCFF]'
        },
        {
            name: 'InPrivate_Use_Area',
            bmp: '\uE000-\uF8FF'
        },
        {
            name: 'InPsalter_Pahlavi',
            astral: '\uD802[\uDF80-\uDFAF]'
        },
        {
            name: 'InRejang',
            bmp: '\uA930-\uA95F'
        },
        {
            name: 'InRumi_Numeral_Symbols',
            astral: '\uD803[\uDE60-\uDE7F]'
        },
        {
            name: 'InRunic',
            bmp: '\u16A0-\u16FF'
        },
        {
            name: 'InSamaritan',
            bmp: '\u0800-\u083F'
        },
        {
            name: 'InSaurashtra',
            bmp: '\uA880-\uA8DF'
        },
        {
            name: 'InSharada',
            astral: '\uD804[\uDD80-\uDDDF]'
        },
        {
            name: 'InShavian',
            astral: '\uD801[\uDC50-\uDC7F]'
        },
        {
            name: 'InShorthand_Format_Controls',
            astral: '\uD82F[\uDCA0-\uDCAF]'
        },
        {
            name: 'InSiddham',
            astral: '\uD805[\uDD80-\uDDFF]'
        },
        {
            name: 'InSinhala',
            bmp: '\u0D80-\u0DFF'
        },
        {
            name: 'InSinhala_Archaic_Numbers',
            astral: '\uD804[\uDDE0-\uDDFF]'
        },
        {
            name: 'InSmall_Form_Variants',
            bmp: '\uFE50-\uFE6F'
        },
        {
            name: 'InSora_Sompeng',
            astral: '\uD804[\uDCD0-\uDCFF]'
        },
        {
            name: 'InSpacing_Modifier_Letters',
            bmp: '\u02B0-\u02FF'
        },
        {
            name: 'InSpecials',
            bmp: '\uFFF0-\uFFFF'
        },
        {
            name: 'InSundanese',
            bmp: '\u1B80-\u1BBF'
        },
        {
            name: 'InSundanese_Supplement',
            bmp: '\u1CC0-\u1CCF'
        },
        {
            name: 'InSuperscripts_and_Subscripts',
            bmp: '\u2070-\u209F'
        },
        {
            name: 'InSupplemental_Arrows_A',
            bmp: '\u27F0-\u27FF'
        },
        {
            name: 'InSupplemental_Arrows_B',
            bmp: '\u2900-\u297F'
        },
        {
            name: 'InSupplemental_Arrows_C',
            astral: '\uD83E[\uDC00-\uDCFF]'
        },
        {
            name: 'InSupplemental_Mathematical_Operators',
            bmp: '\u2A00-\u2AFF'
        },
        {
            name: 'InSupplemental_Punctuation',
            bmp: '\u2E00-\u2E7F'
        },
        {
            name: 'InSupplemental_Symbols_and_Pictographs',
            astral: '\uD83E[\uDD00-\uDDFF]'
        },
        {
            name: 'InSupplementary_Private_Use_Area_A',
            astral: '[\uDB80-\uDBBF][\uDC00-\uDFFF]'
        },
        {
            name: 'InSupplementary_Private_Use_Area_B',
            astral: '[\uDBC0-\uDBFF][\uDC00-\uDFFF]'
        },
        {
            name: 'InSutton_SignWriting',
            astral: '\uD836[\uDC00-\uDEAF]'
        },
        {
            name: 'InSyloti_Nagri',
            bmp: '\uA800-\uA82F'
        },
        {
            name: 'InSyriac',
            bmp: '\u0700-\u074F'
        },
        {
            name: 'InTagalog',
            bmp: '\u1700-\u171F'
        },
        {
            name: 'InTagbanwa',
            bmp: '\u1760-\u177F'
        },
        {
            name: 'InTags',
            astral: '\uDB40[\uDC00-\uDC7F]'
        },
        {
            name: 'InTai_Le',
            bmp: '\u1950-\u197F'
        },
        {
            name: 'InTai_Tham',
            bmp: '\u1A20-\u1AAF'
        },
        {
            name: 'InTai_Viet',
            bmp: '\uAA80-\uAADF'
        },
        {
            name: 'InTai_Xuan_Jing_Symbols',
            astral: '\uD834[\uDF00-\uDF5F]'
        },
        {
            name: 'InTakri',
            astral: '\uD805[\uDE80-\uDECF]'
        },
        {
            name: 'InTamil',
            bmp: '\u0B80-\u0BFF'
        },
        {
            name: 'InTelugu',
            bmp: '\u0C00-\u0C7F'
        },
        {
            name: 'InThaana',
            bmp: '\u0780-\u07BF'
        },
        {
            name: 'InThai',
            bmp: '\u0E00-\u0E7F'
        },
        {
            name: 'InTibetan',
            bmp: '\u0F00-\u0FFF'
        },
        {
            name: 'InTifinagh',
            bmp: '\u2D30-\u2D7F'
        },
        {
            name: 'InTirhuta',
            astral: '\uD805[\uDC80-\uDCDF]'
        },
        {
            name: 'InTransport_and_Map_Symbols',
            astral: '\uD83D[\uDE80-\uDEFF]'
        },
        {
            name: 'InUgaritic',
            astral: '\uD800[\uDF80-\uDF9F]'
        },
        {
            name: 'InUnified_Canadian_Aboriginal_Syllabics',
            bmp: '\u1400-\u167F'
        },
        {
            name: 'InUnified_Canadian_Aboriginal_Syllabics_Extended',
            bmp: '\u18B0-\u18FF'
        },
        {
            name: 'InVai',
            bmp: '\uA500-\uA63F'
        },
        {
            name: 'InVariation_Selectors',
            bmp: '\uFE00-\uFE0F'
        },
        {
            name: 'InVariation_Selectors_Supplement',
            astral: '\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'InVedic_Extensions',
            bmp: '\u1CD0-\u1CFF'
        },
        {
            name: 'InVertical_Forms',
            bmp: '\uFE10-\uFE1F'
        },
        {
            name: 'InWarang_Citi',
            astral: '\uD806[\uDCA0-\uDCFF]'
        },
        {
            name: 'InYi_Radicals',
            bmp: '\uA490-\uA4CF'
        },
        {
            name: 'InYi_Syllables',
            bmp: '\uA000-\uA48F'
        },
        {
            name: 'InYijing_Hexagram_Symbols',
            bmp: '\u4DC0-\u4DFF'
        }
    ]);

};

},{}],237:[function(require,module,exports){
/*!
 * XRegExp Unicode Categories 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2010-2016 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds support for Unicode's general categories. E.g., `\p{Lu}` or `\p{Uppercase Letter}`. See
     * category descriptions in UAX #44 <http://unicode.org/reports/tr44/#GC_Values_Table>. Token
     * names are case insensitive, and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 8.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Categories');
    }

    XRegExp.addUnicodeData([
        {
            name: 'C',
            alias: 'Other',
            isBmpLast: true,
            bmp: '\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5-\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5E\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180E\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FB-\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E43-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AE\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF',
            astral: '\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFFF]|\uD86E[\uDC1E\uDC1F]|\uD83D[\uDD7A\uDDA4\uDED1-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCBD\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3E-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD86D[\uDF35-\uDF3F]|[\uD807\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD81C-\uD82B\uD82D\uD82E\uD830-\uD833\uD837-\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD805[\uDC00-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD19-\uDD7F\uDD85-\uDDBF\uDDC1-\uDFFF]|\uD873[\uDEA2-\uDFFF]'
        },
        {
            name: 'Cc',
            alias: 'Control',
            bmp: '\0-\x1F\x7F-\x9F'
        },
        {
            name: 'Cf',
            alias: 'Format',
            bmp: '\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB',
            astral: '\uDB40[\uDC01\uDC20-\uDC7F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uD804\uDCBD'
        },
        {
            name: 'Cn',
            alias: 'Unassigned',
            bmp: '\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u05FF\u061D\u070E\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5-\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5E\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u2065\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FB-\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E43-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AE\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD\uFEFE\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFF8\uFFFE\uFFFF',
            astral: '\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFFF]|\uD86E[\uDC1E\uDC1F]|\uD83D[\uDD7A\uDDA4\uDED1-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD86D[\uDF35-\uDF3F]|[\uD807\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD81C-\uD82B\uD82D\uD82E\uD830-\uD833\uD837-\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD805[\uDC00-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3E-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD19-\uDD7F\uDD85-\uDDBF\uDDC1-\uDFFF]|\uD873[\uDEA2-\uDFFF]'
        },
        {
            name: 'Co',
            alias: 'Private_Use',
            bmp: '\uE000-\uF8FF',
            astral: '[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]'
        },
        {
            name: 'Cs',
            alias: 'Surrogate',
            bmp: '\uD800-\uDFFF'
        },
        {
            name: 'L',
            alias: 'Letter',
            bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD83A[\uDC00-\uDCC4]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD809[\uDC80-\uDD43]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD811[\uDC00-\uDE46]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD82C[\uDC00\uDC01]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Ll',
            alias: 'Lowercase_Letter',
            bmp: 'a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
            astral: '\uD803[\uDCC0-\uDCF2]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD801[\uDC28-\uDC4F]|\uD806[\uDCC0-\uDCDF]'
        },
        {
            name: 'Lm',
            alias: 'Modifier_Letter',
            bmp: '\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F',
            astral: '\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F]'
        },
        {
            name: 'Lo',
            alias: 'Other_Letter',
            bmp: '\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD83A[\uDC00-\uDCC4]|\uD803[\uDC00-\uDC48]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|\uD81B[\uDF00-\uDF44\uDF50]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD809[\uDC80-\uDD43]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD811[\uDC00-\uDE46]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD82C[\uDC00\uDC01]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Lt',
            alias: 'Titlecase_Letter',
            bmp: '\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC'
        },
        {
            name: 'Lu',
            alias: 'Uppercase_Letter',
            bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
            astral: '\uD806[\uDCA0-\uDCBF]|\uD803[\uDC80-\uDCB2]|\uD801[\uDC00-\uDC27]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]'
        },
        {
            name: 'M',
            alias: 'Mark',
            bmp: '\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
            astral: '\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDCA-\uDDCC\uDE2C-\uDE37\uDEDF-\uDEEA\uDF00-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD82F[\uDC9D\uDC9E]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'Mc',
            alias: 'Spacing_Mark',
            bmp: '\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\u1CF3\u302E\u302F\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC',
            astral: '\uD834[\uDD65\uDD66\uDD6D-\uDD72]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD81B[\uDF51-\uDF7E]'
        },
        {
            name: 'Me',
            alias: 'Enclosing_Mark',
            bmp: '\u0488\u0489\u1ABE\u20DD-\u20E0\u20E2-\u20E4\uA670-\uA672'
        },
        {
            name: 'Mn',
            alias: 'Nonspacing_Mark',
            bmp: '\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
            astral: '\uD805[\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'N',
            alias: 'Number',
            bmp: '0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
            astral: '\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDCC7-\uDCCF]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD806[\uDCE0-\uDCF2]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD834[\uDF60-\uDF71]|\uD83C[\uDD00-\uDD0C]|\uD809[\uDC00-\uDC6E]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD805[\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]'
        },
        {
            name: 'Nd',
            alias: 'Decimal_Number',
            bmp: '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
            astral: '\uD801[\uDCA0-\uDCA9]|\uD835[\uDFCE-\uDFFF]|\uD805[\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]'
        },
        {
            name: 'Nl',
            alias: 'Letter_Number',
            bmp: '\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF',
            astral: '\uD809[\uDC00-\uDC6E]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]'
        },
        {
            name: 'No',
            alias: 'Other_Number',
            bmp: '\xB2\xB3\xB9\xBC-\xBE\u09F4-\u09F9\u0B72-\u0B77\u0BF0-\u0BF2\u0C78-\u0C7E\u0D70-\u0D75\u0F2A-\u0F33\u1369-\u137C\u17F0-\u17F9\u19DA\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215F\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA830-\uA835',
            astral: '\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD83C[\uDD00-\uDD0C]|\uD806[\uDCEA-\uDCF2]|\uD83A[\uDCC7-\uDCCF]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD805[\uDF3A\uDF3B]|\uD81A[\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]'
        },
        {
            name: 'P',
            alias: 'Punctuation',
            bmp: '\x21-\x23\x25-\\x2A\x2C-\x2F\x3A\x3B\\x3F\x40\\x5B-\\x5D\x5F\\x7B\x7D\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65',
            astral: '\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD809[\uDC70-\uDC74]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD836[\uDE87-\uDE8B]|\uD801\uDD6F|\uD82F\uDC9F|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]'
        },
        {
            name: 'Pc',
            alias: 'Connector_Punctuation',
            bmp: '\x5F\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F'
        },
        {
            name: 'Pd',
            alias: 'Dash_Punctuation',
            bmp: '\\x2D\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D'
        },
        {
            name: 'Pe',
            alias: 'Close_Punctuation',
            bmp: '\\x29\\x5D\x7D\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63'
        },
        {
            name: 'Pf',
            alias: 'Final_Punctuation',
            bmp: '\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21'
        },
        {
            name: 'Pi',
            alias: 'Initial_Punctuation',
            bmp: '\xAB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20'
        },
        {
            name: 'Po',
            alias: 'Other_Punctuation',
            bmp: '\x21-\x23\x25-\x27\\x2A\x2C\\x2E\x2F\x3A\x3B\\x3F\x40\\x5C\xA1\xA7\xB6\xB7\xBF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166D\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u2E3C-\u2E3F\u2E41\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65',
            astral: '\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD809[\uDC70-\uDC74]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD836[\uDE87-\uDE8B]|\uD801\uDD6F|\uD82F\uDC9F|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]'
        },
        {
            name: 'Ps',
            alias: 'Open_Punctuation',
            bmp: '\\x28\\x5B\\x7B\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2308\u230A\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u2E42\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3F\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62'
        },
        {
            name: 'S',
            alias: 'Symbol',
            bmp: '\\x24\\x2B\x3C-\x3E\\x5E\x60\\x7C\x7E\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BE\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u23FA\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD82F\uDC9C|\uD805\uDF3F|\uD802[\uDC77\uDC78\uDEC8]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD83B[\uDEF0\uDEF1]'
        },
        {
            name: 'Sc',
            alias: 'Currency_Symbol',
            bmp: '\\x24\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BE\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6'
        },
        {
            name: 'Sk',
            alias: 'Modifier_Symbol',
            bmp: '\\x5E\x60\xA8\xAF\xB4\xB8\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u309B\u309C\uA700-\uA716\uA720\uA721\uA789\uA78A\uAB5B\uFBB2-\uFBC1\uFF3E\uFF40\uFFE3',
            astral: '\uD83C[\uDFFB-\uDFFF]'
        },
        {
            name: 'Sm',
            alias: 'Math_Symbol',
            bmp: '\\x2B\x3C-\x3E\\x7C\x7E\xAC\xB1\xD7\xF7\u03F6\u0606-\u0608\u2044\u2052\u207A-\u207C\u208A-\u208C\u2118\u2140-\u2144\u214B\u2190-\u2194\u219A\u219B\u21A0\u21A3\u21A6\u21AE\u21CE\u21CF\u21D2\u21D4\u21F4-\u22FF\u2320\u2321\u237C\u239B-\u23B3\u23DC-\u23E1\u25B7\u25C1\u25F8-\u25FF\u266F\u27C0-\u27C4\u27C7-\u27E5\u27F0-\u27FF\u2900-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2AFF\u2B30-\u2B44\u2B47-\u2B4C\uFB29\uFE62\uFE64-\uFE66\uFF0B\uFF1C-\uFF1E\uFF5C\uFF5E\uFFE2\uFFE9-\uFFEC',
            astral: '\uD83B[\uDEF0\uDEF1]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]'
        },
        {
            name: 'So',
            alias: 'Other_Symbol',
            bmp: '\xA6\xA9\xAE\xB0\u0482\u058D\u058E\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09FA\u0B70\u0BF3-\u0BF8\u0BFA\u0C7F\u0D79\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u214A\u214C\u214D\u214F\u218A\u218B\u2195-\u2199\u219C-\u219F\u21A1\u21A2\u21A4\u21A5\u21A7-\u21AD\u21AF-\u21CD\u21D0\u21D1\u21D3\u21D5-\u21F3\u2300-\u2307\u230C-\u231F\u2322-\u2328\u232B-\u237B\u237D-\u239A\u23B4-\u23DB\u23E2-\u23FA\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u25B6\u25B8-\u25C0\u25C2-\u25F7\u2600-\u266E\u2670-\u2767\u2794-\u27BF\u2800-\u28FF\u2B00-\u2B2F\u2B45\u2B46\u2B4D-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA828-\uA82B\uA836\uA837\uA839\uAA77-\uAA79\uFDFD\uFFE4\uFFE8\uFFED\uFFEE\uFFFC\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFA]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD82F\uDC9C|\uD805\uDF3F|\uD802[\uDC77\uDC78\uDEC8]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]'
        },
        {
            name: 'Z',
            alias: 'Separator',
            bmp: '\x20\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
        },
        {
            name: 'Zl',
            alias: 'Line_Separator',
            bmp: '\u2028'
        },
        {
            name: 'Zp',
            alias: 'Paragraph_Separator',
            bmp: '\u2029'
        },
        {
            name: 'Zs',
            alias: 'Space_Separator',
            bmp: '\x20\xA0\u1680\u2000-\u200A\u202F\u205F\u3000'
        }
    ]);

};

},{}],238:[function(require,module,exports){
/*!
 * XRegExp Unicode Properties 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2012-2016 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds properties to meet the UTS #18 Level 1 RL1.2 requirements for Unicode regex support. See
     * <http://unicode.org/reports/tr18/#RL1.2>. Following are definitions of these properties from
     * UAX #44 <http://unicode.org/reports/tr44/>:
     *
     * - Alphabetic
     *   Characters with the Alphabetic property. Generated from: Lowercase + Uppercase + Lt + Lm +
     *   Lo + Nl + Other_Alphabetic.
     *
     * - Default_Ignorable_Code_Point
     *   For programmatic determination of default ignorable code points. New characters that should
     *   be ignored in rendering (unless explicitly supported) will be assigned in these ranges,
     *   permitting programs to correctly handle the default rendering of such characters when not
     *   otherwise supported.
     *
     * - Lowercase
     *   Characters with the Lowercase property. Generated from: Ll + Other_Lowercase.
     *
     * - Noncharacter_Code_Point
     *   Code points permanently reserved for internal use.
     *
     * - Uppercase
     *   Characters with the Uppercase property. Generated from: Lu + Other_Uppercase.
     *
     * - White_Space
     *   Spaces, separator characters and other control characters which should be treated by
     *   programming languages as "white space" for the purpose of parsing elements.
     *
     * The properties ASCII, Any, and Assigned are also included but are not defined in UAX #44. UTS
     * #18 RL1.2 additionally requires support for Unicode scripts and general categories. These are
     * included in XRegExp's Unicode Categories and Unicode Scripts addons.
     *
     * Token names are case insensitive, and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 8.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Properties');
    }

    var unicodeData = [
        {
            name: 'ASCII',
            bmp: '\0-\x7F'
        },
        {
            name: 'Alphabetic',
            bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0345\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05B0-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0657\u0659-\u065F\u066E-\u06D3\u06D5-\u06DC\u06E1-\u06E8\u06ED-\u06EF\u06FA-\u06FC\u06FF\u0710-\u073F\u074D-\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0817\u081A-\u082C\u0840-\u0858\u08A0-\u08B4\u08E3-\u08E9\u08F0-\u093B\u093D-\u094C\u094E-\u0950\u0955-\u0963\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C4\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09F0\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A42\u0A47\u0A48\u0A4B\u0A4C\u0A51\u0A59-\u0A5C\u0A5E\u0A70-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC5\u0AC7-\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0-\u0AE3\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D-\u0B44\u0B47\u0B48\u0B4B\u0B4C\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4C\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCC\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D57\u0D5F-\u0D63\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E46\u0E4D\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0ECD\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F71-\u0F81\u0F88-\u0F97\u0F99-\u0FBC\u1000-\u1036\u1038\u103B-\u103F\u1050-\u1062\u1065-\u1068\u106E-\u1086\u108E\u109C\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1713\u1720-\u1733\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17C8\u17D7\u17DC\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u1938\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A1B\u1A20-\u1A5E\u1A61-\u1A74\u1AA7\u1B00-\u1B33\u1B35-\u1B43\u1B45-\u1B4B\u1B80-\u1BA9\u1BAC-\u1BAF\u1BBA-\u1BE5\u1BE7-\u1BF1\u1C00-\u1C35\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1D00-\u1DBF\u1DE7-\u1DF4\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA674-\uA67B\uA67F-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA827\uA840-\uA873\uA880-\uA8C3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA92A\uA930-\uA952\uA960-\uA97C\uA980-\uA9B2\uA9B4-\uA9BF\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA60-\uAA76\uAA7A\uAA7E-\uAABE\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD804[\uDC00-\uDC45\uDC82-\uDCB8\uDCD0-\uDCE8\uDD00-\uDD32\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD83A[\uDC00-\uDCC4]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF36\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD80D[\uDC00-\uDC2E]|\uD87E[\uDC00-\uDE1D]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD808[\uDC00-\uDF99]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD805[\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDF00-\uDF19\uDF1D-\uDF2A]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD811[\uDC00-\uDE46]|\uD82C[\uDC00\uDC01]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF93-\uDF9F]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Any',
            isBmpLast: true,
            bmp: '\0-\uFFFF',
            astral: '[\uD800-\uDBFF][\uDC00-\uDFFF]'
        },
        {
            name: 'Default_Ignorable_Code_Point',
            bmp: '\xAD\u034F\u061C\u115F\u1160\u17B4\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8',
            astral: '[\uDB40-\uDB43][\uDC00-\uDFFF]|\uD834[\uDD73-\uDD7A]|\uD82F[\uDCA0-\uDCA3]'
        },
        {
            name: 'Lowercase',
            bmp: 'a-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u0371\u0373\u0377\u037A-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1DBF\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u2071\u207F\u2090-\u209C\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2170-\u217F\u2184\u24D0-\u24E9\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7D\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B-\uA69D\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7F8-\uA7FA\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
            astral: '\uD803[\uDCC0-\uDCF2]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD801[\uDC28-\uDC4F]|\uD806[\uDCC0-\uDCDF]'
        },
        {
            name: 'Noncharacter_Code_Point',
            bmp: '\uFDD0-\uFDEF\uFFFE\uFFFF',
            astral: '[\uDB3F\uDB7F\uDBBF\uDBFF\uD83F\uD87F\uD8BF\uDAFF\uD97F\uD9BF\uD9FF\uDA3F\uD8FF\uDABF\uDA7F\uD93F][\uDFFE\uDFFF]'
        },
        {
            name: 'Uppercase',
            bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
            astral: '\uD806[\uDCA0-\uDCBF]|\uD803[\uDC80-\uDCB2]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD801[\uDC00-\uDC27]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]'
        },
        {
            name: 'White_Space',
            bmp: '\x09-\x0D\x20\x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
        }
    ];

    // Add non-generated data
    unicodeData.push({
        name: 'Assigned',
        // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
        // Categories addon is required to use this property
        inverseOf: 'Cn'
    });

    XRegExp.addUnicodeData(unicodeData);

};

},{}],239:[function(require,module,exports){
/*!
 * XRegExp Unicode Scripts 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2010-2016 MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */

module.exports = function(XRegExp) {
    'use strict';

    /**
     * Adds support for all Unicode scripts. E.g., `\p{Latin}`. Token names are case insensitive,
     * and any spaces, hyphens, and underscores are ignored.
     *
     * Uses Unicode 8.0.0.
     *
     * @requires XRegExp, Unicode Base
     */

    if (!XRegExp.addUnicodeData) {
        throw new ReferenceError('Unicode Base must be loaded before Unicode Scripts');
    }

    XRegExp.addUnicodeData([
        {
            name: 'Ahom',
            astral: '\uD805[\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF3F]'
        },
        {
            name: 'Anatolian_Hieroglyphs',
            astral: '\uD811[\uDC00-\uDE46]'
        },
        {
            name: 'Arabic',
            bmp: '\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061E\u0620-\u063F\u0641-\u064A\u0656-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u08A0-\u08B4\u08E3-\u08FF\uFB50-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFD\uFE70-\uFE74\uFE76-\uFEFC',
            astral: '\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]'
        },
        {
            name: 'Armenian',
            bmp: '\u0531-\u0556\u0559-\u055F\u0561-\u0587\u058A\u058D-\u058F\uFB13-\uFB17'
        },
        {
            name: 'Avestan',
            astral: '\uD802[\uDF00-\uDF35\uDF39-\uDF3F]'
        },
        {
            name: 'Balinese',
            bmp: '\u1B00-\u1B4B\u1B50-\u1B7C'
        },
        {
            name: 'Bamum',
            bmp: '\uA6A0-\uA6F7',
            astral: '\uD81A[\uDC00-\uDE38]'
        },
        {
            name: 'Bassa_Vah',
            astral: '\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]'
        },
        {
            name: 'Batak',
            bmp: '\u1BC0-\u1BF3\u1BFC-\u1BFF'
        },
        {
            name: 'Bengali',
            bmp: '\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FB'
        },
        {
            name: 'Bopomofo',
            bmp: '\u02EA\u02EB\u3105-\u312D\u31A0-\u31BA'
        },
        {
            name: 'Brahmi',
            astral: '\uD804[\uDC00-\uDC4D\uDC52-\uDC6F\uDC7F]'
        },
        {
            name: 'Braille',
            bmp: '\u2800-\u28FF'
        },
        {
            name: 'Buginese',
            bmp: '\u1A00-\u1A1B\u1A1E\u1A1F'
        },
        {
            name: 'Buhid',
            bmp: '\u1740-\u1753'
        },
        {
            name: 'Canadian_Aboriginal',
            bmp: '\u1400-\u167F\u18B0-\u18F5'
        },
        {
            name: 'Carian',
            astral: '\uD800[\uDEA0-\uDED0]'
        },
        {
            name: 'Caucasian_Albanian',
            astral: '\uD801[\uDD30-\uDD63\uDD6F]'
        },
        {
            name: 'Chakma',
            astral: '\uD804[\uDD00-\uDD34\uDD36-\uDD43]'
        },
        {
            name: 'Cham',
            bmp: '\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F'
        },
        {
            name: 'Cherokee',
            bmp: '\u13A0-\u13F5\u13F8-\u13FD\uAB70-\uABBF'
        },
        {
            name: 'Common',
            bmp: '\0-\x40\\x5B-\x60\\x7B-\xA9\xAB-\xB9\xBB-\xBF\xD7\xF7\u02B9-\u02DF\u02E5-\u02E9\u02EC-\u02FF\u0374\u037E\u0385\u0387\u0589\u0605\u060C\u061B\u061C\u061F\u0640\u06DD\u0964\u0965\u0E3F\u0FD5-\u0FD8\u10FB\u16EB-\u16ED\u1735\u1736\u1802\u1803\u1805\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u2000-\u200B\u200E-\u2064\u2066-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20BE\u2100-\u2125\u2127-\u2129\u212C-\u2131\u2133-\u214D\u214F-\u215F\u2189-\u218B\u2190-\u23FA\u2400-\u2426\u2440-\u244A\u2460-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2E00-\u2E42\u2FF0-\u2FFB\u3000-\u3004\u3006\u3008-\u3020\u3030-\u3037\u303C-\u303F\u309B\u309C\u30A0\u30FB\u30FC\u3190-\u319F\u31C0-\u31E3\u3220-\u325F\u327F-\u32CF\u3358-\u33FF\u4DC0-\u4DFF\uA700-\uA721\uA788-\uA78A\uA830-\uA839\uA92E\uA9CF\uAB5B\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFF70\uFF9E\uFF9F\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD',
            astral: '\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD18\uDD80-\uDD84\uDDC0]|\uD82F[\uDCA0-\uDCA3]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uDB40[\uDC01\uDC20-\uDC7F]|\uD83D[\uDC00-\uDD79\uDD7B-\uDDA3\uDDA5-\uDED0\uDEE0-\uDEEC\uDEF0-\uDEF3\uDF00-\uDF73\uDF80-\uDFD4]|\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9B\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDF00-\uDF56\uDF60-\uDF71]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDD0C\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3A\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]'
        },
        {
            name: 'Coptic',
            bmp: '\u03E2-\u03EF\u2C80-\u2CF3\u2CF9-\u2CFF'
        },
        {
            name: 'Cuneiform',
            astral: '\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]|\uD808[\uDC00-\uDF99]'
        },
        {
            name: 'Cypriot',
            astral: '\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]'
        },
        {
            name: 'Cyrillic',
            bmp: '\u0400-\u0484\u0487-\u052F\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69F\uFE2E\uFE2F'
        },
        {
            name: 'Deseret',
            astral: '\uD801[\uDC00-\uDC4F]'
        },
        {
            name: 'Devanagari',
            bmp: '\u0900-\u0950\u0953-\u0963\u0966-\u097F\uA8E0-\uA8FD'
        },
        {
            name: 'Duployan',
            astral: '\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]'
        },
        {
            name: 'Egyptian_Hieroglyphs',
            astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]'
        },
        {
            name: 'Elbasan',
            astral: '\uD801[\uDD00-\uDD27]'
        },
        {
            name: 'Ethiopic',
            bmp: '\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E'
        },
        {
            name: 'Georgian',
            bmp: '\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u10FF\u2D00-\u2D25\u2D27\u2D2D'
        },
        {
            name: 'Glagolitic',
            bmp: '\u2C00-\u2C2E\u2C30-\u2C5E'
        },
        {
            name: 'Gothic',
            astral: '\uD800[\uDF30-\uDF4A]'
        },
        {
            name: 'Grantha',
            astral: '\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]'
        },
        {
            name: 'Greek',
            bmp: '\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65',
            astral: '\uD800[\uDD40-\uDD8C\uDDA0]|\uD834[\uDE00-\uDE45]'
        },
        {
            name: 'Gujarati',
            bmp: '\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9'
        },
        {
            name: 'Gurmukhi',
            bmp: '\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75'
        },
        {
            name: 'Han',
            bmp: '\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DB5\u4E00-\u9FD5\uF900-\uFA6D\uFA70-\uFAD9',
            astral: '\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD87E[\uDC00-\uDE1D]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD873[\uDC00-\uDEA1]'
        },
        {
            name: 'Hangul',
            bmp: '\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
        },
        {
            name: 'Hanunoo',
            bmp: '\u1720-\u1734'
        },
        {
            name: 'Hatran',
            astral: '\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]'
        },
        {
            name: 'Hebrew',
            bmp: '\u0591-\u05C7\u05D0-\u05EA\u05F0-\u05F4\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFB4F'
        },
        {
            name: 'Hiragana',
            bmp: '\u3041-\u3096\u309D-\u309F',
            astral: '\uD82C\uDC01|\uD83C\uDE00'
        },
        {
            name: 'Imperial_Aramaic',
            astral: '\uD802[\uDC40-\uDC55\uDC57-\uDC5F]'
        },
        {
            name: 'Inherited',
            bmp: '\u0300-\u036F\u0485\u0486\u064B-\u0655\u0670\u0951\u0952\u1AB0-\u1ABE\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C\u200D\u20D0-\u20F0\u302A-\u302D\u3099\u309A\uFE00-\uFE0F\uFE20-\uFE2D',
            astral: '\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uD800[\uDDFD\uDEE0]|\uDB40[\uDD00-\uDDEF]'
        },
        {
            name: 'Inscriptional_Pahlavi',
            astral: '\uD802[\uDF60-\uDF72\uDF78-\uDF7F]'
        },
        {
            name: 'Inscriptional_Parthian',
            astral: '\uD802[\uDF40-\uDF55\uDF58-\uDF5F]'
        },
        {
            name: 'Javanese',
            bmp: '\uA980-\uA9CD\uA9D0-\uA9D9\uA9DE\uA9DF'
        },
        {
            name: 'Kaithi',
            astral: '\uD804[\uDC80-\uDCC1]'
        },
        {
            name: 'Kannada',
            bmp: '\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2'
        },
        {
            name: 'Katakana',
            bmp: '\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D',
            astral: '\uD82C\uDC00'
        },
        {
            name: 'Kayah_Li',
            bmp: '\uA900-\uA92D\uA92F'
        },
        {
            name: 'Kharoshthi',
            astral: '\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F-\uDE47\uDE50-\uDE58]'
        },
        {
            name: 'Khmer',
            bmp: '\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u19E0-\u19FF'
        },
        {
            name: 'Khojki',
            astral: '\uD804[\uDE00-\uDE11\uDE13-\uDE3D]'
        },
        {
            name: 'Khudawadi',
            astral: '\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]'
        },
        {
            name: 'Lao',
            bmp: '\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF'
        },
        {
            name: 'Latin',
            bmp: 'A-Za-z\xAA\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB64\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A'
        },
        {
            name: 'Lepcha',
            bmp: '\u1C00-\u1C37\u1C3B-\u1C49\u1C4D-\u1C4F'
        },
        {
            name: 'Limbu',
            bmp: '\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u194F'
        },
        {
            name: 'Linear_A',
            astral: '\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]'
        },
        {
            name: 'Linear_B',
            astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]'
        },
        {
            name: 'Lisu',
            bmp: '\uA4D0-\uA4FF'
        },
        {
            name: 'Lycian',
            astral: '\uD800[\uDE80-\uDE9C]'
        },
        {
            name: 'Lydian',
            astral: '\uD802[\uDD20-\uDD39\uDD3F]'
        },
        {
            name: 'Mahajani',
            astral: '\uD804[\uDD50-\uDD76]'
        },
        {
            name: 'Malayalam',
            bmp: '\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D75\u0D79-\u0D7F'
        },
        {
            name: 'Mandaic',
            bmp: '\u0840-\u085B\u085E'
        },
        {
            name: 'Manichaean',
            astral: '\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]'
        },
        {
            name: 'Meetei_Mayek',
            bmp: '\uAAE0-\uAAF6\uABC0-\uABED\uABF0-\uABF9'
        },
        {
            name: 'Mende_Kikakui',
            astral: '\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]'
        },
        {
            name: 'Meroitic_Cursive',
            astral: '\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]'
        },
        {
            name: 'Meroitic_Hieroglyphs',
            astral: '\uD802[\uDD80-\uDD9F]'
        },
        {
            name: 'Miao',
            astral: '\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]'
        },
        {
            name: 'Modi',
            astral: '\uD805[\uDE00-\uDE44\uDE50-\uDE59]'
        },
        {
            name: 'Mongolian',
            bmp: '\u1800\u1801\u1804\u1806-\u180E\u1810-\u1819\u1820-\u1877\u1880-\u18AA'
        },
        {
            name: 'Mro',
            astral: '\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]'
        },
        {
            name: 'Multani',
            astral: '\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]'
        },
        {
            name: 'Myanmar',
            bmp: '\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F'
        },
        {
            name: 'Nabataean',
            astral: '\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]'
        },
        {
            name: 'New_Tai_Lue',
            bmp: '\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE\u19DF'
        },
        {
            name: 'Nko',
            bmp: '\u07C0-\u07FA'
        },
        {
            name: 'Ogham',
            bmp: '\u1680-\u169C'
        },
        {
            name: 'Ol_Chiki',
            bmp: '\u1C50-\u1C7F'
        },
        {
            name: 'Old_Hungarian',
            astral: '\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]'
        },
        {
            name: 'Old_Italic',
            astral: '\uD800[\uDF00-\uDF23]'
        },
        {
            name: 'Old_North_Arabian',
            astral: '\uD802[\uDE80-\uDE9F]'
        },
        {
            name: 'Old_Permic',
            astral: '\uD800[\uDF50-\uDF7A]'
        },
        {
            name: 'Old_Persian',
            astral: '\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]'
        },
        {
            name: 'Old_South_Arabian',
            astral: '\uD802[\uDE60-\uDE7F]'
        },
        {
            name: 'Old_Turkic',
            astral: '\uD803[\uDC00-\uDC48]'
        },
        {
            name: 'Oriya',
            bmp: '\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77'
        },
        {
            name: 'Osmanya',
            astral: '\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]'
        },
        {
            name: 'Pahawh_Hmong',
            astral: '\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]'
        },
        {
            name: 'Palmyrene',
            astral: '\uD802[\uDC60-\uDC7F]'
        },
        {
            name: 'Pau_Cin_Hau',
            astral: '\uD806[\uDEC0-\uDEF8]'
        },
        {
            name: 'Phags_Pa',
            bmp: '\uA840-\uA877'
        },
        {
            name: 'Phoenician',
            astral: '\uD802[\uDD00-\uDD1B\uDD1F]'
        },
        {
            name: 'Psalter_Pahlavi',
            astral: '\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]'
        },
        {
            name: 'Rejang',
            bmp: '\uA930-\uA953\uA95F'
        },
        {
            name: 'Runic',
            bmp: '\u16A0-\u16EA\u16EE-\u16F8'
        },
        {
            name: 'Samaritan',
            bmp: '\u0800-\u082D\u0830-\u083E'
        },
        {
            name: 'Saurashtra',
            bmp: '\uA880-\uA8C4\uA8CE-\uA8D9'
        },
        {
            name: 'Sharada',
            astral: '\uD804[\uDD80-\uDDCD\uDDD0-\uDDDF]'
        },
        {
            name: 'Shavian',
            astral: '\uD801[\uDC50-\uDC7F]'
        },
        {
            name: 'Siddham',
            astral: '\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]'
        },
        {
            name: 'SignWriting',
            astral: '\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]'
        },
        {
            name: 'Sinhala',
            bmp: '\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4',
            astral: '\uD804[\uDDE1-\uDDF4]'
        },
        {
            name: 'Sora_Sompeng',
            astral: '\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]'
        },
        {
            name: 'Sundanese',
            bmp: '\u1B80-\u1BBF\u1CC0-\u1CC7'
        },
        {
            name: 'Syloti_Nagri',
            bmp: '\uA800-\uA82B'
        },
        {
            name: 'Syriac',
            bmp: '\u0700-\u070D\u070F-\u074A\u074D-\u074F'
        },
        {
            name: 'Tagalog',
            bmp: '\u1700-\u170C\u170E-\u1714'
        },
        {
            name: 'Tagbanwa',
            bmp: '\u1760-\u176C\u176E-\u1770\u1772\u1773'
        },
        {
            name: 'Tai_Le',
            bmp: '\u1950-\u196D\u1970-\u1974'
        },
        {
            name: 'Tai_Tham',
            bmp: '\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD'
        },
        {
            name: 'Tai_Viet',
            bmp: '\uAA80-\uAAC2\uAADB-\uAADF'
        },
        {
            name: 'Takri',
            astral: '\uD805[\uDE80-\uDEB7\uDEC0-\uDEC9]'
        },
        {
            name: 'Tamil',
            bmp: '\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA'
        },
        {
            name: 'Telugu',
            bmp: '\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7F'
        },
        {
            name: 'Thaana',
            bmp: '\u0780-\u07B1'
        },
        {
            name: 'Thai',
            bmp: '\u0E01-\u0E3A\u0E40-\u0E5B'
        },
        {
            name: 'Tibetan',
            bmp: '\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FD4\u0FD9\u0FDA'
        },
        {
            name: 'Tifinagh',
            bmp: '\u2D30-\u2D67\u2D6F\u2D70\u2D7F'
        },
        {
            name: 'Tirhuta',
            astral: '\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]'
        },
        {
            name: 'Ugaritic',
            astral: '\uD800[\uDF80-\uDF9D\uDF9F]'
        },
        {
            name: 'Vai',
            bmp: '\uA500-\uA62B'
        },
        {
            name: 'Warang_Citi',
            astral: '\uD806[\uDCA0-\uDCF2\uDCFF]'
        },
        {
            name: 'Yi',
            bmp: '\uA000-\uA48C\uA490-\uA4C6'
        }
    ]);

};

},{}],240:[function(require,module,exports){
var XRegExp = require('./xregexp');

require('./addons/build')(XRegExp);
require('./addons/matchrecursive')(XRegExp);
require('./addons/unicode-base')(XRegExp);
require('./addons/unicode-blocks')(XRegExp);
require('./addons/unicode-categories')(XRegExp);
require('./addons/unicode-properties')(XRegExp);
require('./addons/unicode-scripts')(XRegExp);

module.exports = XRegExp;

},{"./addons/build":233,"./addons/matchrecursive":234,"./addons/unicode-base":235,"./addons/unicode-blocks":236,"./addons/unicode-categories":237,"./addons/unicode-properties":238,"./addons/unicode-scripts":239,"./xregexp":241}],241:[function(require,module,exports){
/*!
 * XRegExp 3.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2007-2016 MIT License
 */

'use strict';

/**
 * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and
 * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to
 * make your client-side grepping simpler and more powerful, while freeing you from related
 * cross-browser inconsistencies.
 */

// ==--------------------------==
// Private stuff
// ==--------------------------==

// Property name used for extended regex instance data
var REGEX_DATA = 'xregexp';
// Optional features that can be installed and uninstalled
var features = {
    astral: false,
    natives: false
};
// Native methods to use and restore ('native' is an ES3 reserved keyword)
var nativ = {
    exec: RegExp.prototype.exec,
    test: RegExp.prototype.test,
    match: String.prototype.match,
    replace: String.prototype.replace,
    split: String.prototype.split
};
// Storage for fixed/extended native methods
var fixed = {};
// Storage for regexes cached by `XRegExp.cache`
var regexCache = {};
// Storage for pattern details cached by the `XRegExp` constructor
var patternCache = {};
// Storage for regex syntax tokens added internally or by `XRegExp.addToken`
var tokens = [];
// Token scopes
var defaultScope = 'default';
var classScope = 'class';
// Regexes that match native regex syntax, including octals
var nativeTokens = {
    // Any native multicharacter token in default scope, or any single character
    'default': /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
    // Any native multicharacter token in character class scope, or any single character
    'class': /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
};
// Any backreference or dollar-prefixed character in replacement strings
var replacementToken = /\$(?:{([\w$]+)}|(\d\d?|[\s\S]))/g;
// Check for correct `exec` handling of nonparticipating capturing groups
var correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined;
// Check for ES6 `flags` prop support
var hasFlagsProp = /x/.flags !== undefined;
// Shortcut to `Object.prototype.toString`
var toString = {}.toString;

function hasNativeFlag(flag) {
    // Can't check based on the presense of properties/getters since browsers might support such
    // properties even when they don't support the corresponding flag in regex construction (tested
    // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`
    // throws an error)
    var isSupported = true;
    try {
        // Can't use regex literals for testing even in a `try` because regex literals with
        // unsupported flags cause a compilation error in IE
        new RegExp('', flag);
    } catch (exception) {
        isSupported = false;
    }
    if (isSupported && flag === 'y') {
        // Work around Safari 9.1.1 bug
        return new RegExp('aa|.', 'y').test('b');
    }
    return isSupported;
}
// Check for ES6 `u` flag support
var hasNativeU = hasNativeFlag('u');
// Check for ES6 `y` flag support
var hasNativeY = hasNativeFlag('y');
// Tracker for known flags, including addon flags
var registeredFlags = {
    g: true,
    i: true,
    m: true,
    u: hasNativeU,
    y: hasNativeY
};

/**
 * Attaches extended data and `XRegExp.prototype` properties to a regex object.
 *
 * @param {RegExp} regex Regex to augment.
 * @param {Array} captureNames Array with capture names, or `null`.
 * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.
 * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.
 * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal
 *   operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *   skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {RegExp} Augmented regex.
 */
function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
    var p;

    regex[REGEX_DATA] = {
        captureNames: captureNames
    };

    if (isInternalOnly) {
        return regex;
    }

    // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value
    if (regex.__proto__) {
        regex.__proto__ = XRegExp.prototype;
    } else {
        for (p in XRegExp.prototype) {
            // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this
            // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`
            // extensions exist on `regex.prototype` anyway
            regex[p] = XRegExp.prototype[p];
        }
    }

    regex[REGEX_DATA].source = xSource;
    // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
    regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;

    return regex;
}

/**
 * Removes any duplicate characters from the provided string.
 *
 * @param {String} str String to remove duplicate characters from.
 * @returns {String} String with any duplicate characters removed.
 */
function clipDuplicates(str) {
    return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
}

/**
 * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`
 * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing
 * flags g and y while copying the regex.
 *
 * @param {RegExp} regex Regex to copy.
 * @param {Object} [options] Options object with optional properties:
 *   <li>`addG` {Boolean} Add flag g while copying the regex.
 *   <li>`addY` {Boolean} Add flag y while copying the regex.
 *   <li>`removeG` {Boolean} Remove flag g while copying the regex.
 *   <li>`removeY` {Boolean} Remove flag y while copying the regex.
 *   <li>`isInternalOnly` {Boolean} Whether the copied regex will be used only for internal
 *     operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *     skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
 */
function copyRegex(regex, options) {
    if (!XRegExp.isRegExp(regex)) {
        throw new TypeError('Type RegExp expected');
    }

    var xData = regex[REGEX_DATA] || {},
        flags = getNativeFlags(regex),
        flagsToAdd = '',
        flagsToRemove = '',
        xregexpSource = null,
        xregexpFlags = null;

    options = options || {};

    if (options.removeG) {flagsToRemove += 'g';}
    if (options.removeY) {flagsToRemove += 'y';}
    if (flagsToRemove) {
        flags = nativ.replace.call(flags, new RegExp('[' + flagsToRemove + ']+', 'g'), '');
    }

    if (options.addG) {flagsToAdd += 'g';}
    if (options.addY) {flagsToAdd += 'y';}
    if (flagsToAdd) {
        flags = clipDuplicates(flags + flagsToAdd);
    }

    if (!options.isInternalOnly) {
        if (xData.source !== undefined) {
            xregexpSource = xData.source;
        }
        // null or undefined; don't want to add to `flags` if the previous value was null, since
        // that indicates we're not tracking original precompilation flags
        if (xData.flags != null) {
            // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never
            // removed for non-internal regexes, so don't need to handle it
            xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
        }
    }

    // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid
    // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and
    // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the
    // translation to native regex syntax
    regex = augment(
        new RegExp(regex.source, flags),
        hasNamedCapture(regex) ? xData.captureNames.slice(0) : null,
        xregexpSource,
        xregexpFlags,
        options.isInternalOnly
    );

    return regex;
}

/**
 * Converts hexadecimal to decimal.
 *
 * @param {String} hex
 * @returns {Number}
 */
function dec(hex) {
    return parseInt(hex, 16);
}

/**
 * Returns native `RegExp` flags used by a regex object.
 *
 * @param {RegExp} regex Regex to check.
 * @returns {String} Native flags in use.
 */
function getNativeFlags(regex) {
    return hasFlagsProp ?
        regex.flags :
        // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation
        // with an empty string) allows this to continue working predictably when
        // `XRegExp.proptotype.toString` is overriden
        nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];
}

/**
 * Determines whether a regex has extended instance data used to track capture names.
 *
 * @param {RegExp} regex Regex to check.
 * @returns {Boolean} Whether the regex uses named capture.
 */
function hasNamedCapture(regex) {
    return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
}

/**
 * Converts decimal to hexadecimal.
 *
 * @param {Number|String} dec
 * @returns {String}
 */
function hex(dec) {
    return parseInt(dec, 10).toString(16);
}

/**
 * Returns the first index at which a given value can be found in an array.
 *
 * @param {Array} array Array to search.
 * @param {*} value Value to locate in the array.
 * @returns {Number} Zero-based index at which the item is found, or -1.
 */
function indexOf(array, value) {
    var len = array.length, i;

    for (i = 0; i < len; ++i) {
        if (array[i] === value) {
            return i;
        }
    }

    return -1;
}

/**
 * Determines whether a value is of the specified type, by resolving its internal [[Class]].
 *
 * @param {*} value Object to check.
 * @param {String} type Type to check for, in TitleCase.
 * @returns {Boolean} Whether the object matches the type.
 */
function isType(value, type) {
    return toString.call(value) === '[object ' + type + ']';
}

/**
 * Checks whether the next nonignorable token after the specified position is a quantifier.
 *
 * @param {String} pattern Pattern to search within.
 * @param {Number} pos Index in `pattern` to search at.
 * @param {String} flags Flags used by the pattern.
 * @returns {Boolean} Whether the next token is a quantifier.
 */
function isQuantifierNext(pattern, pos, flags) {
    return nativ.test.call(
        flags.indexOf('x') > -1 ?
            // Ignore any leading whitespace, line comments, and inline comments
            /^(?:\s|#[^#\n]*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ :
            // Ignore any leading inline comments
            /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/,
        pattern.slice(pos)
    );
}

/**
 * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.
 *
 * @param {String} str
 * @returns {String}
 */
function pad4(str) {
    while (str.length < 4) {
        str = '0' + str;
    }
    return str;
}

/**
 * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads
 * the flag preparation logic from the `XRegExp` constructor.
 *
 * @param {String} pattern Regex pattern, possibly with a leading mode modifier.
 * @param {String} flags Any combination of flags.
 * @returns {Object} Object with properties `pattern` and `flags`.
 */
function prepareFlags(pattern, flags) {
    var i;

    // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags
    if (clipDuplicates(flags) !== flags) {
        throw new SyntaxError('Invalid duplicate regex flag ' + flags);
    }

    // Strip and apply a leading mode modifier with any combination of flags except g or y
    pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function($0, $1) {
        if (nativ.test.call(/[gy]/, $1)) {
            throw new SyntaxError('Cannot use flag g or y in mode modifier ' + $0);
        }
        // Allow duplicate flags within the mode modifier
        flags = clipDuplicates(flags + $1);
        return '';
    });

    // Throw on unknown native or nonnative flags
    for (i = 0; i < flags.length; ++i) {
        if (!registeredFlags[flags.charAt(i)]) {
            throw new SyntaxError('Unknown regex flag ' + flags.charAt(i));
        }
    }

    return {
        pattern: pattern,
        flags: flags
    };
}

/**
 * Prepares an options object from the given value.
 *
 * @param {String|Object} value Value to convert to an options object.
 * @returns {Object} Options object.
 */
function prepareOptions(value) {
    var options = {};

    if (isType(value, 'String')) {
        XRegExp.forEach(value, /[^\s,]+/, function(match) {
            options[match] = true;
        });

        return options;
    }

    return value;
}

/**
 * Registers a flag so it doesn't throw an 'unknown flag' error.
 *
 * @param {String} flag Single-character flag to register.
 */
function registerFlag(flag) {
    if (!/^[\w$]$/.test(flag)) {
        throw new Error('Flag must be a single character A-Za-z0-9_$');
    }

    registeredFlags[flag] = true;
}

/**
 * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified
 * position, until a match is found.
 *
 * @param {String} pattern Original pattern from which an XRegExp object is being built.
 * @param {String} flags Flags being used to construct the regex.
 * @param {Number} pos Position to search for tokens within `pattern`.
 * @param {Number} scope Regex scope to apply: 'default' or 'class'.
 * @param {Object} context Context object to use for token handler functions.
 * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.
 */
function runTokens(pattern, flags, pos, scope, context) {
    var i = tokens.length,
        leadChar = pattern.charAt(pos),
        result = null,
        match,
        t;

    // Run in reverse insertion order
    while (i--) {
        t = tokens[i];
        if (
            (t.leadChar && t.leadChar !== leadChar) ||
            (t.scope !== scope && t.scope !== 'all') ||
            (t.flag && flags.indexOf(t.flag) === -1)
        ) {
            continue;
        }

        match = XRegExp.exec(pattern, t.regex, pos, 'sticky');
        if (match) {
            result = {
                matchLength: match[0].length,
                output: t.handler.call(context, match, scope, flags),
                reparse: t.reparse
            };
            // Finished with token tests
            break;
        }
    }

    return result;
}

/**
 * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to
 * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if
 * the Unicode Base addon is not available, since flag A is registered by that addon.
 *
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
function setAstral(on) {
    features.astral = on;
}

/**
 * Enables or disables native method overrides.
 *
 * @param {Boolean} on `true` to enable; `false` to disable.
 */
function setNatives(on) {
    RegExp.prototype.exec = (on ? fixed : nativ).exec;
    RegExp.prototype.test = (on ? fixed : nativ).test;
    String.prototype.match = (on ? fixed : nativ).match;
    String.prototype.replace = (on ? fixed : nativ).replace;
    String.prototype.split = (on ? fixed : nativ).split;

    features.natives = on;
}

/**
 * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow
 * the ES5 abstract operation `ToObject`.
 *
 * @param {*} value Object to check and return.
 * @returns {*} The provided object.
 */
function toObject(value) {
    // null or undefined
    if (value == null) {
        throw new TypeError('Cannot convert null or undefined to object');
    }

    return value;
}

// ==--------------------------==
// Constructor
// ==--------------------------==

/**
 * Creates an extended regular expression object for matching text with a pattern. Differs from a
 * native regular expression in that additional syntax and flags are supported. The returned object
 * is in fact a native `RegExp` and works with all native methods.
 *
 * @class XRegExp
 * @constructor
 * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.
 * @param {String} [flags] Any combination of flags.
 *   Native flags:
 *     <li>`g` - global
 *     <li>`i` - ignore case
 *     <li>`m` - multiline anchors
 *     <li>`u` - unicode (ES6)
 *     <li>`y` - sticky (Firefox 3+, ES6)
 *   Additional XRegExp flags:
 *     <li>`n` - explicit capture
 *     <li>`s` - dot matches all (aka singleline)
 *     <li>`x` - free-spacing and line comments (aka extended)
 *     <li>`A` - astral (requires the Unicode Base addon)
 *   Flags cannot be provided when constructing one `RegExp` from another.
 * @returns {RegExp} Extended regular expression object.
 * @example
 *
 * // With named capture and flag x
 * XRegExp('(?<year>  [0-9]{4} ) -?  # year  \n\
 *          (?<month> [0-9]{2} ) -?  # month \n\
 *          (?<day>   [0-9]{2} )     # day   ', 'x');
 *
 * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)
 * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and
 * // have fresh `lastIndex` properties (set to zero).
 * XRegExp(/regex/);
 */
function XRegExp(pattern, flags) {
    if (XRegExp.isRegExp(pattern)) {
        if (flags !== undefined) {
            throw new TypeError('Cannot supply flags when copying a RegExp');
        }
        return copyRegex(pattern);
    }

    // Copy the argument behavior of `RegExp`
    pattern = pattern === undefined ? '' : String(pattern);
    flags = flags === undefined ? '' : String(flags);

    if (XRegExp.isInstalled('astral') && flags.indexOf('A') === -1) {
        // This causes an error to be thrown if the Unicode Base addon is not available
        flags += 'A';
    }

    if (!patternCache[pattern]) {
        patternCache[pattern] = {};
    }

    if (!patternCache[pattern][flags]) {
        var context = {
            hasNamedCapture: false,
            captureNames: []
        };
        var scope = defaultScope;
        var output = '';
        var pos = 0;
        var result;

        // Check for flag-related errors, and strip/apply flags in a leading mode modifier
        var applied = prepareFlags(pattern, flags);
        var appliedPattern = applied.pattern;
        var appliedFlags = applied.flags;

        // Use XRegExp's tokens to translate the pattern to a native regex pattern.
        // `appliedPattern.length` may change on each iteration if tokens use `reparse`
        while (pos < appliedPattern.length) {
            do {
                // Check for custom tokens at the current position
                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                // If the matched token used the `reparse` option, splice its output into the
                // pattern before running tokens again at the same position
                if (result && result.reparse) {
                    appliedPattern = appliedPattern.slice(0, pos) +
                        result.output +
                        appliedPattern.slice(pos + result.matchLength);
                }
            } while (result && result.reparse);

            if (result) {
                output += result.output;
                pos += (result.matchLength || 1);
            } else {
                // Get the native token at the current position
                var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];
                output += token;
                pos += token.length;
                if (token === '[' && scope === defaultScope) {
                    scope = classScope;
                } else if (token === ']' && scope === classScope) {
                    scope = defaultScope;
                }
            }
        }

        patternCache[pattern][flags] = {
            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
            // groups are sometimes inserted during regex transpilation in order to keep tokens
            // separated. However, more than one empty group in a row is never needed.
            pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, '(?:)'),
            // Strip all but native flags
            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),
            // `context.captureNames` has an item for each capturing group, even if unnamed
            captures: context.hasNamedCapture ? context.captureNames : null
        };
    }

    var generated = patternCache[pattern][flags];
    return augment(
        new RegExp(generated.pattern, generated.flags),
        generated.captures,
        pattern,
        flags
    );
}

// Add `RegExp.prototype` to the prototype chain
XRegExp.prototype = new RegExp();

// ==--------------------------==
// Public properties
// ==--------------------------==

/**
 * The XRegExp version number as a string containing three dot-separated parts. For example,
 * '2.0.0-beta-3'.
 *
 * @static
 * @type String
 */
XRegExp.version = '3.1.1';

// ==--------------------------==
// Public methods
// ==--------------------------==

// Intentionally undocumented; used in tests and addons
XRegExp._hasNativeFlag = hasNativeFlag;
XRegExp._dec = dec;
XRegExp._hex = hex;
XRegExp._pad4 = pad4;

/**
 * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to
 * create XRegExp addons. If more than one token can match the same string, the last added wins.
 *
 * @param {RegExp} regex Regex object that matches the new token.
 * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
 *   to replace the matched token within all future XRegExp regexes. Has access to persistent
 *   properties of the regex being built, through `this`. Invoked with three arguments:
 *   <li>The match array, with named backreference properties.
 *   <li>The regex scope where the match was found: 'default' or 'class'.
 *   <li>The flags used by the regex, including any flags in a leading mode modifier.
 *   The handler function becomes part of the XRegExp construction process, so be careful not to
 *   construct XRegExps within the function or you will trigger infinite recursion.
 * @param {Object} [options] Options object with optional properties:
 *   <li>`scope` {String} Scope where the token applies: 'default', 'class', or 'all'.
 *   <li>`flag` {String} Single-character flag that triggers the token. This also registers the
 *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.
 *   <li>`optionalFlags` {String} Any custom flags checked for within the token `handler` that are
 *     not required to trigger the token. This registers the flags, to prevent XRegExp from
 *     throwing an 'unknown flag' error when any of the flags are used.
 *   <li>`reparse` {Boolean} Whether the `handler` function's output should not be treated as
 *     final, and instead be reparseable by other tokens (including the current token). Allows
 *     token chaining or deferring.
 *   <li>`leadChar` {String} Single character that occurs at the beginning of any successful match
 *     of the token (not always applicable). This doesn't change the behavior of the token unless
 *     you provide an erroneous value. However, providing it can increase the token's performance
 *     since the token can be skipped at any positions where this character doesn't appear.
 * @example
 *
 * // Basic usage: Add \a for the ALERT control code
 * XRegExp.addToken(
 *   /\\a/,
 *   function() {return '\\x07';},
 *   {scope: 'all'}
 * );
 * XRegExp('\\a[\\a-\\n]+').test('\x07\n\x07'); // -> true
 *
 * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.
 * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of
 * // character classes only)
 * XRegExp.addToken(
 *   /([?*+]|{\d+(?:,\d*)?})(\??)/,
 *   function(match) {return match[1] + (match[2] ? '' : '?');},
 *   {flag: 'U'}
 * );
 * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'
 * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'
 */
XRegExp.addToken = function(regex, handler, options) {
    options = options || {};
    var optionalFlags = options.optionalFlags, i;

    if (options.flag) {
        registerFlag(options.flag);
    }

    if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, '');
        for (i = 0; i < optionalFlags.length; ++i) {
            registerFlag(optionalFlags[i]);
        }
    }

    // Add to the private list of syntax tokens
    tokens.push({
        regex: copyRegex(regex, {
            addG: true,
            addY: hasNativeY,
            isInternalOnly: true
        }),
        handler: handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
    });

    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
    // might now produce different results
    XRegExp.cache.flush('patterns');
};

/**
 * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
 * the same pattern and flag combination, the cached copy of the regex is returned.
 *
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.cache('.', 'gs').exec(str)) {
 *   // The regex is compiled once only
 * }
 */
XRegExp.cache = function(pattern, flags) {
    if (!regexCache[pattern]) {
        regexCache[pattern] = {};
    }
    return regexCache[pattern][flags] || (
        regexCache[pattern][flags] = XRegExp(pattern, flags)
    );
};

// Intentionally undocumented; used in tests
XRegExp.cache.flush = function(cacheName) {
    if (cacheName === 'patterns') {
        // Flush the pattern cache used by the `XRegExp` constructor
        patternCache = {};
    } else {
        // Flush the regex cache populated by `XRegExp.cache`
        regexCache = {};
    }
};

/**
 * Escapes any regular expression metacharacters, for use when matching literal strings. The result
 * can safely be used at any point within a regex that uses any flags.
 *
 * @param {String} str String to escape.
 * @returns {String} String with regex metacharacters escaped.
 * @example
 *
 * XRegExp.escape('Escaped? <.>');
 * // -> 'Escaped\?\ <\.>'
 */
XRegExp.escape = function(str) {
    return nativ.replace.call(toObject(str), /[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

/**
 * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
 * regex uses named capture, named backreference properties are included on the match array.
 * Optional `pos` and `sticky` arguments specify the search start position, and whether the match
 * must start at the specified position only. The `lastIndex` property of the provided regex is not
 * used, but is updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.exec` and can be used reliably cross-browser.
 *
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Array} Match array with named backreference properties, or `null`.
 * @example
 *
 * // Basic use, with named backreference
 * var match = XRegExp.exec('U+2620', XRegExp('U\\+(?<hex>[0-9A-F]{4})'));
 * match.hex; // -> '2620'
 *
 * // With pos and sticky, in a loop
 * var pos = 2, result = [], match;
 * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\d)>/, pos, 'sticky')) {
 *   result.push(match[1]);
 *   pos = match.index + match[0].length;
 * }
 * // result -> ['2', '3', '4']
 */
XRegExp.exec = function(str, regex, pos, sticky) {
    var cacheKey = 'g',
        addY = false,
        match,
        r2;

    addY = hasNativeY && !!(sticky || (regex.sticky && sticky !== false));
    if (addY) {
        cacheKey += 'y';
    }

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.match`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: true,
            addY: addY,
            removeY: sticky === false,
            isInternalOnly: true
        })
    );

    r2.lastIndex = pos = pos || 0;

    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
    match = fixed.exec.call(r2, str);

    if (sticky && match && match.index !== pos) {
        match = null;
    }

    if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
    }

    return match;
};

/**
 * Executes a provided function once per regex match. Searches always start at the beginning of the
 * string and continue until the end, regardless of the state of the regex's `global` property and
 * initial `lastIndex`.
 *
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Function} callback Function to execute for each match. Invoked with four arguments:
 *   <li>The match array, with named backreference properties.
 *   <li>The zero-based match index.
 *   <li>The string being traversed.
 *   <li>The regex object being used to traverse the string.
 * @example
 *
 * // Extracts every other digit from a string
 * var evens = [];
 * XRegExp.forEach('1a2345', /\d/, function(match, i) {
 *   if (i % 2) evens.push(+match[0]);
 * });
 * // evens -> [2, 4]
 */
XRegExp.forEach = function(str, regex, callback) {
    var pos = 0,
        i = -1,
        match;

    while ((match = XRegExp.exec(str, regex, pos))) {
        // Because `regex` is provided to `callback`, the function could use the deprecated/
        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
        // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,
        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
        // regexes, mutating the regex will not have any effect on the iteration or matched strings,
        // which is a nice side effect that brings extra safety.
        callback(match, ++i, str, regex);

        pos = match.index + (match[0].length || 1);
    }
};

/**
 * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with
 * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native
 * regexes are not recompiled using XRegExp syntax.
 *
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * var globalCopy = XRegExp.globalize(/regex/);
 * globalCopy.global; // -> true
 */
XRegExp.globalize = function(regex) {
    return copyRegex(regex, {addG: true});
};

/**
 * Installs optional features according to the specified options. Can be undone using
 * `XRegExp.uninstall`.
 *
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.install({
 *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)
 *   astral: true,
 *
 *   // DEPRECATED: Overrides native regex methods with fixed/extended versions
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.install('astral natives');
 */
XRegExp.install = function(options) {
    options = prepareOptions(options);

    if (!features.astral && options.astral) {
        setAstral(true);
    }

    if (!features.natives && options.natives) {
        setNatives(true);
    }
};

/**
 * Checks whether an individual optional feature is installed.
 *
 * @param {String} feature Name of the feature to check. One of:
 *   <li>`astral`
 *   <li>`natives`
 * @returns {Boolean} Whether the feature is installed.
 * @example
 *
 * XRegExp.isInstalled('astral');
 */
XRegExp.isInstalled = function(feature) {
    return !!(features[feature]);
};

/**
 * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes
 * created in another frame, when `instanceof` and `constructor` checks would fail.
 *
 * @param {*} value Object to check.
 * @returns {Boolean} Whether the object is a `RegExp` object.
 * @example
 *
 * XRegExp.isRegExp('string'); // -> false
 * XRegExp.isRegExp(/regex/i); // -> true
 * XRegExp.isRegExp(RegExp('^', 'm')); // -> true
 * XRegExp.isRegExp(XRegExp('(?s).')); // -> true
 */
XRegExp.isRegExp = function(value) {
    return toString.call(value) === '[object RegExp]';
    //return isType(value, 'RegExp');
};

/**
 * Returns the first matched string, or in global mode, an array containing all matched strings.
 * This is essentially a more convenient re-implementation of `String.prototype.match` that gives
 * the result types you actually want (string instead of `exec`-style array in match-first mode,
 * and an empty array instead of `null` when no matches are found in match-all mode). It also lets
 * you override flag g and ignore `lastIndex`, and fixes browser bugs.
 *
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to
 *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
 *   `scope` is 'all'.
 * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
 *   mode: Array of all matched strings, or an empty array.
 * @example
 *
 * // Match first
 * XRegExp.match('abc', /\w/); // -> 'a'
 * XRegExp.match('abc', /\w/g, 'one'); // -> 'a'
 * XRegExp.match('abc', /x/g, 'one'); // -> null
 *
 * // Match all
 * XRegExp.match('abc', /\w/g); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /\w/, 'all'); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /x/, 'all'); // -> []
 */
XRegExp.match = function(str, regex, scope) {
    var global = (regex.global && scope !== 'one') || scope === 'all',
        cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY',
        result,
        r2;

    regex[REGEX_DATA] = regex[REGEX_DATA] || {};

    // Shares cached copies with `XRegExp.exec`/`replace`
    r2 = regex[REGEX_DATA][cacheKey] || (
        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
            addG: !!global,
            removeG: scope === 'one',
            isInternalOnly: true
        })
    );

    result = nativ.match.call(toObject(str), r2);

    if (regex.global) {
        regex.lastIndex = (
            (scope === 'one' && result) ?
                // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
                (result.index + result[0].length) : 0
        );
    }

    return global ? (result || []) : (result && result[0]);
};

/**
 * Retrieves the matches from searching a string using a chain of regexes that successively search
 * within previous matches. The provided `chain` array can contain regexes and or objects with
 * `regex` and `backref` properties. When a backreference is specified, the named or numbered
 * backreference is passed forward to the next regex or returned.
 *
 * @param {String} str String to search.
 * @param {Array} chain Regexes that each search for matches within preceding results.
 * @returns {Array} Matches by the last regex in the chain, or an empty array.
 * @example
 *
 * // Basic usage; matches numbers within <b> tags
 * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [
 *   XRegExp('(?is)<b>.*?</b>'),
 *   /\d+/
 * ]);
 * // -> ['2', '4', '56']
 *
 * // Passing forward and returning specific backreferences
 * html = '<a href="http://xregexp.com/api/">XRegExp</a>\
 *         <a href="http://www.google.com/">Google</a>';
 * XRegExp.matchChain(html, [
 *   {regex: /<a href="([^"]+)">/i, backref: 1},
 *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}
 * ]);
 * // -> ['xregexp.com', 'www.google.com']
 */
XRegExp.matchChain = function(str, chain) {
    return (function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {regex: chain[level]};
        var matches = [];

        function addMatch(match) {
            if (item.backref) {
                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                // `undefined`s for backreferences to nonparticipating capturing groups. In such
                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                // the exception, so also check if the backreference is a number that is within the
                // bounds of the array.
                if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {
                    throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                }

                matches.push(match[item.backref] || '');
            } else {
                matches.push(match[0]);
            }
        }

        for (var i = 0; i < values.length; ++i) {
            XRegExp.forEach(values[i], item.regex, addMatch);
        }

        return ((level === chain.length - 1) || !matches.length) ?
            matches :
            recurseChain(matches, level + 1);
    }([str], 0));
};

/**
 * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
 * or regex, and the replacement can be a string or a function to be called for each match. To
 * perform a global search and replace, use the optional `scope` argument or include flag g if using
 * a regex. Replacement strings can use `${n}` for named and numbered backreferences. Replacement
 * functions can use named backreferences via `arguments[0].name`. Also fixes browser bugs compared
 * to the native `String.prototype.replace` and can be used reliably cross-browser.
 *
 * @param {String} str String to search.
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 *   Replacement strings can include special replacement syntax:
 *     <li>$$ - Inserts a literal $ character.
 *     <li>$&, $0 - Inserts the matched substring.
 *     <li>$` - Inserts the string that precedes the matched substring (left context).
 *     <li>$' - Inserts the string that follows the matched substring (right context).
 *     <li>$n, $nn - Where n/nn are digits referencing an existent capturing group, inserts
 *       backreference n/nn.
 *     <li>${n} - Where n is a name or any number of digits that reference an existent capturing
 *       group, inserts backreference n.
 *   Replacement functions are invoked with three or more arguments:
 *     <li>The matched substring (corresponds to $& above). Named backreferences are accessible as
 *       properties of this first argument.
 *     <li>0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).
 *     <li>The zero-based index of the match within the total search string.
 *     <li>The total string being searched.
 * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not
 *   explicitly specified and using a regex with flag g, `scope` is 'all'.
 * @returns {String} New string with one or all matches replaced.
 * @example
 *
 * // Regex search, using named backreferences in replacement string
 * var name = XRegExp('(?<first>\\w+) (?<last>\\w+)');
 * XRegExp.replace('John Smith', name, '${last}, ${first}');
 * // -> 'Smith, John'
 *
 * // Regex search, using named backreferences in replacement function
 * XRegExp.replace('John Smith', name, function(match) {
 *   return match.last + ', ' + match.first;
 * });
 * // -> 'Smith, John'
 *
 * // String search, with replace-all
 * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');
 * // -> 'XRegExp builds XRegExps'
 */
XRegExp.replace = function(str, search, replacement, scope) {
    var isRegex = XRegExp.isRegExp(search),
        global = (search.global && scope !== 'one') || scope === 'all',
        cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY',
        s2 = search,
        result;

    if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};

        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
        // `lastIndex` isn't updated *during* replacement iterations
        s2 = search[REGEX_DATA][cacheKey] || (
            search[REGEX_DATA][cacheKey] = copyRegex(search, {
                addG: !!global,
                removeG: scope === 'one',
                isInternalOnly: true
            })
        );
    } else if (global) {
        s2 = new RegExp(XRegExp.escape(String(search)), 'g');
    }

    // Fixed `replace` required for named backreferences, etc.
    result = fixed.replace.call(toObject(str), s2, replacement);

    if (isRegex && search.global) {
        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
        search.lastIndex = 0;
    }

    return result;
};

/**
 * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an
 * array of replacement details. Later replacements operate on the output of earlier replacements.
 * Replacement details are accepted as an array with a regex or string to search for, the
 * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp
 * replacement text syntax, which supports named backreference properties via `${name}`.
 *
 * @param {String} str String to search.
 * @param {Array} replacements Array of replacement detail arrays.
 * @returns {String} New string with all replacements.
 * @example
 *
 * str = XRegExp.replaceEach(str, [
 *   [XRegExp('(?<name>a)'), 'z${name}'],
 *   [/b/gi, 'y'],
 *   [/c/g, 'x', 'one'], // scope 'one' overrides /g
 *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
 *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
 *   [/f/g, function($0) {
 *     return $0.toUpperCase();
 *   }]
 * ]);
 */
XRegExp.replaceEach = function(str, replacements) {
    var i, r;

    for (i = 0; i < replacements.length; ++i) {
        r = replacements[i];
        str = XRegExp.replace(str, r[0], r[1], r[2]);
    }

    return str;
};

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 *
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * XRegExp.split('a b c', ' ');
 * // -> ['a', 'b', 'c']
 *
 * // With limit
 * XRegExp.split('a b c', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * XRegExp.split('..word1..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', '..']
 */
XRegExp.split = function(str, separator, limit) {
    return fixed.split.call(toObject(str), separator, limit);
};

/**
 * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
 * `sticky` arguments specify the search start position, and whether the match must start at the
 * specified position only. The `lastIndex` property of the provided regex is not used, but is
 * updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.test` and can be used reliably cross-browser.
 *
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Boolean} Whether the regex matched the provided value.
 * @example
 *
 * // Basic use
 * XRegExp.test('abc', /c/); // -> true
 *
 * // With pos and sticky
 * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false
 * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true
 */
XRegExp.test = function(str, regex, pos, sticky) {
    // Do this the easy way :-)
    return !!XRegExp.exec(str, regex, pos, sticky);
};

/**
 * Uninstalls optional features according to the specified options. All optional features start out
 * uninstalled, so this is used to undo the actions of `XRegExp.install`.
 *
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.uninstall({
 *   // Disables support for astral code points in Unicode addons
 *   astral: true,
 *
 *   // DEPRECATED: Restores native regex methods
 *   natives: true
 * });
 *
 * // With an options string
 * XRegExp.uninstall('astral natives');
 */
XRegExp.uninstall = function(options) {
    options = prepareOptions(options);

    if (features.astral && options.astral) {
        setAstral(false);
    }

    if (features.natives && options.natives) {
        setNatives(false);
    }
};

/**
 * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
 * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
 * Backreferences in provided regex objects are automatically renumbered to work correctly within
 * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
 * `flags` argument.
 *
 * @param {Array} patterns Regexes and strings to combine.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Union of the provided regexes and strings.
 * @example
 *
 * XRegExp.union(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
 * // -> /a\+b\*c|(dogs)\1|(cats)\2/i
 */
XRegExp.union = function(patterns, flags) {
    var numCaptures = 0;
    var numPriorCaptures;
    var captureNames;

    function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];

        // Capturing group
        if (paren) {
            ++numCaptures;
            // If the current capture has a name, preserve the name
            if (name) {
                return '(?<' + name + '>';
            }
        // Backreference
        } else if (backref) {
            // Rewrite the backreference
            return '\\' + (+backref + numPriorCaptures);
        }

        return match;
    }

    if (!(isType(patterns, 'Array') && patterns.length)) {
        throw new TypeError('Must provide a nonempty array of patterns to merge');
    }

    var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g;
    var output = [];
    var pattern;
    for (var i = 0; i < patterns.length; ++i) {
        pattern = patterns[i];

        if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];

            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
            // independently valid; helps keep this simple. Named captures are put back
            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
        } else {
            output.push(XRegExp.escape(pattern));
        }
    }

    return XRegExp(output.join('|'), flags);
};

// ==--------------------------==
// Fixed/extended native methods
// ==--------------------------==

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to
 * override the native method. Use via `XRegExp.exec` without overriding natives.
 *
 * @param {String} str String to search.
 * @returns {Array} Match array with named backreference properties, or `null`.
 */
fixed.exec = function(str) {
    var origLastIndex = this.lastIndex,
        match = nativ.exec.apply(this, arguments),
        name,
        r2,
        i;

    if (match) {
        // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing
        // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9
        // in standards mode follows the spec.
        if (!correctExecNpcg && match.length > 1 && indexOf(match, '') > -1) {
            r2 = copyRegex(this, {
                removeG: true,
                isInternalOnly: true
            });
            // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
            // matching due to characters outside the match
            nativ.replace.call(String(str).slice(match.index), r2, function() {
                var len = arguments.length, i;
                // Skip index 0 and the last 2
                for (i = 1; i < len - 2; ++i) {
                    if (arguments[i] === undefined) {
                        match[i] = undefined;
                    }
                }
            });
        }

        // Attach named capture properties
        if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
            // Skip index 0
            for (i = 1; i < match.length; ++i) {
                name = this[REGEX_DATA].captureNames[i - 1];
                if (name) {
                    match[name] = match[i];
                }
            }
        }

        // Fix browsers that increment `lastIndex` after zero-length matches
        if (this.global && !match[0].length && (this.lastIndex > match.index)) {
            this.lastIndex = match.index;
        }
    }

    if (!this.global) {
        // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
        this.lastIndex = origLastIndex;
    }

    return match;
};

/**
 * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`
 * uses this to override the native method.
 *
 * @param {String} str String to search.
 * @returns {Boolean} Whether the regex matched the provided value.
 */
fixed.test = function(str) {
    // Do this the easy way :-)
    return !!fixed.exec.call(this, str);
};

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to
 * override the native method.
 *
 * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.
 * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
 *   the result of calling `regex.exec(this)`.
 */
fixed.match = function(regex) {
    var result;

    if (!XRegExp.isRegExp(regex)) {
        // Use the native `RegExp` rather than `XRegExp`
        regex = new RegExp(regex);
    } else if (regex.global) {
        result = nativ.match.apply(this, arguments);
        // Fixes IE bug
        regex.lastIndex = 0;

        return result;
    }

    return fixed.exec.call(regex, toObject(this));
};

/**
 * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and
 * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes browser
 * bugs in replacement text syntax when performing a replacement using a nonregex search value, and
 * the value of a replacement regex's `lastIndex` property during replacement iterations and upon
 * completion. Calling `XRegExp.install('natives')` uses this to override the native method. Note
 * that this doesn't support SpiderMonkey's proprietary third (`flags`) argument. Use via
 * `XRegExp.replace` without overriding natives.
 *
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 * @returns {String} New string with one or all matches replaced.
 */
fixed.replace = function(search, replacement) {
    var isRegex = XRegExp.isRegExp(search),
        origLastIndex,
        captureNames,
        result;

    if (isRegex) {
        if (search[REGEX_DATA]) {
            captureNames = search[REGEX_DATA].captureNames;
        }
        // Only needed if `search` is nonglobal
        origLastIndex = search.lastIndex;
    } else {
        search += ''; // Type-convert
    }

    // Don't use `typeof`; some older browsers return 'function' for regex objects
    if (isType(replacement, 'Function')) {
        // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement
        // functions isn't type-converted to a string
        result = nativ.replace.call(String(this), search, function() {
            var args = arguments, i;
            if (captureNames) {
                // Change the `arguments[0]` string primitive to a `String` object that can store
                // properties. This really does need to use `String` as a constructor
                args[0] = new String(args[0]);
                // Store named backreferences on the first argument
                for (i = 0; i < captureNames.length; ++i) {
                    if (captureNames[i]) {
                        args[0][captureNames[i]] = args[i + 1];
                    }
                }
            }
            // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari
            // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)
            if (isRegex && search.global) {
                search.lastIndex = args[args.length - 2] + args[0].length;
            }
            // ES6 specs the context for replacement functions as `undefined`
            return replacement.apply(undefined, args);
        });
    } else {
        // Ensure that the last value of `args` will be a string when given nonstring `this`,
        // while still throwing on null or undefined context
        result = nativ.replace.call(this == null ? this : String(this), search, function() {
            // Keep this function's `arguments` available through closure
            var args = arguments;
            return nativ.replace.call(String(replacement), replacementToken, function($0, $1, $2) {
                var n;
                // Named or numbered backreference with curly braces
                if ($1) {
                    // XRegExp behavior for `${n}`:
                    // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the
                    //    entire match. Any number of leading zeros may be used.
                    // 2. Backreference to named capture `n`, if it exists and is not an integer
                    //    overridden by numbered capture. In practice, this does not overlap with
                    //    numbered capture since XRegExp does not allow named capture to use a bare
                    //    integer as the name.
                    // 3. If the name or number does not refer to an existing capturing group, it's
                    //    an error.
                    n = +$1; // Type-convert; drop leading zeros
                    if (n <= args.length - 3) {
                        return args[n] || '';
                    }
                    // Groups with the same name is an error, else would need `lastIndexOf`
                    n = captureNames ? indexOf(captureNames, $1) : -1;
                    if (n < 0) {
                        throw new SyntaxError('Backreference to undefined group ' + $0);
                    }
                    return args[n + 1] || '';
                }
                // Else, special variable or numbered backreference without curly braces
                if ($2 === '$') { // $$
                    return '$';
                }
                if ($2 === '&' || +$2 === 0) { // $&, $0 (not followed by 1-9), $00
                    return args[0];
                }
                if ($2 === '`') { // $` (left context)
                    return args[args.length - 1].slice(0, args[args.length - 2]);
                }
                if ($2 === "'") { // $' (right context)
                    return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
                }
                // Else, numbered backreference without curly braces
                $2 = +$2; // Type-convert; drop leading zero
                // XRegExp behavior for `$n` and `$nn`:
                // - Backrefs end after 1 or 2 digits. Use `${..}` for more digits.
                // - `$1` is an error if no capturing groups.
                // - `$10` is an error if less than 10 capturing groups. Use `${1}0` instead.
                // - `$01` is `$1` if at least one capturing group, else it's an error.
                // - `$0` (not followed by 1-9) and `$00` are the entire match.
                // Native behavior, for comparison:
                // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.
                // - `$1` is a literal `$1` if no capturing groups.
                // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.
                // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.
                // - `$0` is a literal `$0`.
                if (!isNaN($2)) {
                    if ($2 > args.length - 3) {
                        throw new SyntaxError('Backreference to undefined group ' + $0);
                    }
                    return args[$2] || '';
                }
                // `$` followed by an unsupported char is an error, unlike native JS
                throw new SyntaxError('Invalid token ' + $0);
            });
        });
    }

    if (isRegex) {
        if (search.global) {
            // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
            search.lastIndex = 0;
        } else {
            // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
            search.lastIndex = origLastIndex;
        }
    }

    return result;
};

/**
 * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`
 * uses this to override the native method. Use via `XRegExp.split` without overriding natives.
 *
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 */
fixed.split = function(separator, limit) {
    if (!XRegExp.isRegExp(separator)) {
        // Browsers handle nonregex split correctly, so use the faster native method
        return nativ.split.apply(this, arguments);
    }

    var str = String(this),
        output = [],
        origLastIndex = separator.lastIndex,
        lastLastIndex = 0,
        lastLength;

    // Values for `limit`, per the spec:
    // If undefined: pow(2,32) - 1
    // If 0, Infinity, or NaN: 0
    // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);
    // If negative number: pow(2,32) - floor(abs(limit))
    // If other: Type-convert, then use the above rules
    // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless
    // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+
    limit = (limit === undefined ? -1 : limit) >>> 0;

    XRegExp.forEach(str, separator, function(match) {
        // This condition is not the same as `if (match[0].length)`
        if ((match.index + match[0].length) > lastLastIndex) {
            output.push(str.slice(lastLastIndex, match.index));
            if (match.length > 1 && match.index < str.length) {
                Array.prototype.push.apply(output, match.slice(1));
            }
            lastLength = match[0].length;
            lastLastIndex = match.index + lastLength;
        }
    });

    if (lastLastIndex === str.length) {
        if (!nativ.test.call(separator, '') || lastLength) {
            output.push('');
        }
    } else {
        output.push(str.slice(lastLastIndex));
    }

    separator.lastIndex = origLastIndex;
    return output.length > limit ? output.slice(0, limit) : output;
};

// ==--------------------------==
// Built-in syntax/flag tokens
// ==--------------------------==

/*
 * Letter escapes that natively match literal characters: `\a`, `\A`, etc. These should be
 * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser
 * consistency and to reserve their syntax, but lets them be superseded by addons.
 */
XRegExp.addToken(
    /\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/,
    function(match, scope) {
        // \B is allowed in default scope only
        if (match[1] === 'B' && scope === defaultScope) {
            return match[0];
        }
        throw new SyntaxError('Invalid escape ' + match[0]);
    },
    {
        scope: 'all',
        leadChar: '\\'
    }
);

/*
 * Unicode code point escape with curly braces: `\u{N..}`. `N..` is any one or more digit
 * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag
 * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to
 * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior
 * if you follow a `\u{N..}` token that references a code point above U+FFFF with a quantifier, or
 * if you use the same in a character class.
 */
XRegExp.addToken(
    /\\u{([\dA-Fa-f]+)}/,
    function(match, scope, flags) {
        var code = dec(match[1]);
        if (code > 0x10FFFF) {
            throw new SyntaxError('Invalid Unicode code point ' + match[0]);
        }
        if (code <= 0xFFFF) {
            // Converting to \uNNNN avoids needing to escape the literal character and keep it
            // separate from preceding tokens
            return '\\u' + pad4(hex(code));
        }
        // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling
        if (hasNativeU && flags.indexOf('u') > -1) {
            return match[0];
        }
        throw new SyntaxError('Cannot use Unicode code point above \\u{FFFF} without flag u');
    },
    {
        scope: 'all',
        leadChar: '\\'
    }
);

/*
 * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.
 * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because
 * character class endings can't be determined.
 */
XRegExp.addToken(
    /\[(\^?)]/,
    function(match) {
        // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
        // (?!) should work like \b\B, but is unreliable in some versions of Firefox
        return match[1] ? '[\\s\\S]' : '\\b\\B';
    },
    {leadChar: '['}
);

/*
 * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in
 * free-spacing mode (flag x).
 */
XRegExp.addToken(
    /\(\?#[^)]*\)/,
    function(match, scope, flags) {
        // Keep tokens separated unless the following token is a quantifier. This avoids e.g.
        // inadvertedly changing `\1(?#)1` to `\11`.
        return isQuantifierNext(match.input, match.index + match[0].length, flags) ?
            '' : '(?:)';
    },
    {leadChar: '('}
);

/*
 * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
 */
XRegExp.addToken(
    /\s+|#[^\n]*\n?/,
    function(match, scope, flags) {
        // Keep tokens separated unless the following token is a quantifier. This avoids e.g.
        // inadvertedly changing `\1 1` to `\11`.
        return isQuantifierNext(match.input, match.index + match[0].length, flags) ?
            '' : '(?:)';
    },
    {flag: 'x'}
);

/*
 * Dot, in dotall mode (aka singleline mode, flag s) only.
 */
XRegExp.addToken(
    /\./,
    function() {
        return '[\\s\\S]';
    },
    {
        flag: 's',
        leadChar: '.'
    }
);

/*
 * Named backreference: `\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,
 * and $ only. Also allows numbered backreferences as `\k<n>`.
 */
XRegExp.addToken(
    /\\k<([\w$]+)>/,
    function(match) {
        // Groups with the same name is an error, else would need `lastIndexOf`
        var index = isNaN(match[1]) ? (indexOf(this.captureNames, match[1]) + 1) : +match[1],
            endIndex = match.index + match[0].length;
        if (!index || index > this.captureNames.length) {
            throw new SyntaxError('Backreference to undefined group ' + match[0]);
        }
        // Keep backreferences separate from subsequent literal numbers. This avoids e.g.
        // inadvertedly changing `(?<n>)\k<n>1` to `()\11`.
        return '\\' + index + (
            endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ?
                '' : '(?:)'
        );
    },
    {leadChar: '\\'}
);

/*
 * Numbered backreference or octal, plus any following digits: `\0`, `\11`, etc. Octals except `\0`
 * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches
 * are returned unaltered. IE < 9 doesn't support backreferences above `\99` in regex syntax.
 */
XRegExp.addToken(
    /\\(\d+)/,
    function(match, scope) {
        if (
            !(
                scope === defaultScope &&
                /^[1-9]/.test(match[1]) &&
                +match[1] <= this.captureNames.length
            ) &&
            match[1] !== '0'
        ) {
            throw new SyntaxError('Cannot use octal escape or backreference to undefined group ' +
                match[0]);
        }
        return match[0];
    },
    {
        scope: 'all',
        leadChar: '\\'
    }
);

/*
 * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the
 * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style
 * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively
 * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to
 * Python-style named capture as octals.
 */
XRegExp.addToken(
    /\(\?P?<([\w$]+)>/,
    function(match) {
        // Disallow bare integers as names because named backreferences are added to match arrays
        // and therefore numeric properties may lead to incorrect lookups
        if (!isNaN(match[1])) {
            throw new SyntaxError('Cannot use integer as capture name ' + match[0]);
        }
        if (match[1] === 'length' || match[1] === '__proto__') {
            throw new SyntaxError('Cannot use reserved word as capture name ' + match[0]);
        }
        if (indexOf(this.captureNames, match[1]) > -1) {
            throw new SyntaxError('Cannot use same name for multiple groups ' + match[0]);
        }
        this.captureNames.push(match[1]);
        this.hasNamedCapture = true;
        return '(';
    },
    {leadChar: '('}
);

/*
 * Capturing group; match the opening parenthesis only. Required for support of named capturing
 * groups. Also adds explicit capture mode (flag n).
 */
XRegExp.addToken(
    /\((?!\?)/,
    function(match, scope, flags) {
        if (flags.indexOf('n') > -1) {
            return '(?:';
        }
        this.captureNames.push(null);
        return '(';
    },
    {
        optionalFlags: 'n',
        leadChar: '('
    }
);

module.exports = XRegExp;

},{}],242:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-background-image": {
        width: '100%',
        height: '100%',
        backgroundPosition: 'center center',
        backgroundRepeat: 'no-repeat',
        backgroundSize: 'contain',
        display: 'block',
        overflow: 'auto'
    }
});
var BackgroundImage = function BackgroundImage(_ref) {
    var children = _ref.children,
        _ref$style = _ref.style,
        style = _ref$style === undefined ? {} : _ref$style,
        source = _ref.source,
        props = (0, _objectWithoutProperties3.default)(_ref, ['children', 'style', 'source']);

    var imgStyle = (0, _extends3.default)({
        backgroundImage: 'url("' + source + '")'
    }, style);
    return _react2.default.createElement(
        'doric-background-image',
        (0, _extends3.default)({}, props, { style: imgStyle }),
        children
    );
};

exports.default = BackgroundImage;

},{"babel-runtime/helpers/extends":300,"babel-runtime/helpers/objectWithoutProperties":302,"react":230,"source/util/app":268}],243:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _theme = require('source/util/theme');

var _theme2 = _interopRequireDefault(_theme);

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-button": {
        display: ['-webkit-inline-flex', 'inline-flex'],
        color: _theme2.default.button.text.color,
        padding: '0.7em 0.5em',
        alignItems: 'center',
        justifyContent: 'center',
        position: 'relative',
        userSelect: 'none',
        borderRadius: 3,
        borderWidth: 0,
        overflow: 'hidden',
        verticalAlign: 'top',
        margin: 5
    },
    "doric-button:after": {
        content: '""',
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        transition: 'background-color 250ms linear'
    },
    "doric-button[pressed]:not([disabled]):after": {
        backgroundColor: 'rgba(0, 0, 0, 0.25)',
        transition: 'none'
    },

    "doric-button[disabled]": {
        boxShadow: 'none',
        backgroundColor: '#e6e6e6',
        color: '#808080'
    },
    "doric-button[raised]": {
        boxShadow: _theme2.default.general.boxShadow
    }
});
var Button = function Button(props) {
    var _props$text = props.text,
        text = _props$text === undefined ? null : _props$text,
        children = props.children,
        _props$className = props.className,
        className = _props$className === undefined ? "" : _props$className,
        passThrough = (0, _objectWithoutProperties3.default)(props, ['text', 'children', 'className']);

    var passedOnTap = passThrough.onTap || function () {};

    passThrough.onTap = function (evt) {
        if (passThrough.disabled !== true) {
            passedOnTap(evt);
        }
    };

    return _react2.default.createElement(
        _CustomEvents2.default,
        (0, _extends3.default)({ component: 'doric-button' }, passThrough, { 'class': className }),
        text,
        children
    );
};

exports.default = Button;

},{"babel-runtime/helpers/extends":300,"babel-runtime/helpers/objectWithoutProperties":302,"react":230,"source/component/CustomEvents":247,"source/util/app":268,"source/util/theme":278}],244:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _theme = require('source/util/theme');

var _theme2 = _interopRequireDefault(_theme);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-card": {
        display: 'block',
        boxShadow: _theme2.default.general.boxShadow,
        margin: 5,
        borderRadius: 3,
        overflow: 'hidden',
        backgroundColor: 'white'
    },
    "doric-card .content": {
        padding: 5
    },
    "doric-card .title": {
        position: 'relative',
        overflow: 'hidden',
        WebkitFontSmoothing: 'antialiased',
        fontWeight: 900,
        fontSize: 18,
        padding: 5,
        borderBottom: '1px solid lightgray'
    },
    "doric-card .actions": {
        padding: 5,
        borderTop: '1px solid lightgray'
    }
});
var Card = function Card(props) {
    var children = props.children,
        _props$title = props.title,
        title = _props$title === undefined ? null : _props$title,
        _props$actions = props.actions,
        actions = _props$actions === undefined ? null : _props$actions,
        passThrough = (0, _objectWithoutProperties3.default)(props, ['children', 'title', 'actions']);

    var titleElement = null;
    var actionElement = null;

    if (title !== null) {
        titleElement = _react2.default.createElement(
            'div',
            { className: 'title' },
            title
        );
    }
    if (actions !== null) {
        actionElement = _react2.default.createElement(
            'div',
            { className: 'actions' },
            actions
        );
    }

    return _react2.default.createElement(
        'doric-card',
        passThrough,
        titleElement,
        _react2.default.createElement(
            'div',
            { className: 'content' },
            children
        ),
        actionElement
    );
};

exports.default = Card;

},{"babel-runtime/helpers/objectWithoutProperties":302,"react":230,"source/util/app":268,"source/util/theme":278}],245:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

var _stylesheet = require('source/util/stylesheet');

var _ContentAligners = require('source/component/ContentAligners');

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

var _Icon = require('source/component/Icon');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-checkbox": {
        position: 'relative',
        display: 'block',
        userSelect: 'none'
    },
    "doric-checkbox[disabled='true']": {
        color: 'gray',
        opacity: 0.6
    },
    "doric-checkbox:after": {
        content: "''",
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        transition: _consts2.default.css.backgroundTransition
    },
    "doric-checkbox[pressed]:not([disabled='true']):after": {
        backgroundColor: _stylesheet.CSS.rgba(0, 0, 0, 0.25),
        transition: 'none'
    },
    "doric-checkbox doric-icon": {
        transition: 'color 250ms linear'
    },
    "doric-checkbox[checked='true']:not([disabled='true']) doric-icon": {
        color: _consts2.default.theme.bluish
    }
});
var Checkbox = function Checkbox(props) {
    var _ref;

    var _props$checked = props.checked,
        checked = _props$checked === undefined ? false : _props$checked,
        children = props.children,
        label = props.label,
        _props$onChange = props.onChange,
        onChange = _props$onChange === undefined ? warningFunc("Checkbox has no onChange function") : _props$onChange,
        _props$onIcon = props.onIcon,
        onIcon = _props$onIcon === undefined ? "ion-android-checkbox" : _props$onIcon,
        _props$offIcon = props.offIcon,
        offIcon = _props$offIcon === undefined ? "ion-android-checkbox-outline-blank" : _props$offIcon,
        _props$side = props.side,
        side = _props$side === undefined ? 'left' : _props$side,
        _props$className = props.className,
        className = _props$className === undefined ? "" : _props$className,
        _props$style = props.style,
        style = _props$style === undefined ? {} : _props$style,
        passThrough = (0, _objectWithoutProperties3.default)(props, ['checked', 'children', 'label', 'onChange', 'onIcon', 'offIcon', 'side', 'className', 'style']);

    var change = function change() {
        if (props.disabled !== true) {
            onChange(checked === false);
        }
    };
    var iconName = checked === true ? onIcon : offIcon;
    var padding = (0, _defineProperty3.default)({
        padding: 5
    }, 'padding' + side.charAt(0).toUpperCase() + side.slice(1), 30);

    return _react2.default.createElement(
        _CustomEvents2.default,
        (0, _extends3.default)({ component: 'doric-checkbox', 'class': className, onTap: change }, passThrough, { style: (0, _extends3.default)({}, style, padding), checked: checked }),
        _react2.default.createElement(
            _ContentAligners.CenterContent,
            { 'data-no-press': true, style: (_ref = {}, (0, _defineProperty3.default)(_ref, side, 0), (0, _defineProperty3.default)(_ref, 'top', 0), (0, _defineProperty3.default)(_ref, 'position', 'absolute'), _ref), width: 30, height: '100%' },
            _react2.default.createElement(_Icon.Icon, { icon: iconName, 'data-no-press': true, style: { fontSize: 26 } })
        ),
        label,
        children
    );
};
Checkbox.formValue = "checked";

exports.default = Checkbox;

},{"babel-runtime/helpers/defineProperty":299,"babel-runtime/helpers/extends":300,"babel-runtime/helpers/objectWithoutProperties":302,"react":230,"source/component/ContentAligners":246,"source/component/CustomEvents":247,"source/component/Icon":251,"source/util/app":268,"source/util/consts":270,"source/util/stylesheet":277}],246:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AlignContent = exports.CenterContent = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-center-content": {
        display: ['-webkit-inline-flex', 'inline-flex'],
        alignItems: 'center',
        justifyContent: 'center'
    },
    "doric-align-content": {
        display: ['-webkit-inline-flex', 'inline-flex']
    },
    "doric-center-content.block, doric-align-content.block": {
        display: ['-webkit-flex', 'flex']
    }
});
var CenterContent = function CenterContent(_ref) {
    var width = _ref.width,
        height = _ref.height,
        _ref$className = _ref.className,
        className = _ref$className === undefined ? "" : _ref$className,
        block = _ref.block,
        _ref$style = _ref.style,
        style = _ref$style === undefined ? {} : _ref$style,
        passThrough = (0, _objectWithoutProperties3.default)(_ref, ['width', 'height', 'className', 'block', 'style']);
    return _react2.default.createElement('doric-center-content', (0, _extends3.default)({ 'class': ((block ? "block" : "") + ' ' + className).trim() }, passThrough, { style: (0, _extends3.default)({}, style, { width: width, height: height }) }));
};
var AlignContent = function AlignContent(_ref2) {
    var width = _ref2.width,
        height = _ref2.height,
        _ref2$className = _ref2.className,
        className = _ref2$className === undefined ? "" : _ref2$className,
        block = _ref2.block,
        _ref2$horizontal = _ref2.horizontal,
        horizontal = _ref2$horizontal === undefined ? "center" : _ref2$horizontal,
        _ref2$vertical = _ref2.vertical,
        vertical = _ref2$vertical === undefined ? "center" : _ref2$vertical,
        _ref2$style = _ref2.style,
        style = _ref2$style === undefined ? {} : _ref2$style,
        passThrough = (0, _objectWithoutProperties3.default)(_ref2, ['width', 'height', 'className', 'block', 'horizontal', 'vertical', 'style']);
    return _react2.default.createElement('doric-align-content', (0, _extends3.default)({
        'class': ((block ? "block" : "") + ' ' + className).trim()
    }, passThrough, {
        style: (0, _extends3.default)({}, style, {
            width: width,
            height: height,
            WebkitAlignItems: vertical,
            WebkitJustifyContent: horizontal,
            alignItems: vertical,
            justifyContent: horizontal
        }) }));
};

exports.CenterContent = CenterContent;
exports.AlignContent = AlignContent;

},{"babel-runtime/helpers/extends":300,"babel-runtime/helpers/objectWithoutProperties":302,"react":230,"source/util/app":268}],247:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var traverse = function traverse(node, evt, handlers) {
    var triggers = [];
    var current = node;
    var cont = true;

    evt.stopPropagation();
    evt.stopPropagation = function () {
        return cont = false;
    };
    while (cont == true && current !== document.body && current !== null && current !== undefined) {
        if (handlers.has(current.dataset.synthId) === true) {
            handlers.get(current.dataset.synthId)(evt);
        }
        current = current.parentNode;
    }
};
var handlers = {};
var nextID = 0;
var genID = function genID() {
    nextID += 1;
    return nextID.toString();
};
var registerHandler = function registerHandler(type, id, handler) {
    if (handlers[type] === undefined) {
        window.addEventListener(type, function (evt) {
            return traverse(evt.target, evt, handlers[evt.type.toLowerCase()]);
        }, true);
        handlers[type] = new _map2.default();
    }
    handlers[type].set(id, handler);
};
var unregisterHandlers = function unregisterHandlers(id) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)((0, _values2.default)(handlers)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var mapping = _step.value;

            mapping.delete(id);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
};
window.showHandlers = function () {
    return cblog(handlers);
};

var nativeEvents = new _set2.default(['onCut', 'onCopy', 'onPaste', 'onCompositionEnd', 'onCompositionStart', 'onCompositionUpdate', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onFocus', 'onBlur', 'onChange', 'onInput', 'onSubmit', 'onClick', 'onContextMenu', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', 'onSelect', 'onTouchCancel', 'onTouchEnd', 'onTouchMove', 'onTouchStart', 'onScroll', 'onWheel', 'onAbort', 'onCanPlay', 'onCanPlayThrough', 'onDurationChange', 'onEmptied', 'onEncrypted', 'onEnded', 'onError', 'onLoadedData', 'onLoadedMetadata', 'onLoadStart', 'onPause', 'onPlay', 'onPlaying', 'onProgress', 'onRateChange', 'onSeeked', 'onSeeking', 'onStalled', 'onSuspend', 'onTimeUpdate', 'onVolumeChange', 'onWaiting', 'onAnimationStart', 'onAnimationEnd', 'onAnimationIteration', 'onTransitionEnd']);

var CustomEvents = function (_React$Component) {
    (0, _inherits3.default)(CustomEvents, _React$Component);

    function CustomEvents(props) {
        (0, _classCallCheck3.default)(this, CustomEvents);

        var _this = (0, _possibleConstructorReturn3.default)(this, (CustomEvents.__proto__ || (0, _getPrototypeOf2.default)(CustomEvents)).call(this, props));

        _initialiseProps.call(_this);

        _this.id = genID();
        return _this;
    }

    return CustomEvents;
}(_react2.default.Component);

var _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.updateCallbacks = function () {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(_this2.props)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var key = _step2.value;

                if (key.slice(0, 2) === 'on' && nativeEvents.has(key) === false) {
                    registerHandler(key.slice(2).toLowerCase(), _this2.id, _this2.props[key]);
                }
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }
    };

    this.componentDidMount = function () {
        _this2.updateCallbacks();
        if (_reactDom2.default.findDOMNode(_this2).dataset.synthId === undefined) {
            console.warn(_this2.props.component.name + ' must pass the data-synth-id prop into the DOM elements rendered');
        }
    };

    this.componentDidUpdate = function () {
        unregisterHandlers(_this2.id);
        _this2.updateCallbacks();
    };

    this.componentWillUnmount = function () {
        unregisterHandlers(_this2.id);
    };

    this.render = function () {
        if ((_this2.props.component || null) === null) {
            throw new Error("component must be passed into CustomEvents");
        }
        var Component = _this2.props.component;
        var props = (0, _keys2.default)(_this2.props).reduce(function (p, key) {
            if (key !== 'component' && key.slice(0, 2) !== 'on' || nativeEvents.has(key) === true) {
                p[key] = _this2.props[key];
            }
            return p;
        }, {});
        return _react2.default.createElement(Component, (0, _extends3.default)({ 'data-synth-id': _this2.id }, props));
    };
};

exports.default = CustomEvents;

},{"babel-runtime/core-js/get-iterator":281,"babel-runtime/core-js/map":284,"babel-runtime/core-js/object/get-prototype-of":290,"babel-runtime/core-js/object/keys":291,"babel-runtime/core-js/object/values":293,"babel-runtime/core-js/set":295,"babel-runtime/helpers/classCallCheck":298,"babel-runtime/helpers/extends":300,"babel-runtime/helpers/inherits":301,"babel-runtime/helpers/possibleConstructorReturn":303,"react":230,"react-dom":29}],248:[function(require,module,exports){
'use strict';

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _spinnerGif = require('source/data-uri/spinner.gif.source');

var _spinnerGif2 = _interopRequireDefault(_spinnerGif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-button[fill]": {
        width: '100%',
        height: '100%',
        margin: 0,
        borderRadius: 0
    },
    "@keyframes doric-alert-appear": {
        from: {
            opacity: 0
        },
        to: {
            opacity: 1
        }
    },
    "doric-alert-wrapper": {
        animationName: 'doric-alert-appear',
        animationDuration: '250ms',
        width: '100%',
        height: '100%',
        position: 'absolute',
        top: 0,
        left: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.1)',
        zIndex: 10000,
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'flex-start'
    },
    "doric-alert": {
        backgroundColor: 'white',
        maxWidth: '80vw',
        borderRadius: 3,
        width: '100%',
        marginTop: '5vh',
        boxShadow: '2px 2px 2px rgba(0, 0, 0, 0.3)',
        overflow: 'hidden'
    },
    "doric-alert-title": {
        display: 'block',
        borderBottom: '1px solid lightgray',
        padding: 2,
        fontSize: 18,
        backgroundColor: "#5e9bff",
        color: 'white'
    }
});
var dialogStack = [];
window.addEventListener('keydown', function (evt) {
    if (evt.keyCode === 27 && dialogStack.length > 0) {
        dialogStack.slice(-1)[0].escape(null);
    }
});
var dialog = {
    show: function show(dialogInfo) {
        var Content = dialogInfo.content,
            _dialogInfo$props = dialogInfo.props,
            props = _dialogInfo$props === undefined ? {} : _dialogInfo$props,
            _dialogInfo$title = dialogInfo.title,
            title = _dialogInfo$title === undefined ? null : _dialogInfo$title,
            _dialogInfo$disableEs = dialogInfo.disableEscape,
            disableEscape = _dialogInfo$disableEs === undefined ? false : _dialogInfo$disableEs,
            _dialogInfo$buttons = dialogInfo.buttons,
            buttons = _dialogInfo$buttons === undefined ? [{ text: "Ok", close: true }] : _dialogInfo$buttons;

        var titleElement = title === null ? null : _react2.default.createElement(
            'doric-alert-title',
            null,
            title
        );

        var triggers = {};
        var dialogButtons = buttons.map(function (_ref) {
            var text = _ref.text,
                _ref$close = _ref.close,
                close = _ref$close === undefined ? false : _ref$close,
                _ref$className = _ref.className,
                className = _ref$className === undefined ? '' : _ref$className,
                _ref$trigger = _ref.trigger,
                trigger = _ref$trigger === undefined ? null : _ref$trigger;

            var onTap = void 0;

            switch (true) {
                case close === true:
                    onTap = function onTap() {
                        return dobj.close(null);
                    };
                    break;

                case trigger !== null:
                    onTap = function onTap() {
                        return ref[trigger](dobj.close);
                    };
                    break;
            }

            return _react2.default.createElement(Doric.Button, (0, _extends3.default)({ className: className, text: text, onTap: onTap }, { fill: true }));
        });
        var renderElem = document.createElement("div");

        var resolver = void 0;
        var valuePromise = new _promise2.default(function (resolve) {
            return resolver = resolve;
        });
        var close = function close() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            dialogStack.splice(dialogStack.indexOf(dobj), 1);
            document.body.removeChild(renderElem);
            resolver(value);
        };
        var dobj = {
            escape: function escape() {
                var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

                if (disableEscape !== true) {
                    close(value);
                }
            },

            close: close,
            value: valuePromise
        };
        var ref = void 0;

        var container = _react2.default.createElement(
            'doric-alert-wrapper',
            null,
            _react2.default.createElement(
                'doric-alert',
                null,
                titleElement,
                _react2.default.createElement(
                    'div',
                    { style: { maxHeight: '33vh', borderBottom: '1px solid lightgray' } },
                    _react2.default.createElement(Content, (0, _extends3.default)({}, props, triggers, { ref: function (_ref2) {
                            function ref(_x3) {
                                return _ref2.apply(this, arguments);
                            }

                            ref.toString = function () {
                                return _ref2.toString();
                            };

                            return ref;
                        }(function (self) {
                            return ref = self;
                        }), close: dobj.close }))
                ),
                _react2.default.createElement(
                    Doric.Grid,
                    { cellHeight: 30, colCount: dialogButtons.length },
                    dialogButtons
                )
            )
        );

        dialogStack.push(dobj);
        document.body.appendChild(renderElem);
        ReactDOM.render(container, renderElem);

        return dobj;
    },
    closeTop: function closeTop() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (dialogStack.length > 0) {
            dialogStack.slice(-1)[0].close(value);
        }
    }
};
dialog.alert = function (options) {
    if (typeof options === 'string') {
        options = {
            message: options,
            title: arguments.length <= 1 ? undefined : arguments[1]
        };
    }

    var _options = options,
        message = _options.message,
        _options$title = _options.title,
        title = _options$title === undefined ? null : _options$title;


    return dialog.show({
        content: function content() {
            return _react2.default.createElement(
                'div',
                { style: { padding: 3, textAlign: 'center' } },
                message
            );
        },
        title: title
    });
};

var ConfirmDialogDisplay = function (_React$Component) {
    (0, _inherits3.default)(ConfirmDialogDisplay, _React$Component);

    function ConfirmDialogDisplay(props) {
        (0, _classCallCheck3.default)(this, ConfirmDialogDisplay);

        var _this = (0, _possibleConstructorReturn3.default)(this, (ConfirmDialogDisplay.__proto__ || (0, _getPrototypeOf2.default)(ConfirmDialogDisplay)).call(this, props));

        _this.trueResponse = function (close) {
            return close(true);
        };

        _this.render = function () {
            return _react2.default.createElement(
                'div',
                { style: { padding: 3, textAlign: 'center' } },
                _this.props.message
            );
        };

        return _this;
    }

    return ConfirmDialogDisplay;
}(_react2.default.Component);

dialog.confirm = function (options) {
    if (typeof options === 'string') {
        options = {
            message: options,
            title: arguments.length <= 1 ? undefined : arguments[1]
        };
    }

    var _options2 = options,
        message = _options2.message,
        _options2$title = _options2.title,
        title = _options2$title === undefined ? null : _options2$title,
        okText = _options2.okText,
        cancelText = _options2.cancelText;


    return dialog.show({
        title: title,
        buttons: [{ text: okText || "OK", trigger: 'trueResponse' }, { text: cancelText || "Cancel", close: true }],
        content: ConfirmDialogDisplay,
        props: { message: message }
    });
};

var PromptDialogDisplay = function (_React$Component2) {
    (0, _inherits3.default)(PromptDialogDisplay, _React$Component2);

    function PromptDialogDisplay(props) {
        (0, _classCallCheck3.default)(this, PromptDialogDisplay);

        var _this2 = (0, _possibleConstructorReturn3.default)(this, (PromptDialogDisplay.__proto__ || (0, _getPrototypeOf2.default)(PromptDialogDisplay)).call(this, props));

        _this2.finish = function (close) {
            return close(_this2.state.value);
        };

        _this2.onEnter = function (evt) {
            evt.preventDefault();
            _this2.props.close(_this2.state.value);
        };

        _this2.render = function () {
            return _react2.default.createElement(
                'form',
                { onSubmit: _this2.onEnter },
                _react2.default.createElement(Doric.Input.Text, { label: _this2.props.label, value: _this2.state.value, onChange: function onChange(value) {
                        return _this2.setState({ value: value });
                    } })
            );
        };

        _this2.state = { value: _this2.props.defaultValue };
        return _this2;
    }

    return PromptDialogDisplay;
}(_react2.default.Component);

dialog.prompt = function (options) {
    if (typeof options === 'string') {
        options = {
            message: options,
            title: arguments.length <= 1 ? undefined : arguments[1]
        };
    }

    var _options3 = options,
        message = _options3.message,
        _options3$value = _options3.value,
        value = _options3$value === undefined ? "" : _options3$value,
        _options3$title = _options3.title,
        title = _options3$title === undefined ? null : _options3$title,
        okText = _options3.okText,
        cancelText = _options3.cancelText;


    return dialog.show({
        title: title,
        buttons: [{ text: okText || "OK", trigger: 'finish' }, { text: cancelText || "Cancel", close: true }],
        content: PromptDialogDisplay,
        props: {
            label: message,
            defaultValue: value
        }
    });
};

dialog.spinner = function (message) {
    return dialog.show({
        content: function content() {
            return _react2.default.createElement(
                'div',
                { style: { textAlign: 'center' } },
                message,
                _react2.default.createElement(Doric.Image, { width: '100%', height: 30, source: _spinnerGif2.default })
            );
        },
        buttons: [],
        disableEscape: true
    });
};

window.dialog = dialog;

},{"babel-runtime/core-js/object/get-prototype-of":290,"babel-runtime/core-js/promise":294,"babel-runtime/helpers/classCallCheck":298,"babel-runtime/helpers/extends":300,"babel-runtime/helpers/inherits":301,"babel-runtime/helpers/possibleConstructorReturn":303,"react":230,"source/data-uri/spinner.gif.source":264,"source/util/app":268}],249:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-form, doric-form-layout": {
        display: 'block'
    },
    "doric-button.form-button": {
        display: ["-webkit-flex", "flex"],
        backgroundColor: '#4285f4',
        color: 'white'
    }
});
var FormLayout = function FormLayout(_ref) {
    var style = _ref.style,
        children = _ref.children;
    return _react2.default.createElement(
        'doric-form-layout',
        { style: style },
        children
    );
};
FormLayout.FormItem = function (_ref2) {
    var children = _ref2.children,
        props = (0, _objectWithoutProperties3.default)(_ref2, ['children']);
    return _react2.default.createElement(
        'div',
        props,
        children
    );
};

var FormUpdater = function (_React$Component) {
    (0, _inherits3.default)(FormUpdater, _React$Component);

    function FormUpdater(props) {
        (0, _classCallCheck3.default)(this, FormUpdater);

        var _this = (0, _possibleConstructorReturn3.default)(this, (FormUpdater.__proto__ || (0, _getPrototypeOf2.default)(FormUpdater)).call(this, props));

        _initialiseProps.call(_this);

        _this.state = { value: undefined };
        return _this;
    }

    return FormUpdater;
}(_react2.default.Component);

var _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this.update = function (value) {
        _this3.setState({ value: value });
        _this3.props.update(value);
    };

    this.render = function () {
        var _formProps;

        var _props = _this3.props,
            Type = _props.Type,
            props = _props.props,
            valueName = _props.valueName,
            valueChanged = _props.valueChanged,
            defaultValue = _props.defaultValue;
        var value = _this3.state.value;


        if (value === undefined) {
            value = defaultValue;
        }

        var formProps = (_formProps = {}, (0, _defineProperty3.default)(_formProps, valueName, value), (0, _defineProperty3.default)(_formProps, valueChanged, _this3.update), _formProps);

        return _react2.default.createElement(Type, (0, _extends3.default)({}, props, formProps));
    };
};

var Form = function (_React$Component2) {
    (0, _inherits3.default)(Form, _React$Component2);

    function Form(props) {
        (0, _classCallCheck3.default)(this, Form);

        var _this2 = (0, _possibleConstructorReturn3.default)(this, (Form.__proto__ || (0, _getPrototypeOf2.default)(Form)).call(this, props));

        _this2.submit = function () {
            var _this2$props$onSubmit = _this2.props.onSubmit,
                onSubmit = _this2$props$onSubmit === undefined ? function () {} : _this2$props$onSubmit;


            onSubmit(_this2.values);
        };

        _this2.render = function () {
            var _this2$props = _this2.props,
                _this2$props$submitTe = _this2$props.submitText,
                submitText = _this2$props$submitTe === undefined ? "Submit" : _this2$props$submitTe,
                _this2$props$layout = _this2$props.layout,
                Layout = _this2$props$layout === undefined ? FormLayout : _this2$props$layout;
            var values = _this2.values;

            var layoutProps = (0, _keys2.default)(_this2.props).reduce(function (newProps, key) {
                if (key.startsWith("layout-") === true) {
                    newProps[key.slice(7)] = _this2.props[key];
                }
                return newProps;
            }, {});

            var Item = Layout.FormItem || FormLayout.FormItem;
            var children = _react2.default.Children.toArray(_this2.props.children);
            var displayChildren = children.map(function (child) {
                var name = child.props.formName;
                var defaultValue = child.props.defaultValue;

                var valueName = child.type.formValue || 'value';
                var valueChanged = child.type.formValueChanged || "onChange";
                var value = values[name];

                if (value === undefined) {
                    value = defaultValue;
                }

                values[name] = value;

                var Type = child.type;
                var keys = (0, _keys2.default)(child.props);
                var layoutProps = {};
                var childProps = {};

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = (0, _getIterator3.default)(keys), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var key = _step.value;

                        if (key.startsWith("layout-") === true) {
                            layoutProps[key.slice(7)] = child.props[key];
                        } else {
                            childProps[key] = child.props[key];
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                var updaterProps = {
                    Type: Type,
                    valueName: valueName,
                    valueChanged: valueChanged,
                    defaultValue: defaultValue,
                    update: function update(value) {
                        return _this2.values[name] = value;
                    },
                    props: childProps
                };

                return _react2.default.createElement(
                    Item,
                    layoutProps,
                    _react2.default.createElement(FormUpdater, updaterProps)
                );
            });

            return _react2.default.createElement(
                'doric-form',
                { style: _this2.props.style, 'class': _this2.props.className },
                _react2.default.createElement(
                    Layout,
                    layoutProps,
                    displayChildren
                ),
                _react2.default.createElement(Doric.Button, { text: submitText, className: 'form-button', onTap: _this2.submit, raised: true })
            );
        };

        _this2.values = {};
        return _this2;
    }

    return Form;
}(_react2.default.Component);

exports.default = Form;

},{"babel-runtime/core-js/get-iterator":281,"babel-runtime/core-js/object/get-prototype-of":290,"babel-runtime/core-js/object/keys":291,"babel-runtime/helpers/classCallCheck":298,"babel-runtime/helpers/defineProperty":299,"babel-runtime/helpers/extends":300,"babel-runtime/helpers/inherits":301,"babel-runtime/helpers/objectWithoutProperties":302,"babel-runtime/helpers/possibleConstructorReturn":303,"react":230,"source/util/app":268}],250:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-grid": {
        display: 'block',
        overflow: 'auto'
    },
    "doric-grid-item": {
        display: 'inline-block',
        margin: 0,
        padding: 0,
        borderWidth: 0,
        borderStyle: 'solid',
        borderColor: 'transparent',
        // overflow: 'hidden',
        position: 'relative',
        top: 0,
        left: 0,
        float: 'left'
    },
    "doric-radio-item": {
        width: '100%',
        height: '100%',
        display: ['-webkit-flex', 'flex'],
        justifyContent: 'center',
        alignItems: 'center'
    },
    "doric-radio-item[selected='true']": {
        backgroundColor: 'cyan'
    }
});

var Grid = function Grid(props) {
    var _props$cellSpacing = props.cellSpacing,
        cellSpacing = _props$cellSpacing === undefined ? [0, 0] : _props$cellSpacing,
        _props$cellHeight = props.cellHeight,
        cellHeight = _props$cellHeight === undefined ? 30 : _props$cellHeight,
        _props$colCount = props.colCount,
        colCount = _props$colCount === undefined ? 12 : _props$colCount,
        _props$style = props.style,
        style = _props$style === undefined ? {} : _props$style,
        className = props.className;

    var _ref = typeof cellSpacing === 'number' ? [cellSpacing, cellSpacing] : cellSpacing,
        _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        cellSpacingH = _ref2[0],
        cellSpacingV = _ref2[1];

    var gridStyle = (0, _extends3.default)({}, style, {
        paddingLeft: cellSpacingH,
        paddingTop: cellSpacingV
    });
    var baseItemStyle = {
        borderWidth: cellSpacingV + 'px ' + cellSpacingH + 'px'
    };
    var children = props.children;


    if (cellHeight !== null) {
        baseItemStyle.height = cellHeight + cellSpacingV * 2;
    }

    children = _react2.default.Children.toArray(children);
    children = children.map(function (child) {
        var _child$props = child.props,
            _child$props$colSpan = _child$props.colSpan,
            colSpan = _child$props$colSpan === undefined ? 1 : _child$props$colSpan,
            childProps = (0, _objectWithoutProperties3.default)(_child$props, ['colSpan']);

        var width = 'calc(' + colSpan * 100 / colCount + '% + ' + cellSpacingH + 'px)';
        var marginLeft = -cellSpacingH;
        var marginTop = -cellSpacingV;
        return _react2.default.createElement(
            'doric-grid-item',
            { style: (0, _extends3.default)({}, baseItemStyle, { width: width, marginTop: marginTop, marginLeft: marginLeft }) },
            _react2.default.createElement(child.type, (0, _extends3.default)({}, childProps, { ref: child.ref }))
        );
    });

    return _react2.default.createElement(
        'doric-grid',
        { style: gridStyle, 'class': className },
        children
    );
};

Grid.RadioItem = function (_ref3) {
    var children = _ref3.children,
        selected = _ref3.selected,
        _ref3$itemStyle = _ref3.itemStyle,
        itemStyle = _ref3$itemStyle === undefined ? {} : _ref3$itemStyle;
    return _react2.default.createElement(
        'doric-radio-item',
        { selected: selected, style: itemStyle },
        children
    );
};

exports.default = Grid;

},{"babel-runtime/helpers/extends":300,"babel-runtime/helpers/objectWithoutProperties":302,"babel-runtime/helpers/slicedToArray":304,"react":230,"source/util/app":268}],251:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IconButton = exports.Icon = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _button = require('source/component/button');

var _button2 = _interopRequireDefault(_button);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _icons = require('source/util/icons');

var _icons2 = _interopRequireDefault(_icons);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-icon": {
        display: 'inline',
        fontSize: 16,
        fontFamily: "Ionic",
        padding: 2
    }
});
var Icon = function Icon(_ref) {
    var icon = _ref.icon,
        className = _ref.className,
        passThrough = (0, _objectWithoutProperties3.default)(_ref, ['icon', 'className']);
    return _react2.default.createElement(
        'doric-icon',
        (0, _extends3.default)({}, passThrough, { 'class': className }),
        _icons2.default[icon]
    );
};
var IconButton = function IconButton(_ref2) {
    var icon = _ref2.icon,
        iconStyle = _ref2.iconStyle,
        _ref2$text = _ref2.text,
        text = _ref2$text === undefined ? "" : _ref2$text,
        children = _ref2.children,
        props = (0, _objectWithoutProperties3.default)(_ref2, ['icon', 'iconStyle', 'text', 'children']);
    return _react2.default.createElement(
        _button2.default,
        (0, _extends3.default)({}, props, { text: _react2.default.createElement(Icon, { icon: icon, style: iconStyle }) }),
        text,
        children
    );
};

exports.Icon = Icon;
exports.IconButton = IconButton;

},{"babel-runtime/helpers/extends":300,"babel-runtime/helpers/objectWithoutProperties":302,"react":230,"source/component/button":261,"source/util/app":268,"source/util/icons":275}],252:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-image": {
        display: 'inline-block',
        backgroundRepeat: 'no-repeat',
        backgroundPosition: 'center center',
        verticalAlign: 'top'
    }
});
var Image = function Image(_ref) {
    var source = _ref.source,
        _ref$cover = _ref.cover,
        cover = _ref$cover === undefined ? false : _ref$cover,
        _ref$contain = _ref.contain,
        contain = _ref$contain === undefined ? false : _ref$contain,
        _ref$width = _ref.width,
        width = _ref$width === undefined ? null : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? null : _ref$height,
        _ref$style = _ref.style,
        style = _ref$style === undefined ? {} : _ref$style,
        passThrough = (0, _objectWithoutProperties3.default)(_ref, ['source', 'cover', 'contain', 'width', 'height', 'style']);

    var bgSize = 'contain';

    if (cover === true && contain === false) {
        bgSize = 'cover';
    }

    return _react2.default.createElement('doric-image', (0, _extends3.default)({ style: (0, _extends3.default)({}, style, { backgroundImage: 'url("' + source + '")', width: width, height: height, backgroundSize: bgSize }) }, passThrough));
};

exports.default = Image;

},{"babel-runtime/helpers/extends":300,"babel-runtime/helpers/objectWithoutProperties":302,"react":230,"source/util/app":268}],253:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _doricInput, _doricInputMultilin;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-input": (_doricInput = {
        display: 'inline-block',
        position: 'relative',
        top: 0,
        left: 0
    }, (0, _defineProperty3.default)(_doricInput, 'display', 'block'), (0, _defineProperty3.default)(_doricInput, 'margin', 3), (0, _defineProperty3.default)(_doricInput, 'paddingTop', 22), (0, _defineProperty3.default)(_doricInput, 'backgroundColor', 'white'), (0, _defineProperty3.default)(_doricInput, 'verticalAlign', 'top'), _doricInput),
    "doric-input > input": {
        width: '100%',
        borderWidth: 0,
        padding: 5,
        borderBottom: '2px solid ' + _consts2.default.theme.grayBG,
        backgroundColor: 'transparent',
        position: 'relative',
        top: 0,
        left: 0,
        zIndex: "+1"
    },
    "doric-input > input:focus": {
        outline: 'none'
    },
    "doric-input > doric-input-label": {
        position: 'absolute',
        top: 0,
        left: 0,
        paddingLeft: 2,
        height: 22,
        transformOrigin: 'left top',
        transform: 'translate(0, 3px) scale(0.85)',
        transition: 'transform 150ms linear'
    },
    "doric-input > input:focus ~ doric-input-label:not([placeholder])": {
        color: '#435dec'
    },
    "doric-input > doric-input-label[placeholder]": {
        transform: 'translate(5px, 100%)',
        color: 'gray'
    },
    "doric-input > input + doric-input-flourish": {
        position: 'absolute',
        height: 2,
        backgroundColor: _consts2.default.theme.bluish,
        left: 0,
        right: 0,
        bottom: 0,
        transform: 'scaleX(0)',
        zIndex: "+2"
    },
    "doric-input > input:focus + doric-input-flourish": {
        transition: 'transform 100ms linear',
        transform: 'scaleX(1)'
    }
});

var TextInput = function (_React$Component) {
    (0, _inherits3.default)(TextInput, _React$Component);

    function TextInput(props) {
        (0, _classCallCheck3.default)(this, TextInput);

        var _this = (0, _possibleConstructorReturn3.default)(this, (TextInput.__proto__ || (0, _getPrototypeOf2.default)(TextInput)).call(this, props));

        _this.render = function () {
            var _this$props = _this.props,
                _this$props$value = _this$props.value,
                value = _this$props$value === undefined ? "" : _this$props$value,
                _this$props$type = _this$props.type,
                type = _this$props$type === undefined ? "text" : _this$props$type,
                _this$props$label = _this$props.label,
                label = _this$props$label === undefined ? null : _this$props$label;

            var labelProps = {
                placeholder: value === "" || value === null ? "" : null
            };
            var poc = _this.props.onChange || function () {};
            var onChange = function onChange(evt) {
                return poc(evt.target.value, evt);
            };

            return _react2.default.createElement(
                _CustomEvents2.default,
                { component: 'doric-input', onTap: function onTap() {
                        return _this.refs.textInput.focus();
                    } },
                _react2.default.createElement('input', (0, _extends3.default)({ type: type, onChange: onChange, value: value }, { ref: 'textInput' })),
                _react2.default.createElement('doric-input-flourish', null),
                _react2.default.createElement(
                    'doric-input-label',
                    labelProps,
                    label
                )
            );
        };

        return _this;
    }

    return TextInput;
}(_react2.default.Component);

_app2.default.addStyles({
    "doric-input-multiline": (_doricInputMultilin = {
        display: 'inline-block',
        position: 'relative',
        top: 0,
        left: 0
    }, (0, _defineProperty3.default)(_doricInputMultilin, 'display', 'block'), (0, _defineProperty3.default)(_doricInputMultilin, 'margin', 3), (0, _defineProperty3.default)(_doricInputMultilin, 'paddingTop', 22), (0, _defineProperty3.default)(_doricInputMultilin, 'verticalAlign', 'top'), (0, _defineProperty3.default)(_doricInputMultilin, 'backgroundColor', 'white'), _doricInputMultilin),
    "doric-input-multiline > textarea": {
        width: '100%',
        borderWidth: 1,
        borderColor: 'lightgray',
        verticalAlign: 'top',
        padding: 3,
        margin: 0,
        borderBottom: '2px solid #d0d0d0',
        backgroundColor: 'transparent',
        position: 'relative',
        top: 0,
        left: 0,
        zIndex: "+1",
        resize: 'none'
    },
    "doric-input-multiline > textarea:focus": {
        outline: 'none'
    },
    "doric-input-multiline > textarea:focus ~ doric-input-label:not([placeholder])": {
        color: '#435dec'
    },
    "doric-input-multiline > doric-input-label": {
        position: 'absolute',
        top: 0,
        left: 0,
        paddingLeft: 2,
        height: 22,
        transformOrigin: 'left top',
        transform: 'translate(0, 3px) scale(0.85)',
        transition: 'transform 150ms linear'
    },
    "doric-input-multiline > doric-input-label[placeholder]": {
        transform: 'translate(5px, 100%)',
        color: 'gray'
    },
    "doric-input-multiline > textarea + doric-input-multiline-flourish": {
        position: 'absolute',
        height: 2,
        backgroundColor: '#4285f4',
        left: 0,
        right: 0,
        bottom: 0,
        transform: 'scaleX(0)',
        zIndex: "+2"
    },
    "doric-input-multiline > textarea:focus + doric-input-multiline-flourish": {
        transition: 'transform 100ms linear',
        transform: 'scaleX(1)'
    }
});
var MultilineInput = function MultilineInput(props) {
    var value = props.value,
        _props$label = props.label,
        label = _props$label === undefined ? null : _props$label,
        _props$lines = props.lines,
        lines = _props$lines === undefined ? 3 : _props$lines;

    var labelProps = {
        placeholder: value === "" || value === null ? "" : null
    };
    var poc = props.onChange || function () {};
    var onChange = function onChange(evt) {
        return poc(evt.target.value);
    };

    return _react2.default.createElement(
        _CustomEvents2.default,
        { component: 'doric-input-multiline' },
        _react2.default.createElement('textarea', { value: value, onChange: onChange, rows: lines }),
        _react2.default.createElement('doric-input-multiline-flourish', null),
        _react2.default.createElement(
            'doric-input-label',
            labelProps,
            label
        )
    );
};

var Input = {
    Text: function Text(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'text' }));
    },
    Password: function Password(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'password' }));
    },
    Search: function Search(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'search' }));
    },
    URL: function URL(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'url' }));
    },
    Email: function Email(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'email' }));
    },
    Number: function Number(props) {
        return _react2.default.createElement(TextInput, (0, _extends3.default)({}, props, { type: 'number' }));
    },
    Multiline: MultilineInput
};

exports.default = Input;

},{"babel-runtime/core-js/object/get-prototype-of":290,"babel-runtime/helpers/classCallCheck":298,"babel-runtime/helpers/defineProperty":299,"babel-runtime/helpers/extends":300,"babel-runtime/helpers/inherits":301,"babel-runtime/helpers/possibleConstructorReturn":303,"react":230,"source/component/CustomEvents":247,"source/util/app":268,"source/util/consts":270}],254:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-pinboard": {
        display: 'inline-block',
        position: 'relative',
        overflow: 'auto'
    },
    "doric-pin": {
        position: 'absolute'
    }
});
var Pinboard = function Pinboard(_ref) {
    var _ref$style = _ref.style,
        style = _ref$style === undefined ? {} : _ref$style,
        _ref$width = _ref.width,
        width = _ref$width === undefined ? "100%" : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? "100%" : _ref$height,
        _ref$className = _ref.className,
        className = _ref$className === undefined ? "" : _ref$className,
        children = _ref.children,
        passThrough = (0, _objectWithoutProperties3.default)(_ref, ['style', 'width', 'height', 'className', 'children']);

    children = _react2.default.Children.toArray(children);

    children = children.map(function (child, index) {
        var _child$props = child.props,
            pinStyle = _child$props.pinStyle,
            childProps = (0, _objectWithoutProperties3.default)(_child$props, ['pinStyle']);

        var actualChild = _react2.default.createElement(child.type, (0, _extends3.default)({}, childProps, { ref: child.ref }));
        return _react2.default.createElement(
            'doric-pin',
            { key: index, style: pinStyle },
            actualChild
        );
    });

    return _react2.default.createElement(
        'doric-pinboard',
        { 'class': className, style: (0, _extends3.default)({}, style, { width: width, height: height }) },
        children
    );
};

exports.default = Pinboard;

},{"babel-runtime/helpers/extends":300,"babel-runtime/helpers/objectWithoutProperties":302,"react":230,"source/util/app":268}],255:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-progress": {
        display: 'block',
        height: 10,
        backgroundColor: "#e0e0e0",
        marginTop: 10,
        marginBottom: 10,
        marginLeft: 5,
        marginRight: 5,
        position: 'relative'
    },
    "doric-progress-bar": {
        height: '100%',
        width: '100%',
        position: 'absolute',
        transformOrigin: 'left center',
        transition: 'transform 200ms ease-out'
    },
    "doric-progress-bar.primary": {
        backgroundColor: '#4285f4'
    },
    "doric-progress-bar.secondary": {
        backgroundColor: '#b3cefb'
    }
});
var Progress = function Progress(_ref) {
    var progress = _ref.progress,
        _ref$secondaryProgres = _ref.secondaryProgress,
        secondaryProgress = _ref$secondaryProgres === undefined ? null : _ref$secondaryProgres,
        className = _ref.className,
        children = _ref.children,
        passThrough = (0, _objectWithoutProperties3.default)(_ref, ['progress', 'secondaryProgress', 'className', 'children']);

    var scale = 'scaleX(' + progress + ')';
    var secondaryProgressBar = null;

    if (secondaryProgress !== null) {
        var scale2 = 'scaleX(' + secondaryProgress + ')';
        secondaryProgressBar = _react2.default.createElement('doric-progress-bar', { 'class': 'secondary', style: { WebkitTransform: scale2, transform: scale2 } });
    }

    return _react2.default.createElement(
        'doric-progress',
        (0, _extends3.default)({ 'class': className }, passThrough),
        secondaryProgressBar,
        _react2.default.createElement('doric-progress-bar', { 'class': 'primary', style: { WebkitTransform: scale, transform: scale } })
    );
};

exports.default = Progress;

},{"babel-runtime/helpers/extends":300,"babel-runtime/helpers/objectWithoutProperties":302,"react":230,"source/util/app":268}],256:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _stylesheet = require('source/util/stylesheet');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var animTime = 200;
_app2.default.addStyles({
    "doric-screen": {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%'
    },
    "doric-screen-title": {
        display: ['webkit-flex', 'flex'],
        backgroundColor: '#4285f4',
        color: 'white',
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: 40,
        justifyContent: 'center',
        alignItems: 'center',
        boxShadow: '0 2px 2px 0 rgba(0, 0, 0, 0.25)',
        fontSize: 20,
        zIndex: '+5',
        overflow: 'visible'
    },
    "doric-screen-content": {
        position: 'absolute',
        top: 40,
        left: 0,
        right: 0,
        bottom: 0,
        overflow: 'auto'
    },
    "doric-screen-menu": {
        position: 'absolute',
        top: 40,
        left: 0,
        bottom: 0,
        right: 0,
        backgroundColor: _stylesheet.CSS.rgba(0, 0, 0, 0.2),
        boxShadow: '0 2px 2px 0 rgba(0, 0, 0, 0.25)',
        zIndex: '+5',
        transform: 'translateX(-100%)',
        overflow: 'hidden',
        opacity: 0,
        transition: 'opacity ' + animTime + 'ms linear, transform 0ms linear 250ms'
    },
    "doric-screen-menu > div": {
        transform: 'translateY(-100%)',
        transition: 'transform ' + animTime + 'ms linear'
    },
    "doric-screen-menu[visible='true']": {
        transform: 'translateX(0)',
        opacity: 1,
        transition: 'opacity ' + animTime + 'ms linear'
    },
    "doric-screen-menu[visible='true'] > div": {
        transform: 'translateY(0%)'
    },
    ".doric-screen-menu-button": {
        width: 45,
        height: 40,
        position: 'absolute',
        top: 0,
        right: 0,
        color: 'white',
        borderRadius: 0,
        margin: 0
    },
    ".doric-screen-back-button": {
        height: 40,
        position: 'absolute',
        top: 0,
        left: 0,
        color: 'white',
        borderRadius: 0,
        margin: 0,
        fontSize: 14
    }
});

var Screen = function (_React$Component) {
    (0, _inherits3.default)(Screen, _React$Component);

    function Screen(props) {
        (0, _classCallCheck3.default)(this, Screen);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Screen.__proto__ || (0, _getPrototypeOf2.default)(Screen)).call(this, props));

        _this.toggle = function () {
            _this.setState({
                expanded: !_this.state.expanded
            });
        };

        _this.render = function () {
            var _this$props = _this.props,
                title = _this$props.title,
                _this$props$menu = _this$props.menu,
                menu = _this$props$menu === undefined ? null : _this$props$menu,
                _this$props$backText = _this$props.backText,
                backText = _this$props$backText === undefined ? null : _this$props$backText;
            var _this$props$onBack = _this.props.onBack,
                onBack = _this$props$onBack === undefined ? null : _this$props$onBack;
            var expanded = _this.state.expanded;


            var menuButton = null;
            var backButton = null;

            if (onBack !== null || backText !== null) {
                onBack = onBack || function () {
                    return App.nav.pop();
                };
                backButton = _react2.default.createElement(Doric.IconButton, { icon: 'ion-chevron-left', text: backText, className: 'doric-screen-back-button', onTap: onBack });
            }

            if (menu !== null) {
                menuButton = _react2.default.createElement(Doric.IconButton, { className: 'doric-screen-menu-button', icon: 'ion-navicon', onTap: _this.toggle, iconStyle: { fontSize: 28 } });
            }

            return _react2.default.createElement(
                'doric-screen',
                null,
                _react2.default.createElement(
                    'doric-screen-title',
                    null,
                    title,
                    backButton,
                    menuButton
                ),
                _react2.default.createElement(
                    'doric-screen-menu',
                    { visible: expanded },
                    _react2.default.createElement(
                        'div',
                        { style: { backgroundColor: '#4285f4', position: 'absolute', width: '100%' } },
                        menu
                    )
                ),
                _react2.default.createElement(
                    'doric-screen-content',
                    null,
                    _this.props.children
                )
            );
        };

        _this.state = { expanded: false };
        return _this;
    }

    return Screen;
}(_react2.default.Component);

exports.default = Screen;

},{"babel-runtime/core-js/object/get-prototype-of":290,"babel-runtime/helpers/classCallCheck":298,"babel-runtime/helpers/inherits":301,"babel-runtime/helpers/possibleConstructorReturn":303,"react":230,"source/util/app":268,"source/util/stylesheet":277}],257:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var find = Array.prototype.find;
_app2.default.addStyles({
    "doric-slider": {
        display: 'block',
        margin: 3
    },
    "doric-slider-content": {
        display: 'block',
        position: 'relative',
        top: 0,
        left: 0,
        height: 30,
        margin: 2
    },
    "doric-slider-track": {
        position: 'absolute',
        top: 13,
        left: 12,
        right: 12,
        height: 4,
        backgroundColor: _consts2.default.theme.grayBG,
        overflow: 'visible'
    },
    "doric-slider-track-fill": {
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        backgroundColor: _consts2.default.theme.bluish,
        transformOrigin: 'left center'
    },
    "doric-slider-thumb": {
        position: 'absolute',
        top: 2,
        width: 0,
        height: 0,
        overflow: 'visible'
    },
    "doric-slider-track-circle": {
        display: 'block',
        width: 20,
        height: 20,
        borderRadius: 15,
        backgroundColor: _consts2.default.theme.bluish,
        boxShadow: '1px 1px 1px rgba(0, 0, 0, 0.25)',
        transform: 'translate(-50%, -50%)'
    },
    "doric-slider-value": {
        position: 'absolute',
        width: 30,
        height: 20,
        fontSize: 10,
        textAlign: 'center',
        lineHeight: '20px',
        top: -35,
        left: -15,
        display: 'none',
        borderRadius: 3,
        overflow: 'hidden',
        backgroundColor: _consts2.default.theme.bluish,
        color: 'white',
        zIndex: '+1000'
    },
    "doric-slider-thumb[pressed] > doric-slider-value": {
        display: 'block'
    }
});
var clampNormal = function clampNormal(value) {
    return Math.min(1, Math.max(0, value));
};

var Slider = function (_React$Component) {
    (0, _inherits3.default)(Slider, _React$Component);

    function Slider(props) {
        (0, _classCallCheck3.default)(this, Slider);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Slider.__proto__ || (0, _getPrototypeOf2.default)(Slider)).call(this, props));

        _this.touchStart = function (evt) {
            if (_this.touchID !== null) {
                return;
            }

            var _evt$changedTouches = (0, _slicedToArray3.default)(evt.changedTouches, 1),
                touch = _evt$changedTouches[0];

            var track = _this.refs.track.getBoundingClientRect();
            var thumb = _this.refs.thumb.getBoundingClientRect();
            _this.range = track.width;
            _this.startPos = track.left;
            _this.startValue = thumb.left - track.left;
            _this.touchStartPos = touch.clientX;
            _this.touchID = touch.identifier;
        };

        _this.touchMove = function (evt) {
            var _context;

            var touch = (_context = evt.changedTouches, find).call(_context, function (touch) {
                return touch.identifier === _this.touchID;
            });
            if (touch === undefined) {
                return;
            }

            var _this$props = _this.props,
                _this$props$min = _this$props.min,
                min = _this$props$min === undefined ? 0 : _this$props$min,
                _this$props$max = _this$props.max,
                max = _this$props$max === undefined ? 10 : _this$props$max,
                _this$props$step = _this$props.step,
                step = _this$props$step === undefined ? 1 : _this$props$step,
                _this$props$onChange = _this$props.onChange,
                onChange = _this$props$onChange === undefined ? function () {} : _this$props$onChange,
                value = _this$props.value;

            var offset = touch.clientX - _this.touchStartPos;
            var pos = _this.startValue + offset;

            var range = max - min;
            var newValue = range * clampNormal(pos / _this.range) + min;

            newValue = Math.round(newValue / step) * step;

            if (newValue !== value) {
                onChange(newValue);
            }
        };

        _this.componentDidMount = function () {
            _this.refs.thumb.addEventListener('touchmove', function (evt) {
                evt.preventDefault();
            }, { passive: false, capture: true });
        };

        _this.render = function () {
            var _this$props2 = _this.props,
                _this$props2$min = _this$props2.min,
                min = _this$props2$min === undefined ? 0 : _this$props2$min,
                _this$props2$max = _this$props2.max,
                max = _this$props2$max === undefined ? 10 : _this$props2$max,
                _this$props2$value = _this$props2.value,
                value = _this$props2$value === undefined ? min : _this$props2$value,
                color = _this$props2.color,
                _this$props2$displayF = _this$props2.displayFunc,
                displayFunc = _this$props2$displayF === undefined ? function (i) {
                return i;
            } : _this$props2$displayF,
                _this$props2$label = _this$props2.label,
                label = _this$props2$label === undefined ? null : _this$props2$label;

            var pos = (value - min) / (max - min);
            var thumbStyle = {
                left: pos * 100 + '%'
            };
            var fillStyle = {
                transform: 'scaleX(' + pos + ')',
                backgroundColor: color
            };
            var labelElem = label !== null ? _react2.default.createElement(
                'div',
                null,
                label
            ) : null;

            var events = {
                onTouchStart: _this.touchStart,
                onTouchMove: _this.touchMove,
                onTouchEnd: function onTouchEnd() {
                    return _this.touchID = null;
                }
            };
            var thumb = _react2.default.createElement('doric-slider-track-circle', { 'data-no-press': true, style: { backgroundColor: color } });
            var valueDisplay = _react2.default.createElement(
                'doric-slider-value',
                { style: { backgroundColor: color } },
                displayFunc(value)
            );

            return _react2.default.createElement(
                'doric-slider',
                null,
                labelElem,
                _react2.default.createElement(
                    'doric-slider-content',
                    null,
                    _react2.default.createElement(
                        'doric-slider-track',
                        { ref: 'track' },
                        _react2.default.createElement('doric-slider-track-fill', { style: fillStyle }),
                        _react2.default.createElement(
                            'doric-slider-thumb',
                            (0, _extends3.default)({ ref: 'thumb', style: thumbStyle }, events),
                            thumb,
                            valueDisplay
                        )
                    )
                )
            );
        };

        _this.touchID = null;
        return _this;
    }

    return Slider;
}(_react2.default.Component);

exports.default = Slider;

},{"babel-runtime/core-js/object/get-prototype-of":290,"babel-runtime/helpers/classCallCheck":298,"babel-runtime/helpers/extends":300,"babel-runtime/helpers/inherits":301,"babel-runtime/helpers/possibleConstructorReturn":303,"babel-runtime/helpers/slicedToArray":304,"react":230,"source/component/CustomEvents":247,"source/util/app":268,"source/util/consts":270}],258:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

var _ContentAligners = require('source/component/ContentAligners');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "@keyframes spinner-rotate": {
        from: {
            transform: 'rotate(0)'
        },
        to: {
            transform: 'rotate(360deg)'
        }
    },
    "div.spinner": {
        position: 'relative'
    },
    "div.spinner .hex": {
        width: 22,
        height: 38,
        position: 'absolute',
        left: -11,
        top: -19
    },
    "div.spinner > div": {
        animationName: 'spinner-rotate',
        animationTimingFunction: 'ease-in-out',
        animationIterationCount: 'infinite',
        animationDuration: '2000ms'
    },
    "div.spinner > .outer": {
        animationDirection: 'reverse'
    },
    "div.spinner > .inner > .hex": {
        backgroundColor: 'white'
    },
    "div.spinner > .outer > .hex": {
        backgroundColor: _consts2.default.theme.bluish
    }
});
var Spinner = function Spinner() {
    return _react2.default.createElement(
        'doric-spinner',
        null,
        _react2.default.createElement(
            _ContentAligners.CenterContent,
            { width: 45, height: 45 },
            _react2.default.createElement(
                'div',
                { className: 'spinner' },
                _react2.default.createElement(
                    'div',
                    { className: 'outer' },
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(30deg)" } }),
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(90deg)" } }),
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(150deg)" } })
                ),
                _react2.default.createElement(
                    'div',
                    { className: 'inner' },
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(30deg) scale(0.5)" } }),
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(90deg) scale(0.5)" } }),
                    _react2.default.createElement('div', { className: 'hex', style: { transform: "rotate(150deg) scale(0.5)" } })
                )
            )
        )
    );
};

exports.default = Spinner;

},{"react":230,"source/component/ContentAligners":246,"source/util/app":268,"source/util/consts":270}],259:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _doricTabsTab;

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

var _Image = require('source/component/Image');

var _Image2 = _interopRequireDefault(_Image);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-tabs": {
        position: 'relative',
        top: 0,
        left: 0,
        display: 'block'
    },
    "doric-tabs-bar": {
        height: 35,
        display: 'block',
        position: 'absolute',
        top: 0,
        width: '100%',
        backgroundColor: '#4285f4'
    },
    "doric-tabs-tab": (_doricTabsTab = {
        position: 'relative',
        top: 0,
        left: 0,
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        height: '100%'
    }, (0, _defineProperty3.default)(_doricTabsTab, 'position', 'absolute'), (0, _defineProperty3.default)(_doricTabsTab, 'opacity', 0.6), (0, _defineProperty3.default)(_doricTabsTab, 'color', 'white'), _doricTabsTab),
    "doric-tabs-tab[selected]": {
        opacity: 1
    },
    "doric-tabs-tab[selected]::after": {
        content: '""',
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        height: 3,
        backgroundColor: '#ffae22'
    },
    "doric-tabs-content": {
        display: 'block',
        position: 'absolute',
        top: 35,
        bottom: 0,
        left: 0,
        right: 0
    },
    "doric-tabs-content-wrapper": {
        width: '100%',
        height: '100%',
        display: 'block',
        overflow: 'auto'
    }
});

var Tabs = function Tabs(props) {
    var _props$keepAlive = props.keepAlive,
        keepAlive = _props$keepAlive === undefined ? false : _props$keepAlive,
        _props$selectedIndex = props.selectedIndex,
        selectedIndex = _props$selectedIndex === undefined ? 0 : _props$selectedIndex,
        _props$height = props.height,
        height = _props$height === undefined ? 100 : _props$height,
        _props$unmountOnChang = props.unmountOnChange,
        unmountOnChange = _props$unmountOnChang === undefined ? false : _props$unmountOnChang;

    var children = React.Children.toArray(props.children);
    var onChange = props.onChange || function () {};
    var size = 100 / children.length;

    var tabs = children.map(function (tab, index) {
        var props = {
            selected: index === selectedIndex || null,
            style: {
                width: size + '%',
                left: size * index + '%'
            },
            onTap: function onTap(evt) {
                onChange(index);
            }
        };
        var tabTitle = tab.props.tabTitle;
        var tabIcon = tab.props.tabIcon || null;
        var tabImage = tab.props.tabImage || null;

        var tabContent = null;
        if (tabImage !== null) {
            tabContent = React.createElement(_Image2.default, { source: tabImage, width: '100%', height: '100%' });
        } else {
            tabContent = [React.createElement(
                'div',
                null,
                tabTitle
            )];
            if (tabIcon !== null) {
                tabContent.unshift(React.createElement(
                    'div',
                    { style: { padding: 3 } },
                    React.createElement(Doric.Icon, { icon: tabIcon })
                ));
            }
        }

        return React.createElement(
            Doric.CustomEvents,
            (0, _extends3.default)({ component: 'doric-tabs-tab' }, props),
            tabContent
        );
    });

    var displayChidren = null;
    if (unmountOnChange === false) {
        displayChidren = children.map(function (child, index) {
            var display = index === selectedIndex ? null : 'none';
            return React.createElement(
                'doric-tabs-content-wrapper',
                { style: { display: display }, key: index },
                child
            );
        });
    } else {
        displayChidren = React.createElement(
            'doric-tabs-content-wrapper',
            { key: selectedIndex },
            children[selectedIndex]
        );
    }

    return React.createElement(
        'doric-tabs',
        { style: { height: height } },
        React.createElement(
            'doric-tabs-bar',
            null,
            tabs
        ),
        React.createElement(
            'doric-tabs-content',
            null,
            displayChidren
        )
    );
};

exports.default = Tabs;

},{"babel-runtime/helpers/defineProperty":299,"babel-runtime/helpers/extends":300,"source/component/CustomEvents":247,"source/component/Image":252,"source/util/app":268}],260:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

var _stylesheet = require('source/util/stylesheet');

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

var _ContentAligners = require('source/component/ContentAligners');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-toggle": {
        display: 'block',
        position: 'relative',
        userSelect: 'none'
    },
    "doric-toggle[disabled='true']": {
        color: 'gray',
        opacity: 0.6
    },
    "doric-toggle:after": {
        content: "''",
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        transition: _consts2.default.css.backgroundTransition
    },
    "doric-toggle[pressed]:not([disabled='true']):after": {
        backgroundColor: _stylesheet.CSS.rgba(0, 0, 0, 0.25),
        transition: 'none'
    },
    "doric-toggle-switch": {
        width: 36,
        height: 14,
        borderRadius: 7,
        backgroundColor: _consts2.default.theme.grayBG,
        position: 'relative',
        transition: 'background-color 50ms linear'
    },
    "doric-toggle:not([disabled='true']) doric-toggle-switch[on='true']": {
        backgroundColor: '#b3cefb'
    },
    "doric-toggle-switch:after": {
        content: "''",
        boxShadow: '2px 2px 2px rgba(0, 0, 0, 0.25)',
        position: 'absolute',
        top: -3,
        left: -1,
        width: 20,
        height: 20,
        borderRadius: 11,
        backgroundColor: 'gray',
        transition: 'transform 50ms linear, background-color 50ms linear'
    },
    "doric-toggle-switch[on='true']:after": {
        transform: 'translateX(18px)'
    },
    "doric-toggle:not([disabled='true']) doric-toggle-switch[on='true']:after": {
        backgroundColor: _consts2.default.theme.bluish
    }
});
var Toggle = function Toggle(props) {
    var _ref;

    var _props$on = props.on,
        on = _props$on === undefined ? false : _props$on,
        label = props.label,
        children = props.children,
        _props$side = props.side,
        side = _props$side === undefined ? 'left' : _props$side,
        _props$style = props.style,
        style = _props$style === undefined ? {} : _props$style,
        _props$className = props.className,
        className = _props$className === undefined ? "" : _props$className,
        _props$onChange = props.onChange,
        onChange = _props$onChange === undefined ? warningFunc("Toggle has no change function") : _props$onChange,
        passThrough = (0, _objectWithoutProperties3.default)(props, ['on', 'label', 'children', 'side', 'style', 'className', 'onChange']);

    var change = function change() {
        if (props.disabled !== true) {
            onChange(on === false);
        }
    };
    var padding = (0, _defineProperty3.default)({
        padding: 5
    }, 'padding' + side.charAt(0).toUpperCase() + side.slice(1), 45);

    return _react2.default.createElement(
        _CustomEvents2.default,
        (0, _extends3.default)({ component: 'doric-toggle', on: on, style: (0, _extends3.default)({}, style, padding), onTap: change, 'class': className }, passThrough),
        _react2.default.createElement(
            _ContentAligners.CenterContent,
            { 'data-no-press': true, style: (_ref = {}, (0, _defineProperty3.default)(_ref, side, 0), (0, _defineProperty3.default)(_ref, 'top', 0), (0, _defineProperty3.default)(_ref, 'position', 'absolute'), _ref), width: 45, height: '100%' },
            _react2.default.createElement('doric-toggle-switch', { on: on, 'data-no-press': true })
        ),
        label,
        children
    );
};
Toggle.formValue = "on";

exports.default = Toggle;

},{"babel-runtime/helpers/defineProperty":299,"babel-runtime/helpers/extends":300,"babel-runtime/helpers/objectWithoutProperties":302,"react":230,"source/component/ContentAligners":246,"source/component/CustomEvents":247,"source/util/app":268,"source/util/consts":270,"source/util/stylesheet":277}],261:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

var _theme = require('source/util/theme');

var _theme2 = _interopRequireDefault(_theme);

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_app2.default.addStyles({
    "doric-button": {
        display: ['-webkit-inline-flex', 'inline-flex'],
        color: _theme2.default.button.text.color,
        padding: '0.7em 0.5em',
        alignItems: 'center',
        justifyContent: 'center',
        position: 'relative',
        userSelect: 'none',
        borderRadius: 3,
        borderWidth: 0,
        overflow: 'hidden',
        verticalAlign: 'top',
        margin: 5
    },
    "doric-button:after": {
        content: '""',
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        transition: 'background-color 250ms linear'
    },
    "doric-button[pressed]:not([disabled]):after": {
        backgroundColor: 'rgba(0, 0, 0, 0.25)',
        transition: 'none'
    },

    "doric-button[disabled]": {
        boxShadow: 'none',
        backgroundColor: '#e6e6e6',
        color: '#808080'
    },
    "doric-button[raised]": {
        boxShadow: _theme2.default.general.boxShadow
    }
});
var Button = function Button(props) {
    var _props$text = props.text,
        text = _props$text === undefined ? null : _props$text,
        children = props.children,
        _props$className = props.className,
        className = _props$className === undefined ? "" : _props$className,
        passThrough = (0, _objectWithoutProperties3.default)(props, ['text', 'children', 'className']);

    var passedOnTap = passThrough.onTap || function () {};

    passThrough.onTap = function (evt) {
        if (passThrough.disabled !== true) {
            passedOnTap(evt);
        }
    };

    return _react2.default.createElement(
        _CustomEvents2.default,
        (0, _extends3.default)({ component: 'doric-button' }, passThrough, { 'class': className }),
        text,
        children
    );
};

exports.default = Button;

},{"babel-runtime/helpers/extends":300,"babel-runtime/helpers/objectWithoutProperties":302,"react":230,"source/component/CustomEvents":247,"source/util/app":268,"source/util/theme":278}],262:[function(require,module,exports){
module.exports = "data:application/font-woff;base64,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u8LuSsJP+OywsMPCDgs7LOywsMPCDgs7LIIv+OyysMvCLgu7LOyyCL7gC77gV+FX4VfhV+FX4VfhV+FX4VfhV+FX4VfhV+FX4VfhV+HX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfg1+DX4Nfh1+HX4dfh1+HX4dfh1+HX4dfh1+HX4dfh1+E3eU+T9zR5T5P3NHlPk/c0eU+T9zTHvIfv0eR7tPgeLb5Hi+/R4nu0+B4t+C34Lfgt+C34Lfgt+C34Lfgt+C34bfht+G34bfht+G34bfht+G34bfht+G04bTgdOB04HTgdOB04HTgd3t/hvR3e2+XzXT7f5fNdPt/lc11+ry6f7/L9e/wePT7X43M9/l6Pf7ce/259/n6fv9fn9+vz79CH14fXH/O5f3mJ/xP/J55PPJ94PvF64u/E34m/E38n/k78nfg78Xfi78Tfib8TbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW4m3Em8l3kq8lXgr8VbircRbibcSbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW4m3Em8l3kq8lXgr8VbircRbibcSbyXeSryVeCvxVuKtxFuJtxJvJd5KvJV4K/FW4q3EW1mHX4ffgN+A34DfgN+A34DfgN+A34DfgN+A34DfgN+A34DfgN+E34TfhN+E34SPbxPfJr5NfJv4NvFt4tvEt4lvE98mvk18m/g28W3i28S3iW8T3ya+TXyb+DbxbeLbxLeJbxPfJr5NfJv4NvFt4tvEt4lvE98mvk18m/g28W224bfht+Hj4cTDiYcTDyceTjyceDjxcHbg4+PswMfLiZezA78DvwO/A78DvwsfjyceTzyeeDy78Lvw8Xri9cTr2YXfhd+Fj++zC78LH/9nD34PPj1IepA9+D34Pfg9+PQie/DpRtKN7MHvwe/BpyfZh9+H34dPZ5LOJJ1JOpN0JrlbkrsluVuS/uSY/nC3JHeLuFvE3SLuFnG3iLtFdEt0S9wt4m4Rd4vomeiZ6Jm4W8TdIvom7hZxt4i7RXRPdE90T3RPdE90T3RPdE90T3RPdE/cLeJuEXeLuFvE3SLuFnG3iLtF3C3ibhF3i7hbxN0i7hZxt4i7Rdwt4m4Rd4u4W8TdIu4WcbeIu0XcLeJuEXeLuFvE3SLuFnG3iLtF3C2i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/6L/ov+i/+rX/wHuf9d/AAAAAAAB//8AAnjaY2BgYGQAgjO2i86D6AvLjCdB6SkAS/0G9AA=";

},{}],263:[function(require,module,exports){
module.exports = "data:application/font-woff;base64,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";

},{}],264:[function(require,module,exports){
module.exports = "data:image/gif;base64,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";

},{}],265:[function(require,module,exports){
'use strict';

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _icons = require('source/util/icons');

var _icons2 = _interopRequireDefault(_icons);

var _utils = require('source/util/utils');

var _consts = require('source/util/consts');

var _consts2 = _interopRequireDefault(_consts);

var _env = require('source/util/env');

var _env2 = _interopRequireDefault(_env);

var _ajax = require('source/util/ajax');

var _ajax2 = _interopRequireDefault(_ajax);

var _filesys = require('source/util/filesys');

var _filesys2 = _interopRequireDefault(_filesys);

require('source/util/chrono');

require('source/util/gesture');

require('source/util/deviceready');

require('source/util/settings');

require('source/util/api');

require('source/component/Dialog');

var _theme = require('source/util/theme');

var _theme2 = _interopRequireDefault(_theme);

var _BackgroundImage = require('source/component/BackgroundImage');

var _BackgroundImage2 = _interopRequireDefault(_BackgroundImage);

var _Button = require('source/component/Button');

var _Button2 = _interopRequireDefault(_Button);

var _Card = require('source/component/Card');

var _Card2 = _interopRequireDefault(_Card);

var _ContentAligners = require('source/component/ContentAligners');

var _Checkbox = require('source/component/Checkbox');

var _Checkbox2 = _interopRequireDefault(_Checkbox);

var _CustomEvents = require('source/component/CustomEvents');

var _CustomEvents2 = _interopRequireDefault(_CustomEvents);

var _Form = require('source/component/Form');

var _Form2 = _interopRequireDefault(_Form);

var _Grid = require('source/component/Grid');

var _Grid2 = _interopRequireDefault(_Grid);

var _Icon = require('source/component/Icon');

var _Image = require('source/component/Image');

var _Image2 = _interopRequireDefault(_Image);

var _Input = require('source/component/Input');

var _Input2 = _interopRequireDefault(_Input);

var _Pinboard = require('source/component/Pinboard');

var _Pinboard2 = _interopRequireDefault(_Pinboard);

var _Progress = require('source/component/Progress');

var _Progress2 = _interopRequireDefault(_Progress);

var _Screen = require('source/component/Screen');

var _Screen2 = _interopRequireDefault(_Screen);

var _Slider = require('source/component/Slider');

var _Slider2 = _interopRequireDefault(_Slider);

var _Spinner = require('source/component/Spinner');

var _Spinner2 = _interopRequireDefault(_Spinner);

var _Tabs = require('source/component/Tabs');

var _Tabs2 = _interopRequireDefault(_Tabs);

var _Toggle = require('source/component/Toggle');

var _Toggle2 = _interopRequireDefault(_Toggle);

var _stylesheet = require('source/util/stylesheet');

var _app = require('source/util/app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.Doric = {
    BackgroundImage: _BackgroundImage2.default,
    Button: _Button2.default,
    Card: _Card2.default,
    CenterContent: _ContentAligners.CenterContent,
    AlignContent: _ContentAligners.AlignContent,
    Checkbox: _Checkbox2.default,
    CustomEvents: _CustomEvents2.default,
    Form: _Form2.default,
    Grid: _Grid2.default,
    Icon: _Icon.Icon,
    IconButton: _Icon.IconButton,
    Image: _Image2.default,
    Input: _Input2.default,
    Pinboard: _Pinboard2.default,
    Progress: _Progress2.default,
    Screen: _Screen2.default,
    Slider: _Slider2.default,
    Spinner: _Spinner2.default,
    Tabs: _Tabs2.default,
    Toggle: _Toggle2.default
};
window.React = _react2.default;
window.ReactDOM = _reactDom2.default;
window.DoricUtil = {
    CSS: _stylesheet.CSS,
    warningFunc: _utils.warningFunc,
    Env: _env2.default
};

window.ajax = _ajax2.default;
window.fs = _filesys2.default;

Math.rand = function (a) {
    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (b === null) {
        b = a;
        a = 0;
    }
    return Math.floor(Math.random() * (b - a + 1)) + a;
};

window.cblog = console.log.bind(console);
window.cberr = console.error.bind(console);

},{"react":230,"react-dom":29,"source/component/BackgroundImage":242,"source/component/Button":243,"source/component/Card":244,"source/component/Checkbox":245,"source/component/ContentAligners":246,"source/component/CustomEvents":247,"source/component/Dialog":248,"source/component/Form":249,"source/component/Grid":250,"source/component/Icon":251,"source/component/Image":252,"source/component/Input":253,"source/component/Pinboard":254,"source/component/Progress":255,"source/component/Screen":256,"source/component/Slider":257,"source/component/Spinner":258,"source/component/Tabs":259,"source/component/Toggle":260,"source/util/ajax":266,"source/util/api":267,"source/util/app":268,"source/util/chrono":269,"source/util/consts":270,"source/util/deviceready":271,"source/util/env":272,"source/util/filesys":273,"source/util/gesture":274,"source/util/icons":275,"source/util/settings":276,"source/util/stylesheet":277,"source/util/theme":278,"source/util/utils":279}],266:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require("babel-runtime/core-js/object/entries");

var _entries2 = _interopRequireDefault(_entries);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ajax = function ajax(url) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new _promise2.default(function (resolve, reject) {
        var _options$headers = options.headers,
            headers = _options$headers === undefined ? {} : _options$headers,
            _options$timeout = options.timeout,
            timeout = _options$timeout === undefined ? 0 : _options$timeout,
            _options$type = options.type,
            type = _options$type === undefined ? null : _options$type,
            _options$onProgress = options.onProgress,
            onProgress = _options$onProgress === undefined ? function () {} : _options$onProgress,
            _options$token = options.token,
            token = _options$token === undefined ? null : _options$token;

        var request = new XMLHttpRequest();
        var _options$post = options.post,
            post = _options$post === undefined ? null : _options$post;


        var contentType = null;
        var method = void 0;

        if (token !== null && token.used === false) {
            token.bindTo(request);
        }

        if (post === null) {
            method = 'GET';
        } else {
            method = "POST";
            if (FormData.prototype.isPrototypeOf(post) === false) {
                post = (0, _stringify2.default)(post);
                contentType = "application/json";
            }
        }

        if (type !== null) {
            request.responseType = type;
        }

        request.addEventListener('load', function () {
            if (request.status === 0 || request.status >= 200 && request.status < 300) {
                resolve({
                    status: request.status,
                    statusText: request.statusText,
                    response: request.response,
                    request: request
                });
            } else {
                reject(request);
            }
        });
        request.addEventListener("error", reject);
        request.addEventListener("timeout", reject);
        request.addEventListener("abort", function () {
            return resolve(null);
        });
        request.addEventListener("progress", onProgress);

        try {
            request.open(method, url, true);
            request.timeout = timeout;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)((0, _entries2.default)(headers)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _step$value = (0, _slicedToArray3.default)(_step.value, 2),
                        header = _step$value[0],
                        value = _step$value[1];

                    request.setRequestHeader(header, value);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            request.setRequestHeader("Accept", "");
            request.setRequestHeader("Accept", "*/*");
            if (contentType !== null) {
                request.setRequestHeader("Content-Type", contentType);
            }
            request.send(post);
        } catch (error) {
            reject(error);
        }
    });
};

ajax.cancelToken = function () {
    var request = null;

    return {
        cancel: function cancel() {
            if (request !== null) {
                request.abort();
            }
        },

        get used() {
            return request !== null;
        },
        bindTo: function bindTo(req) {
            if (request === null) {
                request = req;
            }
        }
    };
};

exports.default = ajax;

},{"babel-runtime/core-js/get-iterator":281,"babel-runtime/core-js/json/stringify":283,"babel-runtime/core-js/object/entries":288,"babel-runtime/core-js/promise":294,"babel-runtime/helpers/slicedToArray":304}],267:[function(require,module,exports){
"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

require("source/util/app");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

App.API = function (baseURL) {
    return {
        request: function request(url, options) {
            return ajax("" + baseURL + url, options);
        },
        requestJSON: function requestJSON(url, options) {
            var _this = this;

            return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
                var result;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return ajax("" + baseURL + url, options);

                            case 2:
                                result = _context.sent;

                                if (!(result === null)) {
                                    _context.next = 5;
                                    break;
                                }

                                return _context.abrupt("return", null);

                            case 5:
                                return _context.abrupt("return", JSON.parse(result.response));

                            case 6:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, _this);
            }))();
        },

        getURL: function getURL(url) {
            return "" + baseURL + url;
        }
    };
};

},{"babel-runtime/helpers/asyncToGenerator":297,"babel-runtime/regenerator":307,"source/util/app":268}],268:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactRouter = require('react-router');

var _stylesheet = require('source/util/stylesheet');

var _robotoLightWoff = require('source/data-uri/roboto-light.woff.source');

var _robotoLightWoff2 = _interopRequireDefault(_robotoLightWoff);

var _ioniconsWoff = require('source/data-uri/ionicons.woff.source');

var _ioniconsWoff2 = _interopRequireDefault(_ioniconsWoff);

require('source/util/deviceready');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var head = document.querySelector("head");
var roboto = document.createElement("style");
var appStyle = document.createElement("style");
var fonts = new _set2.default();

var componentStyleSheet = (0, _stylesheet.createStyleSheet)();
var initCalled = false;
var routes = _react2.default.createElement(_reactRouter.Route, { path: '/', component: function component() {
        return _react2.default.createElement(
            'div',
            null,
            'Ready!'
        );
    } });
var routerComponent = void 0;

roboto.setAttribute("data-name", "doric-core-style");
head.appendChild(roboto);

appStyle.setAttribute("data-name", "doric-app-style");
head.appendChild(appStyle);

var initialize = function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
        var wrapper;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        if (!(initCalled === true)) {
                            _context.next = 2;
                            break;
                        }

                        return _context.abrupt('return');

                    case 2:

                        initCalled = true;
                        _context.next = 5;
                        return deviceReady;

                    case 5:
                        wrapper = _react2.default.createElement(
                            _reactRouter.Router,
                            { history: _reactRouter.hashHistory },
                            _react2.default.createElement(_reactRouter.Route, { getChildRoutes: function getChildRoutes(location, load) {
                                    return load(null, routes);
                                } })
                        );

                        document.body.innerHTML = '<div id="app-container" style="position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; overflow: hidden"></div>';
                        componentStyleSheet.__init(roboto);
                        routerComponent = _reactDom2.default.render(wrapper, document.querySelector("#app-container"));

                    case 9:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, undefined);
    }));

    return function initialize() {
        return _ref.apply(this, arguments);
    };
}();
var navReplace = function navReplace(url) {
    return routerComponent.router.replace(url);
};
var navPush = function navPush(url) {
    return routerComponent.router.push(url);
};
var navPop = function navPop() {
    return routerComponent.router.goBack();
};

window.Route = _reactRouter.Route;
window.App = {
    start: function start(appRoutes) {
        var _this = this;

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
            return _regenerator2.default.wrap(function _callee2$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            _context2.next = 2;
                            return initialize();

                        case 2:
                            routes = appRoutes;
                            navReplace("/");
                            App.styleSheet.__init(appStyle);
                            App.styleSheet = (0, _stylesheet.createStyleSheet)();

                        case 6:
                        case 'end':
                            return _context2.stop();
                    }
                }
            }, _callee2, _this);
        }))();
    },
    addFont: function addFont(name, def) {
        if (fonts.has(name) === true) {
            return;
        }
        var elem = document.createElement("style");

        fonts.add(name);
        elem.dataset.fontName = name;
        elem.innerHTML = (0, _stylesheet.genCSS)({ "@font-face": def });

        head.appendChild(elem);
    },

    styleSheet: (0, _stylesheet.createStyleSheet)(),
    nav: {
        push: navPush,
        pop: navPop,
        replace: navReplace
    }
};

componentStyleSheet.addStyles({
    "*": {
        boxSizing: 'border-box'
    },
    "html, body": {
        width: '100%',
        height: '100%',
        padding: 0,
        margin: 0
    },
    body: {
        fontFamily: "Roboto",
        backgroundColor: '#f5f5f5'
    }
});
App.addFont('roboto', {
    fontFamily: '"Roboto"',
    src: 'url("' + _robotoLightWoff2.default + '") format("woff")',
    fontWeight: "normal",
    fontStyle: "normal"
});
App.addFont('ionic', {
    fontFamily: '"Ionic"',
    src: 'url("' + _ioniconsWoff2.default + '") format("woff")',
    fontWeight: "normal",
    fontStyle: "normal"
});

exports.default = componentStyleSheet;

},{"babel-runtime/core-js/set":295,"babel-runtime/helpers/asyncToGenerator":297,"babel-runtime/regenerator":307,"react":230,"react-dom":29,"react-router":182,"source/data-uri/ionicons.woff.source":262,"source/data-uri/roboto-light.woff.source":263,"source/util/deviceready":271,"source/util/stylesheet":277}],269:[function(require,module,exports){
'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _xregexp = require('xregexp');

var _xregexp2 = _interopRequireDefault(_xregexp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var chronoSpecial = {
    'yesterday': function yesterday(date) {
        date.setDate(date.getDate() - 1);
        return date;
    },
    '1 week ago': function weekAgo(date) {
        date.setDate(date.getDate() - 7);
        return date;
    }
};
var chronoUnitRegex = (0, _xregexp2.default)("(?<offset>(\\+|\\-)\\d+) (?<unit>\\w+)");
var unitFunction = {
    millisecond: function millisecond(date, milliseconds) {
        date.setMilliseconds(date.getMilliseconds() + milliseconds);
        return date;
    },
    second: function second(date, seconds) {
        date.setSeconds(date.getSeconds() + seconds);
        return date;
    },
    minute: function minute(date, minutes) {
        date.setMinutes(date.getMinutes() + minutes);
        return date;
    },
    hour: function hour(date, hours) {
        date.setHours(date.getHours() + hours);
        return date;
    },
    day: function day(date, days) {
        date.setDate(date.getDate() + days);
        return date;
    },
    week: function week(date, weeks) {
        date.setDate(date.getDate() + weeks * 7);
        return date;
    },
    month: function month(date, months) {
        var expected = date.getMonth() + months;
        date.setMonth(expected);
        if (date.getMonth() !== expected) {
            date.setDate(0);
        }
        return date;
    },
    year: function year(date, years) {
        date.setFullYear(date.getFullYear() + years);
        return date;
    },
    decade: function decade(date, decades) {
        date.setFullYear(date.getFullYear() + decades * 10);
        return date;
    }
};
var _startOf = {
    second: function second(date) {
        date.setMilliseconds(0);
    },
    minute: function minute(date) {
        _startOf.second(date);
        date.setSeconds(0);
    },
    hour: function hour(date) {
        _startOf.minute(date);
        date.setMinutes(0);
    },
    day: function day(date) {
        _startOf.hour(date);
        date.setHours(0);
    },
    week: function week(date) {
        _startOf.day(date);
        date.setDate(date.getDate() - date.getDay());
    },
    month: function month(date) {
        _startOf.day(date);
        date.setDate(1);
    },
    year: function year(date) {
        _startOf.month(date);
        date.setMonth(0);
    }
};
var _endOf = {
    second: function second(date) {
        date.setMilliseconds(999);
    },
    minute: function minute(date) {
        _endOf.second(date);
        date.setSeconds(59);
    },
    hour: function hour(date) {
        _endOf.minute(date);
        date.setMinutes(59);
    },
    day: function day(date) {
        _endOf.hour(date);
        date.setHours(23);
    },
    week: function week(date) {
        _endOf.day(date);
        date.setDate(date.getDate() + (6 - date.getDay()));
    },
    month: function month(date) {
        _endOf.day(date);
        date.setMonth(date.getMonth() + 1);
        date.setDate(0);
    },
    year: function year(date) {
        _endOf.month(date);
        date.setMonth(11);
    }
};
var unitConversion = {
    'millisecond': 'millisecond',
    'milliseconds': 'millisecond',
    'ms': 'millisecond',

    'second': 'second',
    'seconds': 'second',
    's': 'second',

    'minute': 'minute',
    'minutes': 'minute',
    'min': 'minute',

    'hour': 'hour',
    'hours': 'hour',
    'hr': 'hour',

    'day': 'day',
    'days': 'day',
    'ni': 'day',
    'hi': 'day',
    '': 'day',

    'week': 'week',
    'weeks': 'week',
    'shuu': 'week',
    '': 'week',
    '': 'week',

    'month': 'month',
    'months': 'month',

    'year': 'year',
    'years': 'year',

    'decade': 'decade',
    'decades': 'decade'
};
var chronoInfo = {
    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var chronoFormat = {
    ms: {
        base: function base(date) {
            return date.getMilliseconds();
        },
        padded: function padded(date) {
            return ('00' + date.getMilliseconds()).slice(-3);
        }
    },
    second: {
        base: function base(date) {
            return date.getSeconds();
        },
        padded: function padded(date) {
            return ('0' + date.getSeconds()).slice(-2);
        }
    },
    minute: {
        base: function base(date) {
            return date.getMinutes();
        },
        padded: function padded(date) {
            return ('0' + date.getMinutes()).slice(-2);
        }
    },
    hour: {
        base: function base(date) {
            return date.getHours();
        },
        padded: function padded(date) {
            return ('0' + date.getHours()).slice(-2);
        },
        "12": function _(date) {
            var hour = date.getHours() % 12;
            if (hour === 0) {
                return 12;
            }
            return hour;
        },
        "12padded": function padded(date) {
            return ('0' + chronoFormat.hour['12'](date)).slice(-2);
        }
    },
    weekday: {
        base: function base(date) {
            return date.getDay();
        },
        short: function short(date) {
            return chronoInfo.days[date.getDay()].slice(0, 3);
        },
        full: function full(date) {
            return chronoInfo.days[date.getDay()];
        }
    },
    date: {
        base: function base(date) {
            return date.getDate();
        },
        padded: function padded(date) {
            return ('0' + date.getDate()).slice(-2);
        }
    },
    month: {
        base: function base(date) {
            return date.getMonth() + 1;
        },
        short: function short(date) {
            return chronoInfo.months[date.getDate()].slice(0, 3);
        },
        full: function full(date) {
            return chronoInfo.months[date.getDate()];
        }
    },
    year: {
        base: function base(date) {
            return date.getFullYear() % 100;
        },
        full: function full(date) {
            return date.getFullYear();
        }
    },
    tod: {
        base: function base(date) {
            return date.getHours() < 12 === true ? "AM" : "PM";
        }
    }
};
chronoFormat.day = chronoFormat.date;
var chronoCheckUnit = function chronoCheckUnit(unit) {
    if (unitConversion.hasOwnProperty(unit) === false) {
        throw new Error('Unrecognized unit: ' + unit);
    }
};

/* -AxelDoc-
module global {
    @function chrono {
        @desc Creates a new instance of {chrono}.
        @args {
            @arg dateTime [Date]
                This is some long description of the thing
                {year, month} destructuring?
                [title]year[title]
        }
        @return chrono

        @function diff {
            @desc A function that will calculate the amount of time to add to the first argument in order to get the second argument.
            @args {
                @arg startDate [chrono] The date to start from.
                @arg targetDate [chrono] The date to get to.
            }
            @return object
        }
        @function now {
            @desc Returns the current date as a chrono object.
            @args {}
            @return chrono
        }
        @function parse {
            @desc Parses a date string and returns the chrono object represented by it.
            @args {
                @arg dateString [string] The string to parse.
            }
            @return chrono
        }
        @function parseMS {
            @desc Parses a date string generated by C# code and returns the chrono object represented by it.
            @args {
                @arg dateString [string] The string to parse.
            }
            @return chrono
        }
        @function trigger {
            @desc Fires a function after a specified time.
            @args {
                @arg delay [number] The number of milliseconds to wait.
                @arg func [function] The function to call.
            }
            @return chronoTrigger
        }
    }

    object chrono {
        @prop dateObject {
            @desc Gets a copy of the internal Date object.
            @type Date
        }

        @prop unixTimestamp {
            @desc Gets the unix timestamp of the chrono object.
            @type number
        }

        @prop milliseconds {
            @desc Gets the milliseconds of the chrono object.
            @type number
        }
        @prop seconds {
            @desc Gets the seconds of the chrono object.
            @type number
        }
        @prop minutes {
            @desc Gets the minutes of the chrono object.
            @type number
        }
        @prop hours {
            @desc Gets the hours of the chrono object.
            @type number
        }
        @prop weekday {
            @desc Gets the weekday of the chrono object.
            @type number
        }
        @prop date {
            @desc Gets the date of the chrono object. This number is adjusted to the range (0-30) unlike the normal Date object.
            @type number
        }
        @prop months {
            @desc Gets the months of the chrono object.
            @type number
        }
        @prop year {
            @desc Gets the year of the chrono object.
            @type number
        }

        @function shift {
            @desc Shifts the date forward or backward in time.
            @args {
                @arg offset [Number] The amount of time to shift the date.
                @arg unit [String] The units to shift by. Valid values are: 'second', 'minute', 'hour', 'day', 'week', 'month', 'year', 'decade'.
            }
            @args {
                @arg duration [object] An object that will shift the date.
            }
            @return chrono
        }
        @function startOf {
            @desc Moves the date to the start of the specified unit.
            @args {
                @arg unit [string] The unit to move to the start of. Valid values are: 'second', 'minute', 'hour', 'day', 'week', 'month', 'year'.
            }
            @return chrono
        }
        @function format {
            @desc Formats the chrono object using the specified string.
            @args {
                @arg format [string] The string describing the format the date should be put into.
            }
            @return string
        }
    }

    object chronoTrigger {
        @prop status {
            @desc The status of the trigger.
            @type string
        }

        @function cancel {
            @desc Cancels the trigger if it hasn't fired yet.
        }
    }
}
*/
var chrono = function chrono() {
    var arg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    var internalDate = function () {
        if (arg === null) {
            return new Date();
        }

        if (Date.prototype.isPrototypeOf(arg) === true || typeof arg === 'number') {
            return new Date(arg);
        }

        if (arg.__chrono === true) {
            return arg.dateObject;
        }

        if (typeof arg === 'string') {
            arg = arg.toLowerCase();
            if (chronoSpecial.hasOwnProperty(arg) === true) {
                return chronoSpecial[arg](new Date());
            }

            var match = _xregexp2.default.exec(arg, chronoUnitRegex);
            if (match !== null) {
                var offset = match.offset,
                    unit = match.unit;


                chronoCheckUnit(unit);

                return unitFunction[unitConversion[unit]](new Date(), parseInt(offset));
            }

            return new Date(arg);
        }

        var _arg = arg,
            _arg$year = _arg.year,
            year = _arg$year === undefined ? 1970 : _arg$year,
            _arg$month = _arg.month,
            month = _arg$month === undefined ? 0 : _arg$month,
            _arg$date = _arg.date,
            date = _arg$date === undefined ? 0 : _arg$date,
            _arg$hours = _arg.hours,
            hours = _arg$hours === undefined ? 0 : _arg$hours,
            _arg$minutes = _arg.minutes,
            minutes = _arg$minutes === undefined ? 0 : _arg$minutes,
            _arg$seconds = _arg.seconds,
            seconds = _arg$seconds === undefined ? 0 : _arg$seconds,
            _arg$milliseconds = _arg.milliseconds,
            milliseconds = _arg$milliseconds === undefined ? 0 : _arg$milliseconds;

        return new Date(year, month, date + 1, hours, minutes, seconds, milliseconds);
    }();

    return {
        __chrono: true,
        get dateObject() {
            return new Date(internalDate);
        },
        get unixTimestamp() {
            return internalDate.getTime();
        },

        get milliseconds() {
            return internalDate.getMilliseconds();
        },
        get seconds() {
            return internalDate.getSeconds();
        },
        get minutes() {
            return internalDate.getMinutes();
        },
        get hours() {
            return internalDate.getHours();
        },
        get weekday() {
            return internalDate.getDay();
        },
        get date() {
            return internalDate.getDate() - 1;
        },
        get month() {
            return internalDate.getMonth();
        },
        get year() {
            return internalDate.getFullYear();
        },

        set: function set(props) {
            var _props$year = props.year,
                year = _props$year === undefined ? internalDate.getFullYear() : _props$year,
                _props$month = props.month,
                month = _props$month === undefined ? internalDate.getMonth() : _props$month,
                _props$date = props.date,
                date = _props$date === undefined ? internalDate.getDate() - 1 : _props$date,
                _props$hours = props.hours,
                hours = _props$hours === undefined ? internalDate.getHours() : _props$hours,
                _props$minutes = props.minutes,
                minutes = _props$minutes === undefined ? internalDate.getMinutes() : _props$minutes,
                _props$seconds = props.seconds,
                seconds = _props$seconds === undefined ? internalDate.getSeconds() : _props$seconds,
                _props$milliseconds = props.milliseconds,
                milliseconds = _props$milliseconds === undefined ? internalDate.getMilliseconds() : _props$milliseconds;


            return chrono(new Date(year, month, date + 1, hours, minutes, seconds, milliseconds));
        },
        shift: function shift(offset, unit) {
            var newDate = void 0;
            newDate = new Date(internalDate);

            if ((typeof offset === 'undefined' ? 'undefined' : (0, _typeof3.default)(offset)) === 'object') {
                // if (offset.hasOwnProperty('__chrono_duration') && offset.__chrono_duration === true) {
                //     offset = offset.asObject();
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = (0, _getIterator3.default)((0, _entries2.default)(offset)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = (0, _slicedToArray3.default)(_step.value, 2),
                            _unit = _step$value[0],
                            value = _step$value[1];

                        chronoCheckUnit(_unit);
                        newDate = unitFunction[unitConversion[_unit]](newDate, value);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return chrono(newDate);
            } else {
                if (typeof offset === 'string') {
                    var match = _xregexp2.default.exec(offset, chronoUnitRegex);

                    offset = match.offset;
                    unit = match.unit;

                    chronoCheckUnit(unit);
                    offset = parseInt(offset);
                }

                return chrono(unitFunction[unitConversion[unit]](newDate, offset));
            }
        },
        startOf: function startOf(unit) {
            var adjustedDate = new Date(internalDate);

            _startOf[unit](adjustedDate);

            return chrono(adjustedDate);
        },
        endOf: function endOf(unit) {
            var adjustedDate = new Date(internalDate);

            _endOf[unit](adjustedDate);

            return chrono(adjustedDate);
        },
        format: function format() {
            var formatString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            if (formatString === null) {
                return internalDate.toString();
            }

            if (formatString === 'utc') {
                return internalDate.toUTCString();
            }
            if (formatString === 'locale') {
                return internalDate.toLocaleString();
            }

            return formatString.replace(/\{(\w+)(\/(\w+))?\}/g, function (full, prop, skip) {
                var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'base';
                return chronoFormat[prop][type](internalDate);
            });
        },
        toString: function toString() {
            return internalDate.toString();
        },
        toJSON: function toJSON() {
            // return internalDate.toJSON();
            return "{month}-{day}-{year/full} {hour/padded}:{minute/padded}:{second/padded}".replace(/\{(\w+)(\/(\w+))?\}/g, function (full, prop, skip) {
                var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'base';
                return chronoFormat[prop][type](internalDate);
            });
        }
    };
};
chrono.diff = function (first, second) {
    var internalDate = new Date(second.unixTimestamp - first.unixTimestamp);
    console.log(second.unixTimestamp - first.unixTimestamp);
    console.log(internalDate);

    return {
        milliseconds: internalDate.getMilliseconds(),
        seconds: internalDate.getSeconds(),
        minutes: internalDate.getMinutes(),
        hours: internalDate.getHours(),
        days: internalDate.getDate() - 1,
        months: internalDate.getMonth(),
        years: internalDate.getFullYear() - 1970
    };
};
chrono.now = function () {
    return chrono(Date.now());
};
chrono.parse = function (string) {
    return chrono(Date.parse(string));
};
chrono.parseMS = function (string) {
    return chrono(Date.parse(string.replace("T", " ")));
};
chrono.trigger = function (delay, func) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
    }

    var id = setTimeout(function () {
        status = 'fired';
        func.apply(undefined, args);
    }, delay);
    var status = void 0;

    status = 'waiting';

    return {
        cancel: function cancel() {
            status = 'cancelled';
            clearTimeout(id);
        },

        get status() {
            return status;
        }
    };
};
chrono.wait = function (wait) {
    return new _promise2.default(function (resolve) {
        return setTimeout(function () {
            return resolve(null);
        }, wait);
    });
};

window.chrono = chrono;
// export default chrono;

},{"babel-runtime/core-js/get-iterator":281,"babel-runtime/core-js/object/entries":288,"babel-runtime/core-js/promise":294,"babel-runtime/helpers/slicedToArray":304,"babel-runtime/helpers/typeof":306,"xregexp":240}],270:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    theme: {
        bluish: '#4285f4',
        grayBG: "#d0d0d0"
    },
    css: {
        backgroundTransition: "background-color 250ms linear"
    }
};

},{}],271:[function(require,module,exports){
"use strict";

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _env = require("source/util/env");

var _env2 = _interopRequireDefault(_env);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
    @type Promise
    @name deviceReady
    @desc a promise that resolves after the deviceready event has fired in codova.
        Useful for plugins that are written and included outside of Corinthian.
*/
if (window.deviceReady === undefined) {
    window.deviceReady = new _promise2.default(function (resolve) {
        if (_env2.default.app === true) {
            document.addEventListener("deviceready", function () {
                return resolve(true);
            });
        } else {
            resolve(true);
        }
    });
}

},{"babel-runtime/core-js/promise":294,"source/util/env":272}],272:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _freeze = require('babel-runtime/core-js/object/freeze');

var _freeze2 = _interopRequireDefault(_freeze);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
    @type Object
    @name Environment
    @desc Contains information about the current environment.
    @property {Boolean} mobile
        True if the current page is on a mobile platform (mobile browser, cordova, etc.).
    @property {Boolean} app
        True if the current page is inside of cordova.
*/

var eventSupport = function () {
    var passive = false;
    var once = false;
    var evtChecker = {
        get passive() {
            passive = true;
            return true;
        },
        get once() {
            once = true;
            return true;
        }
    };
    window.addEventListener('load', null, evtChecker);
    return { passive: passive, once: once };
}();

exports.default = (0, _freeze2.default)({
    mobile: typeof orientation !== 'undefined' || navigator.userAgent.indexOf("Mobile") !== -1,
    app: typeof cordova !== 'undefined',
    events: eventSupport
});

},{"babel-runtime/core-js/object/freeze":289}],273:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

require('source/util/deviceready');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var appFileSystem = new _promise2.default(function () {
    var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(resolve, reject) {
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        _context.next = 2;
                        return deviceReady;

                    case 2:
                        if (!(typeof requestFileSystem === 'undefined')) {
                            _context.next = 5;
                            break;
                        }

                        resolve(null);
                        return _context.abrupt('return');

                    case 5:
                        requestFileSystem(LocalFileSystem.PERSISTENT, 0, function (fs) {
                            return resolve(fs.root);
                        }, function (error) {
                            return reject(error);
                        });

                    case 6:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, undefined);
    }));

    return function (_x, _x2) {
        return _ref.apply(this, arguments);
    };
}());
var tempFileSystem = new _promise2.default(function () {
    var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(resolve, reject) {
        return _regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        _context2.next = 2;
                        return deviceReady;

                    case 2:
                        if (!(typeof requestFileSystem === 'undefined')) {
                            _context2.next = 5;
                            break;
                        }

                        resolve(null);
                        return _context2.abrupt('return');

                    case 5:
                        requestFileSystem(LocalFileSystem.TEMPORARY, 0, function (fs) {
                            return resolve(fs.root);
                        }, function (error) {
                            return reject(error);
                        });

                    case 6:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, _callee2, undefined);
    }));

    return function (_x3, _x4) {
        return _ref2.apply(this, arguments);
    };
}());

var protoSeparater = "::";
var fsType = {
    file: "getFile",
    dir: "getDirectory"
};
var getInfo = function getInfo(name) {
    var info = name.split(protoSeparater);

    if (info.length === 1) {
        return [null, info[0]];
    }
    return info;
};
var isFile = function isFile(name) {
    return name.slice(-1) !== '/';
};
var getName = function getName(name) {
    if (isFile(name) === false) {
        name = name.slice(0, -1);
        return name.slice(name.lastIndexOf('/') + 1) + '/';
    }

    return name.slice(name.lastIndexOf('/') + 1);
};
var getPath = function getPath(name) {
    if (isFile(name) === false) {
        name = name.slice(0, -1);
    }

    return name.slice(0, name.lastIndexOf('/') + 1);
};
var getType = function getType(name) {
    if (isFile(name) === true) {
        return fsType.file;
    }
    return fsType.dir;
};

var resolveURL = function resolveURL(url) {
    return new _promise2.default(function (resolve) {
        return resolveLocalFileSystemURL(url, resolve, function () {
            return resolve(null);
        });
    });
};

var get = function get(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return new _promise2.default(function () {
        var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(resolve, reject) {
            var _getInfo, _getInfo2, protocol, fullPath, root, type;

            return _regenerator2.default.wrap(function _callee3$(_context3) {
                while (1) {
                    switch (_context3.prev = _context3.next) {
                        case 0:
                            _getInfo = getInfo(name), _getInfo2 = (0, _slicedToArray3.default)(_getInfo, 2), protocol = _getInfo2[0], fullPath = _getInfo2[1];

                            if (!(protocol === null)) {
                                _context3.next = 9;
                                break;
                            }

                            _context3.t0 = resolve;
                            _context3.next = 5;
                            return resolveURL(fullPath);

                        case 5:
                            _context3.t1 = _context3.sent;
                            (0, _context3.t0)(_context3.t1);
                            _context3.next = 14;
                            break;

                        case 9:
                            _context3.next = 11;
                            return protocol === 'app' ? appFileSystem : tempFileSystem;

                        case 11:
                            root = _context3.sent;
                            type = getType(name);


                            root[type](fullPath, options, resolve, reject);

                        case 14:
                        case 'end':
                            return _context3.stop();
                    }
                }
            }, _callee3, undefined);
        }));

        return function (_x6, _x7) {
            return _ref3.apply(this, arguments);
        };
    }());
};
var exists = function exists(name) {
    return new _promise2.default(function () {
        var _ref4 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(resolve, reject) {
            var _getInfo3, _getInfo4, protocol, path, type, root;

            return _regenerator2.default.wrap(function _callee4$(_context4) {
                while (1) {
                    switch (_context4.prev = _context4.next) {
                        case 0:
                            _getInfo3 = getInfo(name), _getInfo4 = (0, _slicedToArray3.default)(_getInfo3, 2), protocol = _getInfo4[0], path = _getInfo4[1];
                            type = getType(name);
                            _context4.next = 4;
                            return protocol === 'app' ? appFileSystem : tempFileSystem;

                        case 4:
                            root = _context4.sent;


                            root[type](path, { create: false }, function () {
                                return resolve(true);
                            }, function (err) {
                                if (err.code === 1 || err.code === 11) {
                                    resolve(false);
                                } else {
                                    reject(err);
                                }
                            });

                        case 6:
                        case 'end':
                            return _context4.stop();
                    }
                }
            }, _callee4, undefined);
        }));

        return function (_x8, _x9) {
            return _ref4.apply(this, arguments);
        };
    }());
};
var getNativeURL = function () {
    var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(name, isFile) {
        var _getInfo5, _getInfo6, protocol, file;

        return _regenerator2.default.wrap(function _callee5$(_context5) {
            while (1) {
                switch (_context5.prev = _context5.next) {
                    case 0:
                        _getInfo5 = getInfo(name), _getInfo6 = (0, _slicedToArray3.default)(_getInfo5, 1), protocol = _getInfo6[0];

                        if (!(protocol !== null)) {
                            _context5.next = 6;
                            break;
                        }

                        _context5.next = 4;
                        return get(name, { create: false });

                    case 4:
                        file = _context5.sent;
                        return _context5.abrupt('return', file.nativeURL);

                    case 6:
                        return _context5.abrupt('return', name);

                    case 7:
                    case 'end':
                        return _context5.stop();
                }
            }
        }, _callee5, undefined);
    }));

    return function getNativeURL(_x10, _x11) {
        return _ref5.apply(this, arguments);
    };
}();

var readFunctions = {
    text: 'readAsText',
    binary: 'readAsBinaryString',
    url: 'readAsDataURL',
    arraybuffer: 'readAsArrayBuffer'
};
var readfile = function readfile(name, type) {
    return new _promise2.default(function () {
        var _ref6 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(resolve, reject) {
            var entry, reader, readFunc;
            return _regenerator2.default.wrap(function _callee6$(_context6) {
                while (1) {
                    switch (_context6.prev = _context6.next) {
                        case 0:
                            _context6.prev = 0;
                            _context6.next = 3;
                            return get(name, { create: false });

                        case 3:
                            entry = _context6.sent;
                            reader = new FileReader();
                            readFunc = readFunctions[type];


                            reader.onloadend = function () {
                                return resolve(reader.result);
                            };
                            entry.file(function (file) {
                                return reader[readFunc](file, 'utf-8');
                            });
                            _context6.next = 13;
                            break;

                        case 10:
                            _context6.prev = 10;
                            _context6.t0 = _context6['catch'](0);

                            reject(_context6.t0);

                        case 13:
                        case 'end':
                            return _context6.stop();
                    }
                }
            }, _callee6, undefined, [[0, 10]]);
        }));

        return function (_x12, _x13) {
            return _ref6.apply(this, arguments);
        };
    }());
};
var getFileWriter = function getFileWriter(entry) {
    return new _promise2.default(function (resolve, reject) {
        return entry.createWriter(resolve, reject);
    });
};
var writeFile = function writeFile(fileEntry, data, mode) {
    return new _promise2.default(function () {
        var _ref7 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(resolve, reject) {
            var fileWriter, writeData;
            return _regenerator2.default.wrap(function _callee7$(_context7) {
                while (1) {
                    switch (_context7.prev = _context7.next) {
                        case 0:
                            _context7.next = 2;
                            return getFileWriter(fileEntry);

                        case 2:
                            fileWriter = _context7.sent;

                            writeData = function writeData() {
                                fileWriter.onwriteend = function () {
                                    return resolve(null);
                                };
                                fileWriter.write(data);
                            };

                            if (mode === 'truncate' && fileWriter.length !== 0) {
                                fileWriter.seek(0);
                                fileWriter.onwriteend = writeData;
                                fileWriter.truncate(0);
                            } else {
                                if (mode === 'append') {
                                    fileWriter.seek(fileWriter.length);
                                }
                                writeData();
                            }

                        case 5:
                        case 'end':
                            return _context7.stop();
                    }
                }
            }, _callee7, undefined);
        }));

        return function (_x14, _x15) {
            return _ref7.apply(this, arguments);
        };
    }());
};

var readdir = function readdir(name) {
    return new _promise2.default(function () {
        var _ref8 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8(resolve, reject) {
            var _getInfo7, _getInfo8, protocol, entry, dirReader;

            return _regenerator2.default.wrap(function _callee8$(_context8) {
                while (1) {
                    switch (_context8.prev = _context8.next) {
                        case 0:
                            _context8.prev = 0;
                            _getInfo7 = getInfo(name), _getInfo8 = (0, _slicedToArray3.default)(_getInfo7, 1), protocol = _getInfo8[0];
                            _context8.next = 4;
                            return get(name, { create: false });

                        case 4:
                            entry = _context8.sent;
                            dirReader = entry.createReader();


                            dirReader.readEntries(function (entries) {
                                return resolve(entries.map(function (entry) {
                                    return '' + protocol + protoSeparater + entry.fullPath;
                                }));
                            }, reject);
                            _context8.next = 12;
                            break;

                        case 9:
                            _context8.prev = 9;
                            _context8.t0 = _context8['catch'](0);

                            reject(_context8.t0);

                        case 12:
                        case 'end':
                            return _context8.stop();
                    }
                }
            }, _callee8, undefined, [[0, 9]]);
        }));

        return function (_x16, _x17) {
            return _ref8.apply(this, arguments);
        };
    }());
};

var removeEntry = function removeEntry(name, functionName) {
    return new _promise2.default(function () {
        var _ref9 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee9(resolve, reject) {
            var entry;
            return _regenerator2.default.wrap(function _callee9$(_context9) {
                while (1) {
                    switch (_context9.prev = _context9.next) {
                        case 0:
                            _context9.next = 2;
                            return get(name);

                        case 2:
                            entry = _context9.sent;

                            entry[functionName](function () {
                                return resolve(true);
                            }, reject);

                        case 4:
                        case 'end':
                            return _context9.stop();
                    }
                }
            }, _callee9, undefined);
        }));

        return function (_x18, _x19) {
            return _ref9.apply(this, arguments);
        };
    }());
};
var moveEntry = function moveEntry(source, dest) {
    return new _promise2.default(function () {
        var _ref10 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee10(resolve, reject) {
            var destName, destPath, _ref11, _ref12, sourceEntry, destDirEntry;

            return _regenerator2.default.wrap(function _callee10$(_context10) {
                while (1) {
                    switch (_context10.prev = _context10.next) {
                        case 0:
                            destName = getName(dest);
                            destPath = getPath(dest);
                            _context10.next = 4;
                            return _promise2.default.all([get(source), get(destPath)]);

                        case 4:
                            _ref11 = _context10.sent;
                            _ref12 = (0, _slicedToArray3.default)(_ref11, 2);
                            sourceEntry = _ref12[0];
                            destDirEntry = _ref12[1];


                            sourceEntry.moveTo(destDirEntry, destName, function () {
                                return resolve(true);
                            }, reject);

                        case 9:
                        case 'end':
                            return _context10.stop();
                    }
                }
            }, _callee10, undefined);
        }));

        return function (_x20, _x21) {
            return _ref10.apply(this, arguments);
        };
    }());
};
var copyEntry = function copyEntry(source, dest) {
    return new _promise2.default(function () {
        var _ref13 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee11(resolve, reject) {
            var destName, destPath, _ref14, _ref15, sourceEntry, destDirEntry;

            return _regenerator2.default.wrap(function _callee11$(_context11) {
                while (1) {
                    switch (_context11.prev = _context11.next) {
                        case 0:
                            destName = getName(dest);
                            destPath = getPath(dest);
                            _context11.next = 4;
                            return _promise2.default.all([get(source), get(destPath)]);

                        case 4:
                            _ref14 = _context11.sent;
                            _ref15 = (0, _slicedToArray3.default)(_ref14, 2);
                            sourceEntry = _ref15[0];
                            destDirEntry = _ref15[1];


                            sourceEntry.copyTo(destDirEntry, destName, function () {
                                return resolve(true);
                            }, reject);

                        case 9:
                        case 'end':
                            return _context11.stop();
                    }
                }
            }, _callee11, undefined);
        }));

        return function (_x22, _x23) {
            return _ref13.apply(this, arguments);
        };
    }());
};

var rootURL = void 0;
(0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee12() {
    var appRoot, tempRoot;
    return _regenerator2.default.wrap(function _callee12$(_context12) {
        while (1) {
            switch (_context12.prev = _context12.next) {
                case 0:
                    _context12.next = 2;
                    return appFileSystem;

                case 2:
                    appRoot = _context12.sent;
                    _context12.next = 5;
                    return tempFileSystem;

                case 5:
                    tempRoot = _context12.sent;


                    rootURL = {
                        app: appRoot,
                        temp: tempRoot
                    };

                case 7:
                case 'end':
                    return _context12.stop();
            }
        }
    }, _callee12, undefined);
}))();

exports.default = {
    fileRead: function fileRead(name) {
        var _this = this;

        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';
        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee13() {
            return _regenerator2.default.wrap(function _callee13$(_context13) {
                while (1) {
                    switch (_context13.prev = _context13.next) {
                        case 0:
                            _context13.next = 2;
                            return readfile(name, type);

                        case 2:
                            return _context13.abrupt('return', _context13.sent);

                        case 3:
                        case 'end':
                            return _context13.stop();
                    }
                }
            }, _callee13, _this);
        }))();
    },
    dirRead: function dirRead(name) {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee14() {
            return _regenerator2.default.wrap(function _callee14$(_context14) {
                while (1) {
                    switch (_context14.prev = _context14.next) {
                        case 0:
                            if (!(isFile(name) === true)) {
                                _context14.next = 2;
                                break;
                            }

                            throw new TypeError("Cannot call dirRead on a file");

                        case 2:
                            _context14.next = 4;
                            return readdir(name);

                        case 4:
                            return _context14.abrupt('return', _context14.sent);

                        case 5:
                        case 'end':
                            return _context14.stop();
                    }
                }
            }, _callee14, _this2);
        }))();
    },
    fileWrite: function fileWrite(name, data) {
        var _this3 = this;

        var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'truncate';
        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee15() {
            var _getInfo9, _getInfo10, protocol, entry;

            return _regenerator2.default.wrap(function _callee15$(_context15) {
                while (1) {
                    switch (_context15.prev = _context15.next) {
                        case 0:
                            _getInfo9 = getInfo(name), _getInfo10 = (0, _slicedToArray3.default)(_getInfo9, 1), protocol = _getInfo10[0];
                            entry = void 0;

                            if (!(protocol === null)) {
                                _context15.next = 4;
                                break;
                            }

                            throw new Error("Should not be writing to external files directly");

                        case 4:
                            _context15.next = 6;
                            return get(name, { create: true });

                        case 6:
                            entry = _context15.sent;

                            if (!(isFile(entry.fullPath) === false)) {
                                _context15.next = 9;
                                break;
                            }

                            throw new TypeError("Directory exists with that name already");

                        case 9:
                            if (typeof data === 'string') {
                                data = new Blob([data], { type: 'text/plain' });
                            }

                            _context15.next = 12;
                            return writeFile(entry, data, mode);

                        case 12:
                            return _context15.abrupt('return', true);

                        case 13:
                        case 'end':
                            return _context15.stop();
                    }
                }
            }, _callee15, _this3);
        }))();
    },
    fileCreate: function fileCreate(name) {
        var _this4 = this;

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee16() {
            return _regenerator2.default.wrap(function _callee16$(_context16) {
                while (1) {
                    switch (_context16.prev = _context16.next) {
                        case 0:
                            _context16.next = 2;
                            return get(name, { create: true });

                        case 2:
                            return _context16.abrupt('return', _context16.sent);

                        case 3:
                        case 'end':
                            return _context16.stop();
                    }
                }
            }, _callee16, _this4);
        }))();
    },
    dirCreate: function dirCreate(name) {
        var _this5 = this;

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee17() {
            return _regenerator2.default.wrap(function _callee17$(_context17) {
                while (1) {
                    switch (_context17.prev = _context17.next) {
                        case 0:
                            _context17.next = 2;
                            return get(name, { create: true });

                        case 2:
                            return _context17.abrupt('return', _context17.sent);

                        case 3:
                        case 'end':
                            return _context17.stop();
                    }
                }
            }, _callee17, _this5);
        }))();
    },
    fileRemove: function fileRemove(name) {
        var _this6 = this;

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee18() {
            return _regenerator2.default.wrap(function _callee18$(_context18) {
                while (1) {
                    switch (_context18.prev = _context18.next) {
                        case 0:
                            _context18.next = 2;
                            return removeEntry(name, 'remove');

                        case 2:
                            return _context18.abrupt('return', _context18.sent);

                        case 3:
                        case 'end':
                            return _context18.stop();
                    }
                }
            }, _callee18, _this6);
        }))();
    },
    dirRemove: function dirRemove(name) {
        var _this7 = this;

        var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee19() {
            var functionName;
            return _regenerator2.default.wrap(function _callee19$(_context19) {
                while (1) {
                    switch (_context19.prev = _context19.next) {
                        case 0:
                            functionName = recursive === true ? "removeRecursively" : "remove";
                            _context19.next = 3;
                            return removeEntry(name, functionName);

                        case 3:
                            return _context19.abrupt('return', _context19.sent);

                        case 4:
                        case 'end':
                            return _context19.stop();
                    }
                }
            }, _callee19, _this7);
        }))();
    },

    fileExists: exists,
    dirExists: exists,
    fileMove: function fileMove(source, dest) {
        var _this8 = this;

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee20() {
            return _regenerator2.default.wrap(function _callee20$(_context20) {
                while (1) {
                    switch (_context20.prev = _context20.next) {
                        case 0:
                            if (!(isFile(source) !== isFile(dest))) {
                                _context20.next = 2;
                                break;
                            }

                            throw new TypeError("Files can only be moved into other files");

                        case 2:
                            _context20.next = 4;
                            return moveEntry(source, dest);

                        case 4:
                            return _context20.abrupt('return', _context20.sent);

                        case 5:
                        case 'end':
                            return _context20.stop();
                    }
                }
            }, _callee20, _this8);
        }))();
    },
    fileCopy: function fileCopy(source, dest) {
        var _this9 = this;

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee21() {
            return _regenerator2.default.wrap(function _callee21$(_context21) {
                while (1) {
                    switch (_context21.prev = _context21.next) {
                        case 0:
                            if (!(isFile(source) !== isFile(dest))) {
                                _context21.next = 2;
                                break;
                            }

                            throw new TypeError("Files can only be moved into other files");

                        case 2:
                            _context21.next = 4;
                            return copyEntry(source, dest);

                        case 4:
                            return _context21.abrupt('return', _context21.sent);

                        case 5:
                        case 'end':
                            return _context21.stop();
                    }
                }
            }, _callee21, _this9);
        }))();
    },
    dirMove: function dirMove(source, dest) {
        var _this10 = this;

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee22() {
            return _regenerator2.default.wrap(function _callee22$(_context22) {
                while (1) {
                    switch (_context22.prev = _context22.next) {
                        case 0:
                            if (!(isFile(source) !== isFile(dest))) {
                                _context22.next = 2;
                                break;
                            }

                            throw new TypeError("Directories can only be moved into other files");

                        case 2:
                            _context22.next = 4;
                            return moveEntry(source, dest);

                        case 4:
                            return _context22.abrupt('return', _context22.sent);

                        case 5:
                        case 'end':
                            return _context22.stop();
                    }
                }
            }, _callee22, _this10);
        }))();
    },
    dirTree: function dirTree(name) {
        var _this11 = this;

        var files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee23() {
            var list, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry;

            return _regenerator2.default.wrap(function _callee23$(_context23) {
                while (1) {
                    switch (_context23.prev = _context23.next) {
                        case 0:
                            _context23.next = 2;
                            return fs.dirRead(name);

                        case 2:
                            list = _context23.sent;
                            _iteratorNormalCompletion = true;
                            _didIteratorError = false;
                            _iteratorError = undefined;
                            _context23.prev = 6;
                            _iterator = (0, _getIterator3.default)(list);

                        case 8:
                            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                                _context23.next = 17;
                                break;
                            }

                            entry = _step.value;

                            files.push(entry);

                            if (!(isFile(entry) === false)) {
                                _context23.next = 14;
                                break;
                            }

                            _context23.next = 14;
                            return fs.dirTree(entry, files);

                        case 14:
                            _iteratorNormalCompletion = true;
                            _context23.next = 8;
                            break;

                        case 17:
                            _context23.next = 23;
                            break;

                        case 19:
                            _context23.prev = 19;
                            _context23.t0 = _context23['catch'](6);
                            _didIteratorError = true;
                            _iteratorError = _context23.t0;

                        case 23:
                            _context23.prev = 23;
                            _context23.prev = 24;

                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }

                        case 26:
                            _context23.prev = 26;

                            if (!_didIteratorError) {
                                _context23.next = 29;
                                break;
                            }

                            throw _iteratorError;

                        case 29:
                            return _context23.finish(26);

                        case 30:
                            return _context23.finish(23);

                        case 31:
                            return _context23.abrupt('return', files);

                        case 32:
                        case 'end':
                            return _context23.stop();
                    }
                }
            }, _callee23, _this11, [[6, 19, 23, 31], [24,, 26, 30]]);
        }))();
    },
    url: function url(fileName) {
        var _getInfo11 = getInfo(fileName),
            _getInfo12 = (0, _slicedToArray3.default)(_getInfo11, 2),
            protocol = _getInfo12[0],
            fullPath = _getInfo12[1];

        return '' + rootURL[protocol].nativeURL + fullPath;
    },
    entry: function entry(url) {
        var _this12 = this;

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee24() {
            return _regenerator2.default.wrap(function _callee24$(_context24) {
                while (1) {
                    switch (_context24.prev = _context24.next) {
                        case 0:
                            _context24.next = 2;
                            return get(url, { create: false });

                        case 2:
                            return _context24.abrupt('return', _context24.sent);

                        case 3:
                        case 'end':
                            return _context24.stop();
                    }
                }
            }, _callee24, _this12);
        }))();
    }
};

},{"babel-runtime/core-js/get-iterator":281,"babel-runtime/core-js/promise":294,"babel-runtime/helpers/asyncToGenerator":297,"babel-runtime/helpers/slicedToArray":304,"babel-runtime/regenerator":307,"source/util/deviceready":271}],274:[function(require,module,exports){
'use strict';

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _freeze = require('babel-runtime/core-js/object/freeze');

var _freeze2 = _interopRequireDefault(_freeze);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _env = require('source/util/env');

var _env2 = _interopRequireDefault(_env);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var addEventListener = EventTarget.prototype.addEventListener;

EventTarget.prototype.addEventListener = function (type, listener) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (_env2.default.events.passive === false && (typeof opts === 'undefined' ? 'undefined' : (0, _typeof3.default)(opts)) === 'object') {
        opts = opts.capture || false;
    }
    if (_env2.default.events.passive === true && typeof opts === 'boolean') {
        opts = { capture: opts };
    }
    addEventListener.call(this, type, listener, opts);
    // console.log(`adding: ${type}, support: passive(${Env.events.passive}).once(${Env.events.once})`);
};

var forEach = Array.prototype.forEach;
var schedule = function schedule(time, func) {
    return setTimeout(func, time);
};

var findPressTarget = function findPressTarget(node) {
    while (node !== null && node !== undefined && node.getAttribute("data-no-press") !== null) {
        node = node.parentNode;
    }

    return node || document.body;
};
var touchData = function touchData(_ref, _ref2) {
    var x = _ref.pageX,
        y = _ref.pageY,
        id = _ref.identifier,
        target = _ref.target;
    var _ref2$mouseTriggered = _ref2.mouseTriggered,
        mouseTriggered = _ref2$mouseTriggered === undefined ? false : _ref2$mouseTriggered;
    var targetOverride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return (0, _freeze2.default)({
        position: (0, _freeze2.default)({
            x: x, y: y
        }),
        time: Date.now(),
        target: targetOverride || target,
        pressTarget: findPressTarget(targetOverride || target),
        id: id,
        mouseTriggered: mouseTriggered
    });
};

var polarVector = function polarVector(_ref3, _ref4) {
    var _ref3$position = _ref3.position,
        x1 = _ref3$position.x,
        y1 = _ref3$position.y;
    var _ref4$position = _ref4.position,
        x2 = _ref4$position.x,
        y2 = _ref4$position.y;

    var angle = void 0;
    var magnitude = void 0;

    angle = Math.atan2(y2 - y1, x2 - x1);
    angle *= 180 / Math.PI;
    angle = (angle + 450) % 360;

    magnitude = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

    return {
        angle: angle,
        magnitude: magnitude
    };
};

var angleDif = function angleDif(firstAngle, secondAngle) {
    var absDif = Math.abs(firstAngle - secondAngle) % 360;
    if (absDif > 180) {
        return 360 - absDif;
    }
    return absDif;
};

var createEvent = function createEvent(eventType) {
    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var eventProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var event = void 0;

    event = document.createEvent("CustomEvent");
    event.initCustomEvent(eventType, true, true, detail);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(eventProps)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            event[key] = eventProps[key];
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return event;
};

var register = function register(type, createCallbacks) {
    var _createCallbacks = createCallbacks({ polarVector: polarVector, angleDif: angleDif }),
        _createCallbacks$star = _createCallbacks.start,
        start = _createCallbacks$star === undefined ? function () {} : _createCallbacks$star,
        _createCallbacks$move = _createCallbacks.move,
        move = _createCallbacks$move === undefined ? function () {} : _createCallbacks$move,
        _createCallbacks$end = _createCallbacks.end,
        end = _createCallbacks$end === undefined ? function () {} : _createCallbacks$end;

    registeredHandlers.push(type);
    registeredCallbacks[type] = { start: start, move: move, end: end };
    touchVars[type] = {};
};

var editableTagNames = ["input", "textarea", "select"];

var enabled = void 0;
var touchDataStart = void 0;
var touchDataLast = void 0;
var touchVars = void 0;
var registeredHandlers = void 0;
var registeredCallbacks = void 0;

enabled = true;
touchDataStart = {};
touchDataLast = {};
touchVars = {};
registeredHandlers = [];
registeredCallbacks = {};

window.addEventListener("touchstart", function (evt) {
    var changedTouches = evt.changedTouches;

    if (enabled === false) {
        return;
    }

    forEach.call(changedTouches, function (touch) {
        var data = touchData(touch, evt);

        touchDataStart[data.id] = data;
        touchDataLast[data.id] = data;

        data.pressTarget.setAttribute("pressed", "");

        registeredHandlers.forEach(function (handlerName) {
            var handler = registeredCallbacks[handlerName];

            touchVars[handlerName][data.id] = {};
            handler.start({ touch: data, vars: touchVars[handlerName][data.id] });
        });
    });
}, false);
window.addEventListener("touchmove", function (evt) {
    var changedTouches = evt.changedTouches;

    if (enabled === false) {
        return;
    }

    forEach.call(changedTouches, function (touch) {
        var data = touchData(touch, evt);
        var startTouch = touchDataStart[data.id];
        var lastPosition = touchDataLast[data.id];
        var overallVector = polarVector(data, startTouch);
        var difVector = polarVector(data, lastPosition);

        registeredHandlers.forEach(function (handlerName) {
            var handler = registeredCallbacks[handlerName];
            var vars = touchVars[handlerName][data.id];

            handler.move({ touch: data, vars: vars, overallVector: overallVector, difVector: difVector });
        });
    });
}, false);
window.addEventListener("touchend", function (evt) {
    var changedTouches = evt.changedTouches;

    if (enabled === false) {
        return;
    }

    forEach.call(changedTouches, function (touch) {
        var data = touchData(touch, evt);
        var startTouch = touchDataStart[data.id];
        var targetTagName = data.target.nodeName.toLowerCase();
        var overallVector = polarVector(data, startTouch);

        var somethingEditable = void 0;
        var currentNode = void 0;

        data.pressTarget.removeAttribute("pressed");

        somethingEditable = false;
        currentNode = data.target;
        while (true) {
            if (currentNode.getAttribute !== undefined && currentNode.getAttribute("contenteditable") === true) {
                somethingEditable = true;
                break;
            }

            currentNode = currentNode.parentNode;
            if (currentNode === document || currentNode === null) {
                break;
            }
        }

        // if (editableTagNames.indexOf(targetTagName) === -1 && somethingEditable === false && evt.cancelable === true) {
        if (evt.cancelable === true && editableTagNames.indexOf(targetTagName) === -1) {
            evt.preventDefault();
        }

        registeredHandlers.forEach(function (handlerName) {
            var handler = registeredCallbacks[handlerName];
            var vars = touchVars[handlerName][data.id];

            handler.end({ touch: data, vars: vars, startTouch: startTouch, overallVector: overallVector });
            touchVars[handlerName][touch.id] = null;
        });

        touchDataStart[touch.id] = null;
        touchDataLast[touch.id] = null;
    });
}, false);

(function () {
    if (_env2.default.mobile === true) {
        return;
    }
    var copyPropList = ['pageX', 'pageY', 'screenX', 'screenY', 'altKey', 'ctrlKey', 'shiftKey', 'metaKey', 'clientX', 'clientY', 'layerX', 'layerY', 'x', 'y'];
    var createTouch = function createTouch(evt, target) {
        return copyPropList.reduce(function (synthTouch, propertyName) {
            synthTouch[propertyName] = evt[propertyName];
            return synthTouch;
        }, { identifier: -1, target: target, sourceElement: target });
    };
    var createTouchList = function createTouchList(evt, target) {
        return {
            changedTouches: {
                0: createTouch(evt, target),
                length: 1
            }
        };
    };
    var currentElement = void 0;
    var mouseIsDown = void 0;

    currentElement = null;
    mouseIsDown = false;

    window.addEventListener("mousedown", function (evt) {
        if (evt.button !== 0) {
            return;
        }
        var event = createEvent("touchstart", null, (0, _extends3.default)({}, createTouchList(evt, evt.target), {
            mouseTriggered: true
        }));

        mouseIsDown = true;
        currentElement = evt.target;
        currentElement.dispatchEvent(event);
    });
    window.addEventListener("mousemove", function (evt) {
        if (mouseIsDown === false) {
            return;
        }
        var event = createEvent("touchmove", null, (0, _extends3.default)({}, createTouchList(evt, currentElement), {
            mouseTriggered: true
        }));

        if (evt.target.tagName.toLowerCase() !== 'input' || evt.target.type !== 'range') {
            evt.preventDefault();
        }
        currentElement.dispatchEvent(event);
    });
    window.addEventListener("mouseup", function (evt) {
        if (evt.button !== 0 || mouseIsDown === false) {
            return;
        }
        var event = createEvent("touchend", null, (0, _extends3.default)({}, createTouchList(evt, currentElement), {
            mouseTriggered: true
        }));

        mouseIsDown = false;
        currentElement.dispatchEvent(event);
        currentElement = null;
    });
})();

register("tap", function () {
    return {
        start: function start(_ref5) {
            var vars = _ref5.vars;

            vars.valid = true;
        },
        move: function move(_ref6) {
            var vars = _ref6.vars,
                overallVector = _ref6.overallVector;

            if (overallVector.magnitude > 20) {
                vars.valid = false;
            }
        },
        end: function end(_ref7) {
            var vars = _ref7.vars,
                startTouch = _ref7.startTouch,
                touch = _ref7.touch,
                overallVector = _ref7.overallVector;

            if (overallVector.magnitude > 20) {
                vars.valid = false;
            }
            if (vars.valid === true && touch.time - startTouch.time < 500) {
                if (startTouch.target !== document.activeElement && document.activeElement !== null && touch.mouseTriggered === false && 'blur' in document.activeElement) {
                    document.activeElement.blur();
                    startTouch.target.focus();
                }

                startTouch.target.dispatchEvent(createEvent("tap", null, { touch: touch }));
            }
        }
    };
});

register("hold", function () {
    var createCallbackForTouch = function createCallbackForTouch(touch) {
        return function () {
            timeouts[touch.id] = null;
            touch.target.dispatchEvent(createEvent("hold", null, { position: touch.position }));
        };
    };
    var timeouts = void 0;

    timeouts = {};
    return {
        start: function start(_ref8) {
            var touch = _ref8.touch;

            timeouts[touch.id] = schedule(1000, createCallbackForTouch(touch));
        },
        move: function move(_ref9) {
            var touch = _ref9.touch,
                overallVector = _ref9.overallVector;

            if (overallVector.magnitude > 20) {
                clearTimeout(timeouts[touch.id]);
                timeouts[touch.id] = null;
            }
        },
        end: function end(_ref10) {
            var touch = _ref10.touch;

            if (timeouts[touch.id] !== null) {
                clearTimeout(timeouts[touch.id]);
                timeouts[touch.id] = null;
            }
        }
    };
});

window.gesture = { register: register };

},{"babel-runtime/core-js/get-iterator":281,"babel-runtime/core-js/object/freeze":289,"babel-runtime/core-js/object/keys":291,"babel-runtime/helpers/extends":300,"babel-runtime/helpers/typeof":306,"source/util/env":272}],275:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var c = String.fromCharCode;

var icons = {
  "ion-ionic": c(61771),
  "ion-arrow-up-a": c(61708),
  "ion-arrow-right-a": c(61705),
  "ion-arrow-down-a": c(61699),
  "ion-arrow-left-a": c(61702),
  "ion-arrow-up-b": c(61709),
  "ion-arrow-right-b": c(61706),
  "ion-arrow-down-b": c(61700),
  "ion-arrow-left-b": c(61703),
  "ion-arrow-up-c": c(61710),
  "ion-arrow-right-c": c(61707),
  "ion-arrow-down-c": c(61701),
  "ion-arrow-left-c": c(61704),
  "ion-arrow-return-right": c(62054),
  "ion-arrow-return-left": c(62053),
  "ion-arrow-swap": c(62056),
  "ion-arrow-shrink": c(62055),
  "ion-arrow-expand": c(62046),
  "ion-arrow-move": c(62051),
  "ion-arrow-resize": c(62052),
  "ion-chevron-up": c(61734),
  "ion-chevron-right": c(61733),
  "ion-chevron-down": c(61731),
  "ion-chevron-left": c(61732),
  "ion-navicon-round": c(61965),
  "ion-navicon": c(61966),
  "ion-drag": c(61744),
  "ion-log-in": c(62110),
  "ion-log-out": c(62111),
  "ion-checkmark-round": c(61729),
  "ion-checkmark": c(61730),
  "ion-checkmark-circled": c(61728),
  "ion-close-round": c(61737),
  "ion-close": c(61738),
  "ion-close-circled": c(61736),
  "ion-plus-round": c(61975),
  "ion-plus": c(61976),
  "ion-plus-circled": c(61974),
  "ion-minus-round": c(61960),
  "ion-minus": c(61961),
  "ion-minus-circled": c(61959),
  "ion-information": c(61770),
  "ion-information-circled": c(61769),
  "ion-help": c(61763),
  "ion-help-circled": c(61762),
  "ion-backspace-outline": c(62398),
  "ion-backspace": c(62399),
  "ion-help-buoy": c(62076),
  "ion-asterisk": c(62228),
  "ion-alert": c(61697),
  "ion-alert-circled": c(61696),
  "ion-refresh": c(61980),
  "ion-loop": c(61953),
  "ion-shuffle": c(61985),
  "ion-home": c(61764),
  "ion-search": c(61983),
  "ion-flag": c(62073),
  "ion-star": c(62030),
  "ion-heart": c(61761),
  "ion-heart-broken": c(62237),
  "ion-gear-a": c(61757),
  "ion-gear-b": c(61758),
  "ion-toggle-filled": c(62292),
  "ion-toggle": c(62293),
  "ion-settings": c(62125),
  "ion-wrench": c(62138),
  "ion-hammer": c(62075),
  "ion-edit": c(62143),
  "ion-trash-a": c(62034),
  "ion-trash-b": c(62035),
  "ion-document": c(61743),
  "ion-document-text": c(61742),
  "ion-clipboard": c(61735),
  "ion-scissors": c(62283),
  "ion-funnel": c(62235),
  "ion-bookmark": c(62059),
  "ion-email": c(61746),
  "ion-email-unread": c(62403),
  "ion-folder": c(61753),
  "ion-filing": c(61748),
  "ion-archive": c(61698),
  "ion-reply": c(61982),
  "ion-reply-all": c(61981),
  "ion-forward": c(61754),
  "ion-share": c(61984),
  "ion-paper-airplane": c(62147),
  "ion-link": c(61950),
  "ion-paperclip": c(61967),
  "ion-compose": c(61740),
  "ion-briefcase": c(62060),
  "ion-medkit": c(62114),
  "ion-at": c(61711),
  "ion-pound": c(61977),
  "ion-quote": c(62279),
  "ion-cloud": c(61739),
  "ion-upload": c(62037),
  "ion-more": c(61963),
  "ion-grid": c(61759),
  "ion-calendar": c(61719),
  "ion-clock": c(62062),
  "ion-compass": c(62067),
  "ion-pinpoint": c(62119),
  "ion-pin": c(62118),
  "ion-navigate": c(62115),
  "ion-location": c(61951),
  "ion-map": c(61955),
  "ion-lock-combination": c(62676),
  "ion-locked": c(61952),
  "ion-unlocked": c(62036),
  "ion-key": c(62102),
  "ion-arrow-graph-up-right": c(62050),
  "ion-arrow-graph-down-right": c(62048),
  "ion-arrow-graph-up-left": c(62049),
  "ion-arrow-graph-down-left": c(62047),
  "ion-stats-bars": c(62133),
  "ion-connection-bars": c(62068),
  "ion-pie-graph": c(62117),
  "ion-chatbubble": c(61726),
  "ion-chatbubble-working": c(61725),
  "ion-chatbubbles": c(61727),
  "ion-chatbox": c(61723),
  "ion-chatbox-working": c(61722),
  "ion-chatboxes": c(61724),
  "ion-person": c(61971),
  "ion-person-add": c(61969),
  "ion-person-stalker": c(61970),
  "ion-woman": c(62045),
  "ion-man": c(61954),
  "ion-female": c(62072),
  "ion-male": c(62113),
  "ion-transgender": c(62709),
  "ion-fork": c(62074),
  "ion-knife": c(62103),
  "ion-spoon": c(62132),
  "ion-soup-can-outline": c(62707),
  "ion-soup-can": c(62708),
  "ion-beer": c(62058),
  "ion-wineglass": c(62137),
  "ion-coffee": c(62066),
  "ion-icecream": c(62077),
  "ion-pizza": c(62120),
  "ion-power": c(62121),
  "ion-mouse": c(62272),
  "ion-battery-full": c(61715),
  "ion-battery-half": c(61716),
  "ion-battery-low": c(61717),
  "ion-battery-empty": c(61714),
  "ion-battery-charging": c(61713),
  "ion-wifi": c(62044),
  "ion-bluetooth": c(61718),
  "ion-calculator": c(62061),
  "ion-camera": c(61720),
  "ion-eye": c(61747),
  "ion-eye-disabled": c(62214),
  "ion-flash": c(61751),
  "ion-flash-off": c(61750),
  "ion-qr-scanner": c(62278),
  "ion-image": c(61767),
  "ion-images": c(61768),
  "ion-wand": c(62296),
  "ion-contrast": c(62069),
  "ion-aperture": c(62227),
  "ion-crop": c(62401),
  "ion-easel": c(62402),
  "ion-paintbrush": c(62677),
  "ion-paintbucket": c(62678),
  "ion-monitor": c(61962),
  "ion-laptop": c(61948),
  "ion-ipad": c(61945),
  "ion-iphone": c(61946),
  "ion-ipod": c(61947),
  "ion-printer": c(61978),
  "ion-usb": c(62136),
  "ion-outlet": c(62274),
  "ion-bug": c(62142),
  "ion-code": c(62065),
  "ion-code-working": c(62064),
  "ion-code-download": c(62063),
  "ion-fork-repo": c(62144),
  "ion-network": c(62273),
  "ion-pull-request": c(62277),
  "ion-merge": c(62271),
  "ion-xbox": c(62220),
  "ion-playstation": c(62218),
  "ion-steam": c(62219),
  "ion-closed-captioning": c(62231),
  "ion-videocamera": c(62038),
  "ion-film-marker": c(61749),
  "ion-disc": c(61741),
  "ion-headphone": c(61760),
  "ion-music-note": c(61964),
  "ion-radio-waves": c(62124),
  "ion-speakerphone": c(62130),
  "ion-mic-a": c(61956),
  "ion-mic-b": c(61957),
  "ion-mic-c": c(61958),
  "ion-volume-high": c(62039),
  "ion-volume-medium": c(62041),
  "ion-volume-low": c(62040),
  "ion-volume-mute": c(62042),
  "ion-levels": c(62104),
  "ion-play": c(61973),
  "ion-pause": c(61968),
  "ion-stop": c(62031),
  "ion-record": c(61979),
  "ion-skip-forward": c(61987),
  "ion-skip-backward": c(61986),
  "ion-eject": c(61745),
  "ion-bag": c(61712),
  "ion-card": c(61721),
  "ion-cash": c(62230),
  "ion-pricetag": c(62122),
  "ion-pricetags": c(62123),
  "ion-thumbsup": c(62033),
  "ion-thumbsdown": c(62032),
  "ion-happy-outline": c(62406),
  "ion-happy": c(62236),
  "ion-sad-outline": c(62679),
  "ion-sad": c(62282),
  "ion-bowtie": c(62400),
  "ion-tshirt-outline": c(62710),
  "ion-tshirt": c(62711),
  "ion-trophy": c(62294),
  "ion-podium": c(62276),
  "ion-ribbon-a": c(62280),
  "ion-ribbon-b": c(62281),
  "ion-university": c(62295),
  "ion-magnet": c(62112),
  "ion-beaker": c(62057),
  "ion-erlenmeyer-flask": c(62405),
  "ion-egg": c(62071),
  "ion-earth": c(62070),
  "ion-planet": c(62275),
  "ion-lightbulb": c(62105),
  "ion-cube": c(62232),
  "ion-leaf": c(61949),
  "ion-waterdrop": c(62043),
  "ion-flame": c(62234),
  "ion-fireball": c(62233),
  "ion-bonfire": c(62229),
  "ion-umbrella": c(62135),
  "ion-nuclear": c(62116),
  "ion-no-smoking": c(62146),
  "ion-thermometer": c(62134),
  "ion-speedometer": c(62131),
  "ion-model-s": c(62145),
  "ion-plane": c(61972),
  "ion-jet": c(62101),
  "ion-load-a": c(62106),
  "ion-load-b": c(62107),
  "ion-load-c": c(62108),
  "ion-load-d": c(62109),
  "ion-ios-ionic-outline": c(62542),
  "ion-ios-arrow-back": c(62415),
  "ion-ios-arrow-forward": c(62417),
  "ion-ios-arrow-up": c(62424),
  "ion-ios-arrow-right": c(62419),
  "ion-ios-arrow-down": c(62416),
  "ion-ios-arrow-left": c(62418),
  "ion-ios-arrow-thin-up": c(62423),
  "ion-ios-arrow-thin-right": c(62422),
  "ion-ios-arrow-thin-down": c(62420),
  "ion-ios-arrow-thin-left": c(62421),
  "ion-ios-circle-filled": c(62464),
  "ion-ios-circle-outline": c(62465),
  "ion-ios-checkmark-empty": c(62461),
  "ion-ios-checkmark-outline": c(62462),
  "ion-ios-checkmark": c(62463),
  "ion-ios-plus-empty": c(62601),
  "ion-ios-plus-outline": c(62602),
  "ion-ios-plus": c(62603),
  "ion-ios-close-empty": c(62468),
  "ion-ios-close-outline": c(62469),
  "ion-ios-close": c(62470),
  "ion-ios-minus-empty": c(62562),
  "ion-ios-minus-outline": c(62563),
  "ion-ios-minus": c(62564),
  "ion-ios-information-empty": c(62539),
  "ion-ios-information-outline": c(62540),
  "ion-ios-information": c(62541),
  "ion-ios-help-empty": c(62532),
  "ion-ios-help-outline": c(62533),
  "ion-ios-help": c(62534),
  "ion-ios-search": c(62629),
  "ion-ios-search-strong": c(62628),
  "ion-ios-star": c(62643),
  "ion-ios-star-half": c(62641),
  "ion-ios-star-outline": c(62642),
  "ion-ios-heart": c(62531),
  "ion-ios-heart-outline": c(62530),
  "ion-ios-more": c(62570),
  "ion-ios-more-outline": c(62569),
  "ion-ios-home": c(62536),
  "ion-ios-home-outline": c(62535),
  "ion-ios-cloud": c(62476),
  "ion-ios-cloud-outline": c(62473),
  "ion-ios-cloud-upload": c(62475),
  "ion-ios-cloud-upload-outline": c(62474),
  "ion-ios-cloud-download": c(62472),
  "ion-ios-cloud-download-outline": c(62471),
  "ion-ios-upload": c(62667),
  "ion-ios-upload-outline": c(62666),
  "ion-ios-download": c(62496),
  "ion-ios-download-outline": c(62495),
  "ion-ios-refresh": c(62620),
  "ion-ios-refresh-outline": c(62619),
  "ion-ios-refresh-empty": c(62618),
  "ion-ios-reload": c(62621),
  "ion-ios-loop-strong": c(62553),
  "ion-ios-loop": c(62554),
  "ion-ios-bookmarks": c(62442),
  "ion-ios-bookmarks-outline": c(62441),
  "ion-ios-book": c(62440),
  "ion-ios-book-outline": c(62439),
  "ion-ios-flag": c(62509),
  "ion-ios-flag-outline": c(62508),
  "ion-ios-glasses": c(62527),
  "ion-ios-glasses-outline": c(62526),
  "ion-ios-browsers": c(62448),
  "ion-ios-browsers-outline": c(62447),
  "ion-ios-at": c(62426),
  "ion-ios-at-outline": c(62425),
  "ion-ios-pricetag": c(62605),
  "ion-ios-pricetag-outline": c(62604),
  "ion-ios-pricetags": c(62607),
  "ion-ios-pricetags-outline": c(62606),
  "ion-ios-cart": c(62456),
  "ion-ios-cart-outline": c(62455),
  "ion-ios-chatboxes": c(62458),
  "ion-ios-chatboxes-outline": c(62457),
  "ion-ios-chatbubble": c(62460),
  "ion-ios-chatbubble-outline": c(62459),
  "ion-ios-cog": c(62482),
  "ion-ios-cog-outline": c(62481),
  "ion-ios-gear": c(62525),
  "ion-ios-gear-outline": c(62524),
  "ion-ios-settings": c(62631),
  "ion-ios-settings-strong": c(62630),
  "ion-ios-toggle": c(62659),
  "ion-ios-toggle-outline": c(62658),
  "ion-ios-analytics": c(62414),
  "ion-ios-analytics-outline": c(62413),
  "ion-ios-pie": c(62596),
  "ion-ios-pie-outline": c(62595),
  "ion-ios-pulse": c(62611),
  "ion-ios-pulse-strong": c(62610),
  "ion-ios-filing": c(62505),
  "ion-ios-filing-outline": c(62504),
  "ion-ios-box": c(62444),
  "ion-ios-box-outline": c(62443),
  "ion-ios-compose": c(62488),
  "ion-ios-compose-outline": c(62487),
  "ion-ios-trash": c(62661),
  "ion-ios-trash-outline": c(62660),
  "ion-ios-copy": c(62492),
  "ion-ios-copy-outline": c(62491),
  "ion-ios-email": c(62499),
  "ion-ios-email-outline": c(62498),
  "ion-ios-undo": c(62663),
  "ion-ios-undo-outline": c(62662),
  "ion-ios-redo": c(62617),
  "ion-ios-redo-outline": c(62616),
  "ion-ios-paperplane": c(62580),
  "ion-ios-paperplane-outline": c(62579),
  "ion-ios-folder": c(62517),
  "ion-ios-folder-outline": c(62516),
  "ion-ios-paper": c(62578),
  "ion-ios-paper-outline": c(62577),
  "ion-ios-list": c(62548),
  "ion-ios-list-outline": c(62547),
  "ion-ios-world": c(62675),
  "ion-ios-world-outline": c(62674),
  "ion-ios-alarm": c(62408),
  "ion-ios-alarm-outline": c(62407),
  "ion-ios-speedometer": c(62640),
  "ion-ios-speedometer-outline": c(62639),
  "ion-ios-stopwatch": c(62645),
  "ion-ios-stopwatch-outline": c(62644),
  "ion-ios-timer": c(62657),
  "ion-ios-timer-outline": c(62656),
  "ion-ios-clock": c(62467),
  "ion-ios-clock-outline": c(62466),
  "ion-ios-time": c(62655),
  "ion-ios-time-outline": c(62654),
  "ion-ios-calendar": c(62452),
  "ion-ios-calendar-outline": c(62451),
  "ion-ios-photos": c(62594),
  "ion-ios-photos-outline": c(62593),
  "ion-ios-albums": c(62410),
  "ion-ios-albums-outline": c(62409),
  "ion-ios-camera": c(62454),
  "ion-ios-camera-outline": c(62453),
  "ion-ios-reverse-camera": c(62623),
  "ion-ios-reverse-camera-outline": c(62622),
  "ion-ios-eye": c(62501),
  "ion-ios-eye-outline": c(62500),
  "ion-ios-bolt": c(62438),
  "ion-ios-bolt-outline": c(62437),
  "ion-ios-color-wand": c(62486),
  "ion-ios-color-wand-outline": c(62485),
  "ion-ios-color-filter": c(62484),
  "ion-ios-color-filter-outline": c(62483),
  "ion-ios-grid-view": c(62529),
  "ion-ios-grid-view-outline": c(62528),
  "ion-ios-crop-strong": c(62493),
  "ion-ios-crop": c(62494),
  "ion-ios-barcode": c(62428),
  "ion-ios-barcode-outline": c(62427),
  "ion-ios-briefcase": c(62446),
  "ion-ios-briefcase-outline": c(62445),
  "ion-ios-medkit": c(62558),
  "ion-ios-medkit-outline": c(62557),
  "ion-ios-medical": c(62556),
  "ion-ios-medical-outline": c(62555),
  "ion-ios-infinite": c(62538),
  "ion-ios-infinite-outline": c(62537),
  "ion-ios-calculator": c(62450),
  "ion-ios-calculator-outline": c(62449),
  "ion-ios-keypad": c(62544),
  "ion-ios-keypad-outline": c(62543),
  "ion-ios-telephone": c(62649),
  "ion-ios-telephone-outline": c(62648),
  "ion-ios-drag": c(62497),
  "ion-ios-location": c(62550),
  "ion-ios-location-outline": c(62549),
  "ion-ios-navigate": c(62574),
  "ion-ios-navigate-outline": c(62573),
  "ion-ios-locked": c(62552),
  "ion-ios-locked-outline": c(62551),
  "ion-ios-unlocked": c(62665),
  "ion-ios-unlocked-outline": c(62664),
  "ion-ios-monitor": c(62566),
  "ion-ios-monitor-outline": c(62565),
  "ion-ios-printer": c(62609),
  "ion-ios-printer-outline": c(62608),
  "ion-ios-game-controller-a": c(62521),
  "ion-ios-game-controller-a-outline": c(62520),
  "ion-ios-game-controller-b": c(62523),
  "ion-ios-game-controller-b-outline": c(62522),
  "ion-ios-americanfootball": c(62412),
  "ion-ios-americanfootball-outline": c(62411),
  "ion-ios-baseball": c(62430),
  "ion-ios-baseball-outline": c(62429),
  "ion-ios-basketball": c(62432),
  "ion-ios-basketball-outline": c(62431),
  "ion-ios-tennisball": c(62651),
  "ion-ios-tennisball-outline": c(62650),
  "ion-ios-football": c(62519),
  "ion-ios-football-outline": c(62518),
  "ion-ios-body": c(62436),
  "ion-ios-body-outline": c(62435),
  "ion-ios-person": c(62590),
  "ion-ios-person-outline": c(62589),
  "ion-ios-personadd": c(62592),
  "ion-ios-personadd-outline": c(62591),
  "ion-ios-people": c(62588),
  "ion-ios-people-outline": c(62587),
  "ion-ios-musical-notes": c(62572),
  "ion-ios-musical-note": c(62571),
  "ion-ios-bell": c(62434),
  "ion-ios-bell-outline": c(62433),
  "ion-ios-mic": c(62561),
  "ion-ios-mic-outline": c(62560),
  "ion-ios-mic-off": c(62559),
  "ion-ios-volume-high": c(62670),
  "ion-ios-volume-low": c(62671),
  "ion-ios-play": c(62600),
  "ion-ios-play-outline": c(62599),
  "ion-ios-pause": c(62584),
  "ion-ios-pause-outline": c(62583),
  "ion-ios-recording": c(62615),
  "ion-ios-recording-outline": c(62614),
  "ion-ios-fastforward": c(62503),
  "ion-ios-fastforward-outline": c(62502),
  "ion-ios-rewind": c(62625),
  "ion-ios-rewind-outline": c(62624),
  "ion-ios-skipbackward": c(62635),
  "ion-ios-skipbackward-outline": c(62634),
  "ion-ios-skipforward": c(62637),
  "ion-ios-skipforward-outline": c(62636),
  "ion-ios-shuffle-strong": c(62632),
  "ion-ios-shuffle": c(62633),
  "ion-ios-videocam": c(62669),
  "ion-ios-videocam-outline": c(62668),
  "ion-ios-film": c(62507),
  "ion-ios-film-outline": c(62506),
  "ion-ios-flask": c(62513),
  "ion-ios-flask-outline": c(62512),
  "ion-ios-lightbulb": c(62546),
  "ion-ios-lightbulb-outline": c(62545),
  "ion-ios-wineglass": c(62673),
  "ion-ios-wineglass-outline": c(62672),
  "ion-ios-pint": c(62598),
  "ion-ios-pint-outline": c(62597),
  "ion-ios-nutrition": c(62576),
  "ion-ios-nutrition-outline": c(62575),
  "ion-ios-flower": c(62515),
  "ion-ios-flower-outline": c(62514),
  "ion-ios-rose": c(62627),
  "ion-ios-rose-outline": c(62626),
  "ion-ios-paw": c(62586),
  "ion-ios-paw-outline": c(62585),
  "ion-ios-flame": c(62511),
  "ion-ios-flame-outline": c(62510),
  "ion-ios-sunny": c(62647),
  "ion-ios-sunny-outline": c(62646),
  "ion-ios-partlysunny": c(62582),
  "ion-ios-partlysunny-outline": c(62581),
  "ion-ios-cloudy": c(62480),
  "ion-ios-cloudy-outline": c(62479),
  "ion-ios-rainy": c(62613),
  "ion-ios-rainy-outline": c(62612),
  "ion-ios-thunderstorm": c(62653),
  "ion-ios-thunderstorm-outline": c(62652),
  "ion-ios-snowy": c(62638),
  "ion-ios-moon": c(62568),
  "ion-ios-moon-outline": c(62567),
  "ion-ios-cloudy-night": c(62478),
  "ion-ios-cloudy-night-outline": c(62477),
  "ion-android-arrow-up": c(62310),
  "ion-android-arrow-forward": c(62223),
  "ion-android-arrow-down": c(62301),
  "ion-android-arrow-back": c(62154),
  "ion-android-arrow-dropup": c(62309),
  "ion-android-arrow-dropup-circle": c(62308),
  "ion-android-arrow-dropright": c(62307),
  "ion-android-arrow-dropright-circle": c(62306),
  "ion-android-arrow-dropdown": c(62303),
  "ion-android-arrow-dropdown-circle": c(62302),
  "ion-android-arrow-dropleft": c(62305),
  "ion-android-arrow-dropleft-circle": c(62304),
  "ion-android-add": c(62151),
  "ion-android-add-circle": c(62297),
  "ion-android-remove": c(62196),
  "ion-android-remove-circle": c(62377),
  "ion-android-close": c(62167),
  "ion-android-cancel": c(62318),
  "ion-android-radio-button-off": c(62374),
  "ion-android-radio-button-on": c(62375),
  "ion-android-checkmark-circle": c(62325),
  "ion-android-checkbox-outline-blank": c(62322),
  "ion-android-checkbox-outline": c(62323),
  "ion-android-checkbox-blank": c(62321),
  "ion-android-checkbox": c(62324),
  "ion-android-done": c(62339),
  "ion-android-done-all": c(62338),
  "ion-android-menu": c(62356),
  "ion-android-more-horizontal": c(62358),
  "ion-android-more-vertical": c(62359),
  "ion-android-refresh": c(62376),
  "ion-android-sync": c(62385),
  "ion-android-wifi": c(62213),
  "ion-android-call": c(62162),
  "ion-android-apps": c(62300),
  "ion-android-settings": c(62199),
  "ion-android-options": c(62365),
  "ion-android-funnel": c(62347),
  "ion-android-search": c(62197),
  "ion-android-home": c(62351),
  "ion-android-cloud-outline": c(62329),
  "ion-android-cloud": c(62330),
  "ion-android-download": c(62173),
  "ion-android-upload": c(62390),
  "ion-android-cloud-done": c(62328),
  "ion-android-cloud-circle": c(62327),
  "ion-android-favorite-outline": c(62343),
  "ion-android-favorite": c(62344),
  "ion-android-star-outline": c(62382),
  "ion-android-star-half": c(62381),
  "ion-android-star": c(62204),
  "ion-android-calendar": c(62161),
  "ion-android-alarm-clock": c(62298),
  "ion-android-time": c(62387),
  "ion-android-stopwatch": c(62205),
  "ion-android-watch": c(62397),
  "ion-android-locate": c(62185),
  "ion-android-navigate": c(62360),
  "ion-android-pin": c(62371),
  "ion-android-compass": c(62332),
  "ion-android-map": c(62355),
  "ion-android-walk": c(62395),
  "ion-android-bicycle": c(62313),
  "ion-android-car": c(62319),
  "ion-android-bus": c(62317),
  "ion-android-subway": c(62383),
  "ion-android-train": c(62388),
  "ion-android-boat": c(62314),
  "ion-android-plane": c(62372),
  "ion-android-restaurant": c(62378),
  "ion-android-bar": c(62312),
  "ion-android-cart": c(62320),
  "ion-android-camera": c(62163),
  "ion-android-image": c(62180),
  "ion-android-film": c(62345),
  "ion-android-color-palette": c(62331),
  "ion-android-create": c(62334),
  "ion-android-mail": c(62187),
  "ion-android-drafts": c(62340),
  "ion-android-send": c(62198),
  "ion-android-archive": c(62153),
  "ion-android-delete": c(62335),
  "ion-android-attach": c(62311),
  "ion-android-share": c(62200),
  "ion-android-share-alt": c(62380),
  "ion-android-bookmark": c(62315),
  "ion-android-document": c(62337),
  "ion-android-clipboard": c(62326),
  "ion-android-list": c(62353),
  "ion-android-folder-open": c(62346),
  "ion-android-folder": c(62176),
  "ion-android-print": c(62373),
  "ion-android-open": c(62364),
  "ion-android-exit": c(62341),
  "ion-android-contract": c(62333),
  "ion-android-expand": c(62342),
  "ion-android-globe": c(62348),
  "ion-android-chat": c(62164),
  "ion-android-textsms": c(62386),
  "ion-android-hangout": c(62349),
  "ion-android-happy": c(62350),
  "ion-android-sad": c(62379),
  "ion-android-person": c(62368),
  "ion-android-people": c(62366),
  "ion-android-person-add": c(62367),
  "ion-android-contact": c(62168),
  "ion-android-contacts": c(62169),
  "ion-android-playstore": c(62192),
  "ion-android-lock": c(62354),
  "ion-android-unlock": c(62389),
  "ion-android-microphone": c(62188),
  "ion-android-microphone-off": c(62357),
  "ion-android-notifications-none": c(62361),
  "ion-android-notifications": c(62363),
  "ion-android-notifications-off": c(62362),
  "ion-android-volume-mute": c(62392),
  "ion-android-volume-down": c(62391),
  "ion-android-volume-up": c(62394),
  "ion-android-volume-off": c(62393),
  "ion-android-hand": c(62179),
  "ion-android-desktop": c(62336),
  "ion-android-laptop": c(62352),
  "ion-android-phone-portrait": c(62370),
  "ion-android-phone-landscape": c(62369),
  "ion-android-bulb": c(62316),
  "ion-android-sunny": c(62384),
  "ion-android-alert": c(62299),
  "ion-android-warning": c(62396),
  "ion-social-twitter": c(62019),
  "ion-social-twitter-outline": c(62018),
  "ion-social-facebook": c(62001),
  "ion-social-facebook-outline": c(62000),
  "ion-social-googleplus": c(62005),
  "ion-social-googleplus-outline": c(62004),
  "ion-social-google": c(62287),
  "ion-social-google-outline": c(62286),
  "ion-social-dribbble": c(61997),
  "ion-social-dribbble-outline": c(61996),
  "ion-social-octocat": c(62696),
  "ion-social-github": c(62003),
  "ion-social-github-outline": c(62002),
  "ion-social-instagram": c(62289),
  "ion-social-instagram-outline": c(62288),
  "ion-social-whatsapp": c(62704),
  "ion-social-whatsapp-outline": c(62703),
  "ion-social-snapchat": c(62700),
  "ion-social-snapchat-outline": c(62699),
  "ion-social-foursquare": c(62285),
  "ion-social-foursquare-outline": c(62284),
  "ion-social-pinterest": c(62129),
  "ion-social-pinterest-outline": c(62128),
  "ion-social-rss": c(62013),
  "ion-social-rss-outline": c(62012),
  "ion-social-tumblr": c(62017),
  "ion-social-tumblr-outline": c(62016),
  "ion-social-wordpress": c(62025),
  "ion-social-wordpress-outline": c(62024),
  "ion-social-reddit": c(62011),
  "ion-social-reddit-outline": c(62010),
  "ion-social-hackernews": c(62007),
  "ion-social-hackernews-outline": c(62006),
  "ion-social-designernews": c(61995),
  "ion-social-designernews-outline": c(61994),
  "ion-social-yahoo": c(62027),
  "ion-social-yahoo-outline": c(62026),
  "ion-social-buffer": c(61993),
  "ion-social-buffer-outline": c(61992),
  "ion-social-skype": c(62015),
  "ion-social-skype-outline": c(62014),
  "ion-social-linkedin": c(62009),
  "ion-social-linkedin-outline": c(62008),
  "ion-social-vimeo": c(62021),
  "ion-social-vimeo-outline": c(62020),
  "ion-social-twitch": c(62702),
  "ion-social-twitch-outline": c(62701),
  "ion-social-youtube": c(62029),
  "ion-social-youtube-outline": c(62028),
  "ion-social-dropbox": c(61999),
  "ion-social-dropbox-outline": c(61998),
  "ion-social-apple": c(61991),
  "ion-social-apple-outline": c(61990),
  "ion-social-android": c(61989),
  "ion-social-android-outline": c(61988),
  "ion-social-windows": c(62023),
  "ion-social-windows-outline": c(62022),
  "ion-social-html5": c(62691),
  "ion-social-html5-outline": c(62690),
  "ion-social-css3": c(62687),
  "ion-social-css3-outline": c(62686),
  "ion-social-javascript": c(62693),
  "ion-social-javascript-outline": c(62692),
  "ion-social-angular": c(62681),
  "ion-social-angular-outline": c(62680),
  "ion-social-nodejs": c(62695),
  "ion-social-sass": c(62698),
  "ion-social-python": c(62697),
  "ion-social-chrome": c(62683),
  "ion-social-chrome-outline": c(62682),
  "ion-social-codepen": c(62685),
  "ion-social-codepen-outline": c(62684),
  "ion-social-markdown": c(62694),
  "ion-social-tux": c(62149),
  "ion-social-freebsd-devil": c(62148),
  "ion-social-usd": c(62291),
  "ion-social-usd-outline": c(62290),
  "ion-social-bitcoin": c(62127),
  "ion-social-bitcoin-outline": c(62126),
  "ion-social-yen": c(62706),
  "ion-social-yen-outline": c(62705),
  "ion-social-euro": c(62689),
  "ion-social-euro-outline": c(62688)
};

exports.default = icons;

},{}],276:[function(require,module,exports){
"use strict";

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getStorage = function getStorage(storage) {
    return {
        read: function read(name, defaultValue) {
            var value = storage.getItem(name);
            if (value === null) {
                return defaultValue;
            }
            return JSON.parse(value);
        },
        write: function write(name, value) {
            storage.setItem(name, (0, _stringify2.default)(value));
        },
        has: function has(name) {
            return storage.getItem(name) !== null;
        },
        remove: function remove(name) {
            storage.removeItem(name);
        },
        clear: function clear() {
            storage.clear();
        }
    };
};

window.AppSettings = getStorage(localStorage);
window.AppSession = getStorage(sessionStorage);

},{"babel-runtime/core-js/json/stringify":283}],277:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CSS = exports.genCSS = exports.createStyleSheet = undefined;

var _freeze = require("babel-runtime/core-js/object/freeze");

var _freeze2 = _interopRequireDefault(_freeze);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _defineProperty2 = require("babel-runtime/helpers/defineProperty");

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require("babel-runtime/core-js/object/entries");

var _entries2 = _interopRequireDefault(_entries);

var _set = require("babel-runtime/core-js/set");

var _set2 = _interopRequireDefault(_set);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cssNoMeasurement = new _set2.default(["animationIterationCount", "boxFlex", "boxFlexGroup", "boxOrdinalGroup", "columnCount", "fillOpacity", "flex", "flexGrow", "flexPositive", "flexShrink", "flexNegative", "flexOrder", "fontWeight", "lineClamp", "lineHeight", "opacity", "order", "orphans", "stopOpacity", "strokeDashoffset", "strokeOpacity", "strokeWidth", "tabSize", "widows", "zIndex", "zoom"]);
var cssPrefixNames = new _set2.default(['transform', 'transformOrigin', 'boxShadow', 'transition', 'animation', 'animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction', 'userSelect', 'justifyContent', 'alignItems', 'flexWrap']);
var cssPrefixes = ['-webkit-', '-moz-', '-ms-', '-o-', ''];

var getCSSValue = function getCSSValue(prop, value) {
    if (value === null) {
        return null;
    }
    if (typeof value === 'function') {
        value = value();
    }
    if (Array.isArray(value) === true) {
        return value.map(function (value) {
            return getCSSValue(prop, value)[0];
        });
    }
    if (typeof value === 'number' && cssNoMeasurement.has(prop) === false) {
        value += "px";
    }
    return [value];
};

var genCSS = function genCSS(defs) {
    var tabs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var space = '\t'.repeat(tabs);
    return (0, _entries2.default)(defs).reduce(function (css, _ref) {
        var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            selector = _ref2[0],
            cssProps = _ref2[1];

        var content = (0, _entries2.default)(cssProps).reduce(function (contentArray, _ref3) {
            var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
                propName = _ref4[0],
                propValue = _ref4[1];

            var lines = [];
            if (Array.isArray(propValue) === false && (typeof propValue === "undefined" ? "undefined" : (0, _typeof3.default)(propValue)) === 'object') {
                lines = [genCSS((0, _defineProperty3.default)({}, propName, propValue), tabs + 1)];
            } else {
                var value = getCSSValue(propName, propValue);
                var cssPropName = propName.replace(/[A-Z]/g, function (letter) {
                    return '-' + letter.toLowerCase();
                });

                if (cssPrefixNames.has(propName) === true) {
                    lines = cssPrefixes.map(function (prefix) {
                        return space + "\t" + prefix + cssPropName + ": " + value[0] + ";";
                    });
                } else {
                    lines = value.map(function (value) {
                        return space + "\t" + cssPropName + ": " + value + ";";
                    });
                }
            }

            return [].concat((0, _toConsumableArray3.default)(contentArray), (0, _toConsumableArray3.default)(lines));
        }, []).join('\n');
        if (selector.slice(0, 10) === "@keyframes") {
            css.push(space + "@-webkit-keyframes " + selector.slice(11) + " {\n" + content + "\n" + space + "}");
        }
        css.push("" + space + selector + " {\n" + content + "\n" + space + "}");
        return css;
    }, []).join('\n');
};
var createStyleSheet = function createStyleSheet() {
    var styles = {};
    return {
        addStyles: function addStyles(defs) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)((0, _entries2.default)(defs)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _step$value = (0, _slicedToArray3.default)(_step.value, 2),
                        selector = _step$value[0],
                        def = _step$value[1];

                    styles[selector] = def;
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        },
        __init: function __init(styleTag) {
            styleTag.innerHTML = genCSS(styles);
        }
    };
};

var CSS = (0, _freeze2.default)({
    rgba: function rgba(r, g, b, a) {
        return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
    },
    rgb: function rgb(r, g, b) {
        return CSS.rgba(r, g, b, 1);
    }
});

exports.createStyleSheet = createStyleSheet;
exports.genCSS = genCSS;
exports.CSS = CSS;

},{"babel-runtime/core-js/get-iterator":281,"babel-runtime/core-js/object/entries":288,"babel-runtime/core-js/object/freeze":289,"babel-runtime/core-js/set":295,"babel-runtime/helpers/defineProperty":299,"babel-runtime/helpers/slicedToArray":304,"babel-runtime/helpers/toConsumableArray":305,"babel-runtime/helpers/typeof":306}],278:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var theme = {
    general: {
        boxShadow: '0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2)'
    },
    button: {
        text: {
            color: 'black'
        }
    }
};

exports.default = theme;

},{}],279:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.warningFunc = undefined;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var warningFunc = function warningFunc(errorMessage) {
    return function () {
        return console.warn(errorMessage);
    };
};

window.range = {
    array: function array(start) {
        var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var f = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var arr = [];

        if (f === null) {
            if (typeof end === 'function') {
                f = end;
                end = null;
            } else {
                f = function f(i) {
                    return i;
                };
            }
        }
        if (end === null) {
            end = start;
            start = 0;
        }

        while (start < end) {
            arr.push(f(start));
            start += 1;
        }

        return arr;
    },
    gen: _regenerator2.default.mark(function gen(start) {
        var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var f = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        return _regenerator2.default.wrap(function gen$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        if (f === null) {
                            if (typeof end === 'function') {
                                f = end;
                                end = null;
                            } else {
                                f = function f(i) {
                                    return i;
                                };
                            }
                        }
                        if (end === null) {
                            end = start;
                            start = 0;
                        }

                    case 2:
                        if (!(start < end)) {
                            _context.next = 8;
                            break;
                        }

                        _context.next = 5;
                        return f(start);

                    case 5:
                        start += 1;
                        _context.next = 2;
                        break;

                    case 8:
                    case 'end':
                        return _context.stop();
                }
            }
        }, gen, this);
    })
};

exports.warningFunc = warningFunc;

},{"babel-runtime/regenerator":307}],280:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":309}],281:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":310}],282:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/is-iterable"), __esModule: true };
},{"core-js/library/fn/is-iterable":311}],283:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/json/stringify"), __esModule: true };
},{"core-js/library/fn/json/stringify":312}],284:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":313}],285:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":314}],286:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":315}],287:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":316}],288:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/entries"), __esModule: true };
},{"core-js/library/fn/object/entries":317}],289:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/freeze"), __esModule: true };
},{"core-js/library/fn/object/freeze":318}],290:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/get-prototype-of":319}],291:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":320}],292:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":321}],293:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/values"), __esModule: true };
},{"core-js/library/fn/object/values":322}],294:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":323}],295:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":324}],296:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":325}],297:[function(require,module,exports){
"use strict";

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      var callNext = step.bind(null, "next");
      var callThrow = step.bind(null, "throw");

      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          _promise2.default.resolve(value).then(callNext, callThrow);
        }
      }

      callNext();
    });
  };
};

exports.__esModule = true;
},{"babel-runtime/core-js/promise":294}],298:[function(require,module,exports){
"use strict";

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

exports.__esModule = true;
},{}],299:[function(require,module,exports){
"use strict";

var _defineProperty = require("babel-runtime/core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/define-property":287}],300:[function(require,module,exports){
"use strict";

var _Object$assign = require("babel-runtime/core-js/object/assign")["default"];

exports["default"] = _Object$assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/assign":285}],301:[function(require,module,exports){
"use strict";

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = require("babel-runtime/core-js/object/set-prototype-of")["default"];

exports["default"] = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

exports.__esModule = true;
},{"babel-runtime/core-js/object/create":286,"babel-runtime/core-js/object/set-prototype-of":292}],302:[function(require,module,exports){
"use strict";

exports.default = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

exports.__esModule = true;
},{}],303:[function(require,module,exports){
"use strict";

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

exports.__esModule = true;
},{"babel-runtime/helpers/typeof":306}],304:[function(require,module,exports){
"use strict";

var _isIterable2 = require("babel-runtime/core-js/is-iterable");

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
})();

exports.__esModule = true;
},{"babel-runtime/core-js/get-iterator":281,"babel-runtime/core-js/is-iterable":282}],305:[function(require,module,exports){
"use strict";

var _from = require("babel-runtime/core-js/array/from");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

exports.__esModule = true;
},{"babel-runtime/core-js/array/from":280}],306:[function(require,module,exports){
"use strict";

var _Symbol = require("babel-runtime/core-js/symbol")["default"];

exports["default"] = function (obj) {
  return obj && obj.constructor === _Symbol ? "symbol" : typeof obj;
};

exports.__esModule = true;
},{"babel-runtime/core-js/symbol":296}],307:[function(require,module,exports){
(function (global){
// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

module.exports = { "default": module.exports, __esModule: true };

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./runtime":308}],308:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

"use strict";

var _Symbol = require("babel-runtime/core-js/symbol")["default"];

var _Object$create = require("babel-runtime/core-js/object/create")["default"];

var _Object$setPrototypeOf = require("babel-runtime/core-js/object/set-prototype-of")["default"];

var _Promise = require("babel-runtime/core-js/promise")["default"];

!(function (global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof _Symbol === "function" ? _Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = _Object$create((outerFn || Generator).prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (_Object$setPrototypeOf) {
      _Object$setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = _Object$create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function (arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value instanceof AwaitArgument) {
          return _Promise.resolve(value.arg).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return _Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new _Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            context.sent = undefined;
          }
        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }
        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":1,"babel-runtime/core-js/object/create":286,"babel-runtime/core-js/object/set-prototype-of":292,"babel-runtime/core-js/promise":294,"babel-runtime/core-js/symbol":296}],309:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/$.core').Array.from;
},{"../../modules/$.core":334,"../../modules/es6.array.from":387,"../../modules/es6.string.iterator":398}],310:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');
},{"../modules/core.get-iterator":385,"../modules/es6.string.iterator":398,"../modules/web.dom.iterable":404}],311:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.is-iterable');
},{"../modules/core.is-iterable":386,"../modules/es6.string.iterator":398,"../modules/web.dom.iterable":404}],312:[function(require,module,exports){
var core = require('../../modules/$.core');
module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
  return (core.JSON && core.JSON.stringify || JSON.stringify).apply(JSON, arguments);
};
},{"../../modules/$.core":334}],313:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
require('../modules/es7.map.to-json');
module.exports = require('../modules/$.core').Map;
},{"../modules/$.core":334,"../modules/es6.map":389,"../modules/es6.object.to-string":395,"../modules/es6.string.iterator":398,"../modules/es7.map.to-json":400,"../modules/web.dom.iterable":404}],314:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/$.core').Object.assign;
},{"../../modules/$.core":334,"../../modules/es6.object.assign":390}],315:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function create(P, D){
  return $.create(P, D);
};
},{"../../modules/$":359}],316:[function(require,module,exports){
var $ = require('../../modules/$');
module.exports = function defineProperty(it, key, desc){
  return $.setDesc(it, key, desc);
};
},{"../../modules/$":359}],317:[function(require,module,exports){
require('../../modules/es7.object.entries');
module.exports = require('../../modules/$.core').Object.entries;
},{"../../modules/$.core":334,"../../modules/es7.object.entries":401}],318:[function(require,module,exports){
require('../../modules/es6.object.freeze');
module.exports = require('../../modules/$.core').Object.freeze;
},{"../../modules/$.core":334,"../../modules/es6.object.freeze":391}],319:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/$.core').Object.getPrototypeOf;
},{"../../modules/$.core":334,"../../modules/es6.object.get-prototype-of":392}],320:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/$.core').Object.keys;
},{"../../modules/$.core":334,"../../modules/es6.object.keys":393}],321:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/$.core').Object.setPrototypeOf;
},{"../../modules/$.core":334,"../../modules/es6.object.set-prototype-of":394}],322:[function(require,module,exports){
require('../../modules/es7.object.values');
module.exports = require('../../modules/$.core').Object.values;
},{"../../modules/$.core":334,"../../modules/es7.object.values":402}],323:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
module.exports = require('../modules/$.core').Promise;
},{"../modules/$.core":334,"../modules/es6.object.to-string":395,"../modules/es6.promise":396,"../modules/es6.string.iterator":398,"../modules/web.dom.iterable":404}],324:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
module.exports = require('../modules/$.core').Set;
},{"../modules/$.core":334,"../modules/es6.object.to-string":395,"../modules/es6.set":397,"../modules/es6.string.iterator":398,"../modules/es7.set.to-json":403,"../modules/web.dom.iterable":404}],325:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
module.exports = require('../../modules/$.core').Symbol;
},{"../../modules/$.core":334,"../../modules/es6.object.to-string":395,"../../modules/es6.symbol":399}],326:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],327:[function(require,module,exports){
module.exports = function(){ /* empty */ };
},{}],328:[function(require,module,exports){
var isObject = require('./$.is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./$.is-object":352}],329:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./$.cof')
  , TAG = require('./$.wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./$.cof":330,"./$.wks":383}],330:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],331:[function(require,module,exports){
'use strict';
var $            = require('./$')
  , hide         = require('./$.hide')
  , redefineAll  = require('./$.redefine-all')
  , ctx          = require('./$.ctx')
  , strictNew    = require('./$.strict-new')
  , defined      = require('./$.defined')
  , forOf        = require('./$.for-of')
  , $iterDefine  = require('./$.iter-define')
  , step         = require('./$.iter-step')
  , ID           = require('./$.uid')('id')
  , $has         = require('./$.has')
  , isObject     = require('./$.is-object')
  , setSpecies   = require('./$.set-species')
  , DESCRIPTORS  = require('./$.descriptors')
  , isExtensible = Object.isExtensible || isObject
  , SIZE         = DESCRIPTORS ? '_s' : 'size'
  , id           = 0;

var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!$has(it, ID)){
    // can't set id to frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add id
    if(!create)return 'E';
    // add missing object id
    hide(it, ID, ++id);
  // return object id with prefix
  } return 'O' + it[ID];
};

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      strictNew(that, C, NAME);
      that._i = $.create(null); // index
      that._f = undefined;      // first entry
      that._l = undefined;      // last entry
      that[SIZE] = 0;           // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./$":359,"./$.ctx":335,"./$.defined":336,"./$.descriptors":337,"./$.for-of":342,"./$.has":345,"./$.hide":346,"./$.is-object":352,"./$.iter-define":355,"./$.iter-step":357,"./$.redefine-all":367,"./$.set-species":371,"./$.strict-new":375,"./$.uid":382}],332:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var forOf   = require('./$.for-of')
  , classof = require('./$.classof');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    var arr = [];
    forOf(this, false, arr.push, arr);
    return arr;
  };
};
},{"./$.classof":329,"./$.for-of":342}],333:[function(require,module,exports){
'use strict';
var $              = require('./$')
  , global         = require('./$.global')
  , $export        = require('./$.export')
  , fails          = require('./$.fails')
  , hide           = require('./$.hide')
  , redefineAll    = require('./$.redefine-all')
  , forOf          = require('./$.for-of')
  , strictNew      = require('./$.strict-new')
  , isObject       = require('./$.is-object')
  , setToStringTag = require('./$.set-to-string-tag')
  , DESCRIPTORS    = require('./$.descriptors');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
  } else {
    C = wrapper(function(target, iterable){
      strictNew(target, C, NAME);
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)$.setDesc(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./$":359,"./$.descriptors":337,"./$.export":340,"./$.fails":341,"./$.for-of":342,"./$.global":344,"./$.hide":346,"./$.is-object":352,"./$.redefine-all":367,"./$.set-to-string-tag":372,"./$.strict-new":375}],334:[function(require,module,exports){
var core = module.exports = {version: '1.2.6'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],335:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./$.a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./$.a-function":326}],336:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],337:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./$.fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./$.fails":341}],338:[function(require,module,exports){
var isObject = require('./$.is-object')
  , document = require('./$.global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./$.global":344,"./$.is-object":352}],339:[function(require,module,exports){
// all enumerable object keys, includes symbols
var $ = require('./$');
module.exports = function(it){
  var keys       = $.getKeys(it)
    , getSymbols = $.getSymbols;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = $.isEnum
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);
  }
  return keys;
};
},{"./$":359}],340:[function(require,module,exports){
var global    = require('./$.global')
  , core      = require('./$.core')
  , ctx       = require('./$.ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && key in target;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(param){
        return this instanceof C ? new C(param) : C(param);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
  }
};
// type bitmap
$export.F = 1;  // forced
$export.G = 2;  // global
$export.S = 4;  // static
$export.P = 8;  // proto
$export.B = 16; // bind
$export.W = 32; // wrap
module.exports = $export;
},{"./$.core":334,"./$.ctx":335,"./$.global":344}],341:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],342:[function(require,module,exports){
var ctx         = require('./$.ctx')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , anObject    = require('./$.an-object')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
module.exports = function(iterable, entries, fn, that){
  var iterFn = getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    call(iterator, f, step.value, entries);
  }
};
},{"./$.an-object":328,"./$.ctx":335,"./$.is-array-iter":350,"./$.iter-call":353,"./$.to-length":380,"./core.get-iterator-method":384}],343:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./$.to-iobject')
  , getNames  = require('./$').getNames
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return getNames(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.get = function getOwnPropertyNames(it){
  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);
  return getNames(toIObject(it));
};
},{"./$":359,"./$.to-iobject":379}],344:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],345:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],346:[function(require,module,exports){
var $          = require('./$')
  , createDesc = require('./$.property-desc');
module.exports = require('./$.descriptors') ? function(object, key, value){
  return $.setDesc(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./$":359,"./$.descriptors":337,"./$.property-desc":366}],347:[function(require,module,exports){
module.exports = require('./$.global').document && document.documentElement;
},{"./$.global":344}],348:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],349:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./$.cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./$.cof":330}],350:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./$.iterators')
  , ITERATOR   = require('./$.wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./$.iterators":358,"./$.wks":383}],351:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./$.cof');
module.exports = Array.isArray || function(arg){
  return cof(arg) == 'Array';
};
},{"./$.cof":330}],352:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],353:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./$.an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./$.an-object":328}],354:[function(require,module,exports){
'use strict';
var $              = require('./$')
  , descriptor     = require('./$.property-desc')
  , setToStringTag = require('./$.set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./$.hide')(IteratorPrototype, require('./$.wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./$":359,"./$.hide":346,"./$.property-desc":366,"./$.set-to-string-tag":372,"./$.wks":383}],355:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./$.library')
  , $export        = require('./$.export')
  , redefine       = require('./$.redefine')
  , hide           = require('./$.hide')
  , has            = require('./$.has')
  , Iterators      = require('./$.iterators')
  , $iterCreate    = require('./$.iter-create')
  , setToStringTag = require('./$.set-to-string-tag')
  , getProto       = require('./$').getProto
  , ITERATOR       = require('./$.wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , methods, key;
  // Fix native
  if($native){
    var IteratorPrototype = getProto($default.call(new Base));
    // Set @@toStringTag to native iterators
    setToStringTag(IteratorPrototype, TAG, true);
    // FF fix
    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    // fix Array#{values, @@iterator}.name in V8 / FF
    if(DEF_VALUES && $native.name !== VALUES){
      VALUES_BUG = true;
      $default = function values(){ return $native.call(this); };
    }
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES  ? $default : getMethod(VALUES),
      keys:    IS_SET      ? $default : getMethod(KEYS),
      entries: !DEF_VALUES ? $default : getMethod('entries')
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./$":359,"./$.export":340,"./$.has":345,"./$.hide":346,"./$.iter-create":354,"./$.iterators":358,"./$.library":361,"./$.redefine":368,"./$.set-to-string-tag":372,"./$.wks":383}],356:[function(require,module,exports){
var ITERATOR     = require('./$.wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ safe = true; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./$.wks":383}],357:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],358:[function(require,module,exports){
module.exports = {};
},{}],359:[function(require,module,exports){
var $Object = Object;
module.exports = {
  create:     $Object.create,
  getProto:   $Object.getPrototypeOf,
  isEnum:     {}.propertyIsEnumerable,
  getDesc:    $Object.getOwnPropertyDescriptor,
  setDesc:    $Object.defineProperty,
  setDescs:   $Object.defineProperties,
  getKeys:    $Object.keys,
  getNames:   $Object.getOwnPropertyNames,
  getSymbols: $Object.getOwnPropertySymbols,
  each:       [].forEach
};
},{}],360:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = $.getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./$":359,"./$.to-iobject":379}],361:[function(require,module,exports){
module.exports = true;
},{}],362:[function(require,module,exports){
var global    = require('./$.global')
  , macrotask = require('./$.task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = require('./$.cof')(process) == 'process'
  , head, last, notify;

var flush = function(){
  var parent, domain, fn;
  if(isNode && (parent = process.domain)){
    process.domain = null;
    parent.exit();
  }
  while(head){
    domain = head.domain;
    fn     = head.fn;
    if(domain)domain.enter();
    fn(); // <- currently we use it only for Promise - try / catch not required
    if(domain)domain.exit();
    head = head.next;
  } last = undefined;
  if(parent)parent.enter();
};

// Node.js
if(isNode){
  notify = function(){
    process.nextTick(flush);
  };
// browsers with MutationObserver
} else if(Observer){
  var toggle = 1
    , node   = document.createTextNode('');
  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
  notify = function(){
    node.data = toggle = -toggle;
  };
// environments with maybe non-completely correct, but existent Promise
} else if(Promise && Promise.resolve){
  notify = function(){
    Promise.resolve().then(flush);
  };
// for other environments - macrotask based on:
// - setImmediate
// - MessageChannel
// - window.postMessag
// - onreadystatechange
// - setTimeout
} else {
  notify = function(){
    // strange IE + webpack dev server bug - use .call(global)
    macrotask.call(global, flush);
  };
}

module.exports = function asap(fn){
  var task = {fn: fn, next: undefined, domain: isNode && process.domain};
  if(last)last.next = task;
  if(!head){
    head = task;
    notify();
  } last = task;
};
},{"./$.cof":330,"./$.global":344,"./$.task":377}],363:[function(require,module,exports){
// 19.1.2.1 Object.assign(target, source, ...)
var $        = require('./$')
  , toObject = require('./$.to-object')
  , IObject  = require('./$.iobject');

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = require('./$.fails')(function(){
  var a = Object.assign
    , A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , $$    = arguments
    , $$len = $$.length
    , index = 1
    , getKeys    = $.getKeys
    , getSymbols = $.getSymbols
    , isEnum     = $.isEnum;
  while($$len > index){
    var S      = IObject($$[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  }
  return T;
} : Object.assign;
},{"./$":359,"./$.fails":341,"./$.iobject":349,"./$.to-object":381}],364:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./$.export')
  , core    = require('./$.core')
  , fails   = require('./$.fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./$.core":334,"./$.export":340,"./$.fails":341}],365:[function(require,module,exports){
var $         = require('./$')
  , toIObject = require('./$.to-iobject')
  , isEnum    = $.isEnum;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = $.getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};
},{"./$":359,"./$.to-iobject":379}],366:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],367:[function(require,module,exports){
var redefine = require('./$.redefine');
module.exports = function(target, src){
  for(var key in src)redefine(target, key, src[key]);
  return target;
};
},{"./$.redefine":368}],368:[function(require,module,exports){
module.exports = require('./$.hide');
},{"./$.hide":346}],369:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],370:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var getDesc  = require('./$').getDesc
  , isObject = require('./$.is-object')
  , anObject = require('./$.an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./$":359,"./$.an-object":328,"./$.ctx":335,"./$.is-object":352}],371:[function(require,module,exports){
'use strict';
var core        = require('./$.core')
  , $           = require('./$')
  , DESCRIPTORS = require('./$.descriptors')
  , SPECIES     = require('./$.wks')('species');

module.exports = function(KEY){
  var C = core[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./$":359,"./$.core":334,"./$.descriptors":337,"./$.wks":383}],372:[function(require,module,exports){
var def = require('./$').setDesc
  , has = require('./$.has')
  , TAG = require('./$.wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./$":359,"./$.has":345,"./$.wks":383}],373:[function(require,module,exports){
var global = require('./$.global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./$.global":344}],374:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = require('./$.an-object')
  , aFunction = require('./$.a-function')
  , SPECIES   = require('./$.wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./$.a-function":326,"./$.an-object":328,"./$.wks":383}],375:[function(require,module,exports){
module.exports = function(it, Constructor, name){
  if(!(it instanceof Constructor))throw TypeError(name + ": use the 'new' operator!");
  return it;
};
},{}],376:[function(require,module,exports){
var toInteger = require('./$.to-integer')
  , defined   = require('./$.defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./$.defined":336,"./$.to-integer":378}],377:[function(require,module,exports){
var ctx                = require('./$.ctx')
  , invoke             = require('./$.invoke')
  , html               = require('./$.html')
  , cel                = require('./$.dom-create')
  , global             = require('./$.global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listner = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./$.cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listner, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./$.cof":330,"./$.ctx":335,"./$.dom-create":338,"./$.global":344,"./$.html":347,"./$.invoke":348}],378:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],379:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./$.iobject')
  , defined = require('./$.defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./$.defined":336,"./$.iobject":349}],380:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./$.to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./$.to-integer":378}],381:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./$.defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./$.defined":336}],382:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],383:[function(require,module,exports){
var store  = require('./$.shared')('wks')
  , uid    = require('./$.uid')
  , Symbol = require('./$.global').Symbol;
module.exports = function(name){
  return store[name] || (store[name] =
    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
};
},{"./$.global":344,"./$.shared":373,"./$.uid":382}],384:[function(require,module,exports){
var classof   = require('./$.classof')
  , ITERATOR  = require('./$.wks')('iterator')
  , Iterators = require('./$.iterators');
module.exports = require('./$.core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./$.classof":329,"./$.core":334,"./$.iterators":358,"./$.wks":383}],385:[function(require,module,exports){
var anObject = require('./$.an-object')
  , get      = require('./core.get-iterator-method');
module.exports = require('./$.core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./$.an-object":328,"./$.core":334,"./core.get-iterator-method":384}],386:[function(require,module,exports){
var classof   = require('./$.classof')
  , ITERATOR  = require('./$.wks')('iterator')
  , Iterators = require('./$.iterators');
module.exports = require('./$.core').isIterable = function(it){
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    || Iterators.hasOwnProperty(classof(O));
};
},{"./$.classof":329,"./$.core":334,"./$.iterators":358,"./$.wks":383}],387:[function(require,module,exports){
'use strict';
var ctx         = require('./$.ctx')
  , $export     = require('./$.export')
  , toObject    = require('./$.to-object')
  , call        = require('./$.iter-call')
  , isArrayIter = require('./$.is-array-iter')
  , toLength    = require('./$.to-length')
  , getIterFn   = require('./core.get-iterator-method');
$export($export.S + $export.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , $$      = arguments
      , $$len   = $$.length
      , mapfn   = $$len > 1 ? $$[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        result[index] = mapping ? mapfn(O[index], index) : O[index];
      }
    }
    result.length = index;
    return result;
  }
});

},{"./$.ctx":335,"./$.export":340,"./$.is-array-iter":350,"./$.iter-call":353,"./$.iter-detect":356,"./$.to-length":380,"./$.to-object":381,"./core.get-iterator-method":384}],388:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./$.add-to-unscopables')
  , step             = require('./$.iter-step')
  , Iterators        = require('./$.iterators')
  , toIObject        = require('./$.to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./$.iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./$.add-to-unscopables":327,"./$.iter-define":355,"./$.iter-step":357,"./$.iterators":358,"./$.to-iobject":379}],389:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.1 Map Objects
require('./$.collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./$.collection":333,"./$.collection-strong":331}],390:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./$.export');

$export($export.S + $export.F, 'Object', {assign: require('./$.object-assign')});
},{"./$.export":340,"./$.object-assign":363}],391:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./$.is-object');

require('./$.object-sap')('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(it) : it;
  };
});
},{"./$.is-object":352,"./$.object-sap":364}],392:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./$.to-object');

require('./$.object-sap')('getPrototypeOf', function($getPrototypeOf){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});
},{"./$.object-sap":364,"./$.to-object":381}],393:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./$.to-object');

require('./$.object-sap')('keys', function($keys){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./$.object-sap":364,"./$.to-object":381}],394:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./$.export');
$export($export.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});
},{"./$.export":340,"./$.set-proto":370}],395:[function(require,module,exports){

},{}],396:[function(require,module,exports){
'use strict';
var $          = require('./$')
  , LIBRARY    = require('./$.library')
  , global     = require('./$.global')
  , ctx        = require('./$.ctx')
  , classof    = require('./$.classof')
  , $export    = require('./$.export')
  , isObject   = require('./$.is-object')
  , anObject   = require('./$.an-object')
  , aFunction  = require('./$.a-function')
  , strictNew  = require('./$.strict-new')
  , forOf      = require('./$.for-of')
  , setProto   = require('./$.set-proto').set
  , same       = require('./$.same-value')
  , SPECIES    = require('./$.wks')('species')
  , speciesConstructor = require('./$.species-constructor')
  , asap       = require('./$.microtask')
  , PROMISE    = 'Promise'
  , process    = global.process
  , isNode     = classof(process) == 'process'
  , P          = global[PROMISE]
  , Wrapper;

var testResolve = function(sub){
  var test = new P(function(){});
  if(sub)test.constructor = Object;
  return P.resolve(test) === test;
};

var USE_NATIVE = function(){
  var works = false;
  function P2(x){
    var self = new P(x);
    setProto(self, P2.prototype);
    return self;
  }
  try {
    works = P && P.resolve && testResolve();
    setProto(P2, P);
    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
    // actual Firefox has broken subclass support, test that
    if(!(P2.resolve(5).then(function(){}) instanceof P2)){
      works = false;
    }
    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162
    if(works && require('./$.descriptors')){
      var thenableThenGotten = false;
      P.resolve($.setDesc({}, 'then', {
        get: function(){ thenableThenGotten = true; }
      }));
      works = thenableThenGotten;
    }
  } catch(e){ works = false; }
  return works;
}();

// helpers
var sameConstructor = function(a, b){
  // library wrapper special case
  if(LIBRARY && a === P && b === Wrapper)return true;
  return same(a, b);
};
var getConstructor = function(C){
  var S = anObject(C)[SPECIES];
  return S != undefined ? S : C;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var PromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve),
  this.reject  = aFunction(reject)
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(record, isReject){
  if(record.n)return;
  record.n = true;
  var chain = record.c;
  asap(function(){
    var value = record.v
      , ok    = record.s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , result, then;
      try {
        if(handler){
          if(!ok)record.h = true;
          result = handler === true ? value : handler(value);
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    chain.length = 0;
    record.n = false;
    if(isReject)setTimeout(function(){
      var promise = record.p
        , handler, console;
      if(isUnhandled(promise)){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      } record.a = undefined;
    }, 1);
  });
};
var isUnhandled = function(promise){
  var record = promise._d
    , chain  = record.a || record.c
    , i      = 0
    , reaction;
  if(record.h)return false;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var $reject = function(value){
  var record = this;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  record.v = value;
  record.s = 2;
  record.a = record.c.slice();
  notify(record, true);
};
var $resolve = function(value){
  var record = this
    , then;
  if(record.d)return;
  record.d = true;
  record = record.r || record; // unwrap
  try {
    if(record.p === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      asap(function(){
        var wrapper = {r: record, d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      record.v = value;
      record.s = 1;
      notify(record, false);
    }
  } catch(e){
    $reject.call({r: record, d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  P = function Promise(executor){
    aFunction(executor);
    var record = this._d = {
      p: strictNew(this, P, PROMISE),         // <- promise
      c: [],                                  // <- awaiting reactions
      a: undefined,                           // <- checked in isUnhandled reactions
      s: 0,                                   // <- state
      d: false,                               // <- done
      v: undefined,                           // <- value
      h: false,                               // <- handled rejection
      n: false                                // <- notify
    };
    try {
      executor(ctx($resolve, record, 1), ctx($reject, record, 1));
    } catch(err){
      $reject.call(record, err);
    }
  };
  require('./$.redefine-all')(P.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction = new PromiseCapability(speciesConstructor(this, P))
        , promise  = reaction.promise
        , record   = this._d;
      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      record.c.push(reaction);
      if(record.a)record.a.push(reaction);
      if(record.s)notify(record, false);
      return promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
require('./$.set-to-string-tag')(P, PROMISE);
require('./$.set-species')(PROMISE);
Wrapper = require('./$.core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = new PromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof P && sameConstructor(x.constructor, this))return x;
    var capability = new PromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./$.iter-detect')(function(iter){
  P.all(iter)['catch'](function(){});
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject
      , values     = [];
    var abrupt = perform(function(){
      forOf(iterable, false, values.push, values);
      var remaining = values.length
        , results   = Array(remaining);
      if(remaining)$.each.call(values, function(promise, index){
        var alreadyCalled = false;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled = true;
          results[index] = value;
          --remaining || resolve(results);
        }, reject);
      });
      else resolve(results);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = getConstructor(this)
      , capability = new PromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});
},{"./$":359,"./$.a-function":326,"./$.an-object":328,"./$.classof":329,"./$.core":334,"./$.ctx":335,"./$.descriptors":337,"./$.export":340,"./$.for-of":342,"./$.global":344,"./$.is-object":352,"./$.iter-detect":356,"./$.library":361,"./$.microtask":362,"./$.redefine-all":367,"./$.same-value":369,"./$.set-proto":370,"./$.set-species":371,"./$.set-to-string-tag":372,"./$.species-constructor":374,"./$.strict-new":375,"./$.wks":383}],397:[function(require,module,exports){
'use strict';
var strong = require('./$.collection-strong');

// 23.2 Set Objects
require('./$.collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./$.collection":333,"./$.collection-strong":331}],398:[function(require,module,exports){
'use strict';
var $at  = require('./$.string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./$.iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./$.iter-define":355,"./$.string-at":376}],399:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var $              = require('./$')
  , global         = require('./$.global')
  , has            = require('./$.has')
  , DESCRIPTORS    = require('./$.descriptors')
  , $export        = require('./$.export')
  , redefine       = require('./$.redefine')
  , $fails         = require('./$.fails')
  , shared         = require('./$.shared')
  , setToStringTag = require('./$.set-to-string-tag')
  , uid            = require('./$.uid')
  , wks            = require('./$.wks')
  , keyOf          = require('./$.keyof')
  , $names         = require('./$.get-names')
  , enumKeys       = require('./$.enum-keys')
  , isArray        = require('./$.is-array')
  , anObject       = require('./$.an-object')
  , toIObject      = require('./$.to-iobject')
  , createDesc     = require('./$.property-desc')
  , getDesc        = $.getDesc
  , setDesc        = $.setDesc
  , _create        = $.create
  , getNames       = $names.get
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , setter         = false
  , HIDDEN         = wks('_hidden')
  , isEnum         = $.isEnum
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , useNative      = typeof $Symbol == 'function'
  , ObjectProto    = Object.prototype;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(setDesc({}, 'a', {
    get: function(){ return setDesc(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = getDesc(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  setDesc(it, key, D);
  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);
} : setDesc;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol.prototype);
  sym._k = tag;
  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
    configurable: true,
    set: function(value){
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    }
  });
  return sym;
};

var isSymbol = function(it){
  return typeof it == 'symbol';
};

var $defineProperty = function defineProperty(it, key, D){
  if(D && has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return setDesc(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key);
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]
    ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  var D = getDesc(it = toIObject(it), key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);
  return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var names  = getNames(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
  return result;
};
var $stringify = function stringify(it){
  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
  var args = [it]
    , i    = 1
    , $$   = arguments
    , replacer, $replacer;
  while($$.length > i)args.push($$[i++]);
  replacer = args[1];
  if(typeof replacer == 'function')$replacer = replacer;
  if($replacer || !isArray(replacer))replacer = function(key, value){
    if($replacer)value = $replacer.call(this, key, value);
    if(!isSymbol(value))return value;
  };
  args[1] = replacer;
  return _stringify.apply($JSON, args);
};
var buggyJSON = $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
});

// 19.4.1.1 Symbol([description])
if(!useNative){
  $Symbol = function Symbol(){
    if(isSymbol(this))throw TypeError('Symbol is not a constructor');
    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
  };
  redefine($Symbol.prototype, 'toString', function toString(){
    return this._k;
  });

  isSymbol = function(it){
    return it instanceof $Symbol;
  };

  $.create     = $create;
  $.isEnum     = $propertyIsEnumerable;
  $.getDesc    = $getOwnPropertyDescriptor;
  $.setDesc    = $defineProperty;
  $.setDescs   = $defineProperties;
  $.getNames   = $names.get = $getOwnPropertyNames;
  $.getSymbols = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./$.library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }
}

var symbolStatics = {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    return keyOf(SymbolRegistry, key);
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
};
// 19.4.2.2 Symbol.hasInstance
// 19.4.2.3 Symbol.isConcatSpreadable
// 19.4.2.4 Symbol.iterator
// 19.4.2.6 Symbol.match
// 19.4.2.8 Symbol.replace
// 19.4.2.9 Symbol.search
// 19.4.2.10 Symbol.species
// 19.4.2.11 Symbol.split
// 19.4.2.12 Symbol.toPrimitive
// 19.4.2.13 Symbol.toStringTag
// 19.4.2.14 Symbol.unscopables
$.each.call((
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +
  'species,split,toPrimitive,toStringTag,unscopables'
).split(','), function(it){
  var sym = wks(it);
  symbolStatics[it] = useNative ? sym : wrap(sym);
});

setter = true;

$export($export.G + $export.W, {Symbol: $Symbol});

$export($export.S, 'Symbol', symbolStatics);

$export($export.S + $export.F * !useNative, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});

// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./$":359,"./$.an-object":328,"./$.descriptors":337,"./$.enum-keys":339,"./$.export":340,"./$.fails":341,"./$.get-names":343,"./$.global":344,"./$.has":345,"./$.is-array":351,"./$.keyof":360,"./$.library":361,"./$.property-desc":366,"./$.redefine":368,"./$.set-to-string-tag":372,"./$.shared":373,"./$.to-iobject":379,"./$.uid":382,"./$.wks":383}],400:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./$.export');

$export($export.P, 'Map', {toJSON: require('./$.collection-to-json')('Map')});
},{"./$.collection-to-json":332,"./$.export":340}],401:[function(require,module,exports){
// http://goo.gl/XkBrjD
var $export  = require('./$.export')
  , $entries = require('./$.object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});
},{"./$.export":340,"./$.object-to-array":365}],402:[function(require,module,exports){
// http://goo.gl/XkBrjD
var $export = require('./$.export')
  , $values = require('./$.object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});
},{"./$.export":340,"./$.object-to-array":365}],403:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./$.export');

$export($export.P, 'Set', {toJSON: require('./$.collection-to-json')('Set')});
},{"./$.collection-to-json":332,"./$.export":340}],404:[function(require,module,exports){
require('./es6.array.iterator');
var Iterators = require('./$.iterators');
Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
},{"./$.iterators":358,"./es6.array.iterator":388}]},{},[265])(265)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy5hdG9tL3BhY2thZ2VzL2F0b20tYmFiZWwtY29tcGlsZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uLy4uLy4uLy4uLy5hdG9tL3BhY2thZ2VzL2F0b20tYmFiZWwtY29tcGlsZXIvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRNYXJrdXBXcmFwLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL3BlcmZvcm1hbmNlLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwibm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcXVlcnktc3RyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0FSSUFET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0F1dG9Gb2N1c1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0NTU1Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ2FsbGJhY2tRdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NTGF6eVRyZWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01OYW1lc3BhY2VzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9EYW5nZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luSHViLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvS2V5RXNjYXBlVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUG9vbGVkQ2xhc3MuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET00uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbnRhaW5lckluZm8uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUVtcHR5Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW5wdXQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUludmFsaWRBUklBSG9vay5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NT3B0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01TZWxlY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2suanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RFcnJvclV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEluc3RhbmNlTWFwLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0cnVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0TW91bnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdE5vZGVUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0T3duZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UmVmLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0U2VydmVyVXBkYXRlUXVldWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFVwZGF0ZVF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RWZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljQW5pbWF0aW9uRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljS2V5Ym9hcmRFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljVUlFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9UcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvYWRsZXIzMi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZmluZERPTU5vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRLZXkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldE5leHREZWJ1Z0lELmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9yZWFjdFByb2RJbnZhcmlhbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3NldElubmVySFRNTC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3NldFRleHRDb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvQXN5bmNVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL0NvbnRleHRVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL0luZGV4TGluay5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL0luZGV4UmVkaXJlY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9JbmRleFJvdXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvSW50ZXJuYWxQcm9wVHlwZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvUGF0dGVyblV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvUHJvbWlzZVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXJDb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvUm91dGVyVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9UcmFuc2l0aW9uVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9hcHBseVJvdXRlck1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9icm93c2VySGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL2NvbXB1dGVDaGFuZ2VkUm91dGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVJvdXRlckhpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL2dldENvbXBvbmVudHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9nZXRSb3V0ZVBhcmFtcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL2hhc2hIaXN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9pc0FjdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL21hdGNoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvbWF0Y2hSb3V0ZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVySGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL3dpdGhSb3V0ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9BY3Rpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvQXN5bmNVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL0Jyb3dzZXJQcm90b2NvbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL0RPTVN0YXRlU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL0RPTVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9IYXNoUHJvdG9jb2wuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9Mb2NhdGlvblV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvUGF0aFV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvUmVmcmVzaFByb3RvY29sLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL2NyZWF0ZUhpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vay5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFB1cmVDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9yZWFjdC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMveHJlZ2V4cC9zcmMvYWRkb25zL2J1aWxkLmpzIiwibm9kZV9tb2R1bGVzL3hyZWdleHAvc3JjL2FkZG9ucy9tYXRjaHJlY3Vyc2l2ZS5qcyIsIm5vZGVfbW9kdWxlcy94cmVnZXhwL3NyYy9hZGRvbnMvdW5pY29kZS1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3hyZWdleHAvc3JjL2FkZG9ucy91bmljb2RlLWJsb2Nrcy5qcyIsIm5vZGVfbW9kdWxlcy94cmVnZXhwL3NyYy9hZGRvbnMvdW5pY29kZS1jYXRlZ29yaWVzLmpzIiwibm9kZV9tb2R1bGVzL3hyZWdleHAvc3JjL2FkZG9ucy91bmljb2RlLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMveHJlZ2V4cC9zcmMvYWRkb25zL3VuaWNvZGUtc2NyaXB0cy5qcyIsIm5vZGVfbW9kdWxlcy94cmVnZXhwL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy94cmVnZXhwL3NyYy94cmVnZXhwLmpzIiwic291cmNlXFxjb21wb25lbnRcXEJhY2tncm91bmRJbWFnZS5qcyIsInNvdXJjZVxcY29tcG9uZW50XFxCdXR0b24uanMiLCJzb3VyY2VcXGNvbXBvbmVudFxcQ2FyZC5qcyIsInNvdXJjZVxcY29tcG9uZW50XFxDaGVja2JveC5qcyIsInNvdXJjZVxcY29tcG9uZW50XFxDb250ZW50QWxpZ25lcnMuanMiLCJzb3VyY2VcXGNvbXBvbmVudFxcQ3VzdG9tRXZlbnRzLmpzIiwic291cmNlXFxjb21wb25lbnRcXERpYWxvZy5qcyIsInNvdXJjZVxcY29tcG9uZW50XFxGb3JtLmpzIiwic291cmNlXFxjb21wb25lbnRcXEdyaWQuanMiLCJzb3VyY2VcXGNvbXBvbmVudFxcSWNvbi5qcyIsInNvdXJjZVxcY29tcG9uZW50XFxJbWFnZS5qcyIsInNvdXJjZVxcY29tcG9uZW50XFxJbnB1dC5qcyIsInNvdXJjZVxcY29tcG9uZW50XFxQaW5ib2FyZC5qcyIsInNvdXJjZVxcY29tcG9uZW50XFxQcm9ncmVzcy5qcyIsInNvdXJjZVxcY29tcG9uZW50XFxTY3JlZW4uanMiLCJzb3VyY2VcXGNvbXBvbmVudFxcU2xpZGVyLmpzIiwic291cmNlXFxjb21wb25lbnRcXFNwaW5uZXIuanMiLCJzb3VyY2VcXGNvbXBvbmVudFxcVGFicy5qcyIsInNvdXJjZVxcY29tcG9uZW50XFxUb2dnbGUuanMiLCJzb3VyY2VcXGNvbXBvbmVudFxcYnV0dG9uLmpzIiwic291cmNlL2RhdGEtdXJpL2lvbmljb25zLndvZmYuc291cmNlIiwic291cmNlL2RhdGEtdXJpL3JvYm90by1saWdodC53b2ZmLnNvdXJjZSIsInNvdXJjZS9kYXRhLXVyaS9zcGlubmVyLmdpZi5zb3VyY2UiLCJzb3VyY2VcXG1haW4uanMiLCJzb3VyY2VcXHV0aWxcXGFqYXguanMiLCJzb3VyY2VcXHV0aWxcXGFwaS5qcyIsInNvdXJjZVxcdXRpbFxcYXBwLmpzIiwic291cmNlXFx1dGlsXFxjaHJvbm8uanMiLCJzb3VyY2VcXHV0aWxcXGNvbnN0cy5qcyIsInNvdXJjZVxcdXRpbFxcZGV2aWNlcmVhZHkuanMiLCJzb3VyY2VcXHV0aWxcXGVudi5qcyIsInNvdXJjZVxcdXRpbFxcZmlsZXN5cy5qcyIsInNvdXJjZVxcdXRpbFxcZ2VzdHVyZS5qcyIsInNvdXJjZVxcdXRpbFxcaWNvbnMuanMiLCJzb3VyY2VcXHV0aWxcXHNldHRpbmdzLmpzIiwic291cmNlXFx1dGlsXFxzdHlsZXNoZWV0LmpzIiwic291cmNlXFx1dGlsXFx0aGVtZS5qcyIsInNvdXJjZVxcdXRpbFxcdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9lbnRyaWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZnJlZXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvdmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCIuLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL3J1bnRpbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb20uanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9tYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9lbnRyaWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZnJlZXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvdmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9wcm9taXNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmEtZnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hZGQtdG8tdW5zY29wYWJsZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hbi1vYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jbGFzc29mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29sbGVjdGlvbi1zdHJvbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2xsZWN0aW9uLXRvLWpzb24uanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5jb2xsZWN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY29yZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmN0eC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmRlZmluZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5kZXNjcmlwdG9ycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmRvbS1jcmVhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5lbnVtLWtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5leHBvcnQuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5mYWlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmZvci1vZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmdldC1uYW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmdsb2JhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmhpZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5odG1sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaW52b2tlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaW9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmlzLWFycmF5LWl0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pcy1hcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmlzLW9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItY2FsbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItY3JlYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1kZWZpbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWRldGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItc3RlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXJhdG9ycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQua2V5b2YuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5saWJyYXJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQubWljcm90YXNrLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQub2JqZWN0LWFzc2lnbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLm9iamVjdC1zYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5vYmplY3QtdG8tYXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5wcm9wZXJ0eS1kZXNjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQucmVkZWZpbmUtYWxsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQucmVkZWZpbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zYW1lLXZhbHVlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2V0LXByb3RvLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc2V0LXNwZWNpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNoYXJlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnNwZWNpZXMtY29uc3RydWN0b3IuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5zdHJpY3QtbmV3LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc3RyaW5nLWF0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudGFzay5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLWludGVnZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC50by1pb2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8tbGVuZ3RoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8tb2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudWlkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQud2tzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3YrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDblZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzF5REE7Ozs7QUFFQTs7Ozs7O0FBRUEsY0FBb0IsU0FBcEIsQ0FBOEI7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dkNIOztBQUFBO0FBd0NILGlDQUFTLENBQVQ7QUF4Q0c7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLENBQWY7O1FBOENJLFcsR0FBQSxXOzs7QUNqREo7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RvQkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBOztBQ0ZBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICogQHR5cGVjaGVja3NcclxuICovXHJcblxyXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXHJcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cclxuICovXHJcbnZhciBFdmVudExpc3RlbmVyID0ge1xyXG4gIC8qKlxyXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXHJcbiAgICovXHJcbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xyXG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XHJcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XHJcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cclxuICAgKi9cclxuICBjYXB0dXJlOiBmdW5jdGlvbiBjYXB0dXJlKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xyXG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0KCkge31cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XHJcblxyXG4vKipcclxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxyXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XHJcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxyXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXHJcbiAqL1xyXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XHJcblxyXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxyXG5cclxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcclxuXHJcbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxyXG5cclxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcclxuXHJcbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50OyIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XHJcblxyXG4vKipcclxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcclxuICpcclxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcclxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcclxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcclxuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcclxuICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xyXG5cclxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XHJcblxyXG4vKipcclxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxyXG4gKlxyXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxyXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxyXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXHJcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxyXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcclxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcclxuICpcclxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xyXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XHJcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcclxuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcclxuXHJcbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcclxuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xyXG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcclxuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XHJcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XHJcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcclxuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cclxuICpcclxuICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgY2FsbGVyIGtub3dzIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSB0eXBlLiBGb3IgbGVzc1xyXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb21NaXhlZC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258ZmlsZWxpc3R9IG9ialxyXG4gKiBAcmV0dXJuIHthcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XHJcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XHJcblxyXG4gIC8vIFNvbWUgYnJvd3NlcnMgYnVpbHRpbiBvYmplY3RzIGNhbiByZXBvcnQgdHlwZW9mICdmdW5jdGlvbicgKGUuZy4gTm9kZUxpc3RcclxuICAvLyBpbiBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cclxuICAhKCFBcnJheS5pc0FycmF5KG9iaikgJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBBcnJheS1saWtlIG9iamVjdCBleHBlY3RlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuXHJcbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG5cclxuICAhKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggLSAxIGluIG9iaikgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IHNob3VsZCBoYXZlIGtleXMgZm9yIGluZGljZXMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcblxyXG4gICEodHlwZW9mIG9iai5jYWxsZWUgIT09ICdmdW5jdGlvbicpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBjYW5cXCd0IGJlIGBhcmd1bWVudHNgLiBVc2UgcmVzdCBwYXJhbXMgJyArICcoZnVuY3Rpb24oLi4uYXJncykge30pIG9yIEFycmF5LmZyb20oKSBpbnN0ZWFkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuXHJcbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcclxuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcclxuICAvLyBmYWxsYmFjay5cclxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gSUUgPCA5IGRvZXMgbm90IHN1cHBvcnQgQXJyYXkjc2xpY2Ugb24gY29sbGVjdGlvbnMgb2JqZWN0c1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcga2V5IGJ5IGtleS4gVGhpcyBhc3N1bWVzIGFsbCBrZXlzIGhhdmUgYSB2YWx1ZSxcclxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxyXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xyXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcclxuICAgIHJldFtpaV0gPSBvYmpbaWldO1xyXG4gIH1cclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vKipcclxuICogUGVyZm9ybSBhIGhldXJpc3RpYyB0ZXN0IHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgXCJhcnJheS1saWtlXCIuXHJcbiAqXHJcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcclxuICogICBKb3NodSByZXBsaWVkOiBcIk11LlwiXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcclxuICogdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYWN0dWFsIGFycmF5LCBhbiBgYXJndW1lbnRzJyBvYmplY3QsIG9yIGFuXHJcbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxyXG4gKlxyXG4gKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3Igb3RoZXIgYXJyYXktbGlrZSBvYmplY3RzIGxpa2UgRmlsZWxpc3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gb2JqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcclxuICByZXR1cm4gKFxyXG4gICAgLy8gbm90IG51bGwvZmFsc2VcclxuICAgICEhb2JqICYmIChcclxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXHJcbiAgICB0eXBlb2Ygb2JqID09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJykgJiZcclxuICAgIC8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XHJcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcclxuICAgIC8vIG5vdCB3aW5kb3dcclxuICAgICEoJ3NldEludGVydmFsJyBpbiBvYmopICYmXHJcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXHJcbiAgICAvLyBhICdzZWxlY3QnIGVsZW1lbnQgaGFzICdsZW5ndGgnIGFuZCAnaXRlbScgcHJvcGVydGllcyBvbiBJRThcclxuICAgIHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicgJiYgKFxyXG4gICAgLy8gYSByZWFsIGFycmF5XHJcbiAgICBBcnJheS5pc0FycmF5KG9iaikgfHxcclxuICAgIC8vIGFyZ3VtZW50c1xyXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XHJcbiAgICAvLyBIVE1MQ29sbGVjdGlvbi9Ob2RlTGlzdFxyXG4gICAgJ2l0ZW0nIGluIG9iailcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IGJ5IHdyYXBwaW5nIGl0IGluIGFuIGFycmF5IGlmIGl0IGlzIG5vdC5cclxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50IGlmIGl0IGlzIGFscmVhZHkgYW4gYXJyYXkuXHJcbiAqXHJcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5OlxyXG4gKlxyXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XHJcbiAqXHJcbiAqICAgZnVuY3Rpb24gdGFrZXNPbmVPck1vcmVUaGluZ3ModGhpbmdzKSB7XHJcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xyXG4gKiAgICAgLi4uXHJcbiAqICAgfVxyXG4gKlxyXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYHRoaW5ncycgYXMgYW4gYXJyYXksIGJ1dCBhY2NlcHQgc2NhbGFycyBpbiB0aGUgQVBJLlxyXG4gKlxyXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XHJcbiAqIHVzZSB0b0FycmF5IGluc3RlYWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gb2JqXHJcbiAqIEByZXR1cm4ge2FycmF5fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XHJcbiAgaWYgKCFoYXNBcnJheU5hdHVyZShvYmopKSB7XHJcbiAgICByZXR1cm4gW29ial07XHJcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgIHJldHVybiBvYmouc2xpY2UoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQ7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sKi9cclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxuXHJcbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcclxudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKCcuL2dldE1hcmt1cFdyYXAnKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XHJcblxyXG4vKipcclxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXHJcbiAqL1xyXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xyXG5cclxuLyoqXHJcbiAqIFBhdHRlcm4gdXNlZCBieSBgZ2V0Tm9kZU5hbWVgLlxyXG4gKi9cclxudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxyXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cclxuICovXHJcbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xyXG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XHJcbiAgcmV0dXJuIG5vZGVOYW1lTWF0Y2ggJiYgbm9kZU5hbWVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxyXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXHJcbiAqIDxzY3JpcHQ+IGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZC4gSWYgbm8gYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gaXMgc3VwcGxpZWQsXHJcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBBIHN0cmluZyBvZiB2YWxpZCBIVE1MIG1hcmt1cC5cclxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXHJcbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xyXG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xyXG4gICEhIWR1bW15Tm9kZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgZHVtbXkgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cCk7XHJcblxyXG4gIHZhciB3cmFwID0gbm9kZU5hbWUgJiYgZ2V0TWFya3VwV3JhcChub2RlTmFtZSk7XHJcbiAgaWYgKHdyYXApIHtcclxuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XHJcblxyXG4gICAgdmFyIHdyYXBEZXB0aCA9IHdyYXBbMF07XHJcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcclxuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBub2RlLmlubmVySFRNTCA9IG1hcmt1cDtcclxuICB9XHJcblxyXG4gIHZhciBzY3JpcHRzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XHJcbiAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XHJcbiAgICAhaGFuZGxlU2NyaXB0ID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgY3JlYXRlQXJyYXlGcm9tTWl4ZWQoc2NyaXB0cykuZm9yRWFjaChoYW5kbGVTY3JpcHQpO1xyXG4gIH1cclxuXHJcbiAgdmFyIG5vZGVzID0gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpO1xyXG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xyXG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XHJcbiAgfVxyXG4gIHJldHVybiBub2RlcztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gYXJnO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xyXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxyXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxyXG4gKi9cclxudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XHJcblxyXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XHJcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcclxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcclxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcclxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcclxuICByZXR1cm4gYXJnO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcclxuICovXHJcblxyXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xyXG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxyXG4gIC8vIG5vdCBlbmFibGVkLCBvciBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhY2NlcHQgdGhlIGZvY3VzLlwiIGZvciBhbGwga2luZHMgb2ZcclxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cclxuICB0cnkge1xyXG4gICAgbm9kZS5mb2N1cygpO1xyXG4gIH0gY2F0Y2ggKGUpIHt9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQHR5cGVjaGVja3NcclxuICovXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xyXG5cclxuLyoqXHJcbiAqIFNhbWUgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBidXQgd3JhcHMgaW4gYSB0cnktY2F0Y2ggYmxvY2suIEluIElFIGl0IGlzXHJcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXHJcbiAqXHJcbiAqIFRoZSBhY3RpdmVFbGVtZW50IHdpbGwgYmUgbnVsbCBvbmx5IGlmIHRoZSBkb2N1bWVudCBvciBkb2N1bWVudCBib2R5IGlzIG5vdFxyXG4gKiB5ZXQgZGVmaW5lZC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoKSAvKj9ET01FbGVtZW50Ki97XHJcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDsiLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwgKi9cclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xyXG5cclxuLyoqXHJcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIGRldGVjdCB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5LlxyXG4gKi9cclxudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBTb21lIGJyb3dzZXJzIGNhbm5vdCB1c2UgYGlubmVySFRNTGAgdG8gcmVuZGVyIGNlcnRhaW4gZWxlbWVudHMgc3RhbmRhbG9uZSxcclxuICogc28gd2Ugd3JhcCB0aGVtLCByZW5kZXIgdGhlIHdyYXBwZWQgbm9kZXMsIHRoZW4gZXh0cmFjdCB0aGUgZGVzaXJlZCBub2RlLlxyXG4gKlxyXG4gKiBJbiBJRTgsIGNlcnRhaW4gZWxlbWVudHMgY2Fubm90IHJlbmRlciBhbG9uZSwgc28gd3JhcCBhbGwgZWxlbWVudHMgKCcqJykuXHJcbiAqL1xyXG5cclxudmFyIHNob3VsZFdyYXAgPSB7fTtcclxuXHJcbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcclxudmFyIHRhYmxlV3JhcCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xyXG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XHJcblxyXG52YXIgc3ZnV3JhcCA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JywgJzwvc3ZnPiddO1xyXG5cclxudmFyIG1hcmt1cFdyYXAgPSB7XHJcbiAgJyonOiBbMSwgJz88ZGl2PicsICc8L2Rpdj4nXSxcclxuXHJcbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxyXG4gICdjb2wnOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcclxuICAnbGVnZW5kJzogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXHJcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcclxuICAndHInOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcclxuXHJcbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcclxuICAnb3B0aW9uJzogc2VsZWN0V3JhcCxcclxuXHJcbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXHJcbiAgJ2NvbGdyb3VwJzogdGFibGVXcmFwLFxyXG4gICd0Ym9keSc6IHRhYmxlV3JhcCxcclxuICAndGZvb3QnOiB0YWJsZVdyYXAsXHJcbiAgJ3RoZWFkJzogdGFibGVXcmFwLFxyXG5cclxuICAndGQnOiB0cldyYXAsXHJcbiAgJ3RoJzogdHJXcmFwXHJcbn07XHJcblxyXG4vLyBJbml0aWFsaXplIHRoZSBTVkcgZWxlbWVudHMgc2luY2Ugd2Uga25vdyB0aGV5J2xsIGFsd2F5cyBuZWVkIHRvIGJlIHdyYXBwZWRcclxuLy8gY29uc2lzdGVudGx5LiBJZiB0aGV5IGFyZSBjcmVhdGVkIGluc2lkZSBhIDxkaXY+IHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpblxyXG4vLyB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXHJcbnZhciBzdmdFbGVtZW50cyA9IFsnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2RlZnMnLCAnZWxsaXBzZScsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAndGV4dCcsICd0c3BhbiddO1xyXG5zdmdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlTmFtZSkge1xyXG4gIG1hcmt1cFdyYXBbbm9kZU5hbWVdID0gc3ZnV3JhcDtcclxuICBzaG91bGRXcmFwW25vZGVOYW1lXSA9IHRydWU7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBgbm9kZU5hbWVgLlxyXG4gKlxyXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBMb3dlcmNhc2UgYG5vZGVOYW1lYC5cclxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkge1xyXG4gICEhIWR1bW15Tm9kZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgaWYgKCFtYXJrdXBXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xyXG4gICAgbm9kZU5hbWUgPSAnKic7XHJcbiAgfVxyXG4gIGlmICghc2hvdWxkV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcclxuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XHJcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPGxpbmsgLz4nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcclxuICAgIH1cclxuICAgIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gIWR1bW15Tm9kZS5maXJzdENoaWxkO1xyXG4gIH1cclxuICByZXR1cm4gc2hvdWxkV3JhcFtub2RlTmFtZV0gPyBtYXJrdXBXcmFwW25vZGVOYW1lXSA6IG51bGw7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc3VwcGxpZWQgZWxlbWVudCBvciB3aW5kb3cuXHJcbiAqXHJcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcclxuICogbWF5IGJlIG5lZ2F0aXZlIG9yIGV4Y2VlZCB0aGUgZWxlbWVudCBib3VuZGFyaWVzICh3aGljaCBpcyBwb3NzaWJsZSB1c2luZ1xyXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTVdpbmRvd3xET01FbGVtZW50fSBzY3JvbGxhYmxlXHJcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cclxuICovXHJcblxyXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XHJcbiAgaWYgKHNjcm9sbGFibGUgPT09IHdpbmRvdykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxyXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcclxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXHJcbiAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbjsiLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqL1xyXG5cclxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcclxuXHJcbi8qKlxyXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxyXG4gKlxyXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxyXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcclxuICpcclxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcclxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XHJcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xyXG5cclxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcclxuXHJcbi8qKlxyXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XHJcbiAqXHJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXHJcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxyXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcclxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcclxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcclxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxyXG4gKlxyXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcclxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XHJcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cclxuICpcclxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcclxuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXHJcbiAqIGV4cGVjdGluZy5cclxuICpcclxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcclxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxyXG4gKi9cclxuXHJcbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XHJcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xyXG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XHJcblxyXG4gIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICB2YXIgZXJyb3I7XHJcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xyXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xyXG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xyXG4gICAgICB9KSk7XHJcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XHJcbiAgICB9XHJcblxyXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcclxuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqL1xyXG5cclxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cclxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xyXG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIE1lbW9pemVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIHN0cmluZyBhcmd1bWVudC5cclxuICovXHJcblxyXG5mdW5jdGlvbiBtZW1vaXplU3RyaW5nT25seShjYWxsYmFjaykge1xyXG4gIHZhciBjYWNoZSA9IHt9O1xyXG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICBpZiAoIWNhY2hlLmhhc093blByb3BlcnR5KHN0cmluZykpIHtcclxuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYWNoZVtzdHJpbmddO1xyXG4gIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxuXHJcbnZhciBwZXJmb3JtYW5jZTtcclxuXHJcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcclxuICBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB3aW5kb3cubXNQZXJmb3JtYW5jZSB8fCB3aW5kb3cud2Via2l0UGVyZm9ybWFuY2U7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2UgfHwge307IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAdHlwZWNoZWNrc1xyXG4gKi9cclxuXHJcbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcclxuXHJcbnZhciBwZXJmb3JtYW5jZU5vdztcclxuXHJcbi8qKlxyXG4gKiBEZXRlY3QgaWYgd2UgY2FuIHVzZSBgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpYCBhbmQgZ3JhY2VmdWxseSBmYWxsYmFjayB0b1xyXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XHJcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxyXG4gKi9cclxuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xyXG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XHJcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgfTtcclxufSBlbHNlIHtcclxuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xyXG4gICAgcmV0dXJuIERhdGUubm93KCk7XHJcbiAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZU5vdzsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEB0eXBlY2hlY2tzXHJcbiAqIFxyXG4gKi9cclxuXHJcbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuLyoqXHJcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXHJcbiAqL1xyXG5mdW5jdGlvbiBpcyh4LCB5KSB7XHJcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxyXG4gIGlmICh4ID09PSB5KSB7XHJcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcclxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXHJcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxyXG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXHJcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcclxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXHJcbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcclxuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcclxuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcclxuXHJcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XHJcblxyXG4vKipcclxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxyXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXHJcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXHJcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxyXG4gKi9cclxuXHJcbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XHJcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xyXG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxyXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xyXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgICAgfSBjYXRjaCAoeCkge31cclxuICAgIH07XHJcblxyXG4gICAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcclxuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XHJcbiAgICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KSgpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxyXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcclxuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxyXG4gICAgY29udGV4dFR5cGVzOiB0cnVlLFxyXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxyXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXHJcbiAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXHJcbiAgICBtaXhpbnM6IHRydWUsXHJcbiAgICBwcm9wVHlwZXM6IHRydWUsXHJcbiAgICB0eXBlOiB0cnVlXHJcbn07XHJcblxyXG52YXIgS05PV05fU1RBVElDUyA9IHtcclxuICAgIG5hbWU6IHRydWUsXHJcbiAgICBsZW5ndGg6IHRydWUsXHJcbiAgICBwcm90b3R5cGU6IHRydWUsXHJcbiAgICBjYWxsZXI6IHRydWUsXHJcbiAgICBhcmd1bWVudHM6IHRydWUsXHJcbiAgICBhcml0eTogdHJ1ZVxyXG59O1xyXG5cclxudmFyIGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlID0gdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbic7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBjdXN0b21TdGF0aWNzKSB7XHJcbiAgICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHsgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcclxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgaWYgKGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXlzW2ldXSAmJiAhS05PV05fU1RBVElDU1trZXlzW2ldXSAmJiAoIWN1c3RvbVN0YXRpY3MgfHwgIWN1c3RvbVN0YXRpY3Nba2V5c1tpXV0pKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENvbXBvbmVudFtrZXlzW2ldXSA9IHNvdXJjZUNvbXBvbmVudFtrZXlzW2ldXTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXHJcbiAqXHJcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXHJcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxyXG4gKiBleHBlY3RpbmcuXHJcbiAqXHJcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XHJcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cclxuICovXHJcblxyXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICB2YXIgZXJyb3I7XHJcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXHJcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xyXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xyXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xyXG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcclxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxyXG4gICAgICApO1xyXG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xyXG4gICAgfVxyXG5cclxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xyXG4iLCIvKlxyXG5vYmplY3QtYXNzaWduXHJcbihjKSBTaW5kcmUgU29yaHVzXHJcbkBsaWNlbnNlIE1JVFxyXG4qL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcclxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xyXG5cclxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XHJcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBPYmplY3QodmFsKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xyXG5cdHRyeSB7XHJcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cclxuXHJcblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XHJcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXHJcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XHJcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcclxuXHRcdHZhciB0ZXN0MiA9IHt9O1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XHJcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcclxuXHRcdH1cclxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XHJcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcclxuXHRcdH0pO1xyXG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XHJcblx0XHR2YXIgdGVzdDMgPSB7fTtcclxuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xyXG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xyXG5cdFx0fSk7XHJcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cclxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xyXG5cdHZhciBmcm9tO1xyXG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XHJcblx0dmFyIHN5bWJvbHM7XHJcblxyXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XHJcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XHJcblxyXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcclxuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xyXG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XHJcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcclxuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0bztcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgc3RyaWN0VXJpRW5jb2RlID0gcmVxdWlyZSgnc3RyaWN0LXVyaS1lbmNvZGUnKTtcclxudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbmZ1bmN0aW9uIGVuY29kZXJGb3JBcnJheUZvcm1hdChvcHRzKSB7XHJcblx0c3dpdGNoIChvcHRzLmFycmF5Rm9ybWF0KSB7XHJcblx0XHRjYXNlICdpbmRleCc6XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgaW5kZXgpIHtcclxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IG51bGwgPyBbXHJcblx0XHRcdFx0XHRlbmNvZGUoa2V5LCBvcHRzKSxcclxuXHRcdFx0XHRcdCdbJyxcclxuXHRcdFx0XHRcdGluZGV4LFxyXG5cdFx0XHRcdFx0J10nXHJcblx0XHRcdFx0XS5qb2luKCcnKSA6IFtcclxuXHRcdFx0XHRcdGVuY29kZShrZXksIG9wdHMpLFxyXG5cdFx0XHRcdFx0J1snLFxyXG5cdFx0XHRcdFx0ZW5jb2RlKGluZGV4LCBvcHRzKSxcclxuXHRcdFx0XHRcdCddPScsXHJcblx0XHRcdFx0XHRlbmNvZGUodmFsdWUsIG9wdHMpXHJcblx0XHRcdFx0XS5qb2luKCcnKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRjYXNlICdicmFja2V0JzpcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSBudWxsID8gZW5jb2RlKGtleSwgb3B0cykgOiBbXHJcblx0XHRcdFx0XHRlbmNvZGUoa2V5LCBvcHRzKSxcclxuXHRcdFx0XHRcdCdbXT0nLFxyXG5cdFx0XHRcdFx0ZW5jb2RlKHZhbHVlLCBvcHRzKVxyXG5cdFx0XHRcdF0uam9pbignJyk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSBudWxsID8gZW5jb2RlKGtleSwgb3B0cykgOiBbXHJcblx0XHRcdFx0XHRlbmNvZGUoa2V5LCBvcHRzKSxcclxuXHRcdFx0XHRcdCc9JyxcclxuXHRcdFx0XHRcdGVuY29kZSh2YWx1ZSwgb3B0cylcclxuXHRcdFx0XHRdLmpvaW4oJycpO1xyXG5cdFx0XHR9O1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VyRm9yQXJyYXlGb3JtYXQob3B0cykge1xyXG5cdHZhciByZXN1bHQ7XHJcblxyXG5cdHN3aXRjaCAob3B0cy5hcnJheUZvcm1hdCkge1xyXG5cdFx0Y2FzZSAnaW5kZXgnOlxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSB7XHJcblx0XHRcdFx0cmVzdWx0ID0gL1xcWyhcXGQqKV0kLy5leGVjKGtleSk7XHJcblxyXG5cdFx0XHRcdGtleSA9IGtleS5yZXBsYWNlKC9cXFtcXGQqXSQvLCAnJyk7XHJcblxyXG5cdFx0XHRcdGlmICghcmVzdWx0KSB7XHJcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0ge307XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhY2N1bXVsYXRvcltrZXldW3Jlc3VsdFsxXV0gPSB2YWx1ZTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRjYXNlICdicmFja2V0JzpcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikge1xyXG5cdFx0XHRcdHJlc3VsdCA9IC8oXFxbXSkkLy5leGVjKGtleSk7XHJcblxyXG5cdFx0XHRcdGtleSA9IGtleS5yZXBsYWNlKC9cXFtdJC8sICcnKTtcclxuXHJcblx0XHRcdFx0aWYgKCFyZXN1bHQgfHwgYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gW10uY29uY2F0KGFjY3VtdWxhdG9yW2tleV0sIHZhbHVlKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSB7XHJcblx0XHRcdFx0aWYgKGFjY3VtdWxhdG9yW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCB2YWx1ZSk7XHJcblx0XHRcdH07XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBlbmNvZGUodmFsdWUsIG9wdHMpIHtcclxuXHRpZiAob3B0cy5lbmNvZGUpIHtcclxuXHRcdHJldHVybiBvcHRzLnN0cmljdCA/IHN0cmljdFVyaUVuY29kZSh2YWx1ZSkgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBrZXlzU29ydGVyKGlucHV0KSB7XHJcblx0aWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcblx0XHRyZXR1cm4gaW5wdXQuc29ydCgpO1xyXG5cdH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xyXG5cdFx0cmV0dXJuIGtleXNTb3J0ZXIoT2JqZWN0LmtleXMoaW5wdXQpKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0XHRcdHJldHVybiBOdW1iZXIoYSkgLSBOdW1iZXIoYik7XHJcblx0XHR9KS5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG5cdFx0XHRyZXR1cm4gaW5wdXRba2V5XTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGlucHV0O1xyXG59XHJcblxyXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiAoc3RyKSB7XHJcblx0cmV0dXJuIHN0ci5zcGxpdCgnPycpWzFdIHx8ICcnO1xyXG59O1xyXG5cclxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIG9wdHMpIHtcclxuXHRvcHRzID0gb2JqZWN0QXNzaWduKHthcnJheUZvcm1hdDogJ25vbmUnfSwgb3B0cyk7XHJcblxyXG5cdHZhciBmb3JtYXR0ZXIgPSBwYXJzZXJGb3JBcnJheUZvcm1hdChvcHRzKTtcclxuXHJcblx0Ly8gQ3JlYXRlIGFuIG9iamVjdCB3aXRoIG5vIHByb3RvdHlwZVxyXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nL2lzc3Vlcy80N1xyXG5cdHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cclxuXHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XHJcblxyXG5cdGlmICghc3RyKSB7XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxuXHJcblx0c3RyLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcclxuXHRcdHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XHJcblx0XHQvLyBGaXJlZm94IChwcmUgNDApIGRlY29kZXMgYCUzRGAgdG8gYD1gXHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9wdWxsLzM3XHJcblx0XHR2YXIga2V5ID0gcGFydHMuc2hpZnQoKTtcclxuXHRcdHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHMuam9pbignPScpIDogdW5kZWZpbmVkO1xyXG5cclxuXHRcdC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XHJcblx0XHQvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXHJcblx0XHR2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcclxuXHJcblx0XHRmb3JtYXR0ZXIoZGVjb2RlVVJJQ29tcG9uZW50KGtleSksIHZhbCwgcmV0KTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIE9iamVjdC5rZXlzKHJldCkuc29ydCgpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBrZXkpIHtcclxuXHRcdHZhciB2YWwgPSByZXRba2V5XTtcclxuXHRcdGlmIChCb29sZWFuKHZhbCkgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKSkge1xyXG5cdFx0XHQvLyBTb3J0IG9iamVjdCBrZXlzLCBub3QgdmFsdWVzXHJcblx0XHRcdHJlc3VsdFtrZXldID0ga2V5c1NvcnRlcih2YWwpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVzdWx0W2tleV0gPSB2YWw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcclxufTtcclxuXHJcbmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xyXG5cdHZhciBkZWZhdWx0cyA9IHtcclxuXHRcdGVuY29kZTogdHJ1ZSxcclxuXHRcdHN0cmljdDogdHJ1ZSxcclxuXHRcdGFycmF5Rm9ybWF0OiAnbm9uZSdcclxuXHR9O1xyXG5cclxuXHRvcHRzID0gb2JqZWN0QXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcclxuXHJcblx0dmFyIGZvcm1hdHRlciA9IGVuY29kZXJGb3JBcnJheUZvcm1hdChvcHRzKTtcclxuXHJcblx0cmV0dXJuIG9iaiA/IE9iamVjdC5rZXlzKG9iaikuc29ydCgpLm1hcChmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHR2YXIgdmFsID0gb2JqW2tleV07XHJcblxyXG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiAnJztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodmFsID09PSBudWxsKSB7XHJcblx0XHRcdHJldHVybiBlbmNvZGUoa2V5LCBvcHRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XHJcblx0XHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHJcblx0XHRcdHZhbC5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKHZhbDIpIHtcclxuXHRcdFx0XHRpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXN1bHQucHVzaChmb3JtYXR0ZXIoa2V5LCB2YWwyLCByZXN1bHQubGVuZ3RoKSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5qb2luKCcmJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGVuY29kZShrZXksIG9wdHMpICsgJz0nICsgZW5jb2RlKHZhbCwgb3B0cyk7XHJcblx0fSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XHJcblx0XHRyZXR1cm4geC5sZW5ndGggPiAwO1xyXG5cdH0pLmpvaW4oJyYnKSA6ICcnO1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0RE9NJyk7XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBBUklBRE9NUHJvcGVydHlDb25maWcgPSB7XHJcbiAgUHJvcGVydGllczoge1xyXG4gICAgLy8gR2xvYmFsIFN0YXRlcyBhbmQgUHJvcGVydGllc1xyXG4gICAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXHJcbiAgICAnYXJpYS1kZXRhaWxzJzogMCxcclxuICAgICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcclxuICAgICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXHJcbiAgICAnYXJpYS1pbnZhbGlkJzogMCwgLy8gc3RhdGVcclxuICAgICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXHJcbiAgICAnYXJpYS1sYWJlbCc6IDAsXHJcbiAgICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxyXG4gICAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcclxuICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXHJcbiAgICAnYXJpYS1jaGVja2VkJzogMCxcclxuICAgICdhcmlhLWV4cGFuZGVkJzogMCxcclxuICAgICdhcmlhLWhhc3BvcHVwJzogMCxcclxuICAgICdhcmlhLWxldmVsJzogMCxcclxuICAgICdhcmlhLW1vZGFsJzogMCxcclxuICAgICdhcmlhLW11bHRpbGluZSc6IDAsXHJcbiAgICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxyXG4gICAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxyXG4gICAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxyXG4gICAgJ2FyaWEtcHJlc3NlZCc6IDAsXHJcbiAgICAnYXJpYS1yZWFkb25seSc6IDAsXHJcbiAgICAnYXJpYS1yZXF1aXJlZCc6IDAsXHJcbiAgICAnYXJpYS1zZWxlY3RlZCc6IDAsXHJcbiAgICAnYXJpYS1zb3J0JzogMCxcclxuICAgICdhcmlhLXZhbHVlbWF4JzogMCxcclxuICAgICdhcmlhLXZhbHVlbWluJzogMCxcclxuICAgICdhcmlhLXZhbHVlbm93JzogMCxcclxuICAgICdhcmlhLXZhbHVldGV4dCc6IDAsXHJcbiAgICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXHJcbiAgICAnYXJpYS1hdG9taWMnOiAwLFxyXG4gICAgJ2FyaWEtYnVzeSc6IDAsXHJcbiAgICAnYXJpYS1saXZlJzogMCxcclxuICAgICdhcmlhLXJlbGV2YW50JzogMCxcclxuICAgIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xyXG4gICAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXHJcbiAgICAnYXJpYS1ncmFiYmVkJzogMCxcclxuICAgIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXHJcbiAgICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcclxuICAgICdhcmlhLWNvbGNvdW50JzogMCxcclxuICAgICdhcmlhLWNvbGluZGV4JzogMCxcclxuICAgICdhcmlhLWNvbHNwYW4nOiAwLFxyXG4gICAgJ2FyaWEtY29udHJvbHMnOiAwLFxyXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxyXG4gICAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcclxuICAgICdhcmlhLWZsb3d0byc6IDAsXHJcbiAgICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcclxuICAgICdhcmlhLW93bnMnOiAwLFxyXG4gICAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxyXG4gICAgJ2FyaWEtcm93Y291bnQnOiAwLFxyXG4gICAgJ2FyaWEtcm93aW5kZXgnOiAwLFxyXG4gICAgJ2FyaWEtcm93c3Bhbic6IDAsXHJcbiAgICAnYXJpYS1zZXRzaXplJzogMFxyXG4gIH0sXHJcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHt9LFxyXG4gIERPTVByb3BlcnR5TmFtZXM6IHt9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFSSUFET01Qcm9wZXJ0eUNvbmZpZzsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxuXHJcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcclxuXHJcbnZhciBBdXRvRm9jdXNVdGlscyA9IHtcclxuICBmb2N1c0RPTUNvbXBvbmVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgZm9jdXNOb2RlKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpKTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEF1dG9Gb2N1c1V0aWxzOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50IEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcclxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxudmFyIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSA9IHJlcXVpcmUoJy4vRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlJyk7XHJcbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Jyk7XHJcbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNJbnB1dEV2ZW50Jyk7XHJcblxyXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxyXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcclxuXHJcbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XHJcblxyXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcclxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xyXG4gIGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcclxufVxyXG5cclxuLy8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cclxuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcclxuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXHJcbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSAmJiAhaXNQcmVzdG8oKTtcclxuXHJcbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXHJcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcclxuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxyXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XHJcblxyXG4vKipcclxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcclxuICogdGV4dCBpbnB1dCBldmVudHMuIFJlbHkgb24ga2V5cHJlc3MgaW5zdGVhZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xyXG4gIHZhciBvcGVyYSA9IHdpbmRvdy5vcGVyYTtcclxuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcclxufVxyXG5cclxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcclxudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xyXG5cclxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxyXG52YXIgZXZlbnRUeXBlcyA9IHtcclxuICBiZWZvcmVJbnB1dDoge1xyXG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcclxuICAgICAgYnViYmxlZDogJ29uQmVmb3JlSW5wdXQnLFxyXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJ1xyXG4gICAgfSxcclxuICAgIGRlcGVuZGVuY2llczogWyd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlQcmVzcycsICd0b3BUZXh0SW5wdXQnLCAndG9wUGFzdGUnXVxyXG4gIH0sXHJcbiAgY29tcG9zaXRpb25FbmQ6IHtcclxuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XHJcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uRW5kJyxcclxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcclxuICAgIH0sXHJcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXHJcbiAgfSxcclxuICBjb21wb3NpdGlvblN0YXJ0OiB7XHJcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xyXG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblN0YXJ0JyxcclxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xyXG4gICAgfSxcclxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uU3RhcnQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxyXG4gIH0sXHJcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcclxuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XHJcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcclxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSdcclxuICAgIH0sXHJcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblVwZGF0ZScsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXHJcbiAgfVxyXG59O1xyXG5cclxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxyXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxyXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXHJcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XHJcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxyXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxyXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xyXG59XHJcblxyXG4vKipcclxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcclxuICogQHJldHVybiB7b2JqZWN0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XHJcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcclxuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uU3RhcnQnOlxyXG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xyXG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxyXG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcclxuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJzpcclxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XHJcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcclxuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xyXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XHJcbiAgICBjYXNlICd0b3BLZXlVcCc6XHJcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxyXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xyXG4gICAgY2FzZSAndG9wS2V5RG93bic6XHJcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXHJcbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xyXG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxyXG4gICAgY2FzZSAndG9wTW91c2VEb3duJzpcclxuICAgIGNhc2UgJ3RvcEJsdXInOlxyXG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcclxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXHJcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXHJcbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcclxuICogQHJldHVybiB7P3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcclxuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xyXG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XHJcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXHJcbnZhciBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgdmFyIGV2ZW50VHlwZTtcclxuICB2YXIgZmFsbGJhY2tEYXRhO1xyXG5cclxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xyXG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcclxuICB9IGVsc2UgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcclxuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xyXG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcclxuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XHJcbiAgfVxyXG5cclxuICBpZiAoIWV2ZW50VHlwZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcclxuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxyXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxyXG4gICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24gJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcclxuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmdldFBvb2xlZChuYXRpdmVFdmVudFRhcmdldCk7XHJcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xyXG4gICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XHJcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG5cclxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XHJcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cclxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXHJcbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xyXG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcclxuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xyXG4gIHJldHVybiBldmVudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XHJcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcclxuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcclxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xyXG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxyXG4gICAgICAvKipcclxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXHJcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cclxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxyXG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXHJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXHJcbiAgICAgICAqIHBhZ2UuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFRyYWNraW5nIGF0OlxyXG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcclxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxyXG4gICAgICAgKi9cclxuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XHJcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XHJcblxyXG4gICAgY2FzZSAndG9wVGV4dElucHV0JzpcclxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXHJcbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XHJcblxyXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxyXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXHJcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXHJcbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjaGFycztcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXHJcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xyXG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxyXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cclxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxyXG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cclxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XHJcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ29tcG9zaXRpb25FbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xyXG4gICAgICB2YXIgY2hhcnMgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xyXG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xyXG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xyXG4gICAgICByZXR1cm4gY2hhcnM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XHJcbiAgICBjYXNlICd0b3BQYXN0ZSc6XHJcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcclxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxyXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXHJcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXHJcbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcclxuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cclxuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXHJcbiAgICAgICAqL1xyXG4gICAgICBpZiAobmF0aXZlRXZlbnQud2hpY2ggJiYgIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcclxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxyXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cclxuICpcclxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICB2YXIgY2hhcnM7XHJcblxyXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xyXG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcclxuICAvLyBiZSBmaXJlZC5cclxuICBpZiAoIWNoYXJzKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcblxyXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcclxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xyXG4gIHJldHVybiBldmVudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcclxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cclxuICpcclxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxyXG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxyXG4gKlxyXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXHJcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xyXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcclxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXHJcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxyXG4gKlxyXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xyXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXHJcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXHJcbiAqL1xyXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcclxuXHJcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcclxuXHJcbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJlZm9yZUlucHV0RXZlbnRQbHVnaW47IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cclxuICovXHJcblxyXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcclxuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcclxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcclxuICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxyXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXHJcbiAgYm94RmxleDogdHJ1ZSxcclxuICBib3hGbGV4R3JvdXA6IHRydWUsXHJcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxyXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxyXG4gIGZsZXg6IHRydWUsXHJcbiAgZmxleEdyb3c6IHRydWUsXHJcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxyXG4gIGZsZXhTaHJpbms6IHRydWUsXHJcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxyXG4gIGZsZXhPcmRlcjogdHJ1ZSxcclxuICBncmlkUm93OiB0cnVlLFxyXG4gIGdyaWRDb2x1bW46IHRydWUsXHJcbiAgZm9udFdlaWdodDogdHJ1ZSxcclxuICBsaW5lQ2xhbXA6IHRydWUsXHJcbiAgbGluZUhlaWdodDogdHJ1ZSxcclxuICBvcGFjaXR5OiB0cnVlLFxyXG4gIG9yZGVyOiB0cnVlLFxyXG4gIG9ycGhhbnM6IHRydWUsXHJcbiAgdGFiU2l6ZTogdHJ1ZSxcclxuICB3aWRvd3M6IHRydWUsXHJcbiAgekluZGV4OiB0cnVlLFxyXG4gIHpvb206IHRydWUsXHJcblxyXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcclxuICBmaWxsT3BhY2l0eTogdHJ1ZSxcclxuICBmbG9vZE9wYWNpdHk6IHRydWUsXHJcbiAgc3RvcE9wYWNpdHk6IHRydWUsXHJcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxyXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXHJcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcclxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxyXG4gIHN0cm9rZVdpZHRoOiB0cnVlXHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XHJcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XHJcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcclxuICogb2YgdmVuZG9yIHByZWZpeGVzLlxyXG4gKi9cclxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcclxuXHJcbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cclxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXHJcbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vKipcclxuICogTW9zdCBzdHlsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1bnNldCBieSBkb2luZyAuc3R5bGVbcHJvcF0gPSAnJyBidXQgSUU4XHJcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcclxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXHJcbiAqIGluZGl2aWR1YWwgcHJvcGVydGllcy4gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzg1LlxyXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXHJcbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxyXG4gKiBzcGVjaWFsIHByb2RkaW5nLlxyXG4gKi9cclxudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcclxuICBiYWNrZ3JvdW5kOiB7XHJcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogdHJ1ZSxcclxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcclxuICAgIGJhY2tncm91bmRJbWFnZTogdHJ1ZSxcclxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXHJcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlLFxyXG4gICAgYmFja2dyb3VuZFJlcGVhdDogdHJ1ZVxyXG4gIH0sXHJcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiB7XHJcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxyXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZVxyXG4gIH0sXHJcbiAgYm9yZGVyOiB7XHJcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcclxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxyXG4gICAgYm9yZGVyQ29sb3I6IHRydWVcclxuICB9LFxyXG4gIGJvcmRlckJvdHRvbToge1xyXG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IHRydWUsXHJcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcclxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXHJcbiAgfSxcclxuICBib3JkZXJMZWZ0OiB7XHJcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXHJcbiAgICBib3JkZXJMZWZ0U3R5bGU6IHRydWUsXHJcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcclxuICB9LFxyXG4gIGJvcmRlclJpZ2h0OiB7XHJcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxyXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcclxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IHRydWVcclxuICB9LFxyXG4gIGJvcmRlclRvcDoge1xyXG4gICAgYm9yZGVyVG9wV2lkdGg6IHRydWUsXHJcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcclxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXHJcbiAgfSxcclxuICBmb250OiB7XHJcbiAgICBmb250U3R5bGU6IHRydWUsXHJcbiAgICBmb250VmFyaWFudDogdHJ1ZSxcclxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXHJcbiAgICBmb250U2l6ZTogdHJ1ZSxcclxuICAgIGxpbmVIZWlnaHQ6IHRydWUsXHJcbiAgICBmb250RmFtaWx5OiB0cnVlXHJcbiAgfSxcclxuICBvdXRsaW5lOiB7XHJcbiAgICBvdXRsaW5lV2lkdGg6IHRydWUsXHJcbiAgICBvdXRsaW5lU3R5bGU6IHRydWUsXHJcbiAgICBvdXRsaW5lQ29sb3I6IHRydWVcclxuICB9XHJcbn07XHJcblxyXG52YXIgQ1NTUHJvcGVydHkgPSB7XHJcbiAgaXNVbml0bGVzc051bWJlcjogaXNVbml0bGVzc051bWJlcixcclxuICBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnM6IHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcclxuXHJcbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XHJcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZSgnLi9kYW5nZXJvdXNTdHlsZVZhbHVlJyk7XHJcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcclxudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZSgnZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHknKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemVTdHJpbmdPbmx5KGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcclxuICByZXR1cm4gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XHJcbn0pO1xyXG5cclxudmFyIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gZmFsc2U7XHJcbnZhciBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnY3NzRmxvYXQnO1xyXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XHJcbiAgdmFyIHRlbXBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xyXG4gIHRyeSB7XHJcbiAgICAvLyBJRTggdGhyb3dzIFwiSW52YWxpZCBhcmd1bWVudC5cIiBpZiByZXNldHRpbmcgc2hvcnRoYW5kIHN0eWxlIHByb3BlcnRpZXMuXHJcbiAgICB0ZW1wU3R5bGUuZm9udCA9ICcnO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gdHJ1ZTtcclxuICB9XHJcbiAgLy8gSUU4IG9ubHkgc3VwcG9ydHMgYWNjZXNzaW5nIGNzc0Zsb2F0IChzdGFuZGFyZCkgYXMgc3R5bGVGbG9hdFxyXG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ3N0eWxlRmxvYXQnO1xyXG4gIH1cclxufVxyXG5cclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcclxuXHJcbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXHJcbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xyXG5cclxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xyXG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xyXG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xyXG5cclxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcclxuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xyXG4gIH07XHJcblxyXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcclxuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcclxuICB9O1xyXG5cclxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xyXG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1N0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuXFwndCBjb250YWluIGEgc2VtaWNvbG9uLiVzICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHZvaWQgMDtcclxuICB9O1xyXG5cclxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcclxuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcclxuICB9O1xyXG5cclxuICB2YXIgY2hlY2tSZW5kZXJNZXNzYWdlID0gZnVuY3Rpb24gKG93bmVyKSB7XHJcbiAgICBpZiAob3duZXIpIHtcclxuICAgICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XHJcbiAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxyXG4gICAqL1xyXG4gIHZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XHJcbiAgICB2YXIgb3duZXI7XHJcbiAgICBpZiAoY29tcG9uZW50KSB7XHJcbiAgICAgIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xyXG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XHJcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XHJcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XHJcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xyXG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIG93bmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcclxuICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSwgb3duZXIpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXHJcbiAqL1xyXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xyXG5cclxuICAvKipcclxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcclxuICAgKlxyXG4gICAqICAgPiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoe3dpZHRoOiAnMjAwcHgnLCBoZWlnaHQ6IDB9KVxyXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxyXG4gICAqXHJcbiAgICogVW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZCBzbyB0aGF0IGRlY2xhcmF0aXZlIHByb2dyYW1taW5nIGlzIGVhc2llci5cclxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXHJcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XHJcbiAgICogQHJldHVybiB7P3N0cmluZ31cclxuICAgKi9cclxuICBjcmVhdGVNYXJrdXBGb3JTdHlsZXM6IGZ1bmN0aW9uIChzdHlsZXMsIGNvbXBvbmVudCkge1xyXG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcclxuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcclxuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcclxuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpICsgJzsnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcclxuICAgKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcclxuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcclxuICAgKi9cclxuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcywgY29tcG9uZW50KSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcclxuICAgICAgICBpbnN0YW5jZUlEOiBjb21wb25lbnQuX2RlYnVnSUQsXHJcbiAgICAgICAgdHlwZTogJ3VwZGF0ZSBzdHlsZXMnLFxyXG4gICAgICAgIHBheWxvYWQ6IHN0eWxlc1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xyXG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xyXG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xyXG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnIHx8IHN0eWxlTmFtZSA9PT0gJ2Nzc0Zsb2F0Jykge1xyXG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlRmxvYXRBY2Nlc3NvcjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xyXG4gICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcclxuICAgICAgICBpZiAoZXhwYW5zaW9uKSB7XHJcbiAgICAgICAgICAvLyBTaG9ydGhhbmQgcHJvcGVydHkgdGhhdCBJRTggd29uJ3QgbGlrZSB1bnNldHRpbmcsIHNvIHVuc2V0IGVhY2hcclxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XHJcbiAgICAgICAgICBmb3IgKHZhciBpbmRpdmlkdWFsU3R5bGVOYW1lIGluIGV4cGFuc2lvbikge1xyXG4gICAgICAgICAgICBzdHlsZVtpbmRpdmlkdWFsU3R5bGVOYW1lXSA9ICcnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBBIHNwZWNpYWxpemVkIHBzZXVkby1ldmVudCBtb2R1bGUgdG8gaGVscCBrZWVwIHRyYWNrIG9mIGNvbXBvbmVudHMgd2FpdGluZyB0b1xyXG4gKiBiZSBub3RpZmllZCB3aGVuIHRoZWlyIERPTSByZXByZXNlbnRhdGlvbnMgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLlxyXG4gKlxyXG4gKiBUaGlzIGltcGxlbWVudHMgYFBvb2xlZENsYXNzYCwgc28geW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXHJcbiAqIEluc3RlYWQsIHVzZSBgQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKWAuXHJcbiAqXHJcbiAqIEBjbGFzcyBSZWFjdE1vdW50UmVhZHlcclxuICogQGltcGxlbWVudHMgUG9vbGVkQ2xhc3NcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5cclxudmFyIENhbGxiYWNrUXVldWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gQ2FsbGJhY2tRdWV1ZShhcmcpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWxsYmFja1F1ZXVlKTtcclxuXHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xyXG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xyXG4gICAgdGhpcy5fYXJnID0gYXJnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCBDb250ZXh0IHRvIGNhbGwgYGNhbGxiYWNrYCB3aXRoLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCBbXTtcclxuICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XHJcbiAgICB0aGlzLl9jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXHJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXHJcbiAgICpcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuXHJcblxyXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLm5vdGlmeUFsbCA9IGZ1bmN0aW9uIG5vdGlmeUFsbCgpIHtcclxuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XHJcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cztcclxuICAgIHZhciBhcmcgPSB0aGlzLl9hcmc7XHJcbiAgICBpZiAoY2FsbGJhY2tzICYmIGNvbnRleHRzKSB7XHJcbiAgICAgICEoY2FsbGJhY2tzLmxlbmd0aCA9PT0gY29udGV4dHMubGVuZ3RoKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNtYXRjaGVkIGxpc3Qgb2YgY29udGV4dHMgaW4gY2FsbGJhY2sgcXVldWUnKSA6IF9wcm9kSW52YXJpYW50KCcyNCcpIDogdm9pZCAwO1xyXG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xyXG4gICAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0sIGFyZyk7XHJcbiAgICAgIH1cclxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XHJcbiAgICAgIGNvbnRleHRzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUuY2hlY2twb2ludCA9IGZ1bmN0aW9uIGNoZWNrcG9pbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzID8gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA6IDA7XHJcbiAgfTtcclxuXHJcbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUucm9sbGJhY2sgPSBmdW5jdGlvbiByb2xsYmFjayhsZW4pIHtcclxuICAgIGlmICh0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY29udGV4dHMpIHtcclxuICAgICAgdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA9IGxlbjtcclxuICAgICAgdGhpcy5fY29udGV4dHMubGVuZ3RoID0gbGVuO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgcXVldWUuXHJcbiAgICpcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuXHJcblxyXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xyXG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMuXHJcbiAgICovXHJcblxyXG5cclxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMucmVzZXQoKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gQ2FsbGJhY2tRdWV1ZTtcclxufSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2FsbGJhY2tRdWV1ZSk7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xyXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xyXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XHJcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcclxuXHJcbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcclxudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcclxudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XHJcblxyXG52YXIgZXZlbnRUeXBlcyA9IHtcclxuICBjaGFuZ2U6IHtcclxuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XHJcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXHJcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xyXG4gICAgfSxcclxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZvciBJRSBzaGltc1xyXG4gKi9cclxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xyXG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xyXG52YXIgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcclxudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxyXG4gKi9cclxuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xyXG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XHJcbn1cclxuXHJcbnZhciBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBmYWxzZTtcclxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xyXG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XHJcbiAgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gaXNFdmVudFN1cHBvcnRlZCgnY2hhbmdlJykgJiYgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcclxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTtcclxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xyXG5cclxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxyXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcclxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcclxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cclxuICAvL1xyXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cclxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxyXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXHJcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxyXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XHJcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxyXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XHJcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudCk7XHJcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XHJcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcclxuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XHJcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKSB7XHJcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XHJcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XHJcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XHJcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcclxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xyXG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BGb2N1cycpIHtcclxuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcclxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cclxuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XHJcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KTtcclxuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XHJcbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XHJcbiAqL1xyXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XHJcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcclxuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cclxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cclxuICAvLyBJRTEwKyBmaXJlIGlucHV0IGV2ZW50cyB0byBvZnRlbiwgc3VjaCB3aGVuIGEgcGxhY2Vob2xkZXJcclxuICAvLyBjaGFuZ2VzIG9yIHdoZW4gYW4gaW5wdXQgd2l0aCBhIHBsYWNlaG9sZGVyIGlzIGZvY3VzZWQuXHJcbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiAxMSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAoRm9yIElFIDw9MTEpIFJlcGxhY2VtZW50IGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgdmFsdWVgIHByb3BlcnR5IHRoYXQgZ2V0c1xyXG4gKiBzZXQgb24gdGhlIGFjdGl2ZSBlbGVtZW50LlxyXG4gKi9cclxudmFyIG5ld1ZhbHVlUHJvcCA9IHtcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLmdldC5jYWxsKHRoaXMpO1xyXG4gIH0sXHJcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAvLyBDYXN0IHRvIGEgc3RyaW5nIHNvIHdlIGNhbiBkbyBlcXVhbGl0eSBjaGVja3MuXHJcbiAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSAnJyArIHZhbDtcclxuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3Auc2V0LmNhbGwodGhpcywgdmFsKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogKEZvciBJRSA8PTExKSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxyXG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cclxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cclxuICovXHJcbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpIHtcclxuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xyXG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcclxuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB0YXJnZXQudmFsdWU7XHJcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ3ZhbHVlJyk7XHJcblxyXG4gIC8vIE5vdCBndWFyZGVkIGluIGEgY2FuRGVmaW5lUHJvcGVydHkgY2hlY2s6IElFOCBzdXBwb3J0cyBkZWZpbmVQcm9wZXJ0eSBvbmx5XHJcbiAgLy8gb24gRE9NIGVsZW1lbnRzXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5ld1ZhbHVlUHJvcCk7XHJcbiAgaWYgKGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcclxuICAgIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSwgZmFsc2UpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIChGb3IgSUUgPD0xMSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXHJcbiAqIGlmIGFueSBleGlzdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcclxuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIGRlbGV0ZSByZXN0b3JlcyB0aGUgb3JpZ2luYWwgcHJvcGVydHkgZGVmaW5pdGlvblxyXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xyXG5cclxuICBpZiAoYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCkge1xyXG4gICAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgYWN0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcclxuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XHJcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcclxuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIChGb3IgSUUgPD0xMSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcclxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cclxuICovXHJcbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XHJcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgdmFsdWUgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50LnZhbHVlO1xyXG4gIGlmICh2YWx1ZSA9PT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHZhbHVlO1xyXG5cclxuICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIElmIGEgYGNoYW5nZWAgZXZlbnQgc2hvdWxkIGJlIGZpcmVkLCByZXR1cm5zIHRoZSB0YXJnZXQncyBJRC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xyXG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BJbnB1dCcpIHtcclxuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxyXG4gICAgLy8gd2hhdCB3ZSB3YW50IHNvIGZhbGwgdGhyb3VnaCBoZXJlIGFuZCB0cmlnZ2VyIGFuIGFic3RyYWN0IGV2ZW50XHJcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xyXG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BGb2N1cycpIHtcclxuICAgIC8vIEluIElFOCwgd2UgY2FuIGNhcHR1cmUgYWxtb3N0IGFsbCAudmFsdWUgY2hhbmdlcyBieSBhZGRpbmcgYVxyXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXHJcbiAgICAvLyBlcXVhbCB0byAndmFsdWUnXHJcbiAgICAvLyBJbiBJRTktMTEsIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXHJcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxyXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxyXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXHJcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxyXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcclxuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXHJcbiAgICAvL1xyXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxyXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxyXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcclxuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xyXG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcclxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBGb3IgSUU4IGFuZCBJRTkuXHJcbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50SUUodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XHJcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcFNlbGVjdGlvbkNoYW5nZScgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5VXAnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nKSB7XHJcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcclxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxyXG4gICAgLy9cclxuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcclxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXHJcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XHJcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XHJcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcclxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXHJcbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cclxuICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQudmFsdWUgIT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xyXG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xyXG4gICAgICByZXR1cm4gYWN0aXZlRWxlbWVudEluc3Q7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcclxuICovXHJcbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xyXG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxyXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXHJcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cclxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcclxuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2xpY2snKSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcclxuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xyXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXHJcbiAqXHJcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XHJcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcclxuICogLSB0ZXh0YXJlYVxyXG4gKiAtIHNlbGVjdFxyXG4gKi9cclxudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xyXG5cclxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxyXG5cclxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xyXG5cclxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xyXG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XHJcbiAgICAgIGlmIChkb2VzQ2hhbmdlRXZlbnRCdWJibGUpIHtcclxuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFODtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcclxuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xyXG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudElFO1xyXG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XHJcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XHJcbiAgICAgIHZhciBpbnN0ID0gZ2V0VGFyZ2V0SW5zdEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KTtcclxuICAgICAgaWYgKGluc3QpIHtcclxuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbiAgICAgICAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xyXG4gICAgICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xyXG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VFdmVudFBsdWdpbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XHJcbnZhciBEYW5nZXIgPSByZXF1aXJlKCcuL0RhbmdlcicpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xyXG5cclxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcclxudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XHJcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcclxuXHJcbmZ1bmN0aW9uIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCBub2RlKSB7XHJcbiAgLy8gU3BlY2lhbCBjYXNlIGZvciB0ZXh0IGNvbXBvbmVudHMsIHdoaWNoIHJldHVybiBbb3BlbiwgY2xvc2VdIGNvbW1lbnRzXHJcbiAgLy8gZnJvbSBnZXRIb3N0Tm9kZS5cclxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xyXG4gICAgbm9kZSA9IG5vZGVbMV07XHJcbiAgfVxyXG4gIHJldHVybiBub2RlID8gbm9kZS5uZXh0U2libGluZyA6IHBhcmVudE5vZGUuZmlyc3RDaGlsZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluc2VydHMgYGNoaWxkTm9kZWAgYXMgYSBjaGlsZCBvZiBgcGFyZW50Tm9kZWAgYXQgdGhlIGBpbmRleGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXHJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY2hpbGROb2RlIENoaWxkIG5vZGUgdG8gaW5zZXJ0LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgaW5zZXJ0Q2hpbGRBdCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xyXG4gIC8vIFdlIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXHJcbiAgLy8gYGFwcGVuZENoaWxkKG5vZGUpYC4gKFVzaW5nIGB1bmRlZmluZWRgIGlzIG5vdCBhbGxvd2VkIGJ5IGFsbCBicm93c2VycyBzb1xyXG4gIC8vIHdlIGFyZSBjYXJlZnVsIHRvIHVzZSBgbnVsbGAuKVxyXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSkge1xyXG4gIERPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUocGFyZW50Tm9kZSwgY2hpbGRUcmVlLCByZWZlcmVuY2VOb2RlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbW92ZUNoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcclxuICAgIG1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZVswXSwgY2hpbGROb2RlWzFdLCByZWZlcmVuY2VOb2RlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGROb2RlKSkge1xyXG4gICAgdmFyIGNsb3NpbmdDb21tZW50ID0gY2hpbGROb2RlWzFdO1xyXG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlWzBdO1xyXG4gICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGNsb3NpbmdDb21tZW50KTtcclxuICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvc2luZ0NvbW1lbnQpO1xyXG4gIH1cclxuICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCwgcmVmZXJlbmNlTm9kZSkge1xyXG4gIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQ7XHJcbiAgd2hpbGUgKHRydWUpIHtcclxuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIG5vZGUsIHJlZmVyZW5jZU5vZGUpO1xyXG4gICAgaWYgKG5vZGUgPT09IGNsb3NpbmdDb21tZW50KSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgbm9kZSA9IG5leHROb2RlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBzdGFydE5vZGUsIGNsb3NpbmdDb21tZW50KSB7XHJcbiAgd2hpbGUgKHRydWUpIHtcclxuICAgIHZhciBub2RlID0gc3RhcnROb2RlLm5leHRTaWJsaW5nO1xyXG4gICAgaWYgKG5vZGUgPT09IGNsb3NpbmdDb21tZW50KSB7XHJcbiAgICAgIC8vIFRoZSBjbG9zaW5nIGNvbW1lbnQgaXMgcmVtb3ZlZCBieSBSZWFjdE11bHRpQ2hpbGQuXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VEZWxpbWl0ZWRUZXh0KG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCwgc3RyaW5nVGV4dCkge1xyXG4gIHZhciBwYXJlbnROb2RlID0gb3BlbmluZ0NvbW1lbnQucGFyZW50Tm9kZTtcclxuICB2YXIgbm9kZUFmdGVyQ29tbWVudCA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xyXG4gIGlmIChub2RlQWZ0ZXJDb21tZW50ID09PSBjbG9zaW5nQ29tbWVudCkge1xyXG4gICAgLy8gVGhlcmUgYXJlIG5vIHRleHQgbm9kZXMgYmV0d2VlbiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBjb21tZW50czsgaW5zZXJ0XHJcbiAgICAvLyBhIG5ldyBvbmUgaWYgc3RyaW5nVGV4dCBpc24ndCBlbXB0eS5cclxuICAgIGlmIChzdHJpbmdUZXh0KSB7XHJcbiAgICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nVGV4dCksIG5vZGVBZnRlckNvbW1lbnQpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoc3RyaW5nVGV4dCkge1xyXG4gICAgICAvLyBTZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgZmlyc3Qgbm9kZSBhZnRlciB0aGUgb3BlbmluZyBjb21tZW50LCBhbmRcclxuICAgICAgLy8gcmVtb3ZlIGFsbCBmb2xsb3dpbmcgbm9kZXMgdXAgdW50aWwgdGhlIGNsb3NpbmcgY29tbWVudC5cclxuICAgICAgc2V0VGV4dENvbnRlbnQobm9kZUFmdGVyQ29tbWVudCwgc3RyaW5nVGV4dCk7XHJcbiAgICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgbm9kZUFmdGVyQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xyXG4gICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvcGVuaW5nQ29tbWVudCkuX2RlYnVnSUQsXHJcbiAgICAgIHR5cGU6ICdyZXBsYWNlIHRleHQnLFxyXG4gICAgICBwYXlsb2FkOiBzdHJpbmdUZXh0XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcclxuICAgIERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRDaGlsZCwgbWFya3VwKTtcclxuICAgIGlmIChwcmV2SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcclxuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgICAgaW5zdGFuY2VJRDogcHJldkluc3RhbmNlLl9kZWJ1Z0lELFxyXG4gICAgICAgIHR5cGU6ICdyZXBsYWNlIHdpdGgnLFxyXG4gICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG1hcmt1cC5ub2RlKTtcclxuICAgICAgaWYgKG5leHRJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xyXG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xyXG4gICAgICAgICAgaW5zdGFuY2VJRDogbmV4dEluc3RhbmNlLl9kZWJ1Z0lELFxyXG4gICAgICAgICAgdHlwZTogJ21vdW50JyxcclxuICAgICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogT3BlcmF0aW9ucyBmb3IgdXBkYXRpbmcgd2l0aCBET00gY2hpbGRyZW4uXHJcbiAqL1xyXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xyXG5cclxuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAsXHJcblxyXG4gIHJlcGxhY2VEZWxpbWl0ZWRUZXh0OiByZXBsYWNlRGVsaW1pdGVkVGV4dCxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXHJcbiAgICogdXBkYXRlIGNvbmZpZ3VyYXRpb25zIGFyZSBlYWNoIGV4cGVjdGVkIHRvIGhhdmUgYSBgcGFyZW50Tm9kZWAgcHJvcGVydHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uIChwYXJlbnROb2RlLCB1cGRhdGVzKSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgcGFyZW50Tm9kZURlYnVnSUQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShwYXJlbnROb2RlKS5fZGVidWdJRDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHVwZGF0ZXMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZXNba107XHJcbiAgICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcclxuICAgICAgICBjYXNlICdJTlNFUlRfTUFSS1VQJzpcclxuICAgICAgICAgIGluc2VydExhenlUcmVlQ2hpbGRBdChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCwgZ2V0Tm9kZUFmdGVyKHBhcmVudE5vZGUsIHVwZGF0ZS5hZnRlck5vZGUpKTtcclxuICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xyXG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxyXG4gICAgICAgICAgICAgIHR5cGU6ICdpbnNlcnQgY2hpbGQnLFxyXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHsgdG9JbmRleDogdXBkYXRlLnRvSW5kZXgsIGNvbnRlbnQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKCkgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ01PVkVfRVhJU1RJTkcnOlxyXG4gICAgICAgICAgbW92ZUNoaWxkKHBhcmVudE5vZGUsIHVwZGF0ZS5mcm9tTm9kZSwgZ2V0Tm9kZUFmdGVyKHBhcmVudE5vZGUsIHVwZGF0ZS5hZnRlck5vZGUpKTtcclxuICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xyXG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxyXG4gICAgICAgICAgICAgIHR5cGU6ICdtb3ZlIGNoaWxkJyxcclxuICAgICAgICAgICAgICBwYXlsb2FkOiB7IGZyb21JbmRleDogdXBkYXRlLmZyb21JbmRleCwgdG9JbmRleDogdXBkYXRlLnRvSW5kZXggfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1NFVF9NQVJLVVAnOlxyXG4gICAgICAgICAgc2V0SW5uZXJIVE1MKHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcclxuICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xyXG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxyXG4gICAgICAgICAgICAgIHR5cGU6ICdyZXBsYWNlIGNoaWxkcmVuJyxcclxuICAgICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUuY29udGVudC50b1N0cmluZygpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnVEVYVF9DT05URU5UJzpcclxuICAgICAgICAgIHNldFRleHRDb250ZW50KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcclxuICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xyXG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxyXG4gICAgICAgICAgICAgIHR5cGU6ICdyZXBsYWNlIHRleHQnLFxyXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdSRU1PVkVfTk9ERSc6XHJcbiAgICAgICAgICByZW1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUpO1xyXG4gICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXHJcbiAgICAgICAgICAgICAgdHlwZTogJ3JlbW92ZSBjaGlsZCcsXHJcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXggfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRE9NQ2hpbGRyZW5PcGVyYXRpb25zOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XHJcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xyXG5cclxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcclxudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xyXG5cclxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcclxudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xyXG5cclxuLyoqXHJcbiAqIEluIElFICg4LTExKSBhbmQgRWRnZSwgYXBwZW5kaW5nIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gaXMgZHJhbWF0aWNhbGx5XHJcbiAqIGZhc3RlciB0aGFuIGFwcGVuZGluZyBhIGZ1bGwgc3VidHJlZSwgc28gd2UgZXNzZW50aWFsbHkgcXVldWUgdXAgdGhlXHJcbiAqIC5hcHBlbmRDaGlsZCBjYWxscyBoZXJlIGFuZCBhcHBseSB0aGVtIHNvIGVhY2ggbm9kZSBpcyBhZGRlZCB0byBpdHMgcGFyZW50XHJcbiAqIGJlZm9yZSBhbnkgY2hpbGRyZW4gYXJlIGFkZGVkLlxyXG4gKlxyXG4gKiBJbiBvdGhlciBicm93c2VycywgZG9pbmcgc28gaXMgc2xvd2VyIG9yIG5ldXRyYWwgY29tcGFyZWQgdG8gdGhlIG90aGVyIG9yZGVyXHJcbiAqIChpbiBGaXJlZm94LCB0d2ljZSBhcyBzbG93KSBzbyB3ZSBvbmx5IGRvIHRoaXMgaW52ZXJzaW9uIGluIElFLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NwaWN5ai9pbm5lcmh0bWwtdnMtY3JlYXRlZWxlbWVudC12cy1jbG9uZW5vZGUuXHJcbiAqL1xyXG52YXIgZW5hYmxlTGF6eSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdzdHJpbmcnICYmIC9cXGJFZGdlXFwvXFxkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG5cclxuZnVuY3Rpb24gaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpIHtcclxuICBpZiAoIWVuYWJsZUxhenkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIG5vZGUgPSB0cmVlLm5vZGU7XHJcbiAgdmFyIGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcclxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGluc2VydFRyZWVCZWZvcmUobm9kZSwgY2hpbGRyZW5baV0sIG51bGwpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAodHJlZS5odG1sICE9IG51bGwpIHtcclxuICAgIHNldElubmVySFRNTChub2RlLCB0cmVlLmh0bWwpO1xyXG4gIH0gZWxzZSBpZiAodHJlZS50ZXh0ICE9IG51bGwpIHtcclxuICAgIHNldFRleHRDb250ZW50KG5vZGUsIHRyZWUudGV4dCk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgaW5zZXJ0VHJlZUJlZm9yZSA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIHRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcclxuICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmVuJ3QgYWN0dWFsbHkgcGFydCBvZiB0aGUgRE9NIGFmdGVyIGluc2VydGlvbiBzb1xyXG4gIC8vIGFwcGVuZGluZyBjaGlsZHJlbiB3b24ndCB1cGRhdGUgdGhlIERPTS4gV2UgbmVlZCB0byBlbnN1cmUgdGhlIGZyYWdtZW50XHJcbiAgLy8gaXMgcHJvcGVybHkgcG9wdWxhdGVkIGZpcnN0LCBicmVha2luZyBvdXQgb2Ygb3VyIGxhenkgYXBwcm9hY2ggZm9yIGp1c3RcclxuICAvLyB0aGlzIGxldmVsLiBBbHNvLCBzb21lIDxvYmplY3Q+IHBsdWdpbnMgKGxpa2UgRmxhc2ggUGxheWVyKSB3aWxsIHJlYWRcclxuICAvLyA8cGFyYW0+IG5vZGVzIGltbWVkaWF0ZWx5IHVwb24gaW5zZXJ0aW9uIGludG8gdGhlIERPTSwgc28gPG9iamVjdD5cclxuICAvLyBtdXN0IGFsc28gYmUgcG9wdWxhdGVkIHByaW9yIHRvIGluc2VydGlvbiBpbnRvIHRoZSBET00uXHJcbiAgaWYgKHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFIHx8IHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgJiYgdHJlZS5ub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnICYmICh0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09IG51bGwgfHwgdHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSkge1xyXG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xyXG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJlZS5ub2RlLCByZWZlcmVuY2VOb2RlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJlZS5ub2RlLCByZWZlcmVuY2VOb2RlKTtcclxuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkTm9kZSwgbmV3VHJlZSkge1xyXG4gIG9sZE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3VHJlZS5ub2RlLCBvbGROb2RlKTtcclxuICBpbnNlcnRUcmVlQ2hpbGRyZW4obmV3VHJlZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1ZXVlQ2hpbGQocGFyZW50VHJlZSwgY2hpbGRUcmVlKSB7XHJcbiAgaWYgKGVuYWJsZUxhenkpIHtcclxuICAgIHBhcmVudFRyZWUuY2hpbGRyZW4ucHVzaChjaGlsZFRyZWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwYXJlbnRUcmVlLm5vZGUuYXBwZW5kQ2hpbGQoY2hpbGRUcmVlLm5vZGUpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcXVldWVIVE1MKHRyZWUsIGh0bWwpIHtcclxuICBpZiAoZW5hYmxlTGF6eSkge1xyXG4gICAgdHJlZS5odG1sID0gaHRtbDtcclxuICB9IGVsc2Uge1xyXG4gICAgc2V0SW5uZXJIVE1MKHRyZWUubm9kZSwgaHRtbCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBxdWV1ZVRleHQodHJlZSwgdGV4dCkge1xyXG4gIGlmIChlbmFibGVMYXp5KSB7XHJcbiAgICB0cmVlLnRleHQgPSB0ZXh0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzZXRUZXh0Q29udGVudCh0cmVlLm5vZGUsIHRleHQpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcbiAgcmV0dXJuIHRoaXMubm9kZS5ub2RlTmFtZTtcclxufVxyXG5cclxuZnVuY3Rpb24gRE9NTGF6eVRyZWUobm9kZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBub2RlOiBub2RlLFxyXG4gICAgY2hpbGRyZW46IFtdLFxyXG4gICAgaHRtbDogbnVsbCxcclxuICAgIHRleHQ6IG51bGwsXHJcbiAgICB0b1N0cmluZzogdG9TdHJpbmdcclxuICB9O1xyXG59XHJcblxyXG5ET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlID0gaW5zZXJ0VHJlZUJlZm9yZTtcclxuRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUgPSByZXBsYWNlQ2hpbGRXaXRoVHJlZTtcclxuRE9NTGF6eVRyZWUucXVldWVDaGlsZCA9IHF1ZXVlQ2hpbGQ7XHJcbkRPTUxhenlUcmVlLnF1ZXVlSFRNTCA9IHF1ZXVlSFRNTDtcclxuRE9NTGF6eVRyZWUucXVldWVUZXh0ID0gcXVldWVUZXh0O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBET01MYXp5VHJlZTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRE9NTmFtZXNwYWNlcyA9IHtcclxuICBodG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsXHJcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXHJcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERPTU5hbWVzcGFjZXM7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xyXG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcclxufVxyXG5cclxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xyXG4gIC8qKlxyXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XHJcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxyXG4gICAqL1xyXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXHJcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDB4NCxcclxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHg4LFxyXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxyXG4gIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6IDB4MjAsXHJcblxyXG4gIC8qKlxyXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxyXG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAqXHJcbiAgICogaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIHRoYXQgZ2l2ZW4gYW4gYXR0cmlidXRlIG5hbWUgd2lsbCByZXR1cm4gdHJ1ZVxyXG4gICAqIGlmIGl0IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00gdmVyYmF0aW0uIFVzZWZ1bCBmb3IgZGF0YS0qIG9yIGFyaWEtKlxyXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXHJcbiAgICogYXR0cmlidXRlIG5hbWVzLFxyXG4gICAqXHJcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxyXG4gICAqIERPTVByb3BlcnR5SW5qZWN0aW9uIGNvbnN0YW50cyBvciBudWxsLiBJZiB5b3VyIGF0dHJpYnV0ZSBpc24ndCBpbiBoZXJlLFxyXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXHJcbiAgICpcclxuICAgKiBET01BdHRyaWJ1dGVOYW1lczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxyXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcclxuICAgKiBub3JtYWxpemVkIG5hbWUuXHJcbiAgICpcclxuICAgKiBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXHJcbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcclxuICAgKlxyXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cclxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxyXG4gICAqXHJcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXHJcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cclxuICAgKi9cclxuICBpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzogZnVuY3Rpb24gKGRvbVByb3BlcnR5Q29uZmlnKSB7XHJcbiAgICB2YXIgSW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XHJcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XHJcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXNwYWNlcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgfHwge307XHJcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lcyB8fCB7fTtcclxuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcclxuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XHJcblxyXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XHJcbiAgICAgIERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5wdXNoKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICEhRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91XFwncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgXFwnJXNcXCcgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy4nLCBwcm9wTmFtZSkgOiBfcHJvZEludmFyaWFudCgnNDgnLCBwcm9wTmFtZSkgOiB2b2lkIDA7XHJcblxyXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XHJcblxyXG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0ge1xyXG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXHJcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxyXG4gICAgICAgIHByb3BlcnR5TmFtZTogcHJvcE5hbWUsXHJcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXHJcblxyXG4gICAgICAgIG11c3RVc2VQcm9wZXJ0eTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWSksXHJcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcclxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxyXG4gICAgICAgIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxcclxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpXHJcbiAgICAgIH07XHJcbiAgICAgICEocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSArIHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSA8PSAxKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yIG51bWVyaWMgdmFsdWUsIGJ1dCBub3QgYSBjb21iaW5hdGlvbjogJXMnLCBwcm9wTmFtZSkgOiBfcHJvZEludmFyaWFudCgnNTAnLCBwcm9wTmFtZSkgOiB2b2lkIDA7XHJcblxyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWRdID0gcHJvcE5hbWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcclxuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcclxuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2F0dHJpYnV0ZU5hbWVdID0gcHJvcE5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcclxuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChET01Qcm9wZXJ0eU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xyXG4gICAgICAgIHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWUgPSBET01Qcm9wZXJ0eU5hbWVzW3Byb3BOYW1lXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKERPTU11dGF0aW9uTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcclxuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXHJcbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gJzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xyXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cclxuXHJcbi8qKlxyXG4gKiBET01Qcm9wZXJ0eSBleHBvcnRzIGxvb2t1cCBvYmplY3RzIHRoYXQgY2FuIGJlIHVzZWQgbGlrZSBmdW5jdGlvbnM6XHJcbiAqXHJcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXHJcbiAqICAgdHJ1ZVxyXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnZm9vYmFyJ11cclxuICogICB1bmRlZmluZWRcclxuICpcclxuICogQWx0aG91Z2ggdGhpcyBtYXkgYmUgY29uZnVzaW5nLCBpdCBwZXJmb3JtcyBiZXR0ZXIgaW4gZ2VuZXJhbC5cclxuICpcclxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktZXhpc3RzXHJcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LW1pc3NpbmdcclxuICovXHJcbnZhciBET01Qcm9wZXJ0eSA9IHtcclxuXHJcbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxyXG4gIFJPT1RfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0cm9vdCcsXHJcblxyXG4gIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIsXHJcbiAgQVRUUklCVVRFX05BTUVfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCcsXHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxyXG4gICAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcclxuICAgKlxyXG4gICAqIGF0dHJpYnV0ZU5hbWU6XHJcbiAgICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxyXG4gICAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxyXG4gICAqIHByb3BlcnR5TmFtZTpcclxuICAgKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xyXG4gICAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXHJcbiAgICogbXV0YXRpb25NZXRob2Q6XHJcbiAgICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXHJcbiAgICogICBpbml0aWFsIHJlbmRlci5cclxuICAgKiBtdXN0VXNlUHJvcGVydHk6XHJcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cclxuICAgKiBoYXNCb29sZWFuVmFsdWU6XHJcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cclxuICAgKiBoYXNOdW1lcmljVmFsdWU6XHJcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcclxuICAgKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXHJcbiAgICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XHJcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxyXG4gICAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXHJcbiAgICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcclxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cclxuICAgKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxyXG4gICAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxyXG4gICAqL1xyXG4gIHByb3BlcnRpZXM6IHt9LFxyXG5cclxuICAvKipcclxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLCB1c2VkXHJcbiAgICogdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIHByb3BlcnRpZXMuIEF2YWlsYWJsZSBvbmx5IGluIF9fREVWX18uXHJcbiAgICpcclxuICAgKiBhdXRvZm9jdXMgaXMgcHJlZGVmaW5lZCwgYmVjYXVzZSBhZGRpbmcgaXQgdG8gdGhlIHByb3BlcnR5IHdoaXRlbGlzdFxyXG4gICAqIGNhdXNlcyB1bmludGVuZGVkIHNpZGUgZWZmZWN0cy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB7IGF1dG9mb2N1czogJ2F1dG9Gb2N1cycgfSA6IG51bGwsXHJcblxyXG4gIC8qKlxyXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXHJcbiAgICovXHJcbiAgX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zOiBbXSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgY3VzdG9tIGF0dHJpYnV0ZS5cclxuICAgKiBAbWV0aG9kXHJcbiAgICovXHJcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgaXNDdXN0b21BdHRyaWJ1dGVGbiA9IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uc1tpXTtcclxuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIGluamVjdGlvbjogRE9NUHJvcGVydHlJbmplY3Rpb25cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHk7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xyXG5cclxudmFyIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcicpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcclxudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcclxudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xyXG5cclxuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XHJcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XHJcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xyXG4gIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpIDogdm9pZCAwO1xyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxyXG4gKi9cclxudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBJRCBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLlxyXG4gICAqL1xyXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHJldHVybiBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKGlkKTtcclxuICB9LFxyXG5cclxuICBzZXRBdHRyaWJ1dGVGb3JJRDogZnVuY3Rpb24gKG5vZGUsIGlkKSB7XHJcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSwgaWQpO1xyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZU1hcmt1cEZvclJvb3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FICsgJz1cIlwiJztcclxuICB9LFxyXG5cclxuICBzZXRBdHRyaWJ1dGVGb3JSb290OiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRSwgJycpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXHJcbiAgICovXHJcbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcclxuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcclxuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPVwiXCInO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xyXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIGN1c3RvbSBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cclxuICAgKi9cclxuICBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICovXHJcbiAgc2V0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xyXG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xyXG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XHJcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xyXG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcclxuICAgICAgfSBlbHNlIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xyXG4gICAgICAgIHRoaXMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xyXG4gICAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcclxuICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXHJcbiAgICAgICAgbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXSA9IHZhbHVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XHJcbiAgICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxyXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cclxuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xyXG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcclxuICAgICAgcGF5bG9hZFtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcclxuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcclxuICAgICAgICB0eXBlOiAndXBkYXRlIGF0dHJpYnV0ZScsXHJcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyArIHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgcGF5bG9hZCA9IHt9O1xyXG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XHJcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xyXG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxyXG4gICAgICAgIHR5cGU6ICd1cGRhdGUgYXR0cmlidXRlJyxcclxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZXMgYW4gYXR0cmlidXRlcyBmcm9tIGEgbm9kZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICovXHJcbiAgZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XHJcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xyXG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxyXG4gICAgICAgIHR5cGU6ICdyZW1vdmUgYXR0cmlidXRlJyxcclxuICAgICAgICBwYXlsb2FkOiBuYW1lXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICovXHJcbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcclxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XHJcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XHJcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcclxuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XHJcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcclxuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XHJcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcclxuICAgICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xyXG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XHJcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xyXG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxyXG4gICAgICAgIHR5cGU6ICdyZW1vdmUgYXR0cmlidXRlJyxcclxuICAgICAgICBwYXlsb2FkOiBuYW1lXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9uczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xyXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xyXG5cclxudmFyIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cCA9IHJlcXVpcmUoJ2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCcpO1xyXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG5cclxudmFyIERhbmdlciA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVwbGFjZXMgYSBub2RlIHdpdGggYSBzdHJpbmcgb2YgbWFya3VwIGF0IGl0cyBjdXJyZW50IHBvc2l0aW9uIHdpdGhpbiBpdHNcclxuICAgKiBwYXJlbnQuIFRoZSBtYXJrdXAgbXVzdCByZW5kZXIgaW50byBhIHNpbmdsZSByb290IG5vZGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG9sZENoaWxkIENoaWxkIG5vZGUgdG8gcmVwbGFjZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byByZW5kZXIgaW4gcGxhY2Ugb2YgdGhlIGNoaWxkIG5vZGUuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwKSB7XHJcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgd29ya2VyIHRocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgZ2xvYmFsbHkgYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IF9wcm9kSW52YXJpYW50KCc1NicpIDogdm9pZCAwO1xyXG4gICAgIW1hcmt1cCA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IF9wcm9kSW52YXJpYW50KCc1NycpIDogdm9pZCAwO1xyXG4gICAgIShvbGRDaGlsZC5ub2RlTmFtZSAhPT0gJ0hUTUwnKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVwbGFjZSBtYXJrdXAgb2YgdGhlIDxodG1sPiBub2RlLiBUaGlzIGlzIGJlY2F1c2UgYnJvd3NlciBxdWlya3MgbWFrZSB0aGlzIHVucmVsaWFibGUgYW5kL29yIHNsb3cuIElmIHlvdSB3YW50IHRvIHJlbmRlciB0byB0aGUgcm9vdCB5b3UgbXVzdCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkuJykgOiBfcHJvZEludmFyaWFudCgnNTgnKSA6IHZvaWQgMDtcclxuXHJcbiAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdmFyIG5ld0NoaWxkID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgZW1wdHlGdW5jdGlvbilbMF07XHJcbiAgICAgIG9sZENoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZShvbGRDaGlsZCwgbWFya3VwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEYW5nZXI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIE1vZHVsZSB0aGF0IGlzIGluamVjdGFibGUgaW50byBgRXZlbnRQbHVnaW5IdWJgLCB0aGF0IHNwZWNpZmllcyBhXHJcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XHJcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cclxuICogaGF2aW5nIHBsdWdpbnMgYmUgb3JkZXJlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGluamVjdGVkIGJlY2F1c2VcclxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXHJcbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XHJcbiAqIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBldmVudHMgaXMgY29udmVuaWVudCBpbiBgU2ltcGxlRXZlbnRQbHVnaW5gIGhhbmRsZXJzLlxyXG4gKi9cclxuXHJcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IFsnUmVzcG9uZGVyRXZlbnRQbHVnaW4nLCAnU2ltcGxlRXZlbnRQbHVnaW4nLCAnVGFwRXZlbnRQbHVnaW4nLCAnRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJywgJ0NoYW5nZUV2ZW50UGx1Z2luJywgJ1NlbGVjdEV2ZW50UGx1Z2luJywgJ0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XHJcblxyXG52YXIgZXZlbnRUeXBlcyA9IHtcclxuICBtb3VzZUVudGVyOiB7XHJcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUVudGVyJyxcclxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxyXG4gIH0sXHJcbiAgbW91c2VMZWF2ZToge1xyXG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXHJcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cclxuICB9XHJcbn07XHJcblxyXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xyXG5cclxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxyXG5cclxuICAvKipcclxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxyXG4gICAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcclxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXHJcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXHJcbiAgICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cclxuICAgKi9cclxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU92ZXInICYmIChuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50KSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU91dCcgJiYgdG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdmVyJykge1xyXG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgd2luO1xyXG4gICAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXHJcbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxyXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcclxuICAgICAgaWYgKGRvYykge1xyXG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdpbiA9IHdpbmRvdztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBmcm9tO1xyXG4gICAgdmFyIHRvO1xyXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3V0Jykge1xyXG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcclxuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcclxuICAgICAgdG8gPSByZWxhdGVkID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXHJcbiAgICAgIGZyb20gPSBudWxsO1xyXG4gICAgICB0byA9IHRhcmdldEluc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XHJcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoZnJvbSk7XHJcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRvKTtcclxuXHJcbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlTGVhdmUsIGZyb20sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xyXG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XHJcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG9Ob2RlO1xyXG5cclxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xyXG4gICAgZW50ZXIudGFyZ2V0ID0gdG9Ob2RlO1xyXG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xyXG5cclxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xyXG5cclxuICAgIHJldHVybiBbbGVhdmUsIGVudGVyXTtcclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbnRlckxlYXZlRXZlbnRQbHVnaW47IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XHJcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XHJcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xyXG5cclxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xyXG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIHN0b3JlIGZvciBldmVudCBsaXN0ZW5lcnNcclxuICovXHJcbnZhciBsaXN0ZW5lckJhbmsgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxyXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cclxuICovXHJcbnZhciBldmVudFF1ZXVlID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xyXG4gIGlmIChldmVudCkge1xyXG4gICAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XHJcblxyXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xyXG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xyXG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XHJcbn07XHJcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XHJcbn07XHJcblxyXG52YXIgZ2V0RGljdGlvbmFyeUtleSA9IGZ1bmN0aW9uIChpbnN0KSB7XHJcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxyXG4gIHJldHVybiAnLicgKyBpbnN0Ll9yb290Tm9kZUlEO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcclxuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XHJcbiAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICBjYXNlICdvbkNsaWNrJzpcclxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcclxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2snOlxyXG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxyXG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxyXG4gICAgY2FzZSAnb25Nb3VzZURvd25DYXB0dXJlJzpcclxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcclxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XHJcbiAgICBjYXNlICdvbk1vdXNlVXAnOlxyXG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XHJcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxyXG4gKlxyXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKlxyXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxyXG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXHJcbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxyXG4gKlxyXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxyXG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxyXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxyXG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXHJcbiAqXHJcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XHJcbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcclxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cclxuICpcclxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXHJcbiAgICovXHJcbiAgaW5qZWN0aW9uOiB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXHJcbiAgICAgKi9cclxuICAgIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcclxuXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldYC4gSXMgaWRlbXBvdGVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cclxuICAgKi9cclxuICBwdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAhKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiBfcHJvZEludmFyaWFudCgnOTQnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xyXG5cclxuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xyXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XHJcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldID0gbGlzdGVuZXI7XHJcblxyXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XHJcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcikge1xyXG4gICAgICBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxyXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cclxuICAgKi9cclxuICBnZXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcclxuICAgIC8vIFRPRE86IHNob3VsZFByZXZlbnRNb3VzZUV2ZW50IGlzIERPTS1zcGVjaWZpYyBhbmQgZGVmaW5pdGVseSBzaG91bGQgbm90XHJcbiAgICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cclxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcclxuICAgIGlmIChzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLCBpbnN0Ll9jdXJyZW50RWxlbWVudC50eXBlLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcykpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcclxuICAgIHJldHVybiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSAmJiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZXMgYSBsaXN0ZW5lciBmcm9tIHRoZSByZWdpc3RyYXRpb24gYmFuay5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxyXG4gICAqL1xyXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xyXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XHJcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcclxuICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XHJcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBuZXZlciBiZSBudWxsIC0tIHdoZW4gaXMgaXQ/XHJcbiAgICBpZiAoYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUpIHtcclxuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XHJcbiAgICAgIGRlbGV0ZSBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIERPTSBlbGVtZW50IHdpdGggdGhlIHN1cHBsaWVkIElELlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cclxuICAgKi9cclxuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChpbnN0KSB7XHJcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcclxuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XHJcbiAgICAgIGlmICghbGlzdGVuZXJCYW5rLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV0pIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XHJcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xyXG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXHJcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgICB2YXIgZXZlbnRzO1xyXG4gICAgdmFyIHBsdWdpbnMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnM7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxyXG4gICAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xyXG4gICAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcclxuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xyXG4gICAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50cztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cclxuICAgKiBgcHJvY2Vzc0V2ZW50UXVldWVgIGlzIGludm9rZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XHJcbiAgICBpZiAoZXZlbnRzKSB7XHJcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgYWxsIHN5bnRoZXRpYyBldmVudHMgb24gdGhlIGV2ZW50IHF1ZXVlLlxyXG4gICAqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uIChzaW11bGF0ZWQpIHtcclxuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcclxuICAgIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cclxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XHJcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcclxuICAgIGlmIChzaW11bGF0ZWQpIHtcclxuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCk7XHJcbiAgICB9XHJcbiAgICAhIWV2ZW50UXVldWUgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nIGFuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiBfcHJvZEludmFyaWFudCgnOTUnKSA6IHZvaWQgMDtcclxuICAgIC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxyXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZXNlIGFyZSBuZWVkZWQgZm9yIHRlc3RzIG9ubHkuIERvIG5vdCB1c2UhXHJcbiAgICovXHJcbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xyXG4gICAgbGlzdGVuZXJCYW5rID0ge307XHJcbiAgfSxcclxuXHJcbiAgX19nZXRMaXN0ZW5lckJhbms6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBsaXN0ZW5lckJhbms7XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5IdWI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG4vKipcclxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxyXG4gKi9cclxudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxyXG4gKi9cclxudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XHJcblxyXG4vKipcclxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xyXG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xyXG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgZXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcclxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcclxuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcclxuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTYnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcclxuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTcnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcclxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XHJcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XHJcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XHJcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBGYWlsZWQgdG8gcHVibGlzaCBldmVudCBgJXNgIGZvciBwbHVnaW4gYCVzYC4nLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk4JywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XHJcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTknLCBldmVudE5hbWUpIDogdm9pZCAwO1xyXG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcclxuXHJcbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XHJcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XHJcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcclxuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcclxuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XHJcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcclxuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXHJcbiAqIGNhbiBiZSB1c2VkIHdpdGggYEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyYCB0byByZWdpc3RlciBsaXN0ZW5lcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cclxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xyXG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTAwJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XHJcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZTtcclxuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcclxuXHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gPSByZWdpc3RyYXRpb25OYW1lO1xyXG5cclxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcclxuICAgICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxyXG4gKlxyXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cclxuICovXHJcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xyXG5cclxuICAvKipcclxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cclxuICAgKi9cclxuICBwbHVnaW5zOiBbXSxcclxuXHJcbiAgLyoqXHJcbiAgICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXHJcbiAgICovXHJcbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiB7fSxcclxuXHJcbiAgLyoqXHJcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcclxuICAgKi9cclxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXHJcbiAgICovXHJcbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczoge30sXHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxyXG4gICAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcclxuICAgKiBvbmx5IGluIF9fREVWX18uXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOiBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxyXG4gIC8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiBfX0RFVl9fXHJcblxyXG4gIC8qKlxyXG4gICAqIEluamVjdHMgYW4gb3JkZXJpbmcgb2YgcGx1Z2lucyAoYnkgcGx1Z2luIG5hbWUpLiBUaGlzIGFsbG93cyB0aGUgb3JkZXJpbmdcclxuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcclxuICAgKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyfVxyXG4gICAqL1xyXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGZ1bmN0aW9uIChpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcclxuICAgICEhZXZlbnRQbHVnaW5PcmRlciA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzEwMScpIDogdm9pZCAwO1xyXG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxyXG4gICAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XHJcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxyXG4gICAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXHJcbiAgICpcclxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XHJcbiAgICovXHJcbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xyXG4gICAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xyXG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XHJcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xyXG4gICAgICBpZiAoIW5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpIHx8IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBwbHVnaW5Nb2R1bGUpIHtcclxuICAgICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTAyJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XHJcbiAgICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xyXG4gICAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIExvb2tzIHVwIHRoZSBwbHVnaW4gZm9yIHRoZSBzdXBwbGllZCBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cclxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBUaGUgcGx1Z2luIHRoYXQgY3JlYXRlZCB0aGUgc3VwcGxpZWQgZXZlbnQuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gZXZlbnQuZGlzcGF0Y2hDb25maWc7XHJcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xyXG4gICAgICByZXR1cm4gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lXSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gcHVsbGluZyBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyBvdXQgb2YgZGlzcGF0Y2hDb25maWcgaGVscHMgRmxvdyBzZWVcclxuICAgICAgLy8gdGhhdCBpdCBpcyBub3QgdW5kZWZpbmVkLlxyXG4gICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcclxuXHJcbiAgICAgIGZvciAodmFyIHBoYXNlIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XHJcbiAgICAgICAgaWYgKCFwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1twaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1dO1xyXG4gICAgICAgIGlmIChwbHVnaW5Nb2R1bGUpIHtcclxuICAgICAgICAgIHJldHVybiBwbHVnaW5Nb2R1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcmVzZXRFdmVudFBsdWdpbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xyXG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xyXG4gICAgICBpZiAobmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcclxuICAgICAgICBkZWxldGUgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucy5sZW5ndGggPSAwO1xyXG5cclxuICAgIHZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncztcclxuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcclxuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcclxuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcclxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XHJcbiAgICAgICAgZGVsZXRlIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XHJcbiAgICAgIGZvciAodmFyIGxvd2VyQ2FzZWROYW1lIGluIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMpIHtcclxuICAgICAgICBpZiAocG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcclxuICAgICAgICAgIGRlbGV0ZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG4vKipcclxuICogSW5qZWN0ZWQgZGVwZW5kZW5jaWVzOlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiAtIGBDb21wb25lbnRUcmVlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBjYW4gY29udmVydCBiZXR3ZWVuIFJlYWN0IGluc3RhbmNlc1xyXG4gKiAgIGFuZCBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxyXG4gKi9cclxudmFyIENvbXBvbmVudFRyZWU7XHJcbnZhciBUcmVlVHJhdmVyc2FsO1xyXG52YXIgaW5qZWN0aW9uID0ge1xyXG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xyXG4gICAgQ29tcG9uZW50VHJlZSA9IEluamVjdGVkO1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuZ2V0Tm9kZUZyb21JbnN0YW5jZSAmJiBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKSA6IHZvaWQgMDtcclxuICAgIH1cclxuICB9LFxyXG4gIGluamVjdFRyZWVUcmF2ZXJzYWw6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xyXG4gICAgVHJlZVRyYXZlcnNhbCA9IEluamVjdGVkO1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuaXNBbmNlc3RvciAmJiBJbmplY3RlZC5nZXRMb3dlc3RDb21tb25BbmNlc3RvciwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdFRyZWVUcmF2ZXJzYWwoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBpc0FuY2VzdG9yIG9yIGdldExvd2VzdENvbW1vbkFuY2VzdG9yLicpIDogdm9pZCAwO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGlzRW5kaXNoKHRvcExldmVsVHlwZSkge1xyXG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaEVuZCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hDYW5jZWwnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XHJcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlTW92ZScgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hNb3ZlJztcclxufVxyXG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xyXG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZURvd24nIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoU3RhcnQnO1xyXG59XHJcblxyXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcclxuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcclxuXHJcbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcclxuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XHJcblxyXG4gICAgdmFyIGluc3RhbmNlc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaEluc3RhbmNlcyk7XHJcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xyXG5cclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHZvaWQgMDtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cclxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xyXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXHJcbiAqL1xyXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGluc3QpIHtcclxuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xyXG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XHJcbiAgaWYgKHNpbXVsYXRlZCkge1xyXG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCh0eXBlLCBsaXN0ZW5lciwgZXZlbnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XHJcbiAgfVxyXG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xyXG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcclxuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcclxuICB9XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXHJcbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcclxuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJbnN0YW5jZXMpO1xyXG4gIH1cclxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xyXG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXHJcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXHJcbiAqXHJcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xyXG4gKiB0cnVlLCBvciBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xyXG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcclxuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcclxuICB9XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXHJcbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzW2ldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xyXG4gICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKGV2ZW50LCBkaXNwYXRjaEluc3RhbmNlcykpIHtcclxuICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcclxuICovXHJcbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcclxuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xyXG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XHJcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcclxuICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vKipcclxuICogRXhlY3V0aW9uIG9mIGEgXCJkaXJlY3RcIiBkaXNwYXRjaCAtIHRoZXJlIG11c3QgYmUgYXQgbW9zdCBvbmUgZGlzcGF0Y2hcclxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcclxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcclxuICogcmV0dXJuIHZhbHVlcyBhdCBlYWNoIGRpc3BhdGNoIGV4ZWN1dGlvbiwgYnV0IGl0IGRvZXMgdGVuZCB0byBtYWtlIHNlbnNlIHdoZW5cclxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cclxuICpcclxuICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBleGVjdXRpbmcgdGhlIHNpbmdsZSBkaXNwYXRjaC5cclxuICovXHJcbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XHJcbiAgfVxyXG4gIHZhciBkaXNwYXRjaExpc3RlbmVyID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xyXG4gIHZhciBkaXNwYXRjaEluc3RhbmNlID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xyXG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLicpIDogX3Byb2RJbnZhcmlhbnQoJzEwMycpIDogdm9pZCAwO1xyXG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBkaXNwYXRjaExpc3RlbmVyID8gRXZlbnRQbHVnaW5VdGlscy5nZXROb2RlRnJvbUluc3RhbmNlKGRpc3BhdGNoSW5zdGFuY2UpIDogbnVsbDtcclxuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQpIDogbnVsbDtcclxuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcclxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xyXG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzRGlzcGF0Y2hlcyhldmVudCkge1xyXG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYWwgdXRpbGl0aWVzIHRoYXQgYXJlIHVzZWZ1bCBpbiBjcmVhdGluZyBjdXN0b20gRXZlbnQgUGx1Z2lucy5cclxuICovXHJcbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xyXG4gIGlzRW5kaXNoOiBpc0VuZGlzaCxcclxuICBpc01vdmVpc2g6IGlzTW92ZWlzaCxcclxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxyXG5cclxuICBleGVjdXRlRGlyZWN0RGlzcGF0Y2g6IGV4ZWN1dGVEaXJlY3REaXNwYXRjaCxcclxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcclxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlLFxyXG4gIGhhc0Rpc3BhdGNoZXM6IGhhc0Rpc3BhdGNoZXMsXHJcblxyXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICByZXR1cm4gQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpO1xyXG4gIH0sXHJcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2Uobm9kZSk7XHJcbiAgfSxcclxuICBpc0FuY2VzdG9yOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuaXNBbmNlc3RvcihhLCBiKTtcclxuICB9LFxyXG4gIGdldExvd2VzdENvbW1vbkFuY2VzdG9yOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoYSwgYik7XHJcbiAgfSxcclxuICBnZXRQYXJlbnRJbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcclxuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLmdldFBhcmVudEluc3RhbmNlKGluc3QpO1xyXG4gIH0sXHJcbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24gKHRhcmdldCwgZm4sIGFyZykge1xyXG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwudHJhdmVyc2VUd29QaGFzZSh0YXJnZXQsIGZuLCBhcmcpO1xyXG4gIH0sXHJcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiBmdW5jdGlvbiAoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xyXG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwudHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pO1xyXG4gIH0sXHJcblxyXG4gIGluamVjdGlvbjogaW5qZWN0aW9uXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luVXRpbHM7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xyXG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xyXG5cclxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xyXG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgZ2V0TGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcjtcclxuXHJcbi8qKlxyXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XHJcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcclxuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xyXG4gIHJldHVybiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cclxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cclxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcclxuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cclxuICovXHJcbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoaW5zdCwgcGhhc2UsIGV2ZW50KSB7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcclxuICB9XHJcbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XHJcbiAgaWYgKGxpc3RlbmVyKSB7XHJcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcclxuICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxyXG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcclxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxyXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcclxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XHJcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XHJcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxyXG4gKi9cclxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcclxuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcclxuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XHJcbiAgICB2YXIgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBFdmVudFBsdWdpblV0aWxzLmdldFBhcmVudEluc3RhbmNlKHRhcmdldEluc3QpIDogbnVsbDtcclxuICAgIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VUd29QaGFzZShwYXJlbnRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcclxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcclxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xyXG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XHJcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XHJcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcclxuICAgIGlmIChsaXN0ZW5lcikge1xyXG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcclxuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcclxuICogYGRpc3BhdGNoTWFya2VyYC5cclxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcclxuICovXHJcbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XHJcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcclxuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xyXG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcclxuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XHJcbiAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcclxuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxyXG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcclxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxyXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcclxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcclxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbnQgYVxyXG4gKiBzaW5nbGUgb25lLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3IgRXZlbnRQcm9wYWdhdG9yc1xyXG4gKi9cclxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XHJcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcclxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQsXHJcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxyXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UHJvcGFnYXRvcnM7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XHJcblxyXG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaGVscGVyIGNsYXNzIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcclxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cclxuICpcclxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxyXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxyXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxyXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSByb290XHJcbiAqL1xyXG5mdW5jdGlvbiBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUocm9vdCkge1xyXG4gIHRoaXMuX3Jvb3QgPSByb290O1xyXG4gIHRoaXMuX3N0YXJ0VGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xyXG4gIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XHJcbn1cclxuXHJcbl9hc3NpZ24oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnByb3RvdHlwZSwge1xyXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xyXG4gICAgdGhpcy5fc3RhcnRUZXh0ID0gbnVsbDtcclxuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cclxuICBnZXRUZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoJ3ZhbHVlJyBpbiB0aGlzLl9yb290KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxyXG4gICAqIHRleHQgY29udGVudCBhbmQgdGhlIGN1cnJlbnQgY29udGVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cclxuICBnZXREYXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN0YXJ0O1xyXG4gICAgdmFyIHN0YXJ0VmFsdWUgPSB0aGlzLl9zdGFydFRleHQ7XHJcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcclxuICAgIHZhciBlbmQ7XHJcbiAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLmdldFRleHQoKTtcclxuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XHJcblxyXG4gICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcclxuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xyXG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xyXG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcclxuICB9XHJcbn0pO1xyXG5cclxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XHJcblxyXG52YXIgTVVTVF9VU0VfUFJPUEVSVFkgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XHJcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcclxudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xyXG52YXIgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU7XHJcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XHJcblxyXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xyXG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZChuZXcgUmVnRXhwKCdeKGRhdGF8YXJpYSktWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpKSxcclxuICBQcm9wZXJ0aWVzOiB7XHJcbiAgICAvKipcclxuICAgICAqIFN0YW5kYXJkIFByb3BlcnRpZXNcclxuICAgICAqL1xyXG4gICAgYWNjZXB0OiAwLFxyXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcclxuICAgIGFjY2Vzc0tleTogMCxcclxuICAgIGFjdGlvbjogMCxcclxuICAgIGFsbG93RnVsbFNjcmVlbjogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogMCxcclxuICAgIGFsdDogMCxcclxuICAgIC8vIHNwZWNpZmllcyB0YXJnZXQgY29udGV4dCBmb3IgbGlua3Mgd2l0aCBgcHJlbG9hZGAgdHlwZVxyXG4gICAgYXM6IDAsXHJcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBhdXRvQ29tcGxldGU6IDAsXHJcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c1V0aWxzXHJcbiAgICAvLyBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgY2FwdHVyZTogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBjZWxsUGFkZGluZzogMCxcclxuICAgIGNlbGxTcGFjaW5nOiAwLFxyXG4gICAgY2hhclNldDogMCxcclxuICAgIGNoYWxsZW5nZTogMCxcclxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBjaXRlOiAwLFxyXG4gICAgY2xhc3NJRDogMCxcclxuICAgIGNsYXNzTmFtZTogMCxcclxuICAgIGNvbHM6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxyXG4gICAgY29sU3BhbjogMCxcclxuICAgIGNvbnRlbnQ6IDAsXHJcbiAgICBjb250ZW50RWRpdGFibGU6IDAsXHJcbiAgICBjb250ZXh0TWVudTogMCxcclxuICAgIGNvbnRyb2xzOiBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIGNvb3JkczogMCxcclxuICAgIGNyb3NzT3JpZ2luOiAwLFxyXG4gICAgZGF0YTogMCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxyXG4gICAgZGF0ZVRpbWU6IDAsXHJcbiAgICAnZGVmYXVsdCc6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgZGlyOiAwLFxyXG4gICAgZGlzYWJsZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBkcmFnZ2FibGU6IDAsXHJcbiAgICBlbmNUeXBlOiAwLFxyXG4gICAgZm9ybTogMCxcclxuICAgIGZvcm1BY3Rpb246IDAsXHJcbiAgICBmb3JtRW5jVHlwZTogMCxcclxuICAgIGZvcm1NZXRob2Q6IDAsXHJcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBmb3JtVGFyZ2V0OiAwLFxyXG4gICAgZnJhbWVCb3JkZXI6IDAsXHJcbiAgICBoZWFkZXJzOiAwLFxyXG4gICAgaGVpZ2h0OiAwLFxyXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIGhpZ2g6IDAsXHJcbiAgICBocmVmOiAwLFxyXG4gICAgaHJlZkxhbmc6IDAsXHJcbiAgICBodG1sRm9yOiAwLFxyXG4gICAgaHR0cEVxdWl2OiAwLFxyXG4gICAgaWNvbjogMCxcclxuICAgIGlkOiAwLFxyXG4gICAgaW5wdXRNb2RlOiAwLFxyXG4gICAgaW50ZWdyaXR5OiAwLFxyXG4gICAgaXM6IDAsXHJcbiAgICBrZXlQYXJhbXM6IDAsXHJcbiAgICBrZXlUeXBlOiAwLFxyXG4gICAga2luZDogMCxcclxuICAgIGxhYmVsOiAwLFxyXG4gICAgbGFuZzogMCxcclxuICAgIGxpc3Q6IDAsXHJcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIGxvdzogMCxcclxuICAgIG1hbmlmZXN0OiAwLFxyXG4gICAgbWFyZ2luSGVpZ2h0OiAwLFxyXG4gICAgbWFyZ2luV2lkdGg6IDAsXHJcbiAgICBtYXg6IDAsXHJcbiAgICBtYXhMZW5ndGg6IDAsXHJcbiAgICBtZWRpYTogMCxcclxuICAgIG1lZGlhR3JvdXA6IDAsXHJcbiAgICBtZXRob2Q6IDAsXHJcbiAgICBtaW46IDAsXHJcbiAgICBtaW5MZW5ndGg6IDAsXHJcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xyXG4gICAgLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC5cclxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBuYW1lOiAwLFxyXG4gICAgbm9uY2U6IDAsXHJcbiAgICBub1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgb3B0aW11bTogMCxcclxuICAgIHBhdHRlcm46IDAsXHJcbiAgICBwbGFjZWhvbGRlcjogMCxcclxuICAgIHBsYXlzSW5saW5lOiBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIHBvc3RlcjogMCxcclxuICAgIHByZWxvYWQ6IDAsXHJcbiAgICBwcm9maWxlOiAwLFxyXG4gICAgcmFkaW9Hcm91cDogMCxcclxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcclxuICAgIHJlZmVycmVyUG9saWN5OiAwLFxyXG4gICAgcmVsOiAwLFxyXG4gICAgcmVxdWlyZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgcm9sZTogMCxcclxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxyXG4gICAgcm93U3BhbjogSEFTX05VTUVSSUNfVkFMVUUsXHJcbiAgICBzYW5kYm94OiAwLFxyXG4gICAgc2NvcGU6IDAsXHJcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgc2Nyb2xsaW5nOiAwLFxyXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXHJcbiAgICBzaGFwZTogMCxcclxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxyXG4gICAgc2l6ZXM6IDAsXHJcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcclxuICAgIHNwZWxsQ2hlY2s6IDAsXHJcbiAgICBzcmM6IDAsXHJcbiAgICBzcmNEb2M6IDAsXHJcbiAgICBzcmNMYW5nOiAwLFxyXG4gICAgc3JjU2V0OiAwLFxyXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxyXG4gICAgc3RlcDogMCxcclxuICAgIHN0eWxlOiAwLFxyXG4gICAgc3VtbWFyeTogMCxcclxuICAgIHRhYkluZGV4OiAwLFxyXG4gICAgdGFyZ2V0OiAwLFxyXG4gICAgdGl0bGU6IDAsXHJcbiAgICAvLyBTZXR0aW5nIC50eXBlIHRocm93cyBvbiBub24tPGlucHV0PiB0YWdzXHJcbiAgICB0eXBlOiAwLFxyXG4gICAgdXNlTWFwOiAwLFxyXG4gICAgdmFsdWU6IDAsXHJcbiAgICB3aWR0aDogMCxcclxuICAgIHdtb2RlOiAwLFxyXG4gICAgd3JhcDogMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJERmEgUHJvcGVydGllc1xyXG4gICAgICovXHJcbiAgICBhYm91dDogMCxcclxuICAgIGRhdGF0eXBlOiAwLFxyXG4gICAgaW5saXN0OiAwLFxyXG4gICAgcHJlZml4OiAwLFxyXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBzdXBwb3J0ZWQgZm9yIE9wZW5HcmFwaCBpbiBtZXRhIHRhZ3MuXHJcbiAgICBwcm9wZXJ0eTogMCxcclxuICAgIHJlc291cmNlOiAwLFxyXG4gICAgJ3R5cGVvZic6IDAsXHJcbiAgICB2b2NhYjogMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzXHJcbiAgICAgKi9cclxuICAgIC8vIGF1dG9DYXBpdGFsaXplIGFuZCBhdXRvQ29ycmVjdCBhcmUgc3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yXHJcbiAgICAvLyBrZXlib2FyZCBoaW50cy5cclxuICAgIGF1dG9DYXBpdGFsaXplOiAwLFxyXG4gICAgYXV0b0NvcnJlY3Q6IDAsXHJcbiAgICAvLyBhdXRvU2F2ZSBhbGxvd3MgV2ViS2l0L0JsaW5rIHRvIHBlcnNpc3QgdmFsdWVzIG9mIGlucHV0IGZpZWxkcyBvbiBwYWdlIHJlbG9hZHNcclxuICAgIGF1dG9TYXZlOiAwLFxyXG4gICAgLy8gY29sb3IgaXMgZm9yIFNhZmFyaSBtYXNrLWljb24gbGlua1xyXG4gICAgY29sb3I6IDAsXHJcbiAgICAvLyBpdGVtUHJvcCwgaXRlbVNjb3BlLCBpdGVtVHlwZSBhcmUgZm9yXHJcbiAgICAvLyBNaWNyb2RhdGEgc3VwcG9ydC4gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxyXG4gICAgaXRlbVByb3A6IDAsXHJcbiAgICBpdGVtU2NvcGU6IEhBU19CT09MRUFOX1ZBTFVFLFxyXG4gICAgaXRlbVR5cGU6IDAsXHJcbiAgICAvLyBpdGVtSUQgYW5kIGl0ZW1SZWYgYXJlIGZvciBNaWNyb2RhdGEgc3VwcG9ydCBhcyB3ZWxsIGJ1dFxyXG4gICAgLy8gb25seSBzcGVjaWZpZWQgaW4gdGhlIFdIQVRXRyBzcGVjIGRvY3VtZW50LiBTZWVcclxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL21pY3JvZGF0YS5odG1sI21pY3JvZGF0YS1kb20tYXBpXHJcbiAgICBpdGVtSUQ6IDAsXHJcbiAgICBpdGVtUmVmOiAwLFxyXG4gICAgLy8gcmVzdWx0cyBzaG93IGxvb2tpbmcgZ2xhc3MgaWNvbiBhbmQgcmVjZW50IHNlYXJjaGVzIG9uIGlucHV0XHJcbiAgICAvLyBzZWFyY2ggZmllbGRzIGluIFdlYktpdC9CbGlua1xyXG4gICAgcmVzdWx0czogMCxcclxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiBhbiBpZnJhbWVcclxuICAgIC8vIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBzYW5kYm94IGF0dHJpYnV0ZSBvbiBJRTwxMFxyXG4gICAgc2VjdXJpdHk6IDAsXHJcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IGNvbnRyb2xzIGZvY3VzIGJlaGF2aW9yXHJcbiAgICB1bnNlbGVjdGFibGU6IDBcclxuICB9LFxyXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XHJcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxyXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxyXG4gICAgaHRtbEZvcjogJ2ZvcicsXHJcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xyXG4gIH0sXHJcbiAgRE9NUHJvcGVydHlOYW1lczoge31cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSFRNTERPTVByb3BlcnR5Q29uZmlnOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cclxuICovXHJcblxyXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XHJcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcclxuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcclxuICAgICc9JzogJz0wJyxcclxuICAgICc6JzogJz0yJ1xyXG4gIH07XHJcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIFVuZXNjYXBlIGFuZCB1bndyYXAga2V5IGZvciBodW1hbi1yZWFkYWJsZSBkaXNwbGF5XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHVuZXNjYXBlZCBrZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcclxuICB2YXIgdW5lc2NhcGVSZWdleCA9IC8oPTB8PTIpL2c7XHJcbiAgdmFyIHVuZXNjYXBlckxvb2t1cCA9IHtcclxuICAgICc9MCc6ICc9JyxcclxuICAgICc9Mic6ICc6J1xyXG4gIH07XHJcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XHJcblxyXG4gIHJldHVybiAoJycgKyBrZXlTdWJzdHJpbmcpLnJlcGxhY2UodW5lc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcclxuICB9KTtcclxufVxyXG5cclxudmFyIEtleUVzY2FwZVV0aWxzID0ge1xyXG4gIGVzY2FwZTogZXNjYXBlLFxyXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlsczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XHJcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcclxuICAnYnV0dG9uJzogdHJ1ZSxcclxuICAnY2hlY2tib3gnOiB0cnVlLFxyXG4gICdpbWFnZSc6IHRydWUsXHJcbiAgJ2hpZGRlbic6IHRydWUsXHJcbiAgJ3JhZGlvJzogdHJ1ZSxcclxuICAncmVzZXQnOiB0cnVlLFxyXG4gICdzdWJtaXQnOiB0cnVlXHJcbn07XHJcblxyXG5mdW5jdGlvbiBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKSB7XHJcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogX3Byb2RJbnZhcmlhbnQoJzg3JykgOiB2b2lkIDA7XHJcbn1cclxuZnVuY3Rpb24gX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKSB7XHJcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XHJcbiAgIShpbnB1dFByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIHZhbHVlTGluayBhbmQgYSB2YWx1ZSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgdG8gdXNlIHZhbHVlIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsuJykgOiBfcHJvZEludmFyaWFudCgnODgnKSA6IHZvaWQgMDtcclxufVxyXG5cclxuZnVuY3Rpb24gX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpIHtcclxuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcclxuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgY2hlY2tlZExpbmsnKSA6IF9wcm9kSW52YXJpYW50KCc4OScpIDogdm9pZCAwO1xyXG59XHJcblxyXG52YXIgcHJvcFR5cGVzID0ge1xyXG4gIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XHJcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcclxuICB9LFxyXG4gIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcclxuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XHJcbiAgfSxcclxuICBvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcclxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XHJcbiAgaWYgKG93bmVyKSB7XHJcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcclxuICAgIGlmIChuYW1lKSB7XHJcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAnJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxyXG4gKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxyXG4gKi9cclxudmFyIExpbmtlZFZhbHVlVXRpbHMgPSB7XHJcbiAgY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgb3duZXIpIHtcclxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xyXG4gICAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xyXG4gICAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCB0YWdOYW1lLCAncHJvcCcsIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xyXG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxyXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXHJcbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKTtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBmb3JtIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XHJcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gdmFsdWUgcHJvcCBvciBsaW5rLlxyXG4gICAqL1xyXG4gIGdldFZhbHVlOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xyXG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XHJcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XHJcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay52YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxyXG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgY2hlY2tlZCBzdGF0dXMgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIGNoZWNrZWQgcHJvcFxyXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXHJcbiAgICovXHJcbiAgZ2V0Q2hlY2tlZDogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcclxuICAgIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XHJcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcclxuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsudmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxyXG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IGNoYW5nZSBldmVudCB0byBoYW5kbGVcclxuICAgKi9cclxuICBleGVjdXRlT25DaGFuZ2U6IGZ1bmN0aW9uIChpbnB1dFByb3BzLCBldmVudCkge1xyXG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XHJcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XHJcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcclxuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xyXG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKTtcclxuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5vbkNoYW5nZSkge1xyXG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5vbkNoYW5nZS5jYWxsKHVuZGVmaW5lZCwgZXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlsczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxyXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXHJcbiAqIHJlcXVpcmUgYWNjZXNzaW5nIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuIEluIGVhY2ggb2YgdGhlc2UsIGB0aGlzYCByZWZlcnMgdG9cclxuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxyXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXHJcbiAqL1xyXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoY29weUZpZWxkc0Zyb20pIHtcclxuICB2YXIgS2xhc3MgPSB0aGlzO1xyXG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XHJcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XHJcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcclxuICB2YXIgS2xhc3MgPSB0aGlzO1xyXG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XHJcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XHJcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xyXG4gIHZhciBLbGFzcyA9IHRoaXM7XHJcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcclxuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcclxuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMpO1xyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHtcclxuICB2YXIgS2xhc3MgPSB0aGlzO1xyXG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XHJcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XHJcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgdmFyIEtsYXNzID0gdGhpcztcclxuICAhKGluc3RhbmNlIGluc3RhbmNlb2YgS2xhc3MpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiBfcHJvZEludmFyaWFudCgnMjUnKSA6IHZvaWQgMDtcclxuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XHJcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xyXG4gICAgS2xhc3MuaW5zdGFuY2VQb29sLnB1c2goaW5zdGFuY2UpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xyXG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcclxuXHJcbi8qKlxyXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXHJcbiAqIGl0c2VsZiAoc3RhdGljYWxseSkgbm90IGFkZGluZyBhbnkgcHJvdG90eXBpY2FsIGZpZWxkcy4gQW55IENvcHlDb25zdHJ1Y3RvclxyXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxyXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcy5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxyXG4gKi9cclxudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xyXG4gIC8vIENhc3RpbmcgYXMgYW55IHNvIHRoYXQgZmxvdyBpZ25vcmVzIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gYW5kIHRydXN0c1xyXG4gIC8vIGl0IHRvIG1hdGNoIHRoZSB0eXBlIHdlIGRlY2xhcmVkXHJcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xyXG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xyXG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcclxuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XHJcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xyXG4gIH1cclxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcclxuICByZXR1cm4gTmV3S2xhc3M7XHJcbn07XHJcblxyXG52YXIgUG9vbGVkQ2xhc3MgPSB7XHJcbiAgYWRkUG9vbGluZ1RvOiBhZGRQb29saW5nVG8sXHJcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxyXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcclxuICB0aHJlZUFyZ3VtZW50UG9vbGVyOiB0aHJlZUFyZ3VtZW50UG9vbGVyLFxyXG4gIGZvdXJBcmd1bWVudFBvb2xlcjogZm91ckFyZ3VtZW50UG9vbGVyXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcclxudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcclxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XHJcblxyXG52YXIgZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUgPSByZXF1aXJlKCcuL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lJyk7XHJcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XHJcblxyXG4vKipcclxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcclxuICpcclxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXHJcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXHJcbiAqICAgIFJlYWN0RXZlbnRMaXN0ZW5lciwgd2hpY2ggaXMgaW5qZWN0ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc3VwcG9ydCBwbHVnZ2FibGVcclxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cclxuICpcclxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXHJcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxyXG4gKlxyXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xyXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XHJcbiAqICAgIHRvIGV4dHJhY3QgYW55IHN5bnRoZXRpYyBldmVudHMuXHJcbiAqXHJcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcclxuICogICAgXCJkaXNwYXRjaGVzXCIsIGEgc2VxdWVuY2Ugb2YgbGlzdGVuZXJzIGFuZCBJRHMgdGhhdCBjYXJlIGFib3V0IHRoYXQgZXZlbnQuXHJcbiAqXHJcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxyXG4gKlxyXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcclxuICpcclxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxyXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXHJcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cclxuICogICAgICAgfCAgICAgICAgICAgLlxyXG4gKiAgICAgICB2ICAgICAgICAgICAuXHJcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cclxuICogfCBSZWFjdEV2ZW50IHwgICAgLlxyXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXHJcbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xyXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgKy0tLS0tLS0tK3xTaW1wbGVFdmVudHxcclxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XHJcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xyXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXHJcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcclxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxyXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgIHxUYXBFdmVudCAgIHwgIHwtLS0tLS0tLS0tLS18XHJcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcclxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxyXG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXHJcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xyXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcclxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICB8ICAgICAgICB8RW50ZXIvTGVhdmV8XHJcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxyXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcclxuICogfCBhcHBsaWNhdGlvbiB8ICAgLlxyXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXHJcbiAqIHwgICAgICAgICAgICAgfCAgIC5cclxuICogfCAgICAgICAgICAgICB8ICAgLlxyXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXHJcbiAqICAgICAgICAgICAgICAgICAgIC5cclxuICogICAgUmVhY3QgQ29yZSAgICAgLiAgR2VuZXJhbCBQdXJwb3NlIEV2ZW50IFBsdWdpbiBTeXN0ZW1cclxuICovXHJcblxyXG52YXIgaGFzRXZlbnRQYWdlWFk7XHJcbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcclxudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XHJcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xyXG5cclxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxyXG4vLyBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZCBjYXVzZSBkdXBsaWNhdGVcclxuLy8gZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlXHJcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XHJcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXHJcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykgfHwgJ2FuaW1hdGlvbmVuZCcsXHJcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykgfHwgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXHJcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXHJcbiAgdG9wQmx1cjogJ2JsdXInLFxyXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcclxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcclxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxyXG4gIHRvcENsaWNrOiAnY2xpY2snLFxyXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxyXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcclxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcclxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcclxuICB0b3BDb3B5OiAnY29weScsXHJcbiAgdG9wQ3V0OiAnY3V0JyxcclxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcclxuICB0b3BEcmFnOiAnZHJhZycsXHJcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxyXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXHJcbiAgdG9wRHJhZ0V4aXQ6ICdkcmFnZXhpdCcsXHJcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcclxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcclxuICB0b3BEcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxyXG4gIHRvcERyb3A6ICdkcm9wJyxcclxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcclxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXHJcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcclxuICB0b3BFbmRlZDogJ2VuZGVkJyxcclxuICB0b3BFcnJvcjogJ2Vycm9yJyxcclxuICB0b3BGb2N1czogJ2ZvY3VzJyxcclxuICB0b3BJbnB1dDogJ2lucHV0JyxcclxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXHJcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXHJcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXHJcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxyXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxyXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXHJcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcclxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxyXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxyXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXHJcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxyXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxyXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxyXG4gIHRvcFBsYXk6ICdwbGF5JyxcclxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXHJcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXHJcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxyXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXHJcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcclxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXHJcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcclxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXHJcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxyXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXHJcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxyXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxyXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxyXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXHJcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxyXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxyXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXHJcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxyXG4gIHRvcFdoZWVsOiAnd2hlZWwnXHJcbn07XHJcblxyXG4vKipcclxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcclxuICovXHJcbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7XHJcblxyXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XHJcbiAgLy8gSW4gSUU4LCBgbW91bnRBdGAgaXMgYSBob3N0IG9iamVjdCBhbmQgZG9lc24ndCBoYXZlIGBoYXNPd25Qcm9wZXJ0eWBcclxuICAvLyBkaXJlY3RseS5cclxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcclxuICAgIG1vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldID0gcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyKys7XHJcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XHJcbiAgfVxyXG4gIHJldHVybiBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dO1xyXG59XHJcblxyXG4vKipcclxuICogYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgaXMgdXNlZCB0byBhdHRhY2ggdG9wLWxldmVsIGV2ZW50IGxpc3RlbmVycy4gRm9yXHJcbiAqIGV4YW1wbGU6XHJcbiAqXHJcbiAqICAgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIoJ215SUQnLCAnb25DbGljaycsIG15RnVuY3Rpb24pO1xyXG4gKlxyXG4gKiBUaGlzIHdvdWxkIGFsbG9jYXRlIGEgXCJyZWdpc3RyYXRpb25cIiBvZiBgKCdvbkNsaWNrJywgbXlGdW5jdGlvbilgIG9uICdteUlEJy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gX2Fzc2lnbih7fSwgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiwge1xyXG5cclxuICAvKipcclxuICAgKiBJbmplY3RhYmxlIGV2ZW50IGJhY2tlbmRcclxuICAgKi9cclxuICBSZWFjdEV2ZW50TGlzdGVuZXI6IG51bGwsXHJcblxyXG4gIGluamVjdGlvbjoge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gUmVhY3RFdmVudExpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIGluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKFJlYWN0RXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuc2V0SGFuZGxlVG9wTGV2ZWwoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmhhbmRsZVRvcExldmVsKTtcclxuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IGFueSBjcmVhdGVkIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBUcnVlIGlmIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cclxuICAgKi9cclxuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xyXG4gICAgaWYgKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5zZXRFbmFibGVkKGVuYWJsZWQpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgY2FsbGJhY2tzIGFyZSBlbmFibGVkLlxyXG4gICAqL1xyXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgJiYgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5pc0VuYWJsZWQoKSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxyXG4gICAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XHJcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcclxuICAgKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcclxuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XHJcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcclxuICAgKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXHJcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxyXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcclxuICAgKlxyXG4gICAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcclxuICAgKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxyXG4gICAqL1xyXG4gIGxpc3RlblRvOiBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgY29udGVudERvY3VtZW50SGFuZGxlKSB7XHJcbiAgICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcclxuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xyXG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcclxuICAgICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XHJcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BXaGVlbCcpIHtcclxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCd3aGVlbCcpKSB7XHJcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wV2hlZWwnLCAnd2hlZWwnLCBtb3VudEF0KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XHJcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wV2hlZWwnLCAnbW91c2V3aGVlbCcsIG1vdW50QXQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cclxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcclxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICdET01Nb3VzZVNjcm9sbCcsIG1vdW50QXQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcFNjcm9sbCcpIHtcclxuXHJcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCgndG9wU2Nyb2xsJywgJ3Njcm9sbCcsIG1vdW50QXQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BGb2N1cycgfHwgZGVwZW5kZW5jeSA9PT0gJ3RvcEJsdXInKSB7XHJcblxyXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzJywgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCgndG9wRm9jdXMnLCAnZm9jdXMnLCBtb3VudEF0KTtcclxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzaW4nKSkge1xyXG4gICAgICAgICAgICAvLyBJRSBoYXMgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50cyB3aGljaCBidWJibGUuXHJcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxyXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEZvY3VzJywgJ2ZvY3VzaW4nLCBtb3VudEF0KTtcclxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BCbHVyJywgJ2ZvY3Vzb3V0JywgbW91bnRBdCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXHJcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BCbHVyID0gdHJ1ZTtcclxuICAgICAgICAgIGlzTGlzdGVuaW5nLnRvcEZvY3VzID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRvcEV2ZW50TWFwcGluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xyXG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xyXG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcclxuICB9LFxyXG5cclxuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcclxuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFByb3RlY3QgYWdhaW5zdCBkb2N1bWVudC5jcmVhdGVFdmVudCgpIHJldHVybmluZyBudWxsXHJcbiAgICogU29tZSBwb3B1cCBibG9ja2VyIGV4dGVuc2lvbnMgYXBwZWFyIHRvIGRvIHRoaXM6XHJcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82ODg3XHJcbiAgICovXHJcbiAgc3VwcG9ydHNFdmVudFBhZ2VYWTogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCFkb2N1bWVudC5jcmVhdGVFdmVudCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xyXG4gICAgcmV0dXJuIGV2ICE9IG51bGwgJiYgJ3BhZ2VYJyBpbiBldjtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxyXG4gICAqIGFwcGxpY2F0aW9uIGNvZGUgY2FuIGFjY2VzcyB0aGVtIHdpdGhvdXQgdHJpZ2dlcmluZyByZWZsb3dzLlxyXG4gICAqXHJcbiAgICogVmlld3BvcnRNZXRyaWNzIGlzIG9ubHkgdXNlZCBieSBTeW50aGV0aWNNb3VzZS9Ub3VjaEV2ZW50IGFuZCBvbmx5IHdoZW5cclxuICAgKiBwYWdlWC9wYWdlWSBpc24ndCBzdXBwb3J0ZWQgKGxlZ2FjeSBicm93c2VycykuXHJcbiAgICpcclxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXHJcbiAgICpcclxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy9zY3JvbGwuaHRtbFxyXG4gICAqL1xyXG4gIGVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGhhc0V2ZW50UGFnZVhZID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgaGFzRXZlbnRQYWdlWFkgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc3VwcG9ydHNFdmVudFBhZ2VYWSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFoYXNFdmVudFBhZ2VYWSAmJiAhaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUpIHtcclxuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcclxuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5tb25pdG9yU2Nyb2xsVmFsdWUocmVmcmVzaCk7XHJcbiAgICAgIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xyXG5cclxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcclxudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xyXG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XHJcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XHJcblxyXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIFwicHJvZHVjdGlvblwiID09PSAndGVzdCcpIHtcclxuICAvLyBUZW1wb3JhcnkgaGFjay5cclxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcclxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcclxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zdGFudGlhdGVDaGlsZChjaGlsZEluc3RhbmNlcywgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKSB7XHJcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXHJcbiAgdmFyIGtleVVuaXF1ZSA9IGNoaWxkSW5zdGFuY2VzW25hbWVdID09PSB1bmRlZmluZWQ7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xyXG4gICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcclxuICAgIH1cclxuICAgIGlmICgha2V5VW5pcXVlKSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJXMnLCBLZXlFc2NhcGVVdGlscy51bmVzY2FwZShuYW1lKSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChzZWxmRGVidWdJRCkpIDogdm9pZCAwO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoY2hpbGQgIT0gbnVsbCAmJiBrZXlVbmlxdWUpIHtcclxuICAgIGNoaWxkSW5zdGFuY2VzW25hbWVdID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChjaGlsZCwgdHJ1ZSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVhY3RDaGlsZFJlY29uY2lsZXIgcHJvdmlkZXMgaGVscGVycyBmb3IgaW5pdGlhbGl6aW5nIG9yIHVwZGF0aW5nIGEgc2V0IG9mXHJcbiAqIGNoaWxkcmVuLiBJdHMgb3V0cHV0IGlzIHN1aXRhYmxlIGZvciBwYXNzaW5nIGl0IG9udG8gUmVhY3RNdWx0aUNoaWxkIHdoaWNoXHJcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cclxuICovXHJcbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHtcclxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxyXG4gICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZE5vZGVzIE5lc3RlZCBjaGlsZCBtYXBzLlxyXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBpbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXHJcbiAgKSB7XHJcbiAgICBpZiAobmVzdGVkQ2hpbGROb2RlcyA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdmFyIGNoaWxkSW5zdGFuY2VzID0ge307XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gaW5zdGFudGlhdGVDaGlsZChjaGlsZEluc3RzLCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpO1xyXG4gICAgICB9LCBjaGlsZEluc3RhbmNlcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKG5lc3RlZENoaWxkTm9kZXMsIGluc3RhbnRpYXRlQ2hpbGQsIGNoaWxkSW5zdGFuY2VzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZEluc3RhbmNlcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiBhbmQgcmV0dXJucyBhIG5ldyBzZXQgb2YgY2hpbGRyZW4uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cclxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDaGlsZHJlbiBGbGF0IGNoaWxkIGVsZW1lbnQgbWFwcy5cclxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcclxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIG5ldyBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcclxuICApIHtcclxuICAgIC8vIFdlIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgd2F5IHRvIHRyYWNrIG1vdmVzIGhlcmUgYnV0IGlmIHdlIHVzZSBpdGVyYXRvcnNcclxuICAgIC8vIGluc3RlYWQgb2YgZm9yLi5pbiB3ZSBjYW4gemlwIHRoZSBpdGVyYXRvcnMgYW5kIGNoZWNrIGlmIGFuIGl0ZW0gaGFzXHJcbiAgICAvLyBtb3ZlZC5cclxuICAgIC8vIFRPRE86IElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHJldHVybiB0aGUgcHJldkNoaWxkcmVuIG9iamVjdCBzbyB0aGF0IHdlXHJcbiAgICAvLyBjYW4gcXVpY2tseSBiYWlsb3V0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWQuXHJcbiAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBuYW1lO1xyXG4gICAgdmFyIHByZXZDaGlsZDtcclxuICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcclxuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xyXG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2Q2hpbGQgJiYgcHJldkNoaWxkLl9jdXJyZW50RWxlbWVudDtcclxuICAgICAgdmFyIG5leHRFbGVtZW50ID0gbmV4dENoaWxkcmVuW25hbWVdO1xyXG4gICAgICBpZiAocHJldkNoaWxkICE9IG51bGwgJiYgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xyXG4gICAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDaGlsZCwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBwcmV2Q2hpbGQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHByZXZDaGlsZCkge1xyXG4gICAgICAgICAgcmVtb3ZlZE5vZGVzW25hbWVdID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDaGlsZCk7XHJcbiAgICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXHJcbiAgICAgICAgdmFyIG5leHRDaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gbmV4dENoaWxkSW5zdGFuY2U7XHJcbiAgICAgICAgLy8gQ3JlYXRpbmcgbW91bnQgaW1hZ2Ugbm93IGVuc3VyZXMgcmVmcyBhcmUgcmVzb2x2ZWQgaW4gcmlnaHQgb3JkZXJcclxuICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxMDEgZm9yIGV4cGxhbmF0aW9uKS5cclxuICAgICAgICB2YXIgbmV4dENoaWxkTW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChuZXh0Q2hpbGRJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XHJcbiAgICAgICAgbW91bnRJbWFnZXMucHVzaChuZXh0Q2hpbGRNb3VudEltYWdlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gVW5tb3VudCBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cclxuICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XHJcbiAgICAgICAgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuW25hbWVdO1xyXG4gICAgICAgIHJlbW92ZWROb2Rlc1tuYW1lXSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q2hpbGQpO1xyXG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXHJcbiAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gez9vYmplY3R9IHJlbmRlcmVkQ2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAocmVuZGVyZWRDaGlsZHJlbiwgc2FmZWx5KSB7XHJcbiAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcclxuICAgICAgaWYgKHJlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XHJcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocmVuZGVyZWRDaGlsZCwgc2FmZWx5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xyXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XHJcblxyXG4vKipcclxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHJlY29uY2lsZXIgdGhhdCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcclxuICogdGhlIGJyb3dzZXIgY29udGV4dC4gVE9ETzogVGhlc2UgY2FsbGVycyBzaG91bGQgYmUgcmVmYWN0b3JlZCB0byBhdm9pZCB0aGVcclxuICogbmVlZCBmb3IgdGhpcyBpbmplY3Rpb24uXHJcbiAqL1xyXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSB7XHJcblxyXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcclxuXHJcbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBET01DaGlsZHJlbk9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG5cclxudmFyIGluamVjdGVkID0gZmFsc2U7XHJcblxyXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHN3YXBwaW5nIG91dCBtb3VudCBpbWFnZXMgaW4gdGhlIG1pZGRsZSBvZlxyXG4gICAqIHRoZSB0cmVlLlxyXG4gICAqL1xyXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cDogbnVsbCxcclxuXHJcbiAgLyoqXHJcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXHJcbiAgICogbGF0ZXIgbW92ZSBpbnRvIE11bHRpQ2hpbGRDb21wb25lbnRzLlxyXG4gICAqL1xyXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXHJcblxyXG4gIGluamVjdGlvbjoge1xyXG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xyXG4gICAgICAhIWluamVjdGVkID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50OiBpbmplY3RFbnZpcm9ubWVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzEwNCcpIDogdm9pZCAwO1xyXG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcclxuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzID0gZW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcztcclxuICAgICAgaW5qZWN0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcclxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcclxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcclxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XHJcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xyXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xyXG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XHJcbnZhciBSZWFjdE5vZGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3ROb2RlVHlwZXMnKTtcclxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhciBjaGVja1JlYWN0VHlwZVNwZWMgPSByZXF1aXJlKCcuL2NoZWNrUmVhY3RUeXBlU3BlYycpO1xyXG59XHJcblxyXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcclxudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBDb21wb3NpdGVUeXBlcyA9IHtcclxuICBJbXB1cmVDbGFzczogMCxcclxuICBQdXJlQ2xhc3M6IDEsXHJcbiAgU3RhdGVsZXNzRnVuY3Rpb25hbDogMlxyXG59O1xyXG5cclxuZnVuY3Rpb24gU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCkge31cclxuU3RhdGVsZXNzQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIENvbXBvbmVudCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpLl9jdXJyZW50RWxlbWVudC50eXBlO1xyXG4gIHZhciBlbGVtZW50ID0gQ29tcG9uZW50KHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCwgdGhpcy51cGRhdGVyKTtcclxuICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpO1xyXG4gIHJldHVybiBlbGVtZW50O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50KSB7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCksICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcclxuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1B1cmVDb21wb25lbnQoQ29tcG9uZW50KSB7XHJcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCk7XHJcbn1cclxuXHJcbi8vIFNlcGFyYXRlZCBpbnRvIGEgZnVuY3Rpb24gdG8gY29udGFpbiBkZW9wdGltaXphdGlvbnMgY2F1c2VkIGJ5IHRyeS9maW5hbGx5LlxyXG5mdW5jdGlvbiBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmbiwgZGVidWdJRCwgdGltZXJUeXBlKSB7XHJcbiAgaWYgKGRlYnVnSUQgPT09IDApIHtcclxuICAgIC8vIFRvcC1sZXZlbCB3cmFwcGVycyAoc2VlIFJlYWN0TW91bnQpIGFuZCBlbXB0eSBjb21wb25lbnRzIChzZWVcclxuICAgIC8vIFJlYWN0RE9NRW1wdHlDb21wb25lbnQpIGFyZSBpbnZpc2libGUgdG8gaG9va3MgYW5kIGRldnRvb2xzLlxyXG4gICAgLy8gQm90aCBhcmUgaW1wbGVtZW50YXRpb24gZGV0YWlscyB0aGF0IHNob3VsZCBnbyBhd2F5IGluIHRoZSBmdXR1cmUuXHJcbiAgICByZXR1cm4gZm4oKTtcclxuICB9XHJcblxyXG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGZuKCk7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tIFRoZSBMaWZlLUN5Y2xlIG9mIGEgQ29tcG9zaXRlIENvbXBvbmVudCAtLS0tLS0tLS0tLS0tLS0tLS1cclxuICpcclxuICogLSBjb25zdHJ1Y3RvcjogSW5pdGlhbGl6YXRpb24gb2Ygc3RhdGUuIFRoZSBpbnN0YW5jZSBpcyBub3cgcmV0YWluZWQuXHJcbiAqICAgLSBjb21wb25lbnRXaWxsTW91bnRcclxuICogICAtIHJlbmRlclxyXG4gKiAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzXVxyXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlcl1cclxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXHJcbiAqICAgICAtIGNvbXBvbmVudERpZE1vdW50XHJcbiAqXHJcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XHJcbiAqICAgICAgIC0gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAob25seSBjYWxsZWQgaWYgcGFyZW50IHVwZGF0ZWQpXHJcbiAqICAgICAgIC0gc2hvdWxkQ29tcG9uZW50VXBkYXRlXHJcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXHJcbiAqICAgICAgICAgICAtIHJlbmRlclxyXG4gKiAgICAgICAgICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnMgb3IgcmVjZWl2ZSBwcm9wcyBwaGFzZXNdXHJcbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcclxuICpcclxuICogICAgIC0gY29tcG9uZW50V2lsbFVubW91bnRcclxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXHJcbiAqICAgLSBbY2hpbGRyZW4gZGVzdHJveWVkXVxyXG4gKiAtIChkZXN0cm95ZWQpOiBUaGUgaW5zdGFuY2UgaXMgbm93IGJsYW5rLCByZWxlYXNlZCBieSBSZWFjdCBhbmQgcmVhZHkgZm9yIEdDLlxyXG4gKlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBbiBpbmNyZW1lbnRpbmcgSUQgYXNzaWduZWQgdG8gZWFjaCBjb21wb25lbnQgd2hlbiBpdCBpcyBtb3VudGVkLiBUaGlzIGlzXHJcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIG5leHRNb3VudElEID0gMTtcclxuXHJcbi8qKlxyXG4gKiBAbGVuZHMge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LnByb3RvdHlwZX1cclxuICovXHJcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQmFzZSBjb25zdHJ1Y3RvciBmb3IgYWxsIGNvbXBvc2l0ZSBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxyXG4gICAqIEBmaW5hbFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcclxuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xyXG4gICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IG51bGw7XHJcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcclxuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcclxuXHJcbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVRdWV1ZVxyXG4gICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xyXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xyXG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG51bGw7XHJcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XHJcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcclxuICAgIHRoaXMuX21vdW50T3JkZXIgPSAwO1xyXG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcclxuXHJcbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVzIGFuZCBSZWFjdFVwZGF0ZVF1ZXVlLlxyXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XHJcblxyXG4gICAgLy8gQ29tcG9uZW50V2lsbFVubW91bnQgc2hhbGwgb25seSBiZSBjYWxsZWQgb25jZVxyXG4gICAgdGhpcy5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB0aGlzLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdFBhcmVudFxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdENvbnRhaW5lckluZm9cclxuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHRcclxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxyXG4gICAqIEBmaW5hbFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5fbW91bnRPcmRlciA9IG5leHRNb3VudElEKys7XHJcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcclxuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XHJcblxyXG4gICAgdmFyIHB1YmxpY1Byb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XHJcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KGNvbnRleHQpO1xyXG5cclxuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xyXG5cclxuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHRyYW5zYWN0aW9uLmdldFVwZGF0ZVF1ZXVlKCk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXHJcbiAgICB2YXIgZG9Db25zdHJ1Y3QgPSBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KTtcclxuICAgIHZhciBpbnN0ID0gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50KGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xyXG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcclxuXHJcbiAgICAvLyBTdXBwb3J0IGZ1bmN0aW9uYWwgY29tcG9uZW50c1xyXG4gICAgaWYgKCFkb0NvbnN0cnVjdCAmJiAoaW5zdCA9PSBudWxsIHx8IGluc3QucmVuZGVyID09IG51bGwpKSB7XHJcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3Q7XHJcbiAgICAgIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgcmVuZGVyZWRFbGVtZW50KTtcclxuICAgICAgIShpbnN0ID09PSBudWxsIHx8IGluc3QgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KGluc3QpKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDUnLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgICBpbnN0ID0gbmV3IFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpO1xyXG4gICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChpc1B1cmVDb21wb25lbnQoQ29tcG9uZW50KSkge1xyXG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5QdXJlQ2xhc3M7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLkltcHVyZUNsYXNzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGxhdGVyIGluIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQsIGJ1dCBhZGQgYW4gZWFybHlcclxuICAgICAgLy8gd2FybmluZyBub3cgdG8gaGVscCBkZWJ1Z2dpbmdcclxuICAgICAgaWYgKGluc3QucmVuZGVyID09IG51bGwpIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBwcm9wc011dGF0ZWQgPSBpbnN0LnByb3BzICE9PSBwdWJsaWNQcm9wcztcclxuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XHJcblxyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LnByb3BzID09PSB1bmRlZmluZWQgfHwgIXByb3BzTXV0YXRlZCwgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyAndXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGVzZSBzaG91bGQgYmUgc2V0IHVwIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGFzIGEgY29udmVuaWVuY2UgZm9yXHJcbiAgICAvLyBzaW1wbGVyIGNsYXNzIGFic3RyYWN0aW9ucywgd2Ugc2V0IHRoZW0gdXAgYWZ0ZXIgdGhlIGZhY3QuXHJcbiAgICBpbnN0LnByb3BzID0gcHVibGljUHJvcHM7XHJcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xyXG4gICAgaW5zdC5yZWZzID0gZW1wdHlPYmplY3Q7XHJcbiAgICBpbnN0LnVwZGF0ZXIgPSB1cGRhdGVRdWV1ZTtcclxuXHJcbiAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3Q7XHJcblxyXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cclxuICAgIFJlYWN0SW5zdGFuY2VNYXAuc2V0KGluc3QsIHRoaXMpO1xyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIC8vIFNpbmNlIHBsYWluIEpTIGNsYXNzZXMgYXJlIGRlZmluZWQgd2l0aG91dCBhbnkgc3BlY2lhbCBpbml0aWFsaXphdGlvblxyXG4gICAgICAvLyBsb2dpYywgd2UgY2FuIG5vdCBjYXRjaCBjb21tb24gZXJyb3JzIGVhcmx5LiBUaGVyZWZvcmUsIHdlIGhhdmUgdG9cclxuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdC5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHwgaW5zdC5zdGF0ZSwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3QuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LnByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5jb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhICcgKyAnc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcclxuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpbnN0LnN0YXRlID0gaW5pdGlhbFN0YXRlID0gbnVsbDtcclxuICAgIH1cclxuICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XHJcblxyXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xyXG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIG1hcmt1cDtcclxuICAgIGlmIChpbnN0LnVuc3RhYmxlX2hhbmRsZUVycm9yKSB7XHJcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGluc3QuY29tcG9uZW50RGlkTW91bnQpIHtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50RGlkTW91bnQoKTtcclxuICAgICAgICAgIH0sIF90aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkTW91bnQnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkTW91bnQsIGluc3QpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1hcmt1cDtcclxuICB9LFxyXG5cclxuICBfY29uc3RydWN0Q29tcG9uZW50OiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyOiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xyXG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XHJcblxyXG4gICAgaWYgKGRvQ29uc3RydWN0KSB7XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XHJcbiAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2N0b3InKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBjYW4gc3RpbGwgYmUgYW4gaW5zdGFuY2UgaW4gY2FzZSBvZiBmYWN0b3J5IGNvbXBvbmVudHNcclxuICAgIC8vIGJ1dCB3ZSdsbCBjb3VudCB0aGlzIGFzIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGFzIHRoZSBtb3JlIGNvbW1vbiBjYXNlLlxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgcmV0dXJuIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XHJcbiAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBwZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmc6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xyXG4gICAgdmFyIG1hcmt1cDtcclxuICAgIHZhciBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gUm9sbCBiYWNrIHRvIGNoZWNrcG9pbnQsIGhhbmRsZSBlcnJvciAod2hpY2ggbWF5IGFkZCBpdGVtcyB0byB0aGUgdHJhbnNhY3Rpb24pLCBhbmQgdGFrZSBhIG5ldyBjaGVja3BvaW50XHJcbiAgICAgIHRyYW5zYWN0aW9uLnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZS51bnN0YWJsZV9oYW5kbGVFcnJvcihlKTtcclxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uuc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKHRoaXMuX2luc3RhbmNlLnByb3BzLCB0aGlzLl9pbnN0YW5jZS5jb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xyXG5cclxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQudW5tb3VudENvbXBvbmVudCh0cnVlKTtcclxuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XHJcblxyXG4gICAgICAvLyBUcnkgYWdhaW4gLSB3ZSd2ZSBpbmZvcm1lZCB0aGUgY29tcG9uZW50IGFib3V0IHRoZSBlcnJvciwgc28gdGhleSBjYW4gcmVuZGVyIGFuIGVycm9yIG1lc3NhZ2UgdGhpcyB0aW1lLlxyXG4gICAgICAvLyBJZiB0aGlzIHRocm93cyBhZ2FpbiwgdGhlIGVycm9yIHdpbGwgYnViYmxlIHVwIChhbmQgY2FuIGJlIGNhdWdodCBieSBhIGhpZ2hlciBlcnJvciBib3VuZGFyeSkuXHJcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWFya3VwO1xyXG4gIH0sXHJcblxyXG4gIHBlcmZvcm1Jbml0aWFsTW91bnQ6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xyXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcclxuXHJcbiAgICB2YXIgZGVidWdJRCA9IDA7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcclxuICAgICAgICB9LCBkZWJ1Z0lELCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBXaGVuIG1vdW50aW5nLCBjYWxscyB0byBgc2V0U3RhdGVgIGJ5IGBjb21wb25lbnRXaWxsTW91bnRgIHdpbGwgc2V0XHJcbiAgICAgIC8vIGB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZWAgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxyXG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcclxuICAgICAgICBpbnN0LnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShpbnN0LnByb3BzLCBpbnN0LmNvbnRleHQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgbm90IGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgd2Ugbm93IHJlbmRlclxyXG4gICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBub2RlVHlwZSA9IFJlYWN0Tm9kZVR5cGVzLmdldFR5cGUocmVuZGVyZWRFbGVtZW50KTtcclxuICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBub2RlVHlwZTtcclxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQocmVuZGVyZWRFbGVtZW50LCBub2RlVHlwZSAhPT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkgLyogc2hvdWxkSGF2ZURlYnVnSUQgKi9cclxuICAgICk7XHJcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGNoaWxkO1xyXG5cclxuICAgIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgZGVidWdJRCk7XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKGRlYnVnSUQgIT09IDApIHtcclxuICAgICAgICB2YXIgY2hpbGREZWJ1Z0lEcyA9IGNoaWxkLl9kZWJ1Z0lEICE9PSAwID8gW2NoaWxkLl9kZWJ1Z0lEXSA6IFtdO1xyXG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1hcmt1cDtcclxuICB9LFxyXG5cclxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZSh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cclxuICAgKlxyXG4gICAqIEBmaW5hbFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcclxuICAgIGlmICghdGhpcy5fcmVuZGVyZWRDb21wb25lbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XHJcblxyXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVubW91bnQgJiYgIWluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50KSB7XHJcbiAgICAgIGluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50ID0gdHJ1ZTtcclxuXHJcbiAgICAgIGlmIChzYWZlbHkpIHtcclxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0TmFtZSgpICsgJy5jb21wb25lbnRXaWxsVW5tb3VudCgpJztcclxuICAgICAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQuYmluZChpbnN0KSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQoKTtcclxuICAgICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVW5tb3VudCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XHJcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCBzYWZlbHkpO1xyXG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcclxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xyXG4gICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgcGVuZGluZyBmaWVsZHNcclxuICAgIC8vIEV2ZW4gaWYgdGhpcyBjb21wb25lbnQgaXMgc2NoZWR1bGVkIGZvciBhbm90aGVyIHVwZGF0ZSBpbiBSZWFjdFVwZGF0ZXMsXHJcbiAgICAvLyBpdCB3b3VsZCBzdGlsbCBiZSBpZ25vcmVkIGJlY2F1c2UgdGhlc2UgZmllbGRzIGFyZSByZXNldC5cclxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcclxuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XHJcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgLy8gVGhlc2UgZmllbGRzIGRvIG5vdCByZWFsbHkgbmVlZCB0byBiZSByZXNldCBzaW5jZSB0aGlzIG9iamVjdCBpcyBub1xyXG4gICAgLy8gbG9uZ2VyIGFjY2Vzc2libGUuXHJcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcclxuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xyXG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcclxuXHJcbiAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSB0byB0aGlzIGludGVybmFsIHJlcHJlc2VudGF0aW9uXHJcbiAgICAvLyB3aGljaCBhbGxvdyB0aGUgaW50ZXJuYWxzIHRvIGJlIHByb3Blcmx5IGNsZWFuZWQgdXAgZXZlbiBpZiB0aGUgdXNlclxyXG4gICAgLy8gbGVha3MgYSByZWZlcmVuY2UgdG8gdGhlIHB1YmxpYyBpbnN0YW5jZS5cclxuICAgIFJlYWN0SW5zdGFuY2VNYXAucmVtb3ZlKGluc3QpO1xyXG5cclxuICAgIC8vIFNvbWUgZXhpc3RpbmcgY29tcG9uZW50cyByZWx5IG9uIGluc3QucHJvcHMgZXZlbiBhZnRlciB0aGV5J3ZlIGJlZW5cclxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxyXG4gICAgLy8gVE9ETzogaW5zdC5wcm9wcyA9IG51bGw7XHJcbiAgICAvLyBUT0RPOiBpbnN0LnN0YXRlID0gbnVsbDtcclxuICAgIC8vIFRPRE86IGluc3QuY29udGV4dCA9IG51bGw7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXHJcbiAgICogYGNvbnRleHRUeXBlc2BcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XHJcbiAgICogQHJldHVybiB7P29iamVjdH1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9tYXNrQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xyXG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jb250ZXh0VHlwZXM7XHJcbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xyXG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XHJcbiAgICB9XHJcbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IHt9O1xyXG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XHJcbiAgICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cclxuICAgKiBgY29udGV4dFR5cGVzYCwgYW5kIGFzc2VydHMgdGhhdCB0aGV5IGFyZSB2YWxpZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XHJcbiAgICogQHJldHVybiB7P29iamVjdH1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9wcm9jZXNzQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gdGhpcy5fbWFza0NvbnRleHQoY29udGV4dCk7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcclxuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcclxuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCAnY29udGV4dCcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudENvbnRleHRcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XHJcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcclxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XHJcbiAgICB2YXIgY2hpbGRDb250ZXh0O1xyXG5cclxuICAgIGlmIChpbnN0LmdldENoaWxkQ29udGV4dCkge1xyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCgpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2hpbGRDb250ZXh0KSB7XHJcbiAgICAgICEodHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dFR5cGVzKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGRDb250ZXh0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZENvbnRleHQpIHtcclxuICAgICAgICAhKG5hbWUgaW4gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDgnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCBuYW1lKSA6IHZvaWQgMDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gX2Fzc2lnbih7fSwgY3VycmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQXNzZXJ0IHRoYXQgdGhlIGNvbnRleHQgdHlwZXMgYXJlIHZhbGlkXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBjb250ZXh0IGZpZWxkIHRvIGEgUmVhY3RQcm9wVHlwZVxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9jaGVja0NvbnRleHRUeXBlczogZnVuY3Rpb24gKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbikge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgdGhpcy5nZXROYW1lKCksIG51bGwsIHRoaXMuX2RlYnVnSUQpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIG5leHRDb250ZXh0KSB7XHJcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcclxuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcblxyXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIHByZXZDb250ZXh0LCBuZXh0Q29udGV4dCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXHJcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xyXG4gICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ICE9IG51bGwpIHtcclxuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQodGhpcywgdGhpcy5fcGVuZGluZ0VsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9jb250ZXh0KTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgIT09IG51bGwgfHwgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm0gYW4gdXBkYXRlIHRvIGEgbW91bnRlZCBjb21wb25lbnQuIFRoZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGFuZFxyXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcclxuICAgKiBza2lwcGVkKSB0aGUgcmVtYWluaW5nIHVwZGF0ZSBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgY2FsbGVkIGFuZCB0aGUgRE9NXHJcbiAgICogcmVwcmVzZW50YXRpb24gaXMgdXBkYXRlZC5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxyXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2UGFyZW50RWxlbWVudFxyXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBvdmVycmlkYWJsZVxyXG4gICAqL1xyXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2UGFyZW50RWxlbWVudCwgbmV4dFBhcmVudEVsZW1lbnQsIHByZXZVbm1hc2tlZENvbnRleHQsIG5leHRVbm1hc2tlZENvbnRleHQpIHtcclxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XHJcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQXR0ZW1wdGVkIHRvIHVwZGF0ZSBjb21wb25lbnQgYCVzYCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdW5tb3VudGVkIChvciBmYWlsZWQgdG8gbW91bnQpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEzNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG5cclxuICAgIHZhciB3aWxsUmVjZWl2ZSA9IGZhbHNlO1xyXG4gICAgdmFyIG5leHRDb250ZXh0O1xyXG5cclxuICAgIC8vIERldGVybWluZSBpZiB0aGUgY29udGV4dCBoYXMgY2hhbmdlZCBvciBub3RcclxuICAgIGlmICh0aGlzLl9jb250ZXh0ID09PSBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XHJcbiAgICAgIG5leHRDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbmV4dENvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcclxuICAgICAgd2lsbFJlY2VpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcmV2UHJvcHMgPSBwcmV2UGFyZW50RWxlbWVudC5wcm9wcztcclxuICAgIHZhciBuZXh0UHJvcHMgPSBuZXh0UGFyZW50RWxlbWVudC5wcm9wcztcclxuXHJcbiAgICAvLyBOb3QgYSBzaW1wbGUgc3RhdGUgdXBkYXRlIGJ1dCBhIHByb3BzIHVwZGF0ZVxyXG4gICAgaWYgKHByZXZQYXJlbnRFbGVtZW50ICE9PSBuZXh0UGFyZW50RWxlbWVudCkge1xyXG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxyXG4gICAgLy8gX3BlbmRpbmdTdGF0ZVF1ZXVlIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgYW55IHN0YXRlIHVwZGF0ZXMgZ2V0c1xyXG4gICAgLy8gaW1tZWRpYXRlbHkgcmVjb25jaWxlZCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGJhdGNoLlxyXG4gICAgaWYgKHdpbGxSZWNlaXZlICYmIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XHJcbiAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcclxuICAgIHZhciBzaG91bGRVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgIGlmICghdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XHJcbiAgICAgIGlmIChpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xyXG4gICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xyXG4gICAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodGhpcy5fY29tcG9zaXRlVHlwZSA9PT0gQ29tcG9zaXRlVHlwZXMuUHVyZUNsYXNzKSB7XHJcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSAhc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSB8fCAhc2hhbGxvd0VxdWFsKGluc3Quc3RhdGUsIG5leHRTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XHJcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XHJcbiAgICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAvLyBXaWxsIHNldCBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAuXHJcbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gSWYgaXQncyBkZXRlcm1pbmVkIHRoYXQgYSBjb21wb25lbnQgc2hvdWxkIG5vdCB1cGRhdGUsIHdlIHN0aWxsIHdhbnRcclxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cclxuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0UGFyZW50RWxlbWVudDtcclxuICAgICAgdGhpcy5fY29udGV4dCA9IG5leHRVbm1hc2tlZENvbnRleHQ7XHJcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XHJcbiAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XHJcbiAgICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcclxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XHJcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZTtcclxuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcclxuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcclxuXHJcbiAgICBpZiAoIXF1ZXVlKSB7XHJcbiAgICAgIHJldHVybiBpbnN0LnN0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXBsYWNlICYmIHF1ZXVlLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gcXVldWVbMF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIHJlcGxhY2UgPyBxdWV1ZVswXSA6IGluc3Quc3RhdGUpO1xyXG4gICAgZm9yICh2YXIgaSA9IHJlcGxhY2UgPyAxIDogMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBwYXJ0aWFsID0gcXVldWVbaV07XHJcbiAgICAgIF9hc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXh0U3RhdGU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogTWVyZ2VzIG5ldyBwcm9wcyBhbmQgc3RhdGUsIG5vdGlmaWVzIGRlbGVnYXRlIG1ldGhvZHMgb2YgdXBkYXRlIGFuZFxyXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBOZXh0IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cclxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dCBOZXh0IHB1YmxpYyBvYmplY3QgdG8gc2V0IGFzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcclxuICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XHJcblxyXG4gICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9IEJvb2xlYW4oaW5zdC5jb21wb25lbnREaWRVcGRhdGUpO1xyXG4gICAgdmFyIHByZXZQcm9wcztcclxuICAgIHZhciBwcmV2U3RhdGU7XHJcbiAgICB2YXIgcHJldkNvbnRleHQ7XHJcbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XHJcbiAgICAgIHByZXZQcm9wcyA9IGluc3QucHJvcHM7XHJcbiAgICAgIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XHJcbiAgICAgIHByZXZDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUpIHtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XHJcbiAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XHJcbiAgICB0aGlzLl9jb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xyXG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcclxuICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XHJcbiAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcclxuXHJcbiAgICB0aGlzLl91cGRhdGVSZW5kZXJlZENvbXBvbmVudCh0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KTtcclxuXHJcbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIF90aGlzMi5fZGVidWdJRCwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRVcGRhdGUuYmluZChpbnN0LCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCBpbnN0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGwgdGhlIGNvbXBvbmVudCdzIGByZW5kZXJgIG1ldGhvZCBhbmQgdXBkYXRlIHRoZSBET00gYWNjb3JkaW5nbHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcclxuICAgIHZhciBwcmV2Q29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudDtcclxuICAgIHZhciBwcmV2UmVuZGVyZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcclxuICAgIHZhciBuZXh0UmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XHJcblxyXG4gICAgdmFyIGRlYnVnSUQgPSAwO1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZSZW5kZXJlZEVsZW1lbnQsIG5leHRSZW5kZXJlZEVsZW1lbnQpKSB7XHJcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDb21wb25lbnRJbnN0YW5jZSwgbmV4dFJlbmRlcmVkRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIG9sZEhvc3ROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDb21wb25lbnRJbnN0YW5jZSk7XHJcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDb21wb25lbnRJbnN0YW5jZSwgZmFsc2UpO1xyXG5cclxuICAgICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShuZXh0UmVuZGVyZWRFbGVtZW50KTtcclxuICAgICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG5vZGVUeXBlO1xyXG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQsIG5vZGVUeXBlICE9PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSAvKiBzaG91bGRIYXZlRGVidWdJRCAqL1xyXG4gICAgICApO1xyXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGNoaWxkO1xyXG5cclxuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLl9ob3N0UGFyZW50LCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgZGVidWdJRCk7XHJcblxyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XHJcbiAgICAgICAgICB2YXIgY2hpbGREZWJ1Z0lEcyA9IGNoaWxkLl9kZWJ1Z0lEICE9PSAwID8gW2NoaWxkLl9kZWJ1Z0lEXSA6IFtdO1xyXG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZDb21wb25lbnRJbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGRlbiBpbiBzaGFsbG93IHJlbmRlcmluZy5cclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBfcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSkge1xyXG4gICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XHJcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gaW5zdC5yZW5kZXIoKTtcclxuICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gaW5zdC5yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cclxuICAgICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXHJcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cclxuICAgICAgICByZW5kZXJlZEVsZW1lbnQgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlbmRlcmVkRWxlbWVudDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyB8fCB0aGlzLl9jb21wb3NpdGVUeXBlICE9PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XHJcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcclxuICAgIH1cclxuICAgICEoXHJcbiAgICAvLyBUT0RPOiBBbiBgaXNWYWxpZE5vZGVgIGZ1bmN0aW9uIHdvdWxkIHByb2JhYmx5IGJlIG1vcmUgYXBwcm9wcmlhdGVcclxuICAgIHJlbmRlcmVkRWxlbWVudCA9PT0gbnVsbCB8fCByZW5kZXJlZEVsZW1lbnQgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KHJlbmRlcmVkRWxlbWVudCkpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA5JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XHJcblxyXG4gICAgcmV0dXJuIHJlbmRlcmVkRWxlbWVudDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cclxuICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cclxuICAgKiBAZmluYWxcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGF0dGFjaFJlZjogZnVuY3Rpb24gKHJlZiwgY29tcG9uZW50KSB7XHJcbiAgICB2YXIgaW5zdCA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKTtcclxuICAgICEoaW5zdCAhPSBudWxsKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogX3Byb2RJbnZhcmlhbnQoJzExMCcpIDogdm9pZCAwO1xyXG4gICAgdmFyIHB1YmxpY0NvbXBvbmVudEluc3RhbmNlID0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudCAmJiBjb21wb25lbnQuZ2V0TmFtZSA/IGNvbXBvbmVudC5nZXROYW1lKCkgOiAnYSBjb21wb25lbnQnO1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwdWJsaWNDb21wb25lbnRJbnN0YW5jZSAhPSBudWxsIHx8IGNvbXBvbmVudC5fY29tcG9zaXRlVHlwZSAhPT0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbCwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzICcgKyAnKFNlZSByZWYgXCIlc1wiIGluICVzIGNyZWF0ZWQgYnkgJXMpLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJywgcmVmLCBjb21wb25lbnROYW1lLCB0aGlzLmdldE5hbWUoKSkgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcclxuICAgIHJlZnNbcmVmXSA9IHB1YmxpY0NvbXBvbmVudEluc3RhbmNlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIGEgcmVmZXJlbmNlIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgdG8gZGVyZWZlcmVuY2UuXHJcbiAgICogQGZpbmFsXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBkZXRhY2hSZWY6IGZ1bmN0aW9uIChyZWYpIHtcclxuICAgIHZhciByZWZzID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnM7XHJcbiAgICBkZWxldGUgcmVmc1tyZWZdO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGl0XHJcbiAgICogaW4gZXJyb3IgbWVzc2FnZXMuXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvciBudWxsLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGdldE5hbWU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcclxuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmNvbnN0cnVjdG9yO1xyXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLm5hbWUgfHwgbnVsbDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQgLSBpLmUuIHdoYXRcclxuICAgKiBpcyBleHBvc2VkIGJ5IHJlZnMgYW5kIHJldHVybmVkIGJ5IHJlbmRlci4gQ2FuIGJlIG51bGwgZm9yIHN0YXRlbGVzc1xyXG4gICAqIGNvbXBvbmVudHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gdGhlIHB1YmxpYyBjb21wb25lbnQgaW5zdGFuY2UuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XHJcbiAgICBpZiAodGhpcy5fY29tcG9zaXRlVHlwZSA9PT0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnN0O1xyXG4gIH0sXHJcblxyXG4gIC8vIFN0dWJcclxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogbnVsbFxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuLyogZ2xvYmFscyBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18qL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEluamVjdGlvbicpO1xyXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xyXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcclxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XHJcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xyXG5cclxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xyXG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XHJcbnZhciByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlcXVpcmUoJy4vcmVuZGVyU3VidHJlZUludG9Db250YWluZXInKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XHJcblxyXG52YXIgUmVhY3RET00gPSB7XHJcbiAgZmluZERPTU5vZGU6IGZpbmRET01Ob2RlLFxyXG4gIHJlbmRlcjogUmVhY3RNb3VudC5yZW5kZXIsXHJcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlLFxyXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcclxuXHJcbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXHJcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyxcclxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcclxufTtcclxuXHJcbi8vIEluamVjdCB0aGUgcnVudGltZSBpbnRvIGEgZGV2dG9vbHMgZ2xvYmFsIGhvb2sgcmVnYXJkbGVzcyBvZiBicm93c2VyLlxyXG4vLyBBbGxvd3MgZm9yIGRlYnVnZ2luZyB3aGVuIHRoZSBob29rIGlzIGluamVjdGVkIG9uIHRoZSBwYWdlLlxyXG5pZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcclxuICAgIENvbXBvbmVudFRyZWU6IHtcclxuICAgICAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcclxuICAgICAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcclxuICAgICAgICAvLyBpbnN0IGlzIGFuIGludGVybmFsIGluc3RhbmNlIChidXQgY291bGQgYmUgYSBjb21wb3NpdGUpXHJcbiAgICAgICAgaWYgKGluc3QuX3JlbmRlcmVkQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnN0KSB7XHJcbiAgICAgICAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxyXG4gICAgUmVjb25jaWxlcjogUmVhY3RSZWNvbmNpbGVyXHJcbiAgfSk7XHJcbn1cclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XHJcblxyXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgZGV2dG9vbHMgaXMgbm90IGluc3RhbGxlZFxyXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxyXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XHJcbiAgICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCBoYXZlIHRoZSBpc3N1ZSB3aXRoIGRldnRvb2xzIGxvYWRlZCBvdmVyIGZpbGU6Ly9cclxuICAgICAgICB2YXIgc2hvd0ZpbGVVcmxNZXNzYWdlID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSA9PT0gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xyXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyAnICsgKHNob3dGaWxlVXJsTWVzc2FnZSA/ICdhbmQgdXNlIGFuIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGEgZmlsZTogVVJMKSAnIDogJycpICsgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0ZXN0RnVuYyA9IGZ1bmN0aW9uIHRlc3RGbigpIHt9O1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoKHRlc3RGdW5jLm5hbWUgfHwgdGVzdEZ1bmMudG9TdHJpbmcoKSkuaW5kZXhPZigndGVzdEZuJykgIT09IC0xLCAnSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhIG1pbmlmaWVkIGNvcHkgb2YgdGhlIGRldmVsb3BtZW50IGJ1aWxkICcgKyAnb2YgUmVhY3QuIFdoZW4gZGVwbG95aW5nIFJlYWN0IGFwcHMgdG8gcHJvZHVjdGlvbiwgbWFrZSBzdXJlIHRvIHVzZSAnICsgJ3RoZSBwcm9kdWN0aW9uIGJ1aWxkIHdoaWNoIHNraXBzIGRldmVsb3BtZW50IHdhcm5pbmdzIGFuZCBpcyBmYXN0ZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtbWluaWZpY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XHJcblxyXG4gICAgLy8gSWYgd2UncmUgaW4gSUU4LCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGluIGNvbXBhdGliaWxpdHkgbW9kZSBhbmQgcHJvdmlkZVxyXG4gICAgLy8gaW5mb3JtYXRpb24gb24gcHJldmVudGluZyBjb21wYXRpYmlsaXR5IG1vZGVcclxuICAgIHZhciBpZUNvbXBhdGliaWxpdHlNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDg7XHJcblxyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWllQ29tcGF0aWJpbGl0eU1vZGUsICdJbnRlcm5ldCBFeHBsb3JlciBpcyBydW5uaW5nIGluIGNvbXBhdGliaWxpdHkgbW9kZTsgcGxlYXNlIGFkZCB0aGUgJyArICdmb2xsb3dpbmcgdGFnIHRvIHlvdXIgSFRNTCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmc6ICcgKyAnPG1ldGEgaHR0cC1lcXVpdj1cIlgtVUEtQ29tcGF0aWJsZVwiIGNvbnRlbnQ9XCJJRT1lZGdlXCIgLz4nKSA6IHZvaWQgMDtcclxuXHJcbiAgICB2YXIgZXhwZWN0ZWRGZWF0dXJlcyA9IFtcclxuICAgIC8vIHNoaW1zXHJcbiAgICBBcnJheS5pc0FycmF5LCBBcnJheS5wcm90b3R5cGUuZXZlcnksIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgQXJyYXkucHJvdG90eXBlLm1hcCwgRGF0ZS5ub3csIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBPYmplY3Qua2V5cywgU3RyaW5nLnByb3RvdHlwZS50cmltXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKCFleHBlY3RlZEZlYXR1cmVzW2ldKSB7XHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmUgb3IgbW9yZSBFUzUgc2hpbXMgZXhwZWN0ZWQgYnkgUmVhY3QgYXJlIG5vdCBhdmFpbGFibGU6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLXBvbHlmaWxscycpIDogdm9pZCAwO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcclxuICB2YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2snKTtcclxuICB2YXIgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2snKTtcclxuICB2YXIgUmVhY3RET01JbnZhbGlkQVJJQUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NSW52YWxpZEFSSUFIb29rJyk7XHJcblxyXG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayk7XHJcbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLmFkZEhvb2soUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rKTtcclxuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTUludmFsaWRBUklBSG9vayk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuLyogZ2xvYmFsIGhhc093blByb3BlcnR5OnRydWUgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXHJcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIEF1dG9Gb2N1c1V0aWxzID0gcmVxdWlyZSgnLi9BdXRvRm9jdXNVdGlscycpO1xyXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcclxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xyXG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xyXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XHJcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xyXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XHJcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XHJcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRGbGFncycpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFJlYWN0RE9NSW5wdXQgPSByZXF1aXJlKCcuL1JlYWN0RE9NSW5wdXQnKTtcclxudmFyIFJlYWN0RE9NT3B0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTU9wdGlvbicpO1xyXG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XHJcbnZhciBSZWFjdERPTVRleHRhcmVhID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRhcmVhJyk7XHJcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcclxudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkJyk7XHJcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uJyk7XHJcblxyXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcclxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcclxudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xyXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgRmxhZ3MgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xyXG52YXIgZGVsZXRlTGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5kZWxldGVMaXN0ZW5lcjtcclxudmFyIGdldE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZTtcclxudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xyXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xyXG5cclxuLy8gRm9yIHF1aWNrbHkgbWF0Y2hpbmcgY2hpbGRyZW4gdHlwZSwgdG8gdGVzdCBpZiBjYW4gYmUgdHJlYXRlZCBhcyBjb250ZW50LlxyXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XHJcblxyXG52YXIgU1RZTEUgPSAnc3R5bGUnO1xyXG52YXIgSFRNTCA9ICdfX2h0bWwnO1xyXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XHJcbiAgY2hpbGRyZW46IG51bGwsXHJcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IG51bGwsXHJcbiAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiBudWxsXHJcbn07XHJcblxyXG4vLyBOb2RlIHR5cGUgZm9yIGRvY3VtZW50IGZyYWdtZW50cyAoTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKS5cclxudmFyIERPQ19GUkFHTUVOVF9UWVBFID0gMTE7XHJcblxyXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oaW50ZXJuYWxJbnN0YW5jZSkge1xyXG4gIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XHJcbiAgICB2YXIgb3duZXIgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcclxuICAgIGlmIChvd25lcikge1xyXG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcclxuICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gJyBUaGlzIERPTSBub2RlIHdhcyByZW5kZXJlZCBieSBgJyArIG5hbWUgKyAnYC4nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAnJztcclxufVxyXG5cclxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XHJcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHBhaXJzID0gW107XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgdmFyIGtleUVzY2FwZWQgPSAvXlthLXokX11bXFx3JF9dKiQvaS50ZXN0KGtleSkgPyBrZXkgOiBKU09OLnN0cmluZ2lmeShrZXkpO1xyXG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuICdbZnVuY3Rpb24gb2JqZWN0XSc7XHJcbiAgfVxyXG4gIC8vIERpZmZlcnMgZnJvbSBKU09OLnN0cmluZ2lmeSBpbiB0aGF0IHVuZGVmaW5lZCBiZWNhdXNlIHVuZGVmaW5lZCBhbmQgdGhhdFxyXG4gIC8vIGluZiBhbmQgbmFuIGRvbid0IGJlY29tZSBudWxsXHJcbiAgcmV0dXJuIFN0cmluZyhvYmopO1xyXG59XHJcblxyXG52YXIgc3R5bGVNdXRhdGlvbldhcm5pbmcgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZShzdHlsZTEsIHN0eWxlMiwgY29tcG9uZW50KSB7XHJcbiAgaWYgKHN0eWxlMSA9PSBudWxsIHx8IHN0eWxlMiA9PSBudWxsKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChzaGFsbG93RXF1YWwoc3R5bGUxLCBzdHlsZTIpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5fdGFnO1xyXG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xyXG4gIHZhciBvd25lck5hbWU7XHJcbiAgaWYgKG93bmVyKSB7XHJcbiAgICBvd25lck5hbWUgPSBvd25lci5nZXROYW1lKCk7XHJcbiAgfVxyXG5cclxuICB2YXIgaGFzaCA9IG93bmVyTmFtZSArICd8JyArIGNvbXBvbmVudE5hbWU7XHJcblxyXG4gIGlmIChzdHlsZU11dGF0aW9uV2FybmluZy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgc3R5bGVNdXRhdGlvbldhcm5pbmdbaGFzaF0gPSB0cnVlO1xyXG5cclxuICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2Alc2Agd2FzIHBhc3NlZCBhIHN0eWxlIG9iamVjdCB0aGF0IGhhcyBwcmV2aW91c2x5IGJlZW4gbXV0YXRlZC4gJyArICdNdXRhdGluZyBgc3R5bGVgIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIGNsb25pbmcgaXQgYmVmb3JlaGFuZC4gQ2hlY2sgJyArICd0aGUgYHJlbmRlcmAgJXMuIFByZXZpb3VzIHN0eWxlOiAlcy4gTXV0YXRlZCBzdHlsZTogJXMuJywgY29tcG9uZW50TmFtZSwgb3duZXIgPyAnb2YgYCcgKyBvd25lck5hbWUgKyAnYCcgOiAndXNpbmcgPCcgKyBjb21wb25lbnROYW1lICsgJz4nLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTEpLCBmcmllbmRseVN0cmluZ2lmeShzdHlsZTIpKSA6IHZvaWQgMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnRcclxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xyXG4gKi9cclxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyhjb21wb25lbnQsIHByb3BzKSB7XHJcbiAgaWYgKCFwcm9wcykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbY29tcG9uZW50Ll90YWddKSB7XHJcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IF9wcm9kSW52YXJpYW50KCcxMzcnLCBjb21wb25lbnQuX3RhZywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgPyAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICcgKyBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLicgOiAnJykgOiB2b2lkIDA7XHJcbiAgfVxyXG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XHJcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogX3Byb2RJbnZhcmlhbnQoJzYwJykgOiB2b2lkIDA7XHJcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzYxJykgOiB2b2lkIDA7XHJcbiAgfVxyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB2b2lkIDA7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5vbkZvY3VzSW4gPT0gbnVsbCAmJiBwcm9wcy5vbkZvY3VzT3V0ID09IG51bGwsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpIDogdm9pZCAwO1xyXG4gIH1cclxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IF9wcm9kSW52YXJpYW50KCc2MicsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHZvaWQgMDtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5xdWV1ZVB1dExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyLCB0cmFuc2FjdGlvbikge1xyXG4gIGlmICh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcclxuICAgIC8vIGJ1YmJsZS5cclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHJlZ2lzdHJhdGlvbk5hbWUgIT09ICdvblNjcm9sbCcgfHwgaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSksICdUaGlzIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgdGhlIGBvblNjcm9sbGAgZXZlbnQnKSA6IHZvaWQgMDtcclxuICB9XHJcbiAgdmFyIGNvbnRhaW5lckluZm8gPSBpbnN0Ll9ob3N0Q29udGFpbmVySW5mbztcclxuICB2YXIgaXNEb2N1bWVudEZyYWdtZW50ID0gY29udGFpbmVySW5mby5fbm9kZSAmJiBjb250YWluZXJJbmZvLl9ub2RlLm5vZGVUeXBlID09PSBET0NfRlJBR01FTlRfVFlQRTtcclxuICB2YXIgZG9jID0gaXNEb2N1bWVudEZyYWdtZW50ID8gY29udGFpbmVySW5mby5fbm9kZSA6IGNvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XHJcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcclxuICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHB1dExpc3RlbmVyLCB7XHJcbiAgICBpbnN0OiBpbnN0LFxyXG4gICAgcmVnaXN0cmF0aW9uTmFtZTogcmVnaXN0cmF0aW9uTmFtZSxcclxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcigpIHtcclxuICB2YXIgbGlzdGVuZXJUb1B1dCA9IHRoaXM7XHJcbiAgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIobGlzdGVuZXJUb1B1dC5pbnN0LCBsaXN0ZW5lclRvUHV0LnJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyVG9QdXQubGlzdGVuZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnB1dFBvc3RNb3VudCgpIHtcclxuICB2YXIgaW5zdCA9IHRoaXM7XHJcbiAgUmVhY3RET01JbnB1dC5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0ZXh0YXJlYVBvc3RNb3VudCgpIHtcclxuICB2YXIgaW5zdCA9IHRoaXM7XHJcbiAgUmVhY3RET01UZXh0YXJlYS5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvcHRpb25Qb3N0TW91bnQoKSB7XHJcbiAgdmFyIGluc3QgPSB0aGlzO1xyXG4gIFJlYWN0RE9NT3B0aW9uLnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XHJcbn1cclxuXHJcbnZhciBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldiA9IGVtcHR5RnVuY3Rpb247XHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYgPSBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gICAgdmFyIGhhc0V4aXN0aW5nQ29udGVudCA9IHRoaXMuX2NvbnRlbnREZWJ1Z0lEICE9IG51bGw7XHJcbiAgICB2YXIgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XHJcbiAgICAvLyBUaGlzIElEIHJlcHJlc2VudHMgdGhlIGlubGluZWQgY2hpbGQgdGhhdCBoYXMgbm8gYmFja2luZyBpbnN0YW5jZTpcclxuICAgIHZhciBjb250ZW50RGVidWdJRCA9IC1kZWJ1Z0lEO1xyXG5cclxuICAgIGlmIChjb250ZW50ID09IG51bGwpIHtcclxuICAgICAgaWYgKGhhc0V4aXN0aW5nQ29udGVudCkge1xyXG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQodGhpcy5fY29udGVudERlYnVnSUQpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NvbnRlbnREZWJ1Z0lEID0gbnVsbDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBTdHJpbmcoY29udGVudCksIHRoaXMsIHRoaXMuX2FuY2VzdG9ySW5mbyk7XHJcbiAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IGNvbnRlbnREZWJ1Z0lEO1xyXG4gICAgaWYgKGhhc0V4aXN0aW5nQ29udGVudCkge1xyXG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQpO1xyXG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQsIGRlYnVnSUQpO1xyXG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChjb250ZW50RGVidWdJRCk7XHJcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIFtjb250ZW50RGVidWdJRF0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxyXG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXHJcbnZhciBtZWRpYUV2ZW50cyA9IHtcclxuICB0b3BBYm9ydDogJ2Fib3J0JyxcclxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXHJcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXHJcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXHJcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxyXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXHJcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXHJcbiAgdG9wRXJyb3I6ICdlcnJvcicsXHJcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxyXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxyXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXHJcbiAgdG9wUGF1c2U6ICdwYXVzZScsXHJcbiAgdG9wUGxheTogJ3BsYXknLFxyXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcclxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcclxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXHJcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcclxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXHJcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxyXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcclxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXHJcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcclxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnRzTG9jYWwoKSB7XHJcbiAgdmFyIGluc3QgPSB0aGlzO1xyXG4gIC8vIElmIGEgY29tcG9uZW50IHJlbmRlcnMgdG8gbnVsbCBvciBpZiBhbm90aGVyIGNvbXBvbmVudCBmYXRhbHMgYW5kIGNhdXNlc1xyXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZSB0byBiZSBjb3JydXB0ZWQsIGBub2RlYCBoZXJlIGNhbiBiZSBudWxsLlxyXG4gICFpbnN0Ll9yb290Tm9kZUlEID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgbW91bnRlZCB0byB0cmFwIGV2ZW50cycpIDogX3Byb2RJbnZhcmlhbnQoJzYzJykgOiB2b2lkIDA7XHJcbiAgdmFyIG5vZGUgPSBnZXROb2RlKGluc3QpO1xyXG4gICFub2RlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXBCdWJibGVkRXZlbnQoLi4uKTogUmVxdWlyZXMgbm9kZSB0byBiZSByZW5kZXJlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc2NCcpIDogdm9pZCAwO1xyXG5cclxuICBzd2l0Y2ggKGluc3QuX3RhZykge1xyXG4gICAgY2FzZSAnaWZyYW1lJzpcclxuICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIG5vZGUpXTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICd2aWRlbyc6XHJcbiAgICBjYXNlICdhdWRpbyc6XHJcblxyXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW107XHJcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxyXG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xyXG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcclxuICAgICAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMucHVzaChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBub2RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnc291cmNlJzpcclxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBub2RlKV07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnaW1nJzpcclxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIG5vZGUpXTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdmb3JtJzpcclxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBub2RlKV07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnaW5wdXQnOlxyXG4gICAgY2FzZSAnc2VsZWN0JzpcclxuICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgbm9kZSldO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xyXG4gIFJlYWN0RE9NU2VsZWN0LnBvc3RVcGRhdGVXcmFwcGVyKHRoaXMpO1xyXG59XHJcblxyXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3JcclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXHJcblxyXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcclxuICAnYXJlYSc6IHRydWUsXHJcbiAgJ2Jhc2UnOiB0cnVlLFxyXG4gICdicic6IHRydWUsXHJcbiAgJ2NvbCc6IHRydWUsXHJcbiAgJ2VtYmVkJzogdHJ1ZSxcclxuICAnaHInOiB0cnVlLFxyXG4gICdpbWcnOiB0cnVlLFxyXG4gICdpbnB1dCc6IHRydWUsXHJcbiAgJ2tleWdlbic6IHRydWUsXHJcbiAgJ2xpbmsnOiB0cnVlLFxyXG4gICdtZXRhJzogdHJ1ZSxcclxuICAncGFyYW0nOiB0cnVlLFxyXG4gICdzb3VyY2UnOiB0cnVlLFxyXG4gICd0cmFjayc6IHRydWUsXHJcbiAgJ3dicic6IHRydWVcclxufTtcclxuXHJcbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcclxuICAnbGlzdGluZyc6IHRydWUsXHJcbiAgJ3ByZSc6IHRydWUsXHJcbiAgJ3RleHRhcmVhJzogdHJ1ZVxyXG59O1xyXG5cclxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xyXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXHJcblxyXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XHJcbiAgJ21lbnVpdGVtJzogdHJ1ZVxyXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcclxuXHJcbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcclxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXHJcbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcclxuXHJcbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcclxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XHJcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZFRhZ0NhY2hlLCB0YWcpKSB7XHJcbiAgICAhVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHRhZzogJXMnLCB0YWcpIDogX3Byb2RJbnZhcmlhbnQoJzY1JywgdGFnKSA6IHZvaWQgMDtcclxuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcclxuICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPj0gMCB8fCBwcm9wcy5pcyAhPSBudWxsO1xyXG59XHJcblxyXG52YXIgZ2xvYmFsSWRDb3VudGVyID0gMTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IFJlYWN0IGNsYXNzIHRoYXQgaXMgaWRlbXBvdGVudCBhbmQgY2FwYWJsZSBvZiBjb250YWluaW5nIG90aGVyXHJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxyXG4gKiB2YWxpZCBhY2NvcmRpbmcgdG8gYERPTVByb3BlcnR5YC5cclxuICpcclxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cclxuICogIC0gRE9NIHByb3BlcnRpZXM6IGBjbGFzc05hbWVgLCBgbmFtZWAsIGB0aXRsZWAsIGV0Yy5cclxuICpcclxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cclxuICogb2JqZWN0IG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxyXG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcclxuICovXHJcbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KGVsZW1lbnQpIHtcclxuICB2YXIgdGFnID0gZWxlbWVudC50eXBlO1xyXG4gIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZyk7XHJcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xyXG4gIHRoaXMuX3RhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xyXG4gIHRoaXMuX25hbWVzcGFjZVVSSSA9IG51bGw7XHJcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XHJcbiAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG51bGw7XHJcbiAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xyXG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcclxuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcclxuICB0aGlzLl9yb290Tm9kZUlEID0gMDtcclxuICB0aGlzLl9kb21JRCA9IDA7XHJcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xyXG4gIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XHJcbiAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcclxuICB0aGlzLl9mbGFncyA9IDA7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IG51bGw7XHJcbiAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xyXG4gIH1cclxufVxyXG5cclxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xyXG5cclxuUmVhY3RET01Db21wb25lbnQuTWl4aW4gPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyByb290IHRhZyBtYXJrdXAgdGhlbiByZWN1cnNlcy4gVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBhbmRcclxuICAgKiBpcyBub3QgaWRlbXBvdGVudC5cclxuICAgKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBwYXJhbSB7P1JlYWN0RE9NQ29tcG9uZW50fSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaW5mbyBhYm91dCB0aGUgaG9zdCBjb250YWluZXJcclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cclxuICAgKi9cclxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xyXG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IGdsb2JhbElkQ291bnRlcisrO1xyXG4gICAgdGhpcy5fZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XHJcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcclxuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XHJcblxyXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XHJcblxyXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcclxuICAgICAgY2FzZSAnYXVkaW8nOlxyXG4gICAgICBjYXNlICdmb3JtJzpcclxuICAgICAgY2FzZSAnaWZyYW1lJzpcclxuICAgICAgY2FzZSAnaW1nJzpcclxuICAgICAgY2FzZSAnbGluayc6XHJcbiAgICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcclxuICAgICAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSB7XHJcbiAgICAgICAgICBsaXN0ZW5lcnM6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2lucHV0JzpcclxuICAgICAgICBSZWFjdERPTUlucHV0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XHJcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnb3B0aW9uJzpcclxuICAgICAgICBSZWFjdERPTU9wdGlvbi5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xyXG4gICAgICAgIHByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc2VsZWN0JzpcclxuICAgICAgICBSZWFjdERPTVNlbGVjdC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xyXG4gICAgICAgIHByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XHJcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xyXG4gICAgICAgIHByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBwcm9wcyk7XHJcblxyXG4gICAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxyXG4gICAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxyXG4gICAgdmFyIG5hbWVzcGFjZVVSSTtcclxuICAgIHZhciBwYXJlbnRUYWc7XHJcbiAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XHJcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RQYXJlbnQuX25hbWVzcGFjZVVSSTtcclxuICAgICAgcGFyZW50VGFnID0gaG9zdFBhcmVudC5fdGFnO1xyXG4gICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mby5fdGFnKSB7XHJcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RDb250YWluZXJJbmZvLl9uYW1lc3BhY2VVUkk7XHJcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RDb250YWluZXJJbmZvLl90YWc7XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZXNwYWNlVVJJID09IG51bGwgfHwgbmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiBwYXJlbnRUYWcgPT09ICdmb3JlaWdub2JqZWN0Jykge1xyXG4gICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLmh0bWw7XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcclxuICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3N2ZycpIHtcclxuICAgICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLnN2ZztcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLl90YWcgPT09ICdtYXRoJykge1xyXG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMubWF0aG1sO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFyIHBhcmVudEluZm87XHJcbiAgICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcclxuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xyXG4gICAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcclxuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdENvbnRhaW5lckluZm8uX2FuY2VzdG9ySW5mbztcclxuICAgICAgfVxyXG4gICAgICBpZiAocGFyZW50SW5mbykge1xyXG4gICAgICAgIC8vIHBhcmVudEluZm8gc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IGV4Y2VwdCBmb3IgdGhlIHRvcC1sZXZlbFxyXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcclxuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCBudWxsLCB0aGlzLCBwYXJlbnRJbmZvKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9hbmNlc3RvckluZm8gPSB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRJbmZvLCB0aGlzLl90YWcsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtb3VudEltYWdlO1xyXG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcclxuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcclxuICAgICAgdmFyIGVsO1xyXG4gICAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGFnID09PSAnc2NyaXB0Jykge1xyXG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xyXG4gICAgICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcclxuICAgICAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xyXG4gICAgICAgICAgZGl2LmlubmVySFRNTCA9ICc8JyArIHR5cGUgKyAnPjwvJyArIHR5cGUgKyAnPic7XHJcbiAgICAgICAgICBlbCA9IGRpdi5yZW1vdmVDaGlsZChkaXYuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5pcykge1xyXG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSwgcHJvcHMuaXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY3Vhc2Ugb2YgYSBGaXJlZm94IGJ1Zy5cclxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcclxuICAgICAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcclxuICAgICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XHJcbiAgICAgIH1cclxuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBlbCk7XHJcbiAgICAgIHRoaXMuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XHJcbiAgICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xyXG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRBdHRyaWJ1dGVGb3JSb290KGVsKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKG51bGwsIHByb3BzLCB0cmFuc2FjdGlvbik7XHJcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKGVsKTtcclxuICAgICAgdGhpcy5fY3JlYXRlSW5pdGlhbENoaWxkcmVuKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgbGF6eVRyZWUpO1xyXG4gICAgICBtb3VudEltYWdlID0gbGF6eVRyZWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgdGFnT3BlbiA9IHRoaXMuX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnModHJhbnNhY3Rpb24sIHByb3BzKTtcclxuICAgICAgdmFyIHRhZ0NvbnRlbnQgPSB0aGlzLl9jcmVhdGVDb250ZW50TWFya3VwKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCk7XHJcbiAgICAgIGlmICghdGFnQ29udGVudCAmJiBvbWl0dGVkQ2xvc2VUYWdzW3RoaXMuX3RhZ10pIHtcclxuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICcvPic7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnPicgKyB0YWdDb250ZW50ICsgJzwvJyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgKyAnPic7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xyXG4gICAgICBjYXNlICdpbnB1dCc6XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnB1dFBvc3RNb3VudCwgdGhpcyk7XHJcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xyXG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0ZXh0YXJlYVBvc3RNb3VudCwgdGhpcyk7XHJcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xyXG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdzZWxlY3QnOlxyXG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcclxuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYnV0dG9uJzpcclxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XHJcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ29wdGlvbic6XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShvcHRpb25Qb3N0TW91bnQsIHRoaXMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtb3VudEltYWdlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgb3BlbiB0YWcgYW5kIGFsbCBhdHRyaWJ1dGVzLlxyXG4gICAqXHJcbiAgICogVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBiZWNhdXNlIGV2ZW50cyBnZXQgcmVnaXN0ZXJlZC5cclxuICAgKlxyXG4gICAqIEl0ZXJhdGluZyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGlzIGZhc3RlciB0aGFuIGl0ZXJhdGluZyBvdmVyIGFycmF5cy5cclxuICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL29iai12cy1hcnItaXRlcmF0aW9uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIG9mIG9wZW5pbmcgdGFnLlxyXG4gICAqL1xyXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzKSB7XHJcbiAgICB2YXIgcmV0ID0gJzwnICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcclxuXHJcbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XHJcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XHJcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xyXG4gICAgICAgIGlmIChwcm9wVmFsdWUpIHtcclxuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBwcm9wVmFsdWUsIHRyYW5zYWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XHJcbiAgICAgICAgICBpZiAocHJvcFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgLy8gU2VlIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIHN0eWxlIGJsb2NrXHJcbiAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IHByb3BWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wVmFsdWUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHByb3BWYWx1ZSA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hcmt1cCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RhZyAhPSBudWxsICYmIGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgcHJvcHMpKSB7XHJcbiAgICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XHJcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXJrdXApIHtcclxuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXHJcbiAgICAvLyBieXRlcy5cclxuICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xyXG4gICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xyXG4gICAgICByZXQgKz0gJyAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclJvb3QoKTtcclxuICAgIH1cclxuICAgIHJldCArPSAnICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQodGhpcy5fZG9tSUQpO1xyXG4gICAgcmV0dXJuIHJldDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgdGFncy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnRlbnQgbWFya3VwLlxyXG4gICAqL1xyXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgcmV0ID0gJyc7XHJcblxyXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXHJcbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XHJcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcclxuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldCA9IGlubmVySFRNTC5fX2h0bWw7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XHJcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XHJcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXHJcbiAgICAgICAgcmV0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKGNvbnRlbnRUb1VzZSk7XHJcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuICAgICAgICByZXQgPSBtb3VudEltYWdlcy5qb2luKCcnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5ld2xpbmVFYXRpbmdUYWdzW3RoaXMuX3RhZ10gJiYgcmV0LmNoYXJBdCgwKSA9PT0gJ1xcbicpIHtcclxuICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXHJcbiAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xyXG4gICAgICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXHJcbiAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxyXG4gICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXHJcbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XHJcbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxyXG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cclxuICAgICAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xyXG4gICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cclxuICAgICAgcmV0dXJuICdcXG4nICsgcmV0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfY3JlYXRlSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSkge1xyXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXHJcbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XHJcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcclxuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xyXG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlSFRNTChsYXp5VHJlZSwgaW5uZXJIVE1MLl9faHRtbCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XHJcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XHJcbiAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXHJcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgdGV4dENvbnRlbnQgd2hlbiB0aGUgdGV4dCBpcyBlbXB0eS4gSW4gSUUxMSBzZXR0aW5nXHJcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSB0ZXh0IGFyZWEgd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XHJcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIHRleHRhcmVhIHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82NzMxI2lzc3VlY29tbWVudC0yNTQ4NzQ1NTNcclxuICAgICAgICBpZiAoY29udGVudFRvVXNlICE9PSAnJykge1xyXG4gICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYuY2FsbCh0aGlzLCBjb250ZW50VG9Vc2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgRE9NTGF6eVRyZWUucXVldWVUZXh0KGxhenlUcmVlLCBjb250ZW50VG9Vc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcclxuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW91bnRJbWFnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIG1vdW50SW1hZ2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZWNlaXZlcyBhIG5leHQgZWxlbWVudCBhbmQgdXBkYXRlcyB0aGUgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcclxuICAgKi9cclxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcclxuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XHJcbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIGEgRE9NIGNvbXBvbmVudCBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFsbG9jYXRlZCBhbmRcclxuICAgKiBhdHRhY2hlZCB0byB0aGUgRE9NLiBSZWNvbmNpbGVzIHRoZSByb290IERPTSBub2RlLCB0aGVuIHJlY3Vyc2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2RWxlbWVudFxyXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBvdmVycmlkYWJsZVxyXG4gICAqL1xyXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpIHtcclxuICAgIHZhciBsYXN0UHJvcHMgPSBwcmV2RWxlbWVudC5wcm9wcztcclxuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcclxuXHJcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xyXG4gICAgICBjYXNlICdpbnB1dCc6XHJcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcclxuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdvcHRpb24nOlxyXG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xyXG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdzZWxlY3QnOlxyXG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xyXG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XHJcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcclxuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgbmV4dFByb3BzKTtcclxuICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uKTtcclxuICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XHJcblxyXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcclxuICAgICAgY2FzZSAnaW5wdXQnOlxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXHJcbiAgICAgICAgLy8gaGFwcGVuIGFmdGVyIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xyXG4gICAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cclxuICAgICAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XHJcbiAgICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXHJcbiAgICAgICAgLy8gcmVjb25jaWxpYXRpb25cclxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyLCB0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXHJcbiAgICogdXBkYXRpbmcgdGhlIERPTSBhcyBuZWNlc3NhcnkuIFRoaXMgZnVuY3Rpb24gaXMgcHJvYmFibHkgdGhlIHNpbmdsZSBtb3N0XHJcbiAgICogY3JpdGljYWwgcGF0aCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxyXG4gICAqXHJcbiAgICogVE9ETzogQmVuY2htYXJrIHdoZXRoZXIgY2hlY2tpbmcgZm9yIGNoYW5nZWQgdmFsdWVzIGluIG1lbW9yeSBhY3R1YWxseVxyXG4gICAqICAgICAgIGltcHJvdmVzIHBlcmZvcm1hbmNlIChlc3BlY2lhbGx5IHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50cykuXHJcbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xyXG4gICAqICAgICAgIGRvIG5vdCBjaGFuZ2UgZm9yIGEgZ2l2ZW4gcmVjb25jaWxpYXRpb24uXHJcbiAgICogVE9ETzogQmVuY2htYXJrIGFyZWFzIHRoYXQgY2FuIGJlIGltcHJvdmVkIHdpdGggY2FjaGluZy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcclxuICAgKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlXHJcbiAgICovXHJcbiAgX3VwZGF0ZURPTVByb3BlcnRpZXM6IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pIHtcclxuICAgIHZhciBwcm9wS2V5O1xyXG4gICAgdmFyIHN0eWxlTmFtZTtcclxuICAgIHZhciBzdHlsZVVwZGF0ZXM7XHJcbiAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XHJcbiAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xyXG4gICAgICAgIHZhciBsYXN0U3R5bGUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weTtcclxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcclxuICAgICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xyXG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XHJcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcclxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xyXG4gICAgICAgIGlmIChsYXN0UHJvcHNbcHJvcEtleV0pIHtcclxuICAgICAgICAgIC8vIE9ubHkgY2FsbCBkZWxldGVMaXN0ZW5lciBpZiB0aGVyZSB3YXMgYSBsaXN0ZW5lciBwcmV2aW91c2x5IG9yXHJcbiAgICAgICAgICAvLyBlbHNlIHdpbGxEZWxldGVMaXN0ZW5lciBnZXRzIGNhbGxlZCB3aGVuIHRoZXJlIHdhc24ndCBhY3R1YWxseSBhXHJcbiAgICAgICAgICAvLyBsaXN0ZW5lciAoZS5nLiwgb25DbGljaz17bnVsbH0pXHJcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLCBwcm9wS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBsYXN0UHJvcHMpKSB7XHJcbiAgICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xyXG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGdldE5vZGUodGhpcyksIHByb3BLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XHJcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcclxuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xyXG4gICAgICB2YXIgbGFzdFByb3AgPSBwcm9wS2V5ID09PSBTVFlMRSA/IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5IDogbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XHJcbiAgICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcclxuICAgICAgICBpZiAobmV4dFByb3ApIHtcclxuICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSh0aGlzLl9wcmV2aW91c1N0eWxlQ29weSwgdGhpcy5fcHJldmlvdXNTdHlsZSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBuZXh0UHJvcDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5leHRQcm9wID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBfYXNzaWduKHt9LCBuZXh0UHJvcCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XHJcbiAgICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXHJcbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xyXG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xyXG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcclxuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxyXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcclxuICAgICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xyXG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcclxuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXHJcbiAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcclxuICAgICAgICBpZiAobmV4dFByb3ApIHtcclxuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFByb3ApIHtcclxuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIG5leHRQcm9wcykpIHtcclxuICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XHJcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSwgbmV4dFByb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBnZXROb2RlKHRoaXMpO1xyXG4gICAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxyXG4gICAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXHJcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxyXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHN0eWxlVXBkYXRlcykge1xyXG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JTdHlsZXMoZ2V0Tm9kZSh0aGlzKSwgc3R5bGVVcGRhdGVzLCB0aGlzKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZWNvbmNpbGVzIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlXHJcbiAgICogY2hpbGRyZW4gY29udGVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcclxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XHJcbiAgICovXHJcbiAgX3VwZGF0ZURPTUNoaWxkcmVuOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgbGFzdENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBsYXN0UHJvcHMuY2hpbGRyZW5dID8gbGFzdFByb3BzLmNoaWxkcmVuIDogbnVsbDtcclxuICAgIHZhciBuZXh0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIG5leHRQcm9wcy5jaGlsZHJlbl0gPyBuZXh0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xyXG5cclxuICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xyXG4gICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XHJcblxyXG4gICAgLy8gTm90ZSB0aGUgdXNlIG9mIGAhPWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cclxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcclxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IG5leHRQcm9wcy5jaGlsZHJlbjtcclxuXHJcbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXHJcbiAgICAvLyB0aGUgb2xkIGNvbnRlbnRcclxuICAgIHZhciBsYXN0SGFzQ29udGVudE9ySHRtbCA9IGxhc3RDb250ZW50ICE9IG51bGwgfHwgbGFzdEh0bWwgIT0gbnVsbDtcclxuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcclxuICAgIGlmIChsYXN0Q2hpbGRyZW4gIT0gbnVsbCAmJiBuZXh0Q2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG51bGwsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycpO1xyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChuZXh0Q29udGVudCAhPSBudWxsKSB7XHJcbiAgICAgIGlmIChsYXN0Q29udGVudCAhPT0gbmV4dENvbnRlbnQpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xyXG4gICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG5leHRDb250ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xyXG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXJrdXAoJycgKyBuZXh0SHRtbCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbih0aGlzLl9kZWJ1Z0lELCBbXSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZ2V0Tm9kZSh0aGlzKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cclxuICAgKiB0aGUgRE9NLiBUaGF0IG11c3QgYmUgZG9uZSBieSB0aGUgcGFyZW50LlxyXG4gICAqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHNhZmVseSkge1xyXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcclxuICAgICAgY2FzZSAnYXVkaW8nOlxyXG4gICAgICBjYXNlICdmb3JtJzpcclxuICAgICAgY2FzZSAnaWZyYW1lJzpcclxuICAgICAgY2FzZSAnaW1nJzpcclxuICAgICAgY2FzZSAnbGluayc6XHJcbiAgICAgIGNhc2UgJ29iamVjdCc6XHJcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fd3JhcHBlclN0YXRlLmxpc3RlbmVycztcclxuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0ucmVtb3ZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdodG1sJzpcclxuICAgICAgY2FzZSAnaGVhZCc6XHJcbiAgICAgIGNhc2UgJ2JvZHknOlxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbXBvbmVudHMgbGlrZSA8aHRtbD4gPGhlYWQ+IGFuZCA8Ym9keT4gY2FuJ3QgYmUgcmVtb3ZlZCBvciBhZGRlZFxyXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xyXG4gICAgICAgICAqIHRha2UgYWR2YW50YWdlIG9mIFJlYWN0J3MgcmVjb25jaWxpYXRpb24gZm9yIHN0eWxpbmcgYW5kIDx0aXRsZT5cclxuICAgICAgICAgKiBtYW5hZ2VtZW50LiBTbyB3ZSBqdXN0IGRvY3VtZW50IGl0IGFuZCB0aHJvdyBpbiBkYW5nZXJvdXMgY2FzZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgIWZhbHNlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzwlcz4gdHJpZWQgdG8gdW5tb3VudC4gQmVjYXVzZSBvZiBjcm9zcy1icm93c2VyIHF1aXJrcyBpdCBpcyBpbXBvc3NpYmxlIHRvIHVubW91bnQgc29tZSB0b3AtbGV2ZWwgY29tcG9uZW50cyAoZWcgPGh0bWw+LCA8aGVhZD4sIGFuZCA8Ym9keT4pIHJlbGlhYmx5IGFuZCBlZmZpY2llbnRseS4gVG8gZml4IHRoaXMsIGhhdmUgYSBzaW5nbGUgdG9wLWxldmVsIGNvbXBvbmVudCB0aGF0IG5ldmVyIHVubW91bnRzIHJlbmRlciB0aGVzZSBlbGVtZW50cy4nLCB0aGlzLl90YWcpIDogX3Byb2RJbnZhcmlhbnQoJzY2JywgdGhpcy5fdGFnKSA6IHZvaWQgMDtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVubW91bnRDaGlsZHJlbihzYWZlbHkpO1xyXG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xyXG4gICAgRXZlbnRQbHVnaW5IdWIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMpO1xyXG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XHJcbiAgICB0aGlzLl9kb21JRCA9IDA7XHJcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbnVsbCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xyXG4gIH1cclxuXHJcbn07XHJcblxyXG5fYXNzaWduKFJlYWN0RE9NQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RET01Db21wb25lbnQuTWl4aW4sIFJlYWN0TXVsdGlDaGlsZC5NaXhpbik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0ge1xyXG4gIGhhc0NhY2hlZENoaWxkTm9kZXM6IDEgPDwgMFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XHJcbnZhciBGbGFncyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XHJcblxyXG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYSBnaXZlbiBub2RlIHNob3VsZCBiZSBjYWNoZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaG91bGRQcmVjYWNoZU5vZGUobm9kZSwgbm9kZUlEKSB7XHJcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSA9PT0gU3RyaW5nKG5vZGVJRCkgfHwgbm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC10ZXh0OiAnICsgbm9kZUlEICsgJyAnIHx8IG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtZW1wdHk6ICcgKyBub2RlSUQgKyAnICc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEcmlsbCBkb3duICh0aHJvdWdoIGNvbXBvc2l0ZXMgYW5kIGVtcHR5IGNvbXBvbmVudHMpIHVudGlsIHdlIGdldCBhIGhvc3Qgb3JcclxuICogaG9zdCB0ZXh0IGNvbXBvbmVudC5cclxuICpcclxuICogVGhpcyBpcyBwcmV0dHkgcG9seW1vcnBoaWMgYnV0IHVuYXZvaWRhYmxlIHdpdGggdGhlIGN1cnJlbnQgc3RydWN0dXJlIHdlIGhhdmVcclxuICogZm9yIGBfcmVuZGVyZWRDaGlsZHJlbmAuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gIHZhciByZW5kZXJlZDtcclxuICB3aGlsZSAocmVuZGVyZWQgPSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50KSB7XHJcbiAgICBjb21wb25lbnQgPSByZW5kZXJlZDtcclxuICB9XHJcbiAgcmV0dXJuIGNvbXBvbmVudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIHRoZSByZW5kZXJlZCBob3N0L3RleHQgY29tcG9uZW50IHdpdGggdGhlIGdpdmVuXHJcbiAqIERPTSBub2RlLiBUaGUgcGFzc2VkIGBpbnN0YCBjYW4gYmUgYSBjb21wb3NpdGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBwcmVjYWNoZU5vZGUoaW5zdCwgbm9kZSkge1xyXG4gIHZhciBob3N0SW5zdCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoaW5zdCk7XHJcbiAgaG9zdEluc3QuX2hvc3ROb2RlID0gbm9kZTtcclxuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVuY2FjaGVOb2RlKGluc3QpIHtcclxuICB2YXIgbm9kZSA9IGluc3QuX2hvc3ROb2RlO1xyXG4gIGlmIChub2RlKSB7XHJcbiAgICBkZWxldGUgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcclxuICAgIGluc3QuX2hvc3ROb2RlID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQb3B1bGF0ZSBgX2hvc3ROb2RlYCBvbiBlYWNoIGNoaWxkIG9mIGBpbnN0YCwgYXNzdW1pbmcgdGhhdCB0aGUgY2hpbGRyZW5cclxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXHJcbiAqXHJcbiAqIFdlIGNhY2hlIGVudGlyZSBsZXZlbHMgYXQgb25jZSB0byBhdm9pZCBhbiBuXjIgcHJvYmxlbSB3aGVyZSB3ZSBhY2Nlc3MgdGhlXHJcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XHJcbiAqIG5vZGUgZXZlcnkgdGltZS5cclxuICpcclxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcclxuICogZGlmZmVyZW50IHRpbWVzLCB3ZSBjb3VsZCByYWNlIGhlcmUgYW5kIHNlZSBhIG5ld2VyIGBfcmVuZGVyZWRDaGlsZHJlbmAgdGhhblxyXG4gKiB0aGUgRE9NIG5vZGVzIHdlIHNlZS4gVG8gYXZvaWQgdGhpcywgUmVhY3RNdWx0aUNoaWxkIGNhbGxzXHJcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxyXG4gKiB0aW1lIHRoZSBjb250YWluZXIncyBjaGlsZCBub2RlcyBhcmUgYWx3YXlzIGNhY2hlZCAodW50aWwgaXQgdW5tb3VudHMpLlxyXG4gKi9cclxuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcclxuICBpZiAoaW5zdC5fZmxhZ3MgJiBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBjaGlsZHJlbiA9IGluc3QuX3JlbmRlcmVkQ2hpbGRyZW47XHJcbiAgdmFyIGNoaWxkTm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcclxuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xyXG4gICAgaWYgKCFjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIHZhciBjaGlsZEluc3QgPSBjaGlsZHJlbltuYW1lXTtcclxuICAgIHZhciBjaGlsZElEID0gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChjaGlsZEluc3QpLl9kb21JRDtcclxuICAgIGlmIChjaGlsZElEID09PSAwKSB7XHJcbiAgICAgIC8vIFdlJ3JlIGN1cnJlbnRseSB1bm1vdW50aW5nIHRoaXMgY2hpbGQgaW4gUmVhY3RNdWx0aUNoaWxkOyBza2lwIGl0LlxyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIC8vIFdlIGFzc3VtZSB0aGUgY2hpbGQgbm9kZXMgYXJlIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBjaGlsZCBpbnN0YW5jZXMuXHJcbiAgICBmb3IgKDsgY2hpbGROb2RlICE9PSBudWxsOyBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmcpIHtcclxuICAgICAgaWYgKHNob3VsZFByZWNhY2hlTm9kZShjaGlsZE5vZGUsIGNoaWxkSUQpKSB7XHJcbiAgICAgICAgcHJlY2FjaGVOb2RlKGNoaWxkSW5zdCwgY2hpbGROb2RlKTtcclxuICAgICAgICBjb250aW51ZSBvdXRlcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gV2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBET00gY2hpbGRyZW4gd2l0aG91dCBmaW5kaW5nIGFuIElEIG1hdGNoLlxyXG4gICAgIWZhbHNlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIGVsZW1lbnQgd2l0aCBJRCAlcy4nLCBjaGlsZElEKSA6IF9wcm9kSW52YXJpYW50KCczMicsIGNoaWxkSUQpIDogdm9pZCAwO1xyXG4gIH1cclxuICBpbnN0Ll9mbGFncyB8PSBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXHJcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cclxuICovXHJcbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcclxuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xyXG4gICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XHJcbiAgfVxyXG5cclxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgaW5zdGFuY2Ugd2UgaGF2ZSBjYWNoZWQuXHJcbiAgdmFyIHBhcmVudHMgPSBbXTtcclxuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcclxuICAgIHBhcmVudHMucHVzaChub2RlKTtcclxuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcclxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xyXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgY2xvc2VzdDtcclxuICB2YXIgaW5zdDtcclxuICBmb3IgKDsgbm9kZSAmJiAoaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pOyBub2RlID0gcGFyZW50cy5wb3AoKSkge1xyXG4gICAgY2xvc2VzdCA9IGluc3Q7XHJcbiAgICBpZiAocGFyZW50cy5sZW5ndGgpIHtcclxuICAgICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNsb3Nlc3Q7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxyXG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcclxuICB2YXIgaW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpO1xyXG4gIGlmIChpbnN0ICE9IG51bGwgJiYgaW5zdC5faG9zdE5vZGUgPT09IG5vZGUpIHtcclxuICAgIHJldHVybiBpbnN0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAqIERPTSBub2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSB7XHJcbiAgLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XHJcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXHJcbiAgIShpbnN0Ll9ob3N0Tm9kZSAhPT0gdW5kZWZpbmVkKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XHJcblxyXG4gIGlmIChpbnN0Ll9ob3N0Tm9kZSkge1xyXG4gICAgcmV0dXJuIGluc3QuX2hvc3ROb2RlO1xyXG4gIH1cclxuXHJcbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIERPTSBub2RlIHdlIGhhdmUgY2FjaGVkLlxyXG4gIHZhciBwYXJlbnRzID0gW107XHJcbiAgd2hpbGUgKCFpbnN0Ll9ob3N0Tm9kZSkge1xyXG4gICAgcGFyZW50cy5wdXNoKGluc3QpO1xyXG4gICAgIWluc3QuX2hvc3RQYXJlbnQgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgRE9NIHRyZWUgcm9vdCBzaG91bGQgYWx3YXlzIGhhdmUgYSBub2RlIHJlZmVyZW5jZS4nKSA6IF9wcm9kSW52YXJpYW50KCczNCcpIDogdm9pZCAwO1xyXG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XHJcbiAgfVxyXG5cclxuICAvLyBOb3cgcGFyZW50cyBjb250YWlucyBlYWNoIGFuY2VzdG9yIHRoYXQgZG9lcyAqbm90KiBoYXZlIGEgY2FjaGVkIG5hdGl2ZVxyXG4gIC8vIG5vZGUsIGFuZCBgaW5zdGAgaXMgdGhlIGRlZXBlc3QgYW5jZXN0b3IgdGhhdCBkb2VzLlxyXG4gIGZvciAoOyBwYXJlbnRzLmxlbmd0aDsgaW5zdCA9IHBhcmVudHMucG9wKCkpIHtcclxuICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBpbnN0Ll9ob3N0Tm9kZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XHJcbn1cclxuXHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSB7XHJcbiAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxyXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGdldEluc3RhbmNlRnJvbU5vZGUsXHJcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSxcclxuICBwcmVjYWNoZUNoaWxkTm9kZXM6IHByZWNhY2hlQ2hpbGROb2RlcyxcclxuICBwcmVjYWNoZU5vZGU6IHByZWNhY2hlTm9kZSxcclxuICB1bmNhY2hlTm9kZTogdW5jYWNoZU5vZGVcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnRUcmVlOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xyXG5cclxudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xyXG5cclxuZnVuY3Rpb24gUmVhY3RET01Db250YWluZXJJbmZvKHRvcExldmVsV3JhcHBlciwgbm9kZSkge1xyXG4gIHZhciBpbmZvID0ge1xyXG4gICAgX3RvcExldmVsV3JhcHBlcjogdG9wTGV2ZWxXcmFwcGVyLFxyXG4gICAgX2lkQ291bnRlcjogMSxcclxuICAgIF9vd25lckRvY3VtZW50OiBub2RlID8gbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSA/IG5vZGUgOiBub2RlLm93bmVyRG9jdW1lbnQgOiBudWxsLFxyXG4gICAgX25vZGU6IG5vZGUsXHJcbiAgICBfdGFnOiBub2RlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbCxcclxuICAgIF9uYW1lc3BhY2VVUkk6IG5vZGUgPyBub2RlLm5hbWVzcGFjZVVSSSA6IG51bGxcclxuICB9O1xyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBpbmZvLl9hbmNlc3RvckluZm8gPSBub2RlID8gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgaW5mby5fdGFnLCBudWxsKSA6IG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBpbmZvO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29udGFpbmVySW5mbzsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcblxyXG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xyXG4gIC8vIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IHVzZXMgdGhpczpcclxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XHJcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XHJcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xyXG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xyXG4gIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcclxuICB0aGlzLl9kb21JRCA9IDA7XHJcbn07XHJcbl9hc3NpZ24oUmVhY3RET01FbXB0eUNvbXBvbmVudC5wcm90b3R5cGUsIHtcclxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xyXG4gICAgdmFyIGRvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xyXG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcclxuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xyXG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcclxuXHJcbiAgICB2YXIgbm9kZVZhbHVlID0gJyByZWFjdC1lbXB0eTogJyArIHRoaXMuX2RvbUlEICsgJyAnO1xyXG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcclxuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcclxuICAgICAgdmFyIG5vZGUgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQobm9kZVZhbHVlKTtcclxuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBub2RlKTtcclxuICAgICAgcmV0dXJuIERPTUxhenlUcmVlKG5vZGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XHJcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCBpbnNlcnQgYSBjb21tZW50IG5vZGUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uXHJcbiAgICAgICAgLy8gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVyblxyXG4gICAgICAgIC8vIG5vdGhpbmcuXHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnPCEtLScgKyBub2RlVmFsdWUgKyAnLS0+JztcclxuICAgIH1cclxuICB9LFxyXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHt9LFxyXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XHJcbiAgfSxcclxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XHJcbiAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01FbXB0eUNvbXBvbmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSB7XHJcbiAgdXNlQ3JlYXRlRWxlbWVudDogdHJ1ZSxcclxuICB1c2VGaWJlcjogZmFsc2VcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GZWF0dXJlRmxhZ3M7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG5cclxuLyoqXHJcbiAqIE9wZXJhdGlvbnMgdXNlZCB0byBwcm9jZXNzIHVwZGF0ZXMgdG8gRE9NIG5vZGVzLlxyXG4gKi9cclxudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0ge1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudEluc3QsIHVwZGF0ZXMpIHtcclxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UocGFyZW50SW5zdCk7XHJcbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucHJvY2Vzc1VwZGF0ZXMobm9kZSwgdXBkYXRlcyk7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlET3BlcmF0aW9uczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxyXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xyXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcclxudmFyIGRpZFdhcm5DaGVja2VkTGluayA9IGZhbHNlO1xyXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XHJcbnZhciBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gZmFsc2U7XHJcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XHJcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcclxuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xyXG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcclxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xyXG4gIHZhciB1c2VzQ2hlY2tlZCA9IHByb3BzLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcHJvcHMudHlwZSA9PT0gJ3JhZGlvJztcclxuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcclxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxyXG4gKlxyXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xyXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cclxuICpcclxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxyXG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cclxuICpcclxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXHJcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cclxuICpcclxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcclxuICovXHJcbnZhciBSZWFjdERPTUlucHV0ID0ge1xyXG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcclxuICAgIHZhciBjaGVja2VkID0gTGlua2VkVmFsdWVVdGlscy5nZXRDaGVja2VkKHByb3BzKTtcclxuXHJcbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XHJcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnR5cGUgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzIChzZXR0aW5nIC52YWx1ZVxyXG4gICAgICAvLyBiZWZvcmUgLnR5cGUgbWVhbnMgLnZhbHVlIGlzIGxvc3QgaW4gSUUxMSBhbmQgYmVsb3cpXHJcbiAgICAgIHR5cGU6IHVuZGVmaW5lZCxcclxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAuc3RlcCBiZWZvcmUgLnZhbHVlIChzZXR0aW5nIC52YWx1ZSBiZWZvcmUgLnN0ZXBcclxuICAgICAgLy8gbWVhbnMgLnZhbHVlIGlzIHJvdW5kZWQgb24gbW91bnQsIGJhc2VkIHVwb24gc3RlcCBwcmVjaXNpb24pXHJcbiAgICAgIHN0ZXA6IHVuZGVmaW5lZCxcclxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAubWluICYgLm1heCBiZWZvcmUgLnZhbHVlICh0byBlbnN1cmUgcHJvcGVyIG9yZGVyXHJcbiAgICAgIC8vIGluIGNvcm5lciBjYXNlcyBzdWNoIGFzIG1pbiBvciBtYXggZGVyaXZpbmcgZnJvbSB2YWx1ZSwgZS5nLiBJc3N1ZSAjNzE3MClcclxuICAgICAgbWluOiB1bmRlZmluZWQsXHJcbiAgICAgIG1heDogdW5kZWZpbmVkXHJcbiAgICB9LCBwcm9wcywge1xyXG4gICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxyXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXHJcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsXHJcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBob3N0UHJvcHM7XHJcbiAgfSxcclxuXHJcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XHJcblxyXG4gICAgICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XHJcblxyXG4gICAgICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYGlucHV0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xyXG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9wcy5jaGVja2VkTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQ2hlY2tlZExpbmspIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BjaGVja2VkTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XHJcbiAgICAgICAgZGlkV2FybkNoZWNrZWRMaW5rID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XHJcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XHJcbiAgICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXHJcbiAgICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxyXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXHJcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcclxuICAgIH07XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XHJcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XHJcbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcclxuXHJcbiAgICAgIGlmICghaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xyXG4gICAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogU2hvdWxkbid0IHRoaXMgYmUgZ2V0Q2hlY2tlZChwcm9wcyk/XHJcbiAgICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XHJcbiAgICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XHJcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpLCAnY2hlY2tlZCcsIGNoZWNrZWQgfHwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XHJcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcblxyXG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxyXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXHJcbiAgICAgIHZhciBuZXdWYWx1ZSA9ICcnICsgdmFsdWU7XHJcblxyXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxyXG4gICAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcclxuICAgICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cclxuICAgICAgICAvLyBGb3IgbnVtYmVyIGlucHV0cywgdGhlIGRpc3BsYXkgdmFsdWUgbG9zZXMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMuIEZvciBlbWFpbCBpbnB1dHMsXHJcbiAgICAgICAgLy8gQ2hyb21lIHJhaXNlcyBcIlRoZSBzcGVjaWZpZWQgdmFsdWUgPHg+IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIEhlcmUgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0VmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWQsIGF2b2lkaW5nIHRoZXNlIHByb2JsZW1zXHJcbiAgICAgICAgLy8gd2hlbiB0aGUgdXNlciBpcyBpbnB1dHRpbmcgdGV4dFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzXHJcbiAgICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XHJcbiAgICAgICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XHJcblxyXG4gICAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxyXG4gICAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXHJcbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xyXG5cclxuICAgIC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZS4gV2Ugd29uJ3QgZG8gYW55dGhpbmcgaWYgd2UncmUgd29ya2luZyBvblxyXG4gICAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcclxuICAgIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxyXG4gICAgLy8gcmVtb3ZlcyBicm93c2VyLWRlZmF1bHQgdmFsdWVzIChlZyBcIlN1Ym1pdCBRdWVyeVwiKSB3aGVuIG5vIHZhbHVlIGlzXHJcbiAgICAvLyBwcm92aWRlZC5cclxuXHJcbiAgICBzd2l0Y2ggKHByb3BzLnR5cGUpIHtcclxuICAgICAgY2FzZSAnc3VibWl0JzpcclxuICAgICAgY2FzZSAncmVzZXQnOlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdjb2xvcic6XHJcbiAgICAgIGNhc2UgJ2RhdGUnOlxyXG4gICAgICBjYXNlICdkYXRldGltZSc6XHJcbiAgICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcclxuICAgICAgY2FzZSAnbW9udGgnOlxyXG4gICAgICBjYXNlICd0aW1lJzpcclxuICAgICAgY2FzZSAnd2Vlayc6XHJcbiAgICAgICAgLy8gVGhpcyBmaXhlcyB0aGUgbm8tc2hvdyBpc3N1ZSBvbiBpT1MgU2FmYXJpIGFuZCBBbmRyb2lkIENocm9tZTpcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcclxuICAgICAgICBub2RlLnZhbHVlID0gJyc7XHJcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLnZhbHVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXHJcbiAgICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxyXG4gICAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxyXG4gICAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcclxuICAgIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXHJcbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcclxuICAgIGlmIChuYW1lICE9PSAnJykge1xyXG4gICAgICBub2RlLm5hbWUgPSAnJztcclxuICAgIH1cclxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcclxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcclxuICAgIGlmIChuYW1lICE9PSAnJykge1xyXG4gICAgICBub2RlLm5hbWUgPSBuYW1lO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcclxuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcclxuXHJcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcclxuXHJcbiAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcclxuICAvLyBpcyBpbXBvcnRhbnQgd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcclxuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XHJcblxyXG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcclxuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcclxuICAgIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xyXG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xyXG5cclxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xyXG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXHJcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xyXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxyXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcclxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0sIGxldCdzIGp1c3QgdXNlIHRoZSBnbG9iYWxcclxuICAgIC8vIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZy5cclxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XHJcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxyXG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cclxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XHJcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXHJcbiAgICAgIHZhciBvdGhlckluc3RhbmNlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUob3RoZXJOb2RlKTtcclxuICAgICAgIW90aGVySW5zdGFuY2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiBfcHJvZEludmFyaWFudCgnOTAnKSA6IHZvaWQgMDtcclxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XHJcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXHJcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxyXG4gICAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgb3RoZXJJbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnB1dDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XHJcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcclxuXHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcclxudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUsIGRlYnVnSUQpIHtcclxuICBpZiAod2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XHJcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcclxuXHJcbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cclxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cclxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xyXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXHJcbiAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcclxuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKGRlYnVnSUQsIGVsZW1lbnQpIHtcclxuICB2YXIgaW52YWxpZFByb3BzID0gW107XHJcblxyXG4gIGZvciAodmFyIGtleSBpbiBlbGVtZW50LnByb3BzKSB7XHJcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkoZWxlbWVudC50eXBlLCBrZXksIGRlYnVnSUQpO1xyXG4gICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcclxuICB9KS5qb2luKCcsICcpO1xyXG5cclxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xyXG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcclxuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChlbGVtZW50LnR5cGUuaW5kZXhPZignLScpID49IDAgfHwgZWxlbWVudC5wcm9wcy5pcykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgd2FybkludmFsaWRBUklBUHJvcHMoZGVidWdJRCwgZWxlbWVudCk7XHJcbn1cclxuXHJcbnZhciBSZWFjdERPTUludmFsaWRBUklBSG9vayA9IHtcclxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcclxuICAgIH1cclxuICB9LFxyXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW52YWxpZEFSSUFIb29rOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcclxuXHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xyXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ2lucHV0JyAmJiBlbGVtZW50LnR5cGUgIT09ICd0ZXh0YXJlYScgJiYgZWxlbWVudC50eXBlICE9PSAnc2VsZWN0Jykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoZWxlbWVudC5wcm9wcyAhPSBudWxsICYmIGVsZW1lbnQucHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIHRoZSBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XHJcblxyXG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rID0ge1xyXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XHJcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xyXG4gIH0sXHJcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XHJcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XHJcblxyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcclxuXHJcbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xyXG4gIHZhciBjb250ZW50ID0gJyc7XHJcblxyXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xyXG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXHJcbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XHJcbiAgICB9IGVsc2UgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuKSB7XHJcbiAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSB0cnVlO1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdm9pZCAwO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gY29udGVudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxyXG4gKi9cclxudmFyIFJlYWN0RE9NT3B0aW9uID0ge1xyXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBob3N0UGFyZW50KSB7XHJcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKSA6IHZvaWQgMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMb29rIHVwIHdoZXRoZXIgdGhpcyBvcHRpb24gaXMgJ3NlbGVjdGVkJ1xyXG4gICAgdmFyIHNlbGVjdFZhbHVlID0gbnVsbDtcclxuICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcclxuICAgICAgdmFyIHNlbGVjdFBhcmVudCA9IGhvc3RQYXJlbnQ7XHJcblxyXG4gICAgICBpZiAoc2VsZWN0UGFyZW50Ll90YWcgPT09ICdvcHRncm91cCcpIHtcclxuICAgICAgICBzZWxlY3RQYXJlbnQgPSBzZWxlY3RQYXJlbnQuX2hvc3RQYXJlbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZWxlY3RQYXJlbnQgIT0gbnVsbCAmJiBzZWxlY3RQYXJlbnQuX3RhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICBzZWxlY3RWYWx1ZSA9IFJlYWN0RE9NU2VsZWN0LmdldFNlbGVjdFZhbHVlQ29udGV4dChzZWxlY3RQYXJlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIHZhbHVlIGlzIG51bGwgKGUuZy4sIG5vIHNwZWNpZmllZCB2YWx1ZSBvciBhZnRlciBpbml0aWFsIG1vdW50KVxyXG4gICAgLy8gb3IgbWlzc2luZyAoZS5nLiwgZm9yIDxkYXRhbGlzdD4pLCB3ZSBkb24ndCBjaGFuZ2UgcHJvcHMuc2VsZWN0ZWRcclxuICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XHJcbiAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICB2YXIgdmFsdWU7XHJcbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSArICcnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcclxuICAgICAgfVxyXG4gICAgICBzZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcclxuICAgICAgICAvLyBtdWx0aXBsZVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2ldID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0geyBzZWxlY3RlZDogc2VsZWN0ZWQgfTtcclxuICB9LFxyXG5cclxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgLy8gdmFsdWU9XCJcIiBzaG91bGQgbWFrZSBhIHZhbHVlIGF0dHJpYnV0ZSAoIzYyMTkpXHJcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcclxuICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XHJcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xyXG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBzZWxlY3RlZDogdW5kZWZpbmVkLCBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcclxuXHJcbiAgICAvLyBSZWFkIHN0YXRlIG9ubHkgZnJvbSBpbml0aWFsIG1vdW50IGJlY2F1c2UgPHNlbGVjdD4gdXBkYXRlcyB2YWx1ZVxyXG4gICAgLy8gbWFudWFsbHk7IHdlIG5lZWQgdGhlIGluaXRpYWwgc3RhdGUgb25seSBmb3Igc2VydmVyIHJlbmRlcmluZ1xyXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XHJcbiAgICAgIGhvc3RQcm9wcy5zZWxlY3RlZCA9IGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XHJcblxyXG4gICAgaWYgKGNvbnRlbnQpIHtcclxuICAgICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaG9zdFByb3BzO1xyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NT3B0aW9uOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xyXG5cclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xyXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCgpIHtcclxuICBpZiAodGhpcy5fcm9vdE5vZGVJRCAmJiB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSkge1xyXG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcclxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xyXG5cclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xyXG4gIGlmIChvd25lcikge1xyXG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XHJcblxyXG4vKipcclxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcykge1xyXG4gIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcclxuICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgb3duZXIpO1xyXG5cclxuICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgc2VsZWN0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xyXG4gICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcclxuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xyXG4gICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdm9pZCAwO1xyXG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gaW5zdFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGxlXHJcbiAqIEBwYXJhbSB7Kn0gcHJvcFZhbHVlIEEgc3RyaW5nYWJsZSAod2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5nYWJsZXMpLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhpbnN0LCBtdWx0aXBsZSwgcHJvcFZhbHVlKSB7XHJcbiAgdmFyIHNlbGVjdGVkVmFsdWUsIGk7XHJcbiAgdmFyIG9wdGlvbnMgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KS5vcHRpb25zO1xyXG5cclxuICBpZiAobXVsdGlwbGUpIHtcclxuICAgIHNlbGVjdGVkVmFsdWUgPSB7fTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJyArIHByb3BWYWx1ZVtpXV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zW2ldLnZhbHVlKTtcclxuICAgICAgaWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XHJcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXHJcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxyXG4gICAgc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKG9wdGlvbnNbaV0udmFsdWUgPT09IHNlbGVjdGVkVmFsdWUpIHtcclxuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmxlbmd0aCkge1xyXG4gICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxyXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXHJcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cclxuICpcclxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxyXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXHJcbiAqXHJcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcclxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxyXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxyXG4gKlxyXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcclxuICogc2VsZWN0ZWQuXHJcbiAqL1xyXG52YXIgUmVhY3RET01TZWxlY3QgPSB7XHJcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcclxuICAgIHJldHVybiBfYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlLFxyXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xyXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xyXG4gICAgICBwZW5kaW5nVXBkYXRlOiBmYWxzZSxcclxuICAgICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXHJcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcclxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KSxcclxuICAgICAgd2FzTXVsdGlwbGU6IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xyXG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdldFNlbGVjdFZhbHVlQ29udGV4dDogZnVuY3Rpb24gKGluc3QpIHtcclxuICAgIC8vIFJlYWN0RE9NT3B0aW9uIGxvb2tzIGF0IHRoaXMgaW5pdGlhbCB2YWx1ZSBzbyB0aGUgaW5pdGlhbCBnZW5lcmF0ZWRcclxuICAgIC8vIG1hcmt1cCBoYXMgY29ycmVjdCBgc2VsZWN0ZWRgIGF0dHJpYnV0ZXNcclxuICAgIHJldHVybiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xyXG4gIH0sXHJcblxyXG4gIHBvc3RVcGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XHJcblxyXG4gICAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXHJcbiAgICAvLyB0aGlzIHZhbHVlIGRvd25cclxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgdmFyIHdhc011bHRpcGxlID0gaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xyXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSk7XHJcblxyXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XHJcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSBCb29sZWFuKHByb3BzLm11bHRpcGxlKSkge1xyXG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXHJcbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLmRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxyXG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLm11bHRpcGxlID8gW10gOiAnJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XHJcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XHJcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcclxuXHJcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcclxuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gdHJ1ZTtcclxuICB9XHJcbiAgUmVhY3RVcGRhdGVzLmFzYXAodXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQsIHRoaXMpO1xyXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xyXG5cclxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKCcuL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQnKTtcclxudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcclxuXHJcbi8qKlxyXG4gKiBXaGlsZSBgaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBvbiB0aGUgU2VsZWN0aW9uIG9iamVjdCBhbmQgYGNvbGxhcHNlZGBcclxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cclxuICogSWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhbmQgb2Zmc2V0cyBhcmUgdGhlIHNhbWUsIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcclxuICByZXR1cm4gYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGFwcHJvcHJpYXRlIGFuY2hvciBhbmQgZm9jdXMgbm9kZS9vZmZzZXQgcGFpcnMgZm9yIElFLlxyXG4gKlxyXG4gKiBUaGUgY2F0Y2ggaGVyZSBpcyB0aGF0IElFJ3Mgc2VsZWN0aW9uIEFQSSBkb2Vzbid0IHByb3ZpZGUgaW5mb3JtYXRpb25cclxuICogYWJvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGZvcndhcmQgb3IgYmFja3dhcmQsIHNvIHdlIGhhdmUgdG9cclxuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxyXG4gKlxyXG4gKiBJRSB0ZXh0IGRpZmZlcnMgZnJvbSBtb2Rlcm4gc2VsZWN0aW9uIGluIHRoYXQgaXQgYmVoYXZlcyBhcyB0aG91Z2hcclxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXHJcbiAqIGRpZmZlciBiZXR3ZWVuIHRoZSB0d28gQVBJcy5cclxuICpcclxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXHJcbiAqIEByZXR1cm4ge29iamVjdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XHJcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbjtcclxuICB2YXIgc2VsZWN0ZWRSYW5nZSA9IHNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xyXG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XHJcblxyXG4gIC8vIER1cGxpY2F0ZSBzZWxlY3Rpb24gc28gd2UgY2FuIG1vdmUgcmFuZ2Ugd2l0aG91dCBicmVha2luZyB1c2VyIHNlbGVjdGlvbi5cclxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcclxuICBmcm9tU3RhcnQubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XHJcbiAgZnJvbVN0YXJ0LnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0Jywgc2VsZWN0ZWRSYW5nZSk7XHJcblxyXG4gIHZhciBzdGFydE9mZnNldCA9IGZyb21TdGFydC50ZXh0Lmxlbmd0aDtcclxuICB2YXIgZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBzZWxlY3RlZExlbmd0aDtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXJ0OiBzdGFydE9mZnNldCxcclxuICAgIGVuZDogZW5kT2Zmc2V0XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxyXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0cyhub2RlKSB7XHJcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xyXG5cclxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xyXG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xyXG4gIHZhciBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xyXG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcclxuXHJcbiAgdmFyIGN1cnJlbnRSYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xyXG5cclxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xyXG4gIC8vIGRpdnNcIiwgZS5nLiB0aGUgdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXNcclxuICAvLyBkaXZzIGRvIG5vdCBzZWVtIHRvIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZFxyXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXHJcbiAgLy8gd2F5IHRvIGF2b2lkIGVycm9yaW5nIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvclxyXG4gIC8vIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmQgY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXHJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XHJcbiAgdHJ5IHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xyXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xyXG4gICAgY3VycmVudFJhbmdlLmVuZENvbnRhaW5lci5ub2RlVHlwZTtcclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBJZiB0aGUgbm9kZSBhbmQgb2Zmc2V0IHZhbHVlcyBhcmUgdGhlIHNhbWUsIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkLlxyXG4gIC8vIGBTZWxlY3Rpb24uaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBuYXRpdmVseSwgYnV0IElFIHNvbWV0aW1lcyBnZXRzXHJcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cclxuICB2YXIgaXNTZWxlY3Rpb25Db2xsYXBzZWQgPSBpc0NvbGxhcHNlZChzZWxlY3Rpb24uYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCwgc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KTtcclxuXHJcbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xyXG5cclxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcclxuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xyXG4gIHRlbXBSYW5nZS5zZXRFbmQoY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLCBjdXJyZW50UmFuZ2Uuc3RhcnRPZmZzZXQpO1xyXG5cclxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XHJcblxyXG4gIHZhciBzdGFydCA9IGlzVGVtcFJhbmdlQ29sbGFwc2VkID8gMCA6IHRlbXBSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcclxuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcclxuXHJcbiAgLy8gRGV0ZWN0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZC5cclxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xyXG4gIGRldGVjdGlvblJhbmdlLnNldFN0YXJ0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XHJcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xyXG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcclxuICAgIGVuZDogaXNCYWNrd2FyZCA/IHN0YXJ0IDogZW5kXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcclxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5kdXBsaWNhdGUoKTtcclxuICB2YXIgc3RhcnQsIGVuZDtcclxuXHJcbiAgaWYgKG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQpIHtcclxuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcclxuICAgIGVuZCA9IHN0YXJ0O1xyXG4gIH0gZWxzZSBpZiAob2Zmc2V0cy5zdGFydCA+IG9mZnNldHMuZW5kKSB7XHJcbiAgICBzdGFydCA9IG9mZnNldHMuZW5kO1xyXG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xyXG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XHJcbiAgfVxyXG5cclxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcclxuICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcclxuICByYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJhbmdlKTtcclxuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XHJcbiAgcmFuZ2Uuc2VsZWN0KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXHJcbiAqIHNlbGVjdGlvbnMuXHJcbiAqXHJcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxyXG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxyXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxyXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRNb2Rlcm5PZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcclxuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XHJcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcclxuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XHJcblxyXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cclxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cclxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcclxuICAgIHZhciB0ZW1wID0gZW5kO1xyXG4gICAgZW5kID0gc3RhcnQ7XHJcbiAgICBzdGFydCA9IHRlbXA7XHJcbiAgfVxyXG5cclxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcclxuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xyXG5cclxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XHJcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xyXG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcclxuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcclxuXHJcbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcclxuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcclxuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xyXG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIHVzZUlFT2Zmc2V0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnc2VsZWN0aW9uJyBpbiBkb2N1bWVudCAmJiAhKCdnZXRTZWxlY3Rpb24nIGluIHdpbmRvdyk7XHJcblxyXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXHJcbiAgICovXHJcbiAgZ2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gZ2V0SUVPZmZzZXRzIDogZ2V0TW9kZXJuT2Zmc2V0cyxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcclxuICAgKi9cclxuICBzZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBzZXRJRU9mZnNldHMgOiBzZXRNb2Rlcm5PZmZzZXRzXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0aW9uOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXHJcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XHJcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcblxyXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcclxuXHJcbi8qKlxyXG4gKiBUZXh0IG5vZGVzIHZpb2xhdGUgYSBjb3VwbGUgYXNzdW1wdGlvbnMgdGhhdCBSZWFjdCBtYWtlcyBhYm91dCBjb21wb25lbnRzOlxyXG4gKlxyXG4gKiAgLSBXaGVuIG1vdW50aW5nIHRleHQgaW50byB0aGUgRE9NLCBhZGphY2VudCB0ZXh0IG5vZGVzIGFyZSBtZXJnZWQuXHJcbiAqICAtIFRleHQgbm9kZXMgY2Fubm90IGJlIGFzc2lnbmVkIGEgUmVhY3Qgcm9vdCBJRC5cclxuICpcclxuICogVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byB3cmFwIHN0cmluZ3MgYmV0d2VlbiBjb21tZW50IG5vZGVzIHNvIHRoYXQgdGhleVxyXG4gKiBjYW4gdW5kZXJnbyB0aGUgc2FtZSByZWNvbmNpbGlhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gZWxlbWVudHMuXHJcbiAqXHJcbiAqIFRPRE86IEludmVzdGlnYXRlIHJlcHJlc2VudGluZyBSZWFjdCBjb21wb25lbnRzIGluIHRoZSBET00gd2l0aCB0ZXh0IG5vZGVzLlxyXG4gKlxyXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XHJcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgLy8gVE9ETzogVGhpcyBpcyByZWFsbHkgYSBSZWFjdFRleHQgKFJlYWN0Tm9kZSksIG5vdCBhIFJlYWN0RWxlbWVudFxyXG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gdGV4dDtcclxuICB0aGlzLl9zdHJpbmdUZXh0ID0gJycgKyB0ZXh0O1xyXG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxyXG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcclxuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcclxuXHJcbiAgLy8gUHJvcGVydGllc1xyXG4gIHRoaXMuX2RvbUlEID0gMDtcclxuICB0aGlzLl9tb3VudEluZGV4ID0gMDtcclxuICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XHJcbiAgdGhpcy5fY29tbWVudE5vZGVzID0gbnVsbDtcclxufTtcclxuXHJcbl9hc3NpZ24oUmVhY3RET01UZXh0Q29tcG9uZW50LnByb3RvdHlwZSwge1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIHRoZSBtYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLiBUaGlzIG5vZGUgaXMgbm90IGludGVuZGVkIHRvIGhhdmVcclxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFyIHBhcmVudEluZm87XHJcbiAgICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcclxuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xyXG4gICAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvICE9IG51bGwpIHtcclxuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdENvbnRhaW5lckluZm8uX2FuY2VzdG9ySW5mbztcclxuICAgICAgfVxyXG4gICAgICBpZiAocGFyZW50SW5mbykge1xyXG4gICAgICAgIC8vIHBhcmVudEluZm8gc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IGV4Y2VwdCBmb3IgdGhlIHRvcC1sZXZlbFxyXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcclxuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgdGhpcy5fc3RyaW5nVGV4dCwgdGhpcywgcGFyZW50SW5mbyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XHJcbiAgICB2YXIgb3BlbmluZ1ZhbHVlID0gJyByZWFjdC10ZXh0OiAnICsgZG9tSUQgKyAnICc7XHJcbiAgICB2YXIgY2xvc2luZ1ZhbHVlID0gJyAvcmVhY3QtdGV4dCAnO1xyXG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcclxuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xyXG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcclxuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcclxuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KG9wZW5pbmdWYWx1ZSk7XHJcbiAgICAgIHZhciBjbG9zaW5nQ29tbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChjbG9zaW5nVmFsdWUpO1xyXG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XHJcbiAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKG9wZW5pbmdDb21tZW50KSk7XHJcbiAgICAgIGlmICh0aGlzLl9zdHJpbmdUZXh0KSB7XHJcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLl9zdHJpbmdUZXh0KSkpO1xyXG4gICAgICB9XHJcbiAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKGNsb3NpbmdDb21tZW50KSk7XHJcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgb3BlbmluZ0NvbW1lbnQpO1xyXG4gICAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IGNsb3NpbmdDb21tZW50O1xyXG4gICAgICByZXR1cm4gbGF6eVRyZWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGhpcy5fc3RyaW5nVGV4dCk7XHJcblxyXG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcclxuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgZm9yIHRoZSByZWFzb25zIHN0YXRlZFxyXG4gICAgICAgIC8vIGFib3ZlLCBidXQgc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvbiB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXJcclxuICAgICAgICAvLyAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXHJcbiAgICAgICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gJzwhLS0nICsgb3BlbmluZ1ZhbHVlICsgJy0tPicgKyBlc2NhcGVkVGV4dCArICc8IS0tJyArIGNsb3NpbmdWYWx1ZSArICctLT4nO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RUZXh0fSBuZXh0VGV4dCBUaGUgbmV4dCB0ZXh0IGNvbnRlbnRcclxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRUZXh0LCB0cmFuc2FjdGlvbikge1xyXG4gICAgaWYgKG5leHRUZXh0ICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xyXG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRUZXh0O1xyXG4gICAgICB2YXIgbmV4dFN0cmluZ1RleHQgPSAnJyArIG5leHRUZXh0O1xyXG4gICAgICBpZiAobmV4dFN0cmluZ1RleHQgIT09IHRoaXMuX3N0cmluZ1RleHQpIHtcclxuICAgICAgICAvLyBUT0RPOiBTYXZlIHRoaXMgYXMgcGVuZGluZyBwcm9wcyBhbmQgdXNlIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeVxyXG4gICAgICAgIC8vIGFuZC9vciB1cGRhdGVDb21wb25lbnQgdG8gZG8gdGhlIGFjdHVhbCB1cGRhdGUgZm9yIGNvbnNpc3RlbmN5IHdpdGhcclxuICAgICAgICAvLyBvdGhlciBjb21wb25lbnQgdHlwZXM/XHJcbiAgICAgICAgdGhpcy5fc3RyaW5nVGV4dCA9IG5leHRTdHJpbmdUZXh0O1xyXG4gICAgICAgIHZhciBjb21tZW50Tm9kZXMgPSB0aGlzLmdldEhvc3ROb2RlKCk7XHJcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnJlcGxhY2VEZWxpbWl0ZWRUZXh0KGNvbW1lbnROb2Rlc1swXSwgY29tbWVudE5vZGVzWzFdLCBuZXh0U3RyaW5nVGV4dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGhvc3ROb2RlID0gdGhpcy5fY29tbWVudE5vZGVzO1xyXG4gICAgaWYgKGhvc3ROb2RlKSB7XHJcbiAgICAgIHJldHVybiBob3N0Tm9kZTtcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5fY2xvc2luZ0NvbW1lbnQpIHtcclxuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XHJcbiAgICAgIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQubmV4dFNpYmxpbmc7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgIShub2RlICE9IG51bGwpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc3NpbmcgY2xvc2luZyBjb21tZW50IGZvciB0ZXh0IGNvbXBvbmVudCAlcycsIHRoaXMuX2RvbUlEKSA6IF9wcm9kSW52YXJpYW50KCc2NycsIHRoaXMuX2RvbUlEKSA6IHZvaWQgMDtcclxuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyAvcmVhY3QtdGV4dCAnKSB7XHJcbiAgICAgICAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG5vZGU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGhvc3ROb2RlID0gW3RoaXMuX2hvc3ROb2RlLCB0aGlzLl9jbG9zaW5nQ29tbWVudF07XHJcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBob3N0Tm9kZTtcclxuICAgIHJldHVybiBob3N0Tm9kZTtcclxuICB9LFxyXG5cclxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XHJcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xyXG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRDb21wb25lbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcclxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcclxudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcclxuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xyXG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcclxuICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxyXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xyXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcclxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXHJcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cclxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXHJcbiAqXHJcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcclxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXHJcbiAqL1xyXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHtcclxuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xyXG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MScpIDogdm9pZCAwO1xyXG5cclxuICAgIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXHJcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcclxuICAgIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXHJcbiAgICAvLyBjb21wbGV0ZWx5IHNvbHZlIHRoaXMgSUU5IGJ1ZyksIGJ1dCBTZWJhc3RpYW4rQmVuIHNlZW1lZCB0byBsaWtlIHRoaXMgc29sdXRpb24uXHJcbiAgICAvLyBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cclxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xyXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgY2hpbGRyZW46ICcnICsgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcclxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcclxuICB9LFxyXG5cclxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcclxuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGB0ZXh0YXJlYWAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcclxuICAgICAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKSA6IHZvaWQgMDtcclxuICAgICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcclxuICAgIHZhciBpbml0aWFsVmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cclxuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XHJcbiAgICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJykgOiB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MicpIDogdm9pZCAwO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgIShjaGlsZHJlbi5sZW5ndGggPD0gMSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzkzJykgOiB2b2lkIDA7XHJcbiAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcclxuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJztcclxuICAgICAgfVxyXG4gICAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xyXG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgaW5pdGlhbFZhbHVlLFxyXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXHJcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcclxuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xyXG5cclxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XHJcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXHJcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cclxuICAgICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcclxuXHJcbiAgICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXHJcbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xyXG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwpIHtcclxuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcclxuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcclxuICAgIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxyXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcclxuICAgIHZhciB0ZXh0Q29udGVudCA9IG5vZGUudGV4dENvbnRlbnQ7XHJcblxyXG4gICAgLy8gT25seSBzZXQgbm9kZS52YWx1ZSBpZiB0ZXh0Q29udGVudCBpcyBlcXVhbCB0byB0aGUgZXhwZWN0ZWRcclxuICAgIC8vIGluaXRpYWwgdmFsdWUuIEluIElFMTAvSUUxMSB0aGVyZSBpcyBhIGJ1ZyB3aGVyZSB0aGUgcGxhY2Vob2xkZXIgYXR0cmlidXRlXHJcbiAgICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDE1MjUvXHJcbiAgICBpZiAodGV4dENvbnRlbnQgPT09IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpIHtcclxuICAgICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcclxuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcclxuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xyXG4gIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcclxuICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0YXJlYTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXHJcbiAqIGRpZmZlcmVudCB0cmVlcy5cclxuICovXHJcbmZ1bmN0aW9uIGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xyXG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcclxuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XHJcblxyXG4gIHZhciBkZXB0aEEgPSAwO1xyXG4gIGZvciAodmFyIHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IHRlbXBBLl9ob3N0UGFyZW50KSB7XHJcbiAgICBkZXB0aEErKztcclxuICB9XHJcbiAgdmFyIGRlcHRoQiA9IDA7XHJcbiAgZm9yICh2YXIgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gdGVtcEIuX2hvc3RQYXJlbnQpIHtcclxuICAgIGRlcHRoQisrO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxyXG4gIHdoaWxlIChkZXB0aEEgLSBkZXB0aEIgPiAwKSB7XHJcbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xyXG4gICAgZGVwdGhBLS07XHJcbiAgfVxyXG5cclxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXHJcbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcclxuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XHJcbiAgICBkZXB0aEItLTtcclxuICB9XHJcblxyXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxyXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcclxuICB3aGlsZSAoZGVwdGgtLSkge1xyXG4gICAgaWYgKGluc3RBID09PSBpbnN0Qikge1xyXG4gICAgICByZXR1cm4gaW5zdEE7XHJcbiAgICB9XHJcbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xyXG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNBbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcclxuICAhKCdfaG9zdE5vZGUnIGluIGluc3RBKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XHJcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xyXG5cclxuICB3aGlsZSAoaW5zdEIpIHtcclxuICAgIGlmIChpbnN0QiA9PT0gaW5zdEEpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpbnN0QiA9IGluc3RCLl9ob3N0UGFyZW50O1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCkge1xyXG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0UGFyZW50SW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzYnKSA6IHZvaWQgMDtcclxuXHJcbiAgcmV0dXJuIGluc3QuX2hvc3RQYXJlbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcclxuICB2YXIgcGF0aCA9IFtdO1xyXG4gIHdoaWxlIChpbnN0KSB7XHJcbiAgICBwYXRoLnB1c2goaW5zdCk7XHJcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcclxuICB9XHJcbiAgdmFyIGk7XHJcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XHJcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xyXG4gIH1cclxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxyXG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXHJcbiAqXHJcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xyXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xyXG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcclxuICB2YXIgcGF0aEZyb20gPSBbXTtcclxuICB3aGlsZSAoZnJvbSAmJiBmcm9tICE9PSBjb21tb24pIHtcclxuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XHJcbiAgICBmcm9tID0gZnJvbS5faG9zdFBhcmVudDtcclxuICB9XHJcbiAgdmFyIHBhdGhUbyA9IFtdO1xyXG4gIHdoaWxlICh0byAmJiB0byAhPT0gY29tbW9uKSB7XHJcbiAgICBwYXRoVG8ucHVzaCh0byk7XHJcbiAgICB0byA9IHRvLl9ob3N0UGFyZW50O1xyXG4gIH1cclxuICB2YXIgaTtcclxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcclxuICAgIGZuKHBhdGhGcm9tW2ldLCAnYnViYmxlZCcsIGFyZ0Zyb20pO1xyXG4gIH1cclxuICBmb3IgKGkgPSBwYXRoVG8ubGVuZ3RoOyBpLS0gPiAwOykge1xyXG4gICAgZm4ocGF0aFRvW2ldLCAnY2FwdHVyZWQnLCBhcmdUbyk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBpc0FuY2VzdG9yOiBpc0FuY2VzdG9yLFxyXG4gIGdldExvd2VzdENvbW1vbkFuY2VzdG9yOiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcixcclxuICBnZXRQYXJlbnRJbnN0YW5jZTogZ2V0UGFyZW50SW5zdGFuY2UsXHJcbiAgdHJhdmVyc2VUd29QaGFzZTogdHJhdmVyc2VUd29QaGFzZSxcclxuICB0cmF2ZXJzZUVudGVyTGVhdmU6IHRyYXZlcnNlRW50ZXJMZWF2ZVxyXG59OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcclxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcclxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xyXG5cclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhciByZWFjdFByb3BzID0ge1xyXG4gICAgY2hpbGRyZW46IHRydWUsXHJcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcclxuICAgIGtleTogdHJ1ZSxcclxuICAgIHJlZjogdHJ1ZSxcclxuXHJcbiAgICBhdXRvRm9jdXM6IHRydWUsXHJcbiAgICBkZWZhdWx0VmFsdWU6IHRydWUsXHJcbiAgICB2YWx1ZUxpbms6IHRydWUsXHJcbiAgICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcclxuICAgIGNoZWNrZWRMaW5rOiB0cnVlLFxyXG4gICAgaW5uZXJIVE1MOiB0cnVlLFxyXG4gICAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiB0cnVlLFxyXG4gICAgb25Gb2N1c0luOiB0cnVlLFxyXG4gICAgb25Gb2N1c091dDogdHJ1ZVxyXG4gIH07XHJcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcclxuXHJcbiAgdmFyIHZhbGlkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgZGVidWdJRCkge1xyXG4gICAgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAocmVhY3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiByZWFjdFByb3BzW25hbWVdIHx8IHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XHJcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cclxuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XHJcblxyXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XHJcblxyXG4gICAgaWYgKHN0YW5kYXJkTmFtZSAhPSBudWxsKSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBET00gcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ3Vlc3Mgd2hpY2ggcHJvcCB0aGUgdXNlciBpbnRlbmRlZC5cclxuICAgICAgLy8gSXQgaXMgbGlrZWx5IHRoYXQgdGhlIHVzZXIgd2FzIGp1c3QgYmxpbmRseSBzcHJlYWRpbmcvZm9yd2FyZGluZyBwcm9wc1xyXG4gICAgICAvLyBDb21wb25lbnRzIHNob3VsZCBiZSBjYXJlZnVsIHRvIG9ubHkgcmVuZGVyIHZhbGlkIHByb3BzL2F0dHJpYnV0ZXMuXHJcbiAgICAgIC8vIFdhcm5pbmcgd2lsbCBiZSBpbnZva2VkIGluIHdhcm5Vbmtub3duUHJvcGVydGllcyB0byBhbGxvdyBncm91cGluZy5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xyXG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcclxuICBmb3IgKHZhciBrZXkgaW4gZWxlbWVudC5wcm9wcykge1xyXG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KGVsZW1lbnQudHlwZSwga2V5LCBkZWJ1Z0lEKTtcclxuICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XHJcbiAgfSkuam9pbignLCAnKTtcclxuXHJcbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBwcm9wICVzIG9uIDwlcz4gdGFnLiBSZW1vdmUgdGhpcyBwcm9wIGZyb20gdGhlIGVsZW1lbnQuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXVua25vd24tcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XHJcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3BzICVzIG9uIDwlcz4gdGFnLiBSZW1vdmUgdGhlc2UgcHJvcHMgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcclxuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChlbGVtZW50LnR5cGUuaW5kZXhPZignLScpID49IDAgfHwgZWxlbWVudC5wcm9wcy5pcykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB3YXJuVW5rbm93blByb3BlcnRpZXMoZGVidWdJRCwgZWxlbWVudCk7XHJcbn1cclxuXHJcbnZhciBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2sgPSB7XHJcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcclxuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XHJcbiAgfSxcclxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcclxuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2s7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0gcmVxdWlyZSgnLi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rJyk7XHJcbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2snKTtcclxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xyXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xyXG5cclxudmFyIHBlcmZvcm1hbmNlTm93ID0gcmVxdWlyZSgnZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cnKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG52YXIgaG9va3MgPSBbXTtcclxudmFyIGRpZEhvb2tUaHJvd0ZvckV2ZW50ID0ge307XHJcblxyXG5mdW5jdGlvbiBjYWxsSG9vayhldmVudCwgZm4sIGNvbnRleHQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcclxuICB0cnkge1xyXG4gICAgZm4uY2FsbChjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRIb29rVGhyb3dGb3JFdmVudFtldmVudF0sICdFeGNlcHRpb24gdGhyb3duIGJ5IGhvb2sgd2hpbGUgaGFuZGxpbmcgJXM6ICVzJywgZXZlbnQsIGUgKyAnXFxuJyArIGUuc3RhY2spIDogdm9pZCAwO1xyXG4gICAgZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVtaXRFdmVudChldmVudCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBob29rID0gaG9va3NbaV07XHJcbiAgICB2YXIgZm4gPSBob29rW2V2ZW50XTtcclxuICAgIGlmIChmbikge1xyXG4gICAgICBjYWxsSG9vayhldmVudCwgZm4sIGhvb2ssIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxudmFyIGlzUHJvZmlsaW5nID0gZmFsc2U7XHJcbnZhciBmbHVzaEhpc3RvcnkgPSBbXTtcclxudmFyIGxpZmVDeWNsZVRpbWVyU3RhY2sgPSBbXTtcclxudmFyIGN1cnJlbnRGbHVzaE5lc3RpbmcgPSAwO1xyXG52YXIgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XHJcbnZhciBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSAwO1xyXG52YXIgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XHJcbnZhciBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xyXG52YXIgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XHJcbnZhciBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcclxuXHJcbnZhciBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IGZhbHNlO1xyXG5cclxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KCkge1xyXG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sucHVyZ2VVbm1vdW50ZWRDb21wb25lbnRzKCk7XHJcbiAgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suY2xlYXJIaXN0b3J5KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKSB7XHJcbiAgcmV0dXJuIHJlZ2lzdGVyZWRJRHMucmVkdWNlKGZ1bmN0aW9uICh0cmVlLCBpZCkge1xyXG4gICAgdmFyIG93bmVySUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQoaWQpO1xyXG4gICAgdmFyIHBhcmVudElEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XHJcbiAgICB0cmVlW2lkXSA9IHtcclxuICAgICAgZGlzcGxheU5hbWU6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoaWQpLFxyXG4gICAgICB0ZXh0OiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFRleHQoaWQpLFxyXG4gICAgICB1cGRhdGVDb3VudDogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRVcGRhdGVDb3VudChpZCksXHJcbiAgICAgIGNoaWxkSURzOiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldENoaWxkSURzKGlkKSxcclxuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIG93bmVycyBidXQgdGhpcyBpcyBjbG9zZSBlbm91Z2guXHJcbiAgICAgIG93bmVySUQ6IG93bmVySUQgfHwgcGFyZW50SUQgJiYgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKHBhcmVudElEKSB8fCAwLFxyXG4gICAgICBwYXJlbnRJRDogcGFyZW50SURcclxuICAgIH07XHJcbiAgICByZXR1cm4gdHJlZTtcclxuICB9LCB7fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlc2V0TWVhc3VyZW1lbnRzKCkge1xyXG4gIHZhciBwcmV2aW91c1N0YXJ0VGltZSA9IGN1cnJlbnRGbHVzaFN0YXJ0VGltZTtcclxuICB2YXIgcHJldmlvdXNNZWFzdXJlbWVudHMgPSBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHM7XHJcbiAgdmFyIHByZXZpb3VzT3BlcmF0aW9ucyA9IFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmdldEhpc3RvcnkoKTtcclxuXHJcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcclxuICAgIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IDA7XHJcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBbXTtcclxuICAgIGNsZWFySGlzdG9yeSgpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKHByZXZpb3VzTWVhc3VyZW1lbnRzLmxlbmd0aCB8fCBwcmV2aW91c09wZXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICB2YXIgcmVnaXN0ZXJlZElEcyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UmVnaXN0ZXJlZElEcygpO1xyXG4gICAgZmx1c2hIaXN0b3J5LnB1c2goe1xyXG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIHByZXZpb3VzU3RhcnRUaW1lLFxyXG4gICAgICBtZWFzdXJlbWVudHM6IHByZXZpb3VzTWVhc3VyZW1lbnRzIHx8IFtdLFxyXG4gICAgICBvcGVyYXRpb25zOiBwcmV2aW91c09wZXJhdGlvbnMgfHwgW10sXHJcbiAgICAgIHRyZWVTbmFwc2hvdDogZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGNsZWFySGlzdG9yeSgpO1xyXG4gIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XHJcbiAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVidWdJRChkZWJ1Z0lEKSB7XHJcbiAgdmFyIGFsbG93Um9vdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XHJcblxyXG4gIGlmIChhbGxvd1Jvb3QgJiYgZGVidWdJRCA9PT0gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoIWRlYnVnSUQpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3REZWJ1Z1Rvb2w6IGRlYnVnSUQgbWF5IG5vdCBiZSBlbXB0eS4nKSA6IHZvaWQgMDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XHJcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgJiYgIWxpZmVDeWNsZVRpbWVySGFzV2FybmVkKSB7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ0RpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0YXJ0IHdoaWxlICVzIHRpbWVyIGlzIHN0aWxsIGluICcgKyAncHJvZ3Jlc3MgZm9yICVzIGluc3RhbmNlLicsIHRpbWVyVHlwZSwgY3VycmVudFRpbWVyVHlwZSB8fCAnbm8nLCBkZWJ1Z0lEID09PSBjdXJyZW50VGltZXJEZWJ1Z0lEID8gJ3RoZSBzYW1lJyA6ICdhbm90aGVyJykgOiB2b2lkIDA7XHJcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XHJcbiAgfVxyXG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XHJcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XHJcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IGRlYnVnSUQ7XHJcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XHJcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgIT09IHRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnV2UgZGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RvcCB3aGlsZSAlcyB0aW1lciBpcyBzdGlsbCBpbiAnICsgJ3Byb2dyZXNzIGZvciAlcyBpbnN0YW5jZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgYnVnIGluIFJlYWN0LicsIHRpbWVyVHlwZSwgY3VycmVudFRpbWVyVHlwZSB8fCAnbm8nLCBkZWJ1Z0lEID09PSBjdXJyZW50VGltZXJEZWJ1Z0lEID8gJ3RoZSBzYW1lJyA6ICdhbm90aGVyJykgOiB2b2lkIDA7XHJcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XHJcbiAgfVxyXG4gIGlmIChpc1Byb2ZpbGluZykge1xyXG4gICAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzLnB1c2goe1xyXG4gICAgICB0aW1lclR5cGU6IHRpbWVyVHlwZSxcclxuICAgICAgaW5zdGFuY2VJRDogZGVidWdJRCxcclxuICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBjdXJyZW50VGltZXJTdGFydFRpbWUgLSBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uXHJcbiAgICB9KTtcclxuICB9XHJcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcclxuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcclxuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcclxuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gcGF1c2VDdXJyZW50TGlmZUN5Y2xlVGltZXIoKSB7XHJcbiAgdmFyIGN1cnJlbnRUaW1lciA9IHtcclxuICAgIHN0YXJ0VGltZTogY3VycmVudFRpbWVyU3RhcnRUaW1lLFxyXG4gICAgbmVzdGVkRmx1c2hTdGFydFRpbWU6IHBlcmZvcm1hbmNlTm93KCksXHJcbiAgICBkZWJ1Z0lEOiBjdXJyZW50VGltZXJEZWJ1Z0lELFxyXG4gICAgdGltZXJUeXBlOiBjdXJyZW50VGltZXJUeXBlXHJcbiAgfTtcclxuICBsaWZlQ3ljbGVUaW1lclN0YWNrLnB1c2goY3VycmVudFRpbWVyKTtcclxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xyXG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xyXG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xyXG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIoKSB7XHJcbiAgdmFyIF9saWZlQ3ljbGVUaW1lclN0YWNrJCA9IGxpZmVDeWNsZVRpbWVyU3RhY2sucG9wKCksXHJcbiAgICAgIHN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5zdGFydFRpbWUsXHJcbiAgICAgIG5lc3RlZEZsdXNoU3RhcnRUaW1lID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLm5lc3RlZEZsdXNoU3RhcnRUaW1lLFxyXG4gICAgICBkZWJ1Z0lEID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLmRlYnVnSUQsXHJcbiAgICAgIHRpbWVyVHlwZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC50aW1lclR5cGU7XHJcblxyXG4gIHZhciBuZXN0ZWRGbHVzaER1cmF0aW9uID0gcGVyZm9ybWFuY2VOb3coKSAtIG5lc3RlZEZsdXNoU3RhcnRUaW1lO1xyXG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcclxuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uICs9IG5lc3RlZEZsdXNoRHVyYXRpb247XHJcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IGRlYnVnSUQ7XHJcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcclxufVxyXG5cclxudmFyIGxhc3RNYXJrVGltZVN0YW1wID0gMDtcclxudmFyIGNhblVzZVBlcmZvcm1hbmNlTWVhc3VyZSA9XHJcbi8vICRGbG93Rml4TWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzIzNDVcclxudHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyA9PT0gJ2Z1bmN0aW9uJztcclxuXHJcbmZ1bmN0aW9uIHNob3VsZE1hcmsoZGVidWdJRCkge1xyXG4gIGlmICghaXNQcm9maWxpbmcgfHwgIWNhblVzZVBlcmZvcm1hbmNlTWVhc3VyZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChkZWJ1Z0lEKTtcclxuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50ICE9PSAnb2JqZWN0Jykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICB2YXIgaXNIb3N0RWxlbWVudCA9IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnO1xyXG4gIGlmIChpc0hvc3RFbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXJrQmVnaW4oZGVidWdJRCwgbWFya1R5cGUpIHtcclxuICBpZiAoIXNob3VsZE1hcmsoZGVidWdJRCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBtYXJrTmFtZSA9IGRlYnVnSUQgKyAnOjonICsgbWFya1R5cGU7XHJcbiAgbGFzdE1hcmtUaW1lU3RhbXAgPSBwZXJmb3JtYW5jZU5vdygpO1xyXG4gIHBlcmZvcm1hbmNlLm1hcmsobWFya05hbWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXJrRW5kKGRlYnVnSUQsIG1hcmtUeXBlKSB7XHJcbiAgaWYgKCFzaG91bGRNYXJrKGRlYnVnSUQpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgbWFya05hbWUgPSBkZWJ1Z0lEICsgJzo6JyArIG1hcmtUeXBlO1xyXG4gIHZhciBkaXNwbGF5TmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoZGVidWdJRCkgfHwgJ1Vua25vd24nO1xyXG5cclxuICAvLyBDaHJvbWUgaGFzIGFuIGlzc3VlIG9mIGRyb3BwaW5nIG1hcmtlcnMgcmVjb3JkZWQgdG9vIGZhc3Q6XHJcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjQwNjUyXHJcbiAgLy8gVG8gd29yayBhcm91bmQgdGhpcywgd2Ugd2lsbCBub3QgcmVwb3J0IHZlcnkgc21hbGwgbWVhc3VyZW1lbnRzLlxyXG4gIC8vIEkgZGV0ZXJtaW5lZCB0aGUgbWFnaWMgbnVtYmVyIGJ5IHR3ZWFraW5nIGl0IGJhY2sgYW5kIGZvcnRoLlxyXG4gIC8vIDAuMDVtcyB3YXMgZW5vdWdoIHRvIHByZXZlbnQgdGhlIGlzc3VlLCBidXQgSSBzZXQgaXQgdG8gMC4xbXMgdG8gYmUgc2FmZS5cclxuICAvLyBXaGVuIHRoZSBidWcgaXMgZml4ZWQsIHdlIGNhbiBgbWVhc3VyZSgpYCB1bmNvbmRpdGlvbmFsbHkgaWYgd2Ugd2FudCB0by5cclxuICB2YXIgdGltZVN0YW1wID0gcGVyZm9ybWFuY2VOb3coKTtcclxuICBpZiAodGltZVN0YW1wIC0gbGFzdE1hcmtUaW1lU3RhbXAgPiAwLjEpIHtcclxuICAgIHZhciBtZWFzdXJlbWVudE5hbWUgPSBkaXNwbGF5TmFtZSArICcgWycgKyBtYXJrVHlwZSArICddJztcclxuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUobWVhc3VyZW1lbnROYW1lLCBtYXJrTmFtZSk7XHJcbiAgfVxyXG5cclxuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKG1hcmtOYW1lKTtcclxuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmVtZW50TmFtZSk7XHJcbn1cclxuXHJcbnZhciBSZWFjdERlYnVnVG9vbCA9IHtcclxuICBhZGRIb29rOiBmdW5jdGlvbiAoaG9vaykge1xyXG4gICAgaG9va3MucHVzaChob29rKTtcclxuICB9LFxyXG4gIHJlbW92ZUhvb2s6IGZ1bmN0aW9uIChob29rKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChob29rc1tpXSA9PT0gaG9vaykge1xyXG4gICAgICAgIGhvb2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgICBpLS07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIGlzUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gaXNQcm9maWxpbmc7XHJcbiAgfSxcclxuICBiZWdpblByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpc1Byb2ZpbGluZyA9IHRydWU7XHJcbiAgICBmbHVzaEhpc3RvcnkubGVuZ3RoID0gMDtcclxuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XHJcbiAgICBSZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rKTtcclxuICB9LFxyXG4gIGVuZFByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCFpc1Byb2ZpbGluZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaXNQcm9maWxpbmcgPSBmYWxzZTtcclxuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XHJcbiAgICBSZWFjdERlYnVnVG9vbC5yZW1vdmVIb29rKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rKTtcclxuICB9LFxyXG4gIGdldEZsdXNoSGlzdG9yeTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGZsdXNoSGlzdG9yeTtcclxuICB9LFxyXG4gIG9uQmVnaW5GbHVzaDogZnVuY3Rpb24gKCkge1xyXG4gICAgY3VycmVudEZsdXNoTmVzdGluZysrO1xyXG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcclxuICAgIHBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyKCk7XHJcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5GbHVzaCcpO1xyXG4gIH0sXHJcbiAgb25FbmRGbHVzaDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcclxuICAgIGN1cnJlbnRGbHVzaE5lc3RpbmctLTtcclxuICAgIHJlc3VtZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xyXG4gICAgZW1pdEV2ZW50KCdvbkVuZEZsdXNoJyk7XHJcbiAgfSxcclxuICBvbkJlZ2luTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcclxuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcclxuICAgIGVtaXRFdmVudCgnb25CZWdpbkxpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcclxuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCB0aW1lclR5cGUpO1xyXG4gICAgYmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xyXG4gIH0sXHJcbiAgb25FbmRMaWZlQ3ljbGVUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xyXG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xyXG4gICAgZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcclxuICAgIG1hcmtFbmQoZGVidWdJRCwgdGltZXJUeXBlKTtcclxuICAgIGVtaXRFdmVudCgnb25FbmRMaWZlQ3ljbGVUaW1lcicsIGRlYnVnSUQsIHRpbWVyVHlwZSk7XHJcbiAgfSxcclxuICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xyXG4gIH0sXHJcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBlbWl0RXZlbnQoJ29uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xyXG4gIH0sXHJcbiAgb25Ib3N0T3BlcmF0aW9uOiBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XHJcbiAgICBjaGVja0RlYnVnSUQob3BlcmF0aW9uLmluc3RhbmNlSUQpO1xyXG4gICAgZW1pdEV2ZW50KCdvbkhvc3RPcGVyYXRpb24nLCBvcGVyYXRpb24pO1xyXG4gIH0sXHJcbiAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgZW1pdEV2ZW50KCdvblNldFN0YXRlJyk7XHJcbiAgfSxcclxuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoZGVidWdJRCwgY2hpbGREZWJ1Z0lEcykge1xyXG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xyXG4gICAgY2hpbGREZWJ1Z0lEcy5mb3JFYWNoKGNoZWNrRGVidWdJRCk7XHJcbiAgICBlbWl0RXZlbnQoJ29uU2V0Q2hpbGRyZW4nLCBkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcclxuICB9LFxyXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKSB7XHJcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XHJcbiAgICBjaGVja0RlYnVnSUQocGFyZW50RGVidWdJRCwgdHJ1ZSk7XHJcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcclxuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAnbW91bnQnKTtcclxuICB9LFxyXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XHJcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XHJcbiAgICBtYXJrRW5kKGRlYnVnSUQsICdtb3VudCcpO1xyXG4gICAgZW1pdEV2ZW50KCdvbk1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XHJcbiAgfSxcclxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcclxuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcclxuICAgIGVtaXRFdmVudCgnb25CZWZvcmVVcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50KTtcclxuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAndXBkYXRlJyk7XHJcbiAgfSxcclxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcclxuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcclxuICAgIG1hcmtFbmQoZGVidWdJRCwgJ3VwZGF0ZScpO1xyXG4gICAgZW1pdEV2ZW50KCdvblVwZGF0ZUNvbXBvbmVudCcsIGRlYnVnSUQpO1xyXG4gIH0sXHJcbiAgb25CZWZvcmVVbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xyXG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xyXG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcclxuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAndW5tb3VudCcpO1xyXG4gIH0sXHJcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xyXG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xyXG4gICAgbWFya0VuZChkZWJ1Z0lELCAndW5tb3VudCcpO1xyXG4gICAgZW1pdEV2ZW50KCdvblVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcclxuICB9LFxyXG4gIG9uVGVzdEV2ZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBlbWl0RXZlbnQoJ29uVGVzdEV2ZW50Jyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gVE9ETyByZW1vdmUgdGhlc2Ugd2hlbiBSTi93d3cgZ2V0cyB1cGRhdGVkXHJcblJlYWN0RGVidWdUb29sLmFkZERldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5hZGRIb29rO1xyXG5SZWFjdERlYnVnVG9vbC5yZW1vdmVEZXZ0b29sID0gUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlSG9vaztcclxuXHJcblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayk7XHJcblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RDb21wb25lbnRUcmVlSG9vayk7XHJcbnZhciB1cmwgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XHJcbmlmICgvWz8mXXJlYWN0X3BlcmZcXGIvLnRlc3QodXJsKSkge1xyXG4gIFJlYWN0RGVidWdUb29sLmJlZ2luUHJvZmlsaW5nKCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWJ1Z1Rvb2w7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcclxudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xyXG5cclxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XHJcblxyXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xyXG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXHJcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xyXG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXHJcbiAgY2xvc2U6IFJlYWN0VXBkYXRlcy5mbHVzaEJhdGNoZWRVcGRhdGVzLmJpbmQoUmVhY3RVcGRhdGVzKVxyXG59O1xyXG5cclxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW0ZMVVNIX0JBVENIRURfVVBEQVRFUywgUkVTRVRfQkFUQ0hFRF9VUERBVEVTXTtcclxuXHJcbmZ1bmN0aW9uIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpIHtcclxuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XHJcbn1cclxuXHJcbl9hc3NpZ24oUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIHtcclxuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKTtcclxuXHJcbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0ge1xyXG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaW4gYSBjb250ZXh0IHdpdGhpbiB3aGljaCBjYWxscyB0byBgc2V0U3RhdGVgXHJcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cclxuICAgKi9cclxuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XHJcblxyXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XHJcblxyXG4gICAgLy8gVGhlIGNvZGUgaXMgd3JpdHRlbiB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uc1xyXG4gICAgaWYgKGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMpIHtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIsIGMsIGQsIGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oY2FsbGJhY2ssIG51bGwsIGEsIGIsIGMsIGQsIGUpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgQVJJQURPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9BUklBRE9NUHJvcGVydHlDb25maWcnKTtcclxudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nKTtcclxudmFyIENoYW5nZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9DaGFuZ2VFdmVudFBsdWdpbicpO1xyXG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSByZXF1aXJlKCcuL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyJyk7XHJcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0VudGVyTGVhdmVFdmVudFBsdWdpbicpO1xyXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9IVE1MRE9NUHJvcGVydHlDb25maWcnKTtcclxudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50Jyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01FbXB0eUNvbXBvbmVudCcpO1xyXG52YXIgUmVhY3RET01UcmVlVHJhdmVyc2FsID0gcmVxdWlyZSgnLi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwnKTtcclxudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0Q29tcG9uZW50Jyk7XHJcbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5Jyk7XHJcbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRMaXN0ZW5lcicpO1xyXG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5qZWN0aW9uJyk7XHJcbnZhciBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uJyk7XHJcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vU1ZHRE9NUHJvcGVydHlDb25maWcnKTtcclxudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TZWxlY3RFdmVudFBsdWdpbicpO1xyXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NpbXBsZUV2ZW50UGx1Z2luJyk7XHJcblxyXG52YXIgYWxyZWFkeUluamVjdGVkID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBpbmplY3QoKSB7XHJcbiAgaWYgKGFscmVhZHlJbmplY3RlZCkge1xyXG4gICAgLy8gVE9ETzogVGhpcyBpcyBjdXJyZW50bHkgdHJ1ZSBiZWNhdXNlIHRoZXNlIGluamVjdGlvbnMgYXJlIHNoYXJlZCBiZXR3ZWVuXHJcbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcclxuICAgIC8vIGFuZCBub3Qgc2hhcmUgYW55IGluamVjdGlvbiBzdGF0ZS4gVGhlbiB0aGlzIHByb2JsZW0gd2lsbCBiZSBzb2x2ZWQuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGFscmVhZHlJbmplY3RlZCA9IHRydWU7XHJcblxyXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXHJcbiAgICovXHJcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcik7XHJcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XHJcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RUcmVlVHJhdmVyc2FsKFJlYWN0RE9NVHJlZVRyYXZlcnNhbCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxyXG4gICAqIHRoZW0pLlxyXG4gICAqL1xyXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XHJcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXHJcbiAgICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcclxuICAgIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcclxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcclxuICAgIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cclxuICB9KTtcclxuXHJcbiAgUmVhY3RJbmplY3Rpb24uSG9zdENvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xyXG5cclxuICBSZWFjdEluamVjdGlvbi5Ib3N0Q29tcG9uZW50LmluamVjdFRleHRDb21wb25lbnRDbGFzcyhSZWFjdERPTVRleHRDb21wb25lbnQpO1xyXG5cclxuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhBUklBRE9NUHJvcGVydHlDb25maWcpO1xyXG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XHJcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xyXG5cclxuICBSZWFjdEluamVjdGlvbi5FbXB0eUNvbXBvbmVudC5pbmplY3RFbXB0eUNvbXBvbmVudEZhY3RvcnkoZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XHJcbiAgICByZXR1cm4gbmV3IFJlYWN0RE9NRW1wdHlDb21wb25lbnQoaW5zdGFudGlhdGUpO1xyXG4gIH0pO1xyXG5cclxuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xyXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcclxuXHJcbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgaW5qZWN0OiBpbmplY3RcclxufTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcclxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxyXG5cclxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSRUFDVF9FTEVNRU5UX1RZUEU7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGVtcHR5Q29tcG9uZW50RmFjdG9yeTtcclxuXHJcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uID0ge1xyXG4gIGluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeTogZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIGVtcHR5Q29tcG9uZW50RmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSB7XHJcbiAgY3JlYXRlOiBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcclxuICAgIHJldHVybiBlbXB0eUNvbXBvbmVudEZhY3RvcnkoaW5zdGFudGlhdGUpO1xyXG4gIH1cclxufTtcclxuXHJcblJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uID0gUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbXB0eUNvbXBvbmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNhdWdodEVycm9yID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXHJcbiAqIEBwYXJhbSB7Kn0gYSBGaXJzdCBhcmd1bWVudFxyXG4gKiBAcGFyYW0geyp9IGIgU2Vjb25kIGFyZ3VtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgYSkge1xyXG4gIHRyeSB7XHJcbiAgICBmdW5jKGEpO1xyXG4gIH0gY2F0Y2ggKHgpIHtcclxuICAgIGlmIChjYXVnaHRFcnJvciA9PT0gbnVsbCkge1xyXG4gICAgICBjYXVnaHRFcnJvciA9IHg7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xyXG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2VkIGJ5IFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHNvIHRoYXQgYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIGV2ZW50XHJcbiAgICogaGFuZGxlciBhcmUgc3VyZSB0byBiZSByZXRocm93biBieSByZXRocm93Q2F1Z2h0RXJyb3IuXHJcbiAgICovXHJcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXHJcblxyXG4gIC8qKlxyXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxyXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cclxuICAgKi9cclxuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChjYXVnaHRFcnJvcikge1xyXG4gICAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcclxuICAgICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIC8qKlxyXG4gICAqIFRvIGhlbHAgZGV2ZWxvcG1lbnQgd2UgY2FuIGdldCBiZXR0ZXIgZGV2dG9vbHMgaW50ZWdyYXRpb24gYnkgc2ltdWxhdGluZyBhXHJcbiAgICogcmVhbCBicm93c2VyIGV2ZW50LlxyXG4gICAqL1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XHJcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGEpIHtcclxuICAgICAgdmFyIGJvdW5kRnVuYyA9IGZ1bmMuYmluZChudWxsLCBhKTtcclxuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIG5hbWU7XHJcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XHJcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcclxuICAgICAgLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjMzNlxyXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcclxuICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXJyb3JVdGlsczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XHJcblxyXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcclxuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XHJcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xyXG59XHJcblxyXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcclxuICAgKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxyXG4gICAqL1xyXG4gIGhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICAgIHZhciBldmVudHMgPSBFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50RW1pdHRlck1peGluOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xyXG5cclxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xyXG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIGRlZXBlc3QgUmVhY3QgY29tcG9uZW50IGNvbXBsZXRlbHkgY29udGFpbmluZyB0aGUgcm9vdCBvZiB0aGVcclxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcclxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxyXG4gKi9cclxuZnVuY3Rpb24gZmluZFBhcmVudChpbnN0KSB7XHJcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cclxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXHJcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXHJcbiAgd2hpbGUgKGluc3QuX2hvc3RQYXJlbnQpIHtcclxuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xyXG4gIH1cclxuICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcclxuICB2YXIgY29udGFpbmVyID0gcm9vdE5vZGUucGFyZW50Tm9kZTtcclxuICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7XHJcbn1cclxuXHJcbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xyXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xyXG4gIHRoaXMudG9wTGV2ZWxUeXBlID0gdG9wTGV2ZWxUeXBlO1xyXG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcclxuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xyXG59XHJcbl9hc3NpZ24oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnByb3RvdHlwZSwge1xyXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcclxuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xyXG4gICAgdGhpcy5hbmNlc3RvcnMubGVuZ3RoID0gMDtcclxuICB9XHJcbn0pO1xyXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLCBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcik7XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcclxuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCk7XHJcbiAgdmFyIHRhcmdldEluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xyXG5cclxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cclxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XHJcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXHJcbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cclxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xyXG4gIGRvIHtcclxuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcclxuICAgIGFuY2VzdG9yID0gYW5jZXN0b3IgJiYgZmluZFBhcmVudChhbmNlc3Rvcik7XHJcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcclxuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xyXG4gIHZhciBzY3JvbGxQb3NpdGlvbiA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHdpbmRvdyk7XHJcbiAgY2Ioc2Nyb2xsUG9zaXRpb24pO1xyXG59XHJcblxyXG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0ge1xyXG4gIF9lbmFibGVkOiB0cnVlLFxyXG4gIF9oYW5kbGVUb3BMZXZlbDogbnVsbCxcclxuXHJcbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcclxuXHJcbiAgc2V0SGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uIChoYW5kbGVUb3BMZXZlbCkge1xyXG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xyXG4gIH0sXHJcblxyXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XHJcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XHJcbiAgfSxcclxuXHJcbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXHJcbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XHJcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXHJcbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XHJcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xyXG4gIH0sXHJcblxyXG4gIG1vbml0b3JTY3JvbGxWYWx1ZTogZnVuY3Rpb24gKHJlZnJlc2gpIHtcclxuICAgIHZhciBjYWxsYmFjayA9IHNjcm9sbFZhbHVlTW9uaXRvci5iaW5kKG51bGwsIHJlZnJlc2gpO1xyXG4gICAgRXZlbnRMaXN0ZW5lci5saXN0ZW4od2luZG93LCAnc2Nyb2xsJywgY2FsbGJhY2spO1xyXG4gIH0sXHJcblxyXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XHJcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGJvb2tLZWVwaW5nID0gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLmdldFBvb2xlZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcclxuICAgICAgLy8gYHByZXZlbnREZWZhdWx0YC5cclxuICAgICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnJlbGVhc2UoYm9va0tlZXBpbmcpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSB7XHJcbiAgLy8gV2hlbiB0cnVlLCBjYWxsIGNvbnNvbGUudGltZSgpIGJlZm9yZSBhbmQgLnRpbWVFbmQoKSBhZnRlciBlYWNoIHRvcC1sZXZlbFxyXG4gIC8vIHJlbmRlciAoYm90aCBpbml0aWFsIHJlbmRlcnMgYW5kIHVwZGF0ZXMpLiBVc2VmdWwgd2hlbiBsb29raW5nIGF0IHByb2QtbW9kZVxyXG4gIC8vIHRpbWVsaW5lIHByb2ZpbGVzIGluIENocm9tZSwgZm9yIGV4YW1wbGUuXHJcbiAgbG9nVG9wTGV2ZWxSZW5kZXJzOiBmYWxzZVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZlYXR1cmVGbGFnczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG5cclxudmFyIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IG51bGw7XHJcbnZhciB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBudWxsO1xyXG5cclxudmFyIFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiA9IHtcclxuICAvLyBUaGlzIGFjY2VwdHMgYSBjbGFzcyB0aGF0IHJlY2VpdmVzIHRoZSB0YWcgc3RyaW5nLiBUaGlzIGlzIGEgY2F0Y2ggYWxsXHJcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cclxuICBpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xyXG4gICAgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XHJcbiAgfSxcclxuICAvLyBUaGlzIGFjY2VwdHMgYSB0ZXh0IGNvbXBvbmVudCBjbGFzcyB0aGF0IHRha2VzIHRoZSB0ZXh0IHN0cmluZyB0byBiZVxyXG4gIC8vIHJlbmRlcmVkIGFzIHByb3BzLlxyXG4gIGluamVjdFRleHRDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XHJcbiAgICB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGEgaG9zdCBpbnRlcm5hbCBjb21wb25lbnQgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjcmVhdGUuXHJcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgaW50ZXJuYWwgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KSB7XHJcbiAgIWdlbmVyaWNDb21wb25lbnRDbGFzcyA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBpcyBubyByZWdpc3RlcmVkIGNvbXBvbmVudCBmb3IgdGhlIHRhZyAlcycsIGVsZW1lbnQudHlwZSkgOiBfcHJvZEludmFyaWFudCgnMTExJywgZWxlbWVudC50eXBlKSA6IHZvaWQgMDtcclxuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XHJcbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VGb3JUZXh0KHRleHQpIHtcclxuICByZXR1cm4gbmV3IHRleHRDb21wb25lbnRDbGFzcyh0ZXh0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNUZXh0Q29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gIHJldHVybiBjb21wb25lbnQgaW5zdGFuY2VvZiB0ZXh0Q29tcG9uZW50Q2xhc3M7XHJcbn1cclxuXHJcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSB7XHJcbiAgY3JlYXRlSW50ZXJuYWxDb21wb25lbnQ6IGNyZWF0ZUludGVybmFsQ29tcG9uZW50LFxyXG4gIGNyZWF0ZUluc3RhbmNlRm9yVGV4dDogY3JlYXRlSW5zdGFuY2VGb3JUZXh0LFxyXG4gIGlzVGV4dENvbXBvbmVudDogaXNUZXh0Q29tcG9uZW50LFxyXG4gIGluamVjdGlvbjogUmVhY3RIb3N0Q29tcG9uZW50SW5qZWN0aW9uXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SG9zdENvbXBvbmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGhpc3RvcnkgPSBbXTtcclxuXHJcbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHtcclxuICBvbkhvc3RPcGVyYXRpb246IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcclxuICAgIGhpc3RvcnkucHVzaChvcGVyYXRpb24pO1xyXG4gIH0sXHJcbiAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suX3ByZXZlbnRDbGVhcmluZykge1xyXG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0cy5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGhpc3RvcnkgPSBbXTtcclxuICB9LFxyXG4gIGdldEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBoaXN0b3J5O1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2s7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xyXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XHJcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XHJcbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XHJcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XHJcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xyXG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RDb21wb25lbnQnKTtcclxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XHJcblxyXG52YXIgUmVhY3RJbmplY3Rpb24gPSB7XHJcbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LmluamVjdGlvbixcclxuICBET01Qcm9wZXJ0eTogRE9NUHJvcGVydHkuaW5qZWN0aW9uLFxyXG4gIEVtcHR5Q29tcG9uZW50OiBSZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbixcclxuICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLFxyXG4gIEV2ZW50UGx1Z2luVXRpbHM6IEV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLFxyXG4gIEV2ZW50RW1pdHRlcjogUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmluamVjdGlvbixcclxuICBIb3N0Q29tcG9uZW50OiBSZWFjdEhvc3RDb21wb25lbnQuaW5qZWN0aW9uLFxyXG4gIFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5pbmplY3Rpb25cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbmplY3Rpb247IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdGlvbicpO1xyXG5cclxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xyXG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XHJcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xyXG5cclxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcclxuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxyXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XHJcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cclxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXHJcbiAqL1xyXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcclxuXHJcbiAgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAndGV4dCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XHJcbiAgfSxcclxuXHJcbiAgZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcclxuICAgICAgc2VsZWN0aW9uUmFuZ2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKSA6IG51bGxcclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXHJcbiAgICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXHJcbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXHJcbiAgICovXHJcbiAgcmVzdG9yZVNlbGVjdGlvbjogZnVuY3Rpb24gKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcclxuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcclxuICAgIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcclxuICAgIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcclxuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcclxuICAgICAgaWYgKFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XHJcbiAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5zZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XHJcbiAgICAgIH1cclxuICAgICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxyXG4gICAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxyXG4gICAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XHJcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XHJcbiAgICovXHJcbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgIHZhciBzZWxlY3Rpb247XHJcblxyXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcclxuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cclxuICAgICAgc2VsZWN0aW9uID0ge1xyXG4gICAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcclxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xyXG4gICAgICAvLyBJRTggaW5wdXQuXHJcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xyXG4gICAgICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgc2VsZWN0aW9uIHBlciBkb2N1bWVudCBpbiBJRSwgc28gaXQgbXVzdFxyXG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cclxuICAgICAgaWYgKHJhbmdlLnBhcmVudEVsZW1lbnQoKSA9PT0gaW5wdXQpIHtcclxuICAgICAgICBzZWxlY3Rpb24gPSB7XHJcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXHJcbiAgICAgICAgICBlbmQ6IC1yYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxyXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xyXG4gICAqIHRoZSBpbnB1dC5cclxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXHJcbiAgICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxyXG4gICAqL1xyXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XHJcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xyXG4gICAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xyXG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGVuZCA9IHN0YXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XHJcbiAgICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcclxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcclxuICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XHJcbiAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xyXG4gICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcclxuICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xyXG4gICAgICByYW5nZS5zZWxlY3QoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFJlYWN0RE9NU2VsZWN0aW9uLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnB1dFNlbGVjdGlvbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcclxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcclxuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXHJcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXHJcbiAqL1xyXG5cclxuLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggRVM2OiB2YXIgUmVhY3RJbnN0YW5jZU1hcCA9IG5ldyBNYXAoKTtcclxuXHJcbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xyXG4gICAqIHRyYW5zZm9ybSB0aGVzZSB0byBzdHJpbmdzIGZvciBJRSBzdXBwb3J0LiBXaGVuIHRoaXMgdHJhbnNmb3JtIGlzIGZ1bGx5XHJcbiAgICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXHJcbiAgICovXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IHVuZGVmaW5lZDtcclxuICB9LFxyXG5cclxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcclxuICB9LFxyXG5cclxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSAhPT0gdW5kZWZpbmVkO1xyXG4gIH0sXHJcblxyXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnN0YW5jZU1hcDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBSZWFjdEluc3RydW1lbnRhdGlvbiB3aXRoIGEgX19ERVZfXyBjaGVja1xyXG5cclxudmFyIGRlYnVnVG9vbCA9IG51bGw7XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhciBSZWFjdERlYnVnVG9vbCA9IHJlcXVpcmUoJy4vUmVhY3REZWJ1Z1Rvb2wnKTtcclxuICBkZWJ1Z1Rvb2wgPSBSZWFjdERlYnVnVG9vbDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7IGRlYnVnVG9vbDogZGVidWdUb29sIH07IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICB2YXIgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xyXG5cclxuICB2YXIgd2FybkludmFsaWRTZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFwcm9jZXNzaW5nQ2hpbGRDb250ZXh0LCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKSA6IHZvaWQgMDtcclxuICB9O1xyXG59XHJcblxyXG52YXIgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayA9IHtcclxuICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IHRydWU7XHJcbiAgfSxcclxuICBvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSBmYWxzZTtcclxuICB9LFxyXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHdhcm5JbnZhbGlkU2V0U3RhdGUoKTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2s7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcclxuXHJcbnZhciBUQUdfRU5EID0gL1xcLz8+LztcclxudmFyIENPTU1FTlRfU1RBUlQgPSAvXjxcXCFcXC1cXC0vO1xyXG5cclxudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSB7XHJcbiAgQ0hFQ0tTVU1fQVRUUl9OQU1FOiAnZGF0YS1yZWFjdC1jaGVja3N1bScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZ1xyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxyXG4gICAqL1xyXG4gIGFkZENoZWNrc3VtVG9NYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXApIHtcclxuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcclxuXHJcbiAgICAvLyBBZGQgY2hlY2tzdW0gKGhhbmRsZSBib3RoIHBhcmVudCB0YWdzLCBjb21tZW50cyBhbmQgc2VsZi1jbG9zaW5nIHRhZ3MpXHJcbiAgICBpZiAoQ09NTUVOVF9TVEFSVC50ZXN0KG1hcmt1cCkpIHtcclxuICAgICAgcmV0dXJuIG1hcmt1cDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShUQUdfRU5ELCAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCIkJicpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgdG8gdXNlXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHJvb3QgUmVhY3QgZWxlbWVudFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFya3VwIGlzIHRoZSBzYW1lXHJcbiAgICovXHJcbiAgY2FuUmV1c2VNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXAsIGVsZW1lbnQpIHtcclxuICAgIHZhciBleGlzdGluZ0NoZWNrc3VtID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xyXG4gICAgZXhpc3RpbmdDaGVja3N1bSA9IGV4aXN0aW5nQ2hlY2tzdW0gJiYgcGFyc2VJbnQoZXhpc3RpbmdDaGVja3N1bSwgMTApO1xyXG4gICAgdmFyIG1hcmt1cENoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xyXG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNYXJrdXBDaGVja3N1bTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xyXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xyXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcclxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XHJcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xyXG52YXIgUmVhY3RET01Db250YWluZXJJbmZvID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbnRhaW5lckluZm8nKTtcclxudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZlYXR1cmVGbGFncycpO1xyXG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RmVhdHVyZUZsYWdzJyk7XHJcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XHJcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcclxudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKCcuL1JlYWN0TWFya3VwQ2hlY2tzdW0nKTtcclxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XHJcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XHJcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xyXG5cclxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcclxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcclxudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcclxudmFyIFJPT1RfQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRTtcclxuXHJcbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XHJcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcclxudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xyXG5cclxudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxyXG4gKiB0aGF0J3Mgbm90IGNvbW1vbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5ncy5cclxuICpcclxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciB3aGVyZSB0aGUgc3RyaW5ncyBkaXZlcmdlXHJcbiAqL1xyXG5mdW5jdGlvbiBmaXJzdERpZmZlcmVuY2VJbmRleChzdHJpbmcxLCBzdHJpbmcyKSB7XHJcbiAgdmFyIG1pbkxlbiA9IE1hdGgubWluKHN0cmluZzEubGVuZ3RoLCBzdHJpbmcyLmxlbmd0aCk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5MZW47IGkrKykge1xyXG4gICAgaWYgKHN0cmluZzEuY2hhckF0KGkpICE9PSBzdHJpbmcyLmNoYXJBdChpKSkge1xyXG4gICAgICByZXR1cm4gaTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHN0cmluZzEubGVuZ3RoID09PSBzdHJpbmcyLmxlbmd0aCA/IC0xIDogbWluTGVuO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtET01FbGVtZW50fERPTURvY3VtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpblxyXG4gKiBhIFJlYWN0IGNvbXBvbmVudFxyXG4gKiBAcmV0dXJuIHs/Kn0gRE9NIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSB0aGUgcmVhY3RSb290IElELCBvciBudWxsLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gIGlmICghY29udGFpbmVyKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcclxuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbnRlcm5hbEdldElEKG5vZGUpIHtcclxuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXHJcbiAgLy8gd2hpY2ggc3VwcG9ydCBhdHRyaWJ1dGVzIG9yIGEgLmdldEF0dHJpYnV0ZSBtZXRob2QsIGdyYWNlZnVsbHkgcmV0dXJuXHJcbiAgLy8gdGhlIGVtcHR5IHN0cmluZywgYXMgaWYgdGhlIGF0dHJpYnV0ZSB3ZXJlIG1pc3NpbmcuXHJcbiAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgfHwgJyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNb3VudHMgdGhpcyBjb21wb25lbnQgYW5kIGluc2VydHMgaXQgaW50byB0aGUgRE9NLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXHJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXHJcbiAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxyXG4gKi9cclxuZnVuY3Rpb24gbW91bnRDb21wb25lbnRJbnRvTm9kZSh3cmFwcGVySW5zdGFuY2UsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XHJcbiAgdmFyIG1hcmtlck5hbWU7XHJcbiAgaWYgKFJlYWN0RmVhdHVyZUZsYWdzLmxvZ1RvcExldmVsUmVuZGVycykge1xyXG4gICAgdmFyIHdyYXBwZWRFbGVtZW50ID0gd3JhcHBlckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5wcm9wcy5jaGlsZDtcclxuICAgIHZhciB0eXBlID0gd3JhcHBlZEVsZW1lbnQudHlwZTtcclxuICAgIG1hcmtlck5hbWUgPSAnUmVhY3QgbW91bnQ6ICcgKyAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZSA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lKTtcclxuICAgIGNvbnNvbGUudGltZShtYXJrZXJOYW1lKTtcclxuICB9XHJcblxyXG4gIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQod3JhcHBlckluc3RhbmNlLCB0cmFuc2FjdGlvbiwgbnVsbCwgUmVhY3RET01Db250YWluZXJJbmZvKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyKSwgY29udGV4dCwgMCAvKiBwYXJlbnREZWJ1Z0lEICovXHJcbiAgKTtcclxuXHJcbiAgaWYgKG1hcmtlck5hbWUpIHtcclxuICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcclxuICB9XHJcblxyXG4gIHdyYXBwZXJJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3RvcExldmVsV3JhcHBlciA9IHdyYXBwZXJJbnN0YW5jZTtcclxuICBSZWFjdE1vdW50Ll9tb3VudEltYWdlSW50b05vZGUobWFya3VwLCBjb250YWluZXIsIHdyYXBwZXJJbnN0YW5jZSwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJhdGNoZWQgbW91bnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cclxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cclxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxyXG4gKi9cclxuZnVuY3Rpb24gYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUoY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcclxuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXHJcbiAgLyogdXNlQ3JlYXRlRWxlbWVudCAqL1xyXG4gICFzaG91bGRSZXVzZU1hcmt1cCAmJiBSZWFjdERPTUZlYXR1cmVGbGFncy51c2VDcmVhdGVFbGVtZW50KTtcclxuICB0cmFuc2FjdGlvbi5wZXJmb3JtKG1vdW50Q29tcG9uZW50SW50b05vZGUsIG51bGwsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XHJcbiAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVbm1vdW50cyBhIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBET00uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGluc3RhbmNlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gdW5tb3VudCBmcm9tLlxyXG4gKiBAZmluYWxcclxuICogQGludGVybmFsXHJcbiAqIEBzZWUge1JlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZX1cclxuICovXHJcbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRGcm9tTm9kZShpbnN0YW5jZSwgY29udGFpbmVyLCBzYWZlbHkpIHtcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCgpO1xyXG4gIH1cclxuICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChpbnN0YW5jZSwgc2FmZWx5KTtcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2goKTtcclxuICB9XHJcblxyXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcclxuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbXB0eWluZy1hLW5vZGVcclxuICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xyXG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGhhcyBhIGRpcmVjdCBSZWFjdC1yZW5kZXJlZCBjaGlsZCB0aGF0IGlzXHJcbiAqIG5vdCBhIFJlYWN0IHJvb3QgZWxlbWVudC4gVXNlZnVsIGZvciB3YXJuaW5nIGluIGByZW5kZXJgLFxyXG4gKiBgdW5tb3VudENvbXBvbmVudEF0Tm9kZWAsIGV0Yy5cclxuICpcclxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBjb250YWlucyBhIGRpcmVjdCBjaGlsZCB0aGF0IHdhc1xyXG4gKiByZW5kZXJlZCBieSBSZWFjdCBidXQgaXMgbm90IGEgcm9vdCBlbGVtZW50LlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcikge1xyXG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcclxuICBpZiAocm9vdEVsKSB7XHJcbiAgICB2YXIgaW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XHJcbiAgICByZXR1cm4gISEoaW5zdCAmJiBpbnN0Ll9ob3N0UGFyZW50KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIFJlYWN0IERPTSBlbGVtZW50IGFuZFxyXG4gKiBpdCBoYXMgYmVlbiByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGhhcyBiZWVuIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIG5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lcikge1xyXG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcclxuICByZXR1cm4gISEocm9vdEVsICYmIGlzUmVhY3ROb2RlKHJvb3RFbCkgJiYgIVJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCkpO1xyXG59XHJcblxyXG4vKipcclxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBub2RlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgRE9NIG5vZGUuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XHJcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIFJlYWN0IG5vZGUgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBSZWFjdCBET00gbm9kZS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1JlYWN0Tm9kZShub2RlKSB7XHJcbiAgcmV0dXJuIGlzVmFsaWRDb250YWluZXIobm9kZSkgJiYgKG5vZGUuaGFzQXR0cmlidXRlKFJPT1RfQVRUUl9OQU1FKSB8fCBub2RlLmhhc0F0dHJpYnV0ZShBVFRSX05BTUUpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcclxuICB2YXIgcHJldkhvc3RJbnN0YW5jZSA9IHJvb3RFbCAmJiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xyXG4gIHJldHVybiBwcmV2SG9zdEluc3RhbmNlICYmICFwcmV2SG9zdEluc3RhbmNlLl9ob3N0UGFyZW50ID8gcHJldkhvc3RJbnN0YW5jZSA6IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gIHZhciByb290ID0gZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyKGNvbnRhaW5lcik7XHJcbiAgcmV0dXJuIHJvb3QgPyByb290Ll9ob3N0Q29udGFpbmVySW5mby5fdG9wTGV2ZWxXcmFwcGVyIDogbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlbXBvcmFyeSAoPykgaGFjayBzbyB0aGF0IHdlIGNhbiBzdG9yZSBhbGwgdG9wLWxldmVsIHBlbmRpbmcgdXBkYXRlcyBvblxyXG4gKiBjb21wb3NpdGVzIGluc3RlYWQgb2YgaGF2aW5nIHRvIHdvcnJ5IGFib3V0IGRpZmZlcmVudCB0eXBlcyBvZiBjb21wb25lbnRzXHJcbiAqIGhlcmUuXHJcbiAqL1xyXG52YXIgdG9wTGV2ZWxSb290Q291bnRlciA9IDE7XHJcbnZhciBUb3BMZXZlbFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5yb290SUQgPSB0b3BMZXZlbFJvb3RDb3VudGVyKys7XHJcbn07XHJcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIFRvcExldmVsV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdUb3BMZXZlbFdyYXBwZXInO1xyXG59XHJcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkO1xyXG59O1xyXG5Ub3BMZXZlbFdyYXBwZXIuaXNSZWFjdFRvcExldmVsV3JhcHBlciA9IHRydWU7XHJcblxyXG4vKipcclxuICogTW91bnRpbmcgaXMgdGhlIHByb2Nlc3Mgb2YgaW5pdGlhbGl6aW5nIGEgUmVhY3QgY29tcG9uZW50IGJ5IGNyZWF0aW5nIGl0c1xyXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cclxuICogQW55IHByaW9yIGNvbnRlbnQgaW5zaWRlIGBjb250YWluZXJgIGlzIGRlc3Ryb3llZCBpbiB0aGUgcHJvY2Vzcy5cclxuICpcclxuICogICBSZWFjdE1vdW50LnJlbmRlcihcclxuICogICAgIGNvbXBvbmVudCxcclxuICogICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKVxyXG4gKiAgICk7XHJcbiAqXHJcbiAqICAgPGRpdiBpZD1cImNvbnRhaW5lclwiPiAgICAgICAgICAgICAgICAgICA8LS0gU3VwcGxpZWQgYGNvbnRhaW5lcmAuXHJcbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XHJcbiAqICAgICAgIC8vIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgIDwvZGl2PlxyXG4gKlxyXG4gKiBJbnNpZGUgb2YgYGNvbnRhaW5lcmAsIHRoZSBmaXJzdCBlbGVtZW50IHJlbmRlcmVkIGlzIHRoZSBcInJlYWN0Um9vdFwiLlxyXG4gKi9cclxudmFyIFJlYWN0TW91bnQgPSB7XHJcblxyXG4gIFRvcExldmVsV3JhcHBlcjogVG9wTGV2ZWxXcmFwcGVyLFxyXG5cclxuICAvKipcclxuICAgKiBVc2VkIGJ5IGRldnRvb2xzLiBUaGUga2V5cyBhcmUgbm90IGltcG9ydGFudC5cclxuICAgKi9cclxuICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCxcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBpcyBhIGhvb2sgcHJvdmlkZWQgdG8gc3VwcG9ydCByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyB3aGlsZVxyXG4gICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFwcGFyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiBpdHMgYGNvbnRhaW5lcmAgZG9lcyBub3RcclxuICAgKiBjaGFuZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBUaGUgYGNvbnRhaW5lcmAgYmVpbmcgcmVuZGVyZWQgaW50by5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJDYWxsYmFjayBUaGlzIG11c3QgYmUgY2FsbGVkIG9uY2UgdG8gZG8gdGhlIHJlbmRlci5cclxuICAgKi9cclxuICBzY3JvbGxNb25pdG9yOiBmdW5jdGlvbiAoY29udGFpbmVyLCByZW5kZXJDYWxsYmFjaykge1xyXG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBUYWtlIGEgY29tcG9uZW50IHRoYXQncyBhbHJlYWR5IG1vdW50ZWQgaW50byB0aGUgRE9NIGFuZCByZXBsYWNlIGl0cyBwcm9wc1xyXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHByZXZDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIGFscmVhZHkgaW4gdGhlIERPTVxyXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXHJcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXHJcbiAgICovXHJcbiAgX3VwZGF0ZVJvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcclxuICAgIFJlYWN0TW91bnQuc2Nyb2xsTW9uaXRvcihjb250YWluZXIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRWxlbWVudEludGVybmFsKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCk7XHJcbiAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwocHJldkNvbXBvbmVudCwgY2FsbGJhY2spO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcHJldkNvbXBvbmVudDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXIgYSBuZXcgY29tcG9uZW50IGludG8gdGhlIERPTS4gSG9va2VkIGJ5IGhvb2tzIVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGVsZW1lbnQgdG8gcmVuZGVyXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBpZiB3ZSBzaG91bGQgc2tpcCB0aGUgbWFya3VwIGluc2VydGlvblxyXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XHJcbiAgICovXHJcbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xyXG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXHJcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcclxuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS5cclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ19yZW5kZXJOZXdSb290Q29tcG9uZW50KCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gJyArICdyZW5kZXIgaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcclxuXHJcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ19yZWdpc3RlckNvbXBvbmVudCguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM3JykgOiB2b2lkIDA7XHJcblxyXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZygpO1xyXG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgZmFsc2UpO1xyXG5cclxuICAgIC8vIFRoZSBpbml0aWFsIHJlbmRlciBpcyBzeW5jaHJvbm91cyBidXQgYW55IHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nXHJcbiAgICAvLyByZW5kZXJpbmcsIGluIGNvbXBvbmVudFdpbGxNb3VudCBvciBjb21wb25lbnREaWRNb3VudCwgd2lsbCBiZSBiYXRjaGVkXHJcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXHJcblxyXG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlLCBjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XHJcblxyXG4gICAgdmFyIHdyYXBwZXJJRCA9IGNvbXBvbmVudEluc3RhbmNlLl9pbnN0YW5jZS5yb290SUQ7XHJcbiAgICBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3dyYXBwZXJJRF0gPSBjb21wb25lbnRJbnN0YW5jZTtcclxuXHJcbiAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcclxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcclxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcGFyZW50Q29tcG9uZW50IFRoZSBjb25jZXB0dWFsIHBhcmVudCBvZiB0aGlzIHJlbmRlciB0cmVlLlxyXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXHJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXHJcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXHJcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cclxuICAgKi9cclxuICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcclxuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgUmVhY3RJbnN0YW5jZU1hcC5oYXMocGFyZW50Q29tcG9uZW50KSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCczOCcpIDogdm9pZCAwO1xyXG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xyXG4gIH0sXHJcblxyXG4gIF9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcclxuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgJ1JlYWN0RE9NLnJlbmRlcicpO1xyXG4gICAgIVJlYWN0LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6XHJcbiAgICAvLyBDaGVjayBpZiBpdCBxdWFja3MgbGlrZSBhbiBlbGVtZW50XHJcbiAgICBuZXh0RWxlbWVudCAhPSBudWxsICYmIG5leHRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyAnIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB1bmludGVudGlvbmFsbHkgbG9hZGluZyB0d28gaW5kZXBlbmRlbnQgJyArICdjb3BpZXMgb2YgUmVhY3QuJyA6ICcnKSA6IF9wcm9kSW52YXJpYW50KCczOScsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6IG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogdm9pZCAwO1xyXG5cclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJywgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJykgOiB2b2lkIDA7XHJcblxyXG4gICAgdmFyIG5leHRXcmFwcGVkRWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9wTGV2ZWxXcmFwcGVyLCB7IGNoaWxkOiBuZXh0RWxlbWVudCB9KTtcclxuXHJcbiAgICB2YXIgbmV4dENvbnRleHQ7XHJcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgIHZhciBwYXJlbnRJbnN0ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgbmV4dENvbnRleHQgPSBwYXJlbnRJbnN0Ll9wcm9jZXNzQ2hpbGRDb250ZXh0KHBhcmVudEluc3QuX2NvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbmV4dENvbnRleHQgPSBlbXB0eU9iamVjdDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcik7XHJcblxyXG4gICAgaWYgKHByZXZDb21wb25lbnQpIHtcclxuICAgICAgdmFyIHByZXZXcmFwcGVkRWxlbWVudCA9IHByZXZDb21wb25lbnQuX2N1cnJlbnRFbGVtZW50O1xyXG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2V3JhcHBlZEVsZW1lbnQucHJvcHMuY2hpbGQ7XHJcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XHJcbiAgICAgICAgdmFyIHB1YmxpY0luc3QgPSBwcmV2Q29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xyXG4gICAgICAgIHZhciB1cGRhdGVkQ2FsbGJhY2sgPSBjYWxsYmFjayAmJiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHB1YmxpY0luc3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmVhY3RNb3VudC5fdXBkYXRlUm9vdENvbXBvbmVudChwcmV2Q29tcG9uZW50LCBuZXh0V3JhcHBlZEVsZW1lbnQsIG5leHRDb250ZXh0LCBjb250YWluZXIsIHVwZGF0ZWRDYWxsYmFjayk7XHJcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3Q7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xyXG4gICAgdmFyIGNvbnRhaW5lckhhc1JlYWN0TWFya3VwID0gcmVhY3RSb290RWxlbWVudCAmJiAhIWludGVybmFsR2V0SUQocmVhY3RSb290RWxlbWVudCk7XHJcbiAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJykgOiB2b2lkIDA7XHJcblxyXG4gICAgICBpZiAoIWNvbnRhaW5lckhhc1JlYWN0TWFya3VwIHx8IHJlYWN0Um9vdEVsZW1lbnQubmV4dFNpYmxpbmcpIHtcclxuICAgICAgICB2YXIgcm9vdEVsZW1lbnRTaWJsaW5nID0gcmVhY3RSb290RWxlbWVudDtcclxuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XHJcbiAgICAgICAgICBpZiAoaW50ZXJuYWxHZXRJRChyb290RWxlbWVudFNpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpIDogdm9pZCAwO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJvb3RFbGVtZW50U2libGluZyA9IHJvb3RFbGVtZW50U2libGluZy5uZXh0U2libGluZztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2hvdWxkUmV1c2VNYXJrdXAgPSBjb250YWluZXJIYXNSZWFjdE1hcmt1cCAmJiAhcHJldkNvbXBvbmVudCAmJiAhY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQ7XHJcbiAgICB2YXIgY29tcG9uZW50ID0gUmVhY3RNb3VudC5fcmVuZGVyTmV3Um9vdENvbXBvbmVudChuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIG5leHRDb250ZXh0KS5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcclxuICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tcG9uZW50O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cclxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20ucmVuZGVyXHJcbiAgICpcclxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxyXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxyXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxyXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxyXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXHJcbiAgICovXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcclxuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxyXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS51bm1vdW50Y29tcG9uZW50YXRub2RlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBjb21wb25lbnQgd2FzIGZvdW5kIGluIGFuZCB1bm1vdW50ZWQgZnJvbVxyXG4gICAqICAgICAgICAgICAgICAgICAgIGBjb250YWluZXJgXHJcbiAgICovXHJcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xyXG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXHJcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcclxuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFN0cmljdGx5IHNwZWFraW5nLCB1bm1vdW50aW5nIHdvbid0IGNhdXNlIGFcclxuICAgIC8vIHJlbmRlciBidXQgd2Ugc3RpbGwgZG9uJ3QgZXhwZWN0IHRvIGJlIGluIGEgcmVuZGVyIGNhbGwgaGVyZS4pXHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcclxuXHJcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCc0MCcpIDogdm9pZCAwO1xyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgJyArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpIDogdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKTtcclxuICAgIGlmICghcHJldkNvbXBvbmVudCkge1xyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBiZWluZyB1bm1vdW50ZWQgd2FzIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgaXNuJ3QgYVxyXG4gICAgICAvLyByb290IG5vZGUuXHJcbiAgICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cclxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGNvbnRhaW5lci5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpO1xyXG5cclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJykgOiB2b2lkIDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3ByZXZDb21wb25lbnQuX2luc3RhbmNlLnJvb3RJRF07XHJcbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXModW5tb3VudENvbXBvbmVudEZyb21Ob2RlLCBwcmV2Q29tcG9uZW50LCBjb250YWluZXIsIGZhbHNlKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0sXHJcblxyXG4gIF9tb3VudEltYWdlSW50b05vZGU6IGZ1bmN0aW9uIChtYXJrdXAsIGNvbnRhaW5lciwgaW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbikge1xyXG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtb3VudENvbXBvbmVudEludG9Ob2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IHZhbGlkLicpIDogX3Byb2RJbnZhcmlhbnQoJzQxJykgOiB2b2lkIDA7XHJcblxyXG4gICAgaWYgKHNob3VsZFJldXNlTWFya3VwKSB7XHJcbiAgICAgIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xyXG4gICAgICBpZiAoUmVhY3RNYXJrdXBDaGVja3N1bS5jYW5SZXVzZU1hcmt1cChtYXJrdXAsIHJvb3RFbGVtZW50KSkge1xyXG4gICAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUoaW5zdGFuY2UsIHJvb3RFbGVtZW50KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcclxuICAgICAgICByb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xyXG5cclxuICAgICAgICB2YXIgcm9vdE1hcmt1cCA9IHJvb3RFbGVtZW50Lm91dGVySFRNTDtcclxuICAgICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUsIGNoZWNrc3VtKTtcclxuXHJcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRNYXJrdXAgPSBtYXJrdXA7XHJcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIC8vIGJlY2F1c2Ugcm9vdE1hcmt1cCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLCB2YXJpb3VzIG5vcm1hbGl6YXRpb25zXHJcbiAgICAgICAgICAvLyB3aWxsIGhhdmUgb2NjdXJyZWQgd2hpY2ggd2lsbCBub3QgYmUgcHJlc2VudCBpbiBgbWFya3VwYC4gSGVyZSxcclxuICAgICAgICAgIC8vIGluc2VydCBtYXJrdXAgaW50byBhIDxkaXY+IG9yIDxpZnJhbWU+IGRlcGVuZGluZyBvbiB0aGUgY29udGFpbmVyXHJcbiAgICAgICAgICAvLyB0eXBlIHRvIHBlcmZvcm0gdGhlIHNhbWUgbm9ybWFsaXphdGlvbnMgYmVmb3JlIGNvbXBhcmluZy5cclxuICAgICAgICAgIHZhciBub3JtYWxpemVyO1xyXG4gICAgICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUpIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBub3JtYWxpemVyLmlubmVySFRNTCA9IG1hcmt1cDtcclxuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuaW5uZXJIVE1MO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vcm1hbGl6ZXIpO1xyXG4gICAgICAgICAgICBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC53cml0ZShtYXJrdXApO1xyXG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub3JtYWxpemVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChub3JtYWxpemVkTWFya3VwLCByb290TWFya3VwKTtcclxuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9ICcgKGNsaWVudCkgJyArIG5vcm1hbGl6ZWRNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCkgKyAnXFxuIChzZXJ2ZXIpICcgKyByb290TWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApO1xyXG5cclxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uIHRoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3Ugc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyBhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZTpcXG4lcycsIGRpZmZlcmVuY2UpIDogX3Byb2RJbnZhcmlhbnQoJzQyJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XHJcblxyXG4gICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IGJ1dCB5b3UgZGlkblxcJ3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFdlIGNhblxcJ3QgZG8gdGhpcyB3aXRob3V0IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IF9wcm9kSW52YXJpYW50KCc0MycpIDogdm9pZCAwO1xyXG5cclxuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XHJcbiAgICAgIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XHJcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xyXG4gICAgICB9XHJcbiAgICAgIERPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUoY29udGFpbmVyLCBtYXJrdXAsIG51bGwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2V0SW5uZXJIVE1MKGNvbnRhaW5lciwgbWFya3VwKTtcclxuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZShpbnN0YW5jZSwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHZhciBob3N0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lci5maXJzdENoaWxkKTtcclxuICAgICAgaWYgKGhvc3ROb2RlLl9kZWJ1Z0lEICE9PSAwKSB7XHJcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XHJcbiAgICAgICAgICBpbnN0YW5jZUlEOiBob3N0Tm9kZS5fZGVidWdJRCxcclxuICAgICAgICAgIHR5cGU6ICdtb3VudCcsXHJcbiAgICAgICAgICBwYXlsb2FkOiBtYXJrdXAudG9TdHJpbmcoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xyXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xyXG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XHJcblxyXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcclxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XHJcbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZFJlY29uY2lsZXInKTtcclxuXHJcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xyXG52YXIgZmxhdHRlbkNoaWxkcmVuID0gcmVxdWlyZSgnLi9mbGF0dGVuQ2hpbGRyZW4nKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG5cclxuLyoqXHJcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBtYXJrdXAgdG8gYmUgcmVuZGVyZWQgYW5kIGluc2VydGVkIGF0IGEgc3VwcGxpZWQgaW5kZXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZUluc2VydE1hcmt1cChtYXJrdXAsIGFmdGVyTm9kZSwgdG9JbmRleCkge1xyXG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogJ0lOU0VSVF9NQVJLVVAnLFxyXG4gICAgY29udGVudDogbWFya3VwLFxyXG4gICAgZnJvbUluZGV4OiBudWxsLFxyXG4gICAgZnJvbU5vZGU6IG51bGwsXHJcbiAgICB0b0luZGV4OiB0b0luZGV4LFxyXG4gICAgYWZ0ZXJOb2RlOiBhZnRlck5vZGVcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggU291cmNlIGluZGV4IG9mIHRoZSBleGlzdGluZyBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcclxuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6ICdNT1ZFX0VYSVNUSU5HJyxcclxuICAgIGNvbnRlbnQ6IG51bGwsXHJcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxyXG4gICAgZnJvbU5vZGU6IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShjaGlsZCksXHJcbiAgICB0b0luZGV4OiB0b0luZGV4LFxyXG4gICAgYWZ0ZXJOb2RlOiBhZnRlck5vZGVcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHJlbW92aW5nIGFuIGVsZW1lbnQgYXQgYW4gaW5kZXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSkge1xyXG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogJ1JFTU9WRV9OT0RFJyxcclxuICAgIGNvbnRlbnQ6IG51bGwsXHJcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxyXG4gICAgZnJvbU5vZGU6IG5vZGUsXHJcbiAgICB0b0luZGV4OiBudWxsLFxyXG4gICAgYWZ0ZXJOb2RlOiBudWxsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBzZXR0aW5nIHRoZSBtYXJrdXAgb2YgYSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZVNldE1hcmt1cChtYXJrdXApIHtcclxuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6ICdTRVRfTUFSS1VQJyxcclxuICAgIGNvbnRlbnQ6IG1hcmt1cCxcclxuICAgIGZyb21JbmRleDogbnVsbCxcclxuICAgIGZyb21Ob2RlOiBudWxsLFxyXG4gICAgdG9JbmRleDogbnVsbCxcclxuICAgIGFmdGVyTm9kZTogbnVsbFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3Igc2V0dGluZyB0aGUgdGV4dCBjb250ZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIG1ha2VUZXh0Q29udGVudCh0ZXh0Q29udGVudCkge1xyXG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogJ1RFWFRfQ09OVEVOVCcsXHJcbiAgICBjb250ZW50OiB0ZXh0Q29udGVudCxcclxuICAgIGZyb21JbmRleDogbnVsbCxcclxuICAgIGZyb21Ob2RlOiBudWxsLFxyXG4gICAgdG9JbmRleDogbnVsbCxcclxuICAgIGFmdGVyTm9kZTogbnVsbFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQdXNoIGFuIHVwZGF0ZSwgaWYgYW55LCBvbnRvIHRoZSBxdWV1ZS4gQ3JlYXRlcyBhIG5ldyBxdWV1ZSBpZiBub25lIGlzXHJcbiAqIHBhc3NlZCBhbmQgYWx3YXlzIHJldHVybnMgdGhlIHF1ZXVlLiBNdXRhdGl2ZS5cclxuICovXHJcbmZ1bmN0aW9uIGVucXVldWUocXVldWUsIHVwZGF0ZSkge1xyXG4gIGlmICh1cGRhdGUpIHtcclxuICAgIHF1ZXVlID0gcXVldWUgfHwgW107XHJcbiAgICBxdWV1ZS5wdXNoKHVwZGF0ZSk7XHJcbiAgfVxyXG4gIHJldHVybiBxdWV1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3NlcyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHByb2Nlc3NRdWV1ZShpbnN0LCB1cGRhdGVRdWV1ZSkge1xyXG4gIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyhpbnN0LCB1cGRhdGVRdWV1ZSk7XHJcbn1cclxuXHJcbnZhciBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiA9IGVtcHR5RnVuY3Rpb247XHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdmFyIGdldERlYnVnSUQgPSBmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgaWYgKCFpbnN0Ll9kZWJ1Z0lEKSB7XHJcbiAgICAgIC8vIENoZWNrIGZvciBBUlQtbGlrZSBpbnN0YW5jZXMuIFRPRE86IFRoaXMgaXMgc2lsbHkvZ3Jvc3MuXHJcbiAgICAgIHZhciBpbnRlcm5hbDtcclxuICAgICAgaWYgKGludGVybmFsID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdCkpIHtcclxuICAgICAgICBpbnN0ID0gaW50ZXJuYWw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpbnN0Ll9kZWJ1Z0lEO1xyXG4gIH07XHJcbiAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcclxuICAgIHZhciBkZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcclxuICAgIC8vIFRPRE86IFJlYWN0IE5hdGl2ZSBlbXB0eSBjb21wb25lbnRzIGFyZSBhbHNvIG11bHRpY2hpbGQuXHJcbiAgICAvLyBUaGlzIG1lYW5zIHRoZXkgc3RpbGwgZ2V0IGludG8gdGhpcyBtZXRob2QgYnV0IGRvbid0IGhhdmUgX2RlYnVnSUQuXHJcbiAgICBpZiAoZGVidWdJRCAhPT0gMCkge1xyXG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZHJlbiA/IE9iamVjdC5rZXlzKGNoaWxkcmVuKS5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiBjaGlsZHJlbltrZXldLl9kZWJ1Z0lEO1xyXG4gICAgICB9KSA6IFtdKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVhY3RNdWx0aUNoaWxkIGFyZSBjYXBhYmxlIG9mIHJlY29uY2lsaW5nIG11bHRpcGxlIGNoaWxkcmVuLlxyXG4gKlxyXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBvbmVudHMgdGhhdCBtdXN0IHJlY29uY2lsZSBtdWx0aXBsZVxyXG4gICAqIGNoaWxkcmVuLiBUaGlzIGlzIHVzZWQgYnkgYFJlYWN0RE9NQ29tcG9uZW50YCB0byBtb3VudCwgdXBkYXRlLCBhbmRcclxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXHJcbiAgICpcclxuICAgKiBAbGVuZHMge1JlYWN0TXVsdGlDaGlsZC5wcm90b3R5cGV9XHJcbiAgICovXHJcbiAgTWl4aW46IHtcclxuXHJcbiAgICBfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB2YXIgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XHJcbiAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuICAgIH0sXHJcblxyXG4gICAgX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW47XHJcbiAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcclxuICAgICAgICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBzZWxmRGVidWdJRCk7XHJcbiAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcclxuICAgICAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgc2VsZkRlYnVnSUQpO1xyXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XHJcbiAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcclxuICAgICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGRyZW4gTmVzdGVkIGNoaWxkIG1hcHMuXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgbW91bnRlZCByZXByZXNlbnRhdGlvbnMuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgbW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xyXG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xyXG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gY2hpbGRyZW47XHJcblxyXG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcclxuICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbmFtZV07XHJcbiAgICAgICAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xyXG4gICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xyXG4gICAgICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleCsrO1xyXG4gICAgICAgICAgbW91bnRJbWFnZXMucHVzaChtb3VudEltYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBjaGlsZHJlbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtb3VudEltYWdlcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIHRleHQgY29udGVudCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRDb250ZW50IFN0cmluZyBvZiBjb250ZW50LlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVRleHRDb250ZW50OiBmdW5jdGlvbiAobmV4dENvbnRlbnQpIHtcclxuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XHJcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXHJcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcclxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAhZmFsc2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIFNldCBuZXcgdGV4dCBjb250ZW50LlxyXG4gICAgICB2YXIgdXBkYXRlcyA9IFttYWtlVGV4dENvbnRlbnQobmV4dENvbnRlbnQpXTtcclxuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbWFya3VwIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dE1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZU1hcmt1cDogZnVuY3Rpb24gKG5leHRNYXJrdXApIHtcclxuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XHJcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXHJcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcclxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAhZmFsc2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VTZXRNYXJrdXAobmV4dE1hcmt1cCldO1xyXG4gICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBuZXcgY2hpbGRyZW4uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxyXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgIC8vIEhvb2sgdXNlZCBieSBSZWFjdCBBUlRcclxuICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXHJcbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICAgKiBAZmluYWxcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xyXG4gICAgICB2YXIgcmVtb3ZlZE5vZGVzID0ge307XHJcbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xyXG4gICAgICB2YXIgbmV4dENoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcclxuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIgdXBkYXRlcyA9IG51bGw7XHJcbiAgICAgIHZhciBuYW1lO1xyXG4gICAgICAvLyBgbmV4dEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBjaGlsZCBpbiBgbmV4dENoaWxkcmVuYCwgYnV0XHJcbiAgICAgIC8vIGBsYXN0SW5kZXhgIHdpbGwgYmUgdGhlIGxhc3QgaW5kZXggdmlzaXRlZCBpbiBgcHJldkNoaWxkcmVuYC5cclxuICAgICAgdmFyIG5leHRJbmRleCA9IDA7XHJcbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xyXG4gICAgICAvLyBgbmV4dE1vdW50SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIG5ld2x5IG1vdW50ZWQgY2hpbGQuXHJcbiAgICAgIHZhciBuZXh0TW91bnRJbmRleCA9IDA7XHJcbiAgICAgIHZhciBsYXN0UGxhY2VkTm9kZSA9IG51bGw7XHJcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcclxuICAgICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xyXG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XHJcbiAgICAgICAgaWYgKHByZXZDaGlsZCA9PT0gbmV4dENoaWxkKSB7XHJcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLm1vdmVDaGlsZChwcmV2Q2hpbGQsIGxhc3RQbGFjZWROb2RlLCBuZXh0SW5kZXgsIGxhc3RJbmRleCkpO1xyXG4gICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xyXG4gICAgICAgICAgcHJldkNoaWxkLl9tb3VudEluZGV4ID0gbmV4dEluZGV4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAocHJldkNoaWxkKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgYF9tb3VudEluZGV4YCBnZXRzIHVuc2V0IGJ5IHVubW91bnRpbmcuXHJcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcclxuICAgICAgICAgICAgLy8gVGhlIGByZW1vdmVkTm9kZXNgIGxvb3AgYmVsb3cgd2lsbCBhY3R1YWxseSByZW1vdmUgdGhlIGNoaWxkLlxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXHJcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl9tb3VudENoaWxkQXRJbmRleChuZXh0Q2hpbGQsIG1vdW50SW1hZ2VzW25leHRNb3VudEluZGV4XSwgbGFzdFBsYWNlZE5vZGUsIG5leHRJbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpKTtcclxuICAgICAgICAgIG5leHRNb3VudEluZGV4Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5leHRJbmRleCsrO1xyXG4gICAgICAgIGxhc3RQbGFjZWROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKG5leHRDaGlsZCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxyXG4gICAgICBmb3IgKG5hbWUgaW4gcmVtb3ZlZE5vZGVzKSB7XHJcbiAgICAgICAgaWYgKHJlbW92ZWROb2Rlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZHJlbltuYW1lXSwgcmVtb3ZlZE5vZGVzW25hbWVdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh1cGRhdGVzKSB7XHJcbiAgICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW47XHJcblxyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbmV4dENoaWxkcmVuKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxyXG4gICAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuIEl0IGRvZXMgbm90IGFjdHVhbGx5IHBlcmZvcm0gYW55XHJcbiAgICAgKiBiYWNrZW5kIG9wZXJhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHNhZmVseSkge1xyXG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XHJcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpO1xyXG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGUgc3VwcGxpZWQgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdmUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4LCBsYXN0SW5kZXgpIHtcclxuICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIGBjaGlsZGAgaXMgbGVzcyB0aGFuIGBsYXN0SW5kZXhgLCB0aGVuIGl0IG5lZWRzIHRvXHJcbiAgICAgIC8vIGJlIG1vdmVkLiBPdGhlcndpc2UsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgaXQgYmVjYXVzZSBhIGNoaWxkIHdpbGwgYmVcclxuICAgICAgLy8gaW5zZXJ0ZWQgb3IgbW92ZWQgYmVmb3JlIGBjaGlsZGAuXHJcbiAgICAgIGlmIChjaGlsZC5fbW91bnRJbmRleCA8IGxhc3RJbmRleCkge1xyXG4gICAgICAgIHJldHVybiBtYWtlTW92ZShjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBjb21wb25lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIGNyZWF0ZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb3VudEltYWdlIE1hcmt1cCB0byBpbnNlcnQuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSkge1xyXG4gICAgICByZXR1cm4gbWFrZUluc2VydE1hcmt1cChtb3VudEltYWdlLCBhZnRlck5vZGUsIGNoaWxkLl9tb3VudEluZGV4KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgY29tcG9uZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENoaWxkIHRvIHJlbW92ZS5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xyXG4gICAgICByZXR1cm4gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW91bnRzIGEgY2hpbGQgd2l0aCB0aGUgc3VwcGxpZWQgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdW50LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cclxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9tb3VudENoaWxkQXRJbmRleDogZnVuY3Rpb24gKGNoaWxkLCBtb3VudEltYWdlLCBhZnRlck5vZGUsIGluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xyXG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVDaGlsZChjaGlsZCwgYWZ0ZXJOb2RlLCBtb3VudEltYWdlKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbm1vdW50cyBhIHJlbmRlcmVkIGNoaWxkLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF91bm1vdW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xyXG4gICAgICB2YXIgdXBkYXRlID0gdGhpcy5yZW1vdmVDaGlsZChjaGlsZCwgbm9kZSk7XHJcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gbnVsbDtcclxuICAgICAgcmV0dXJuIHVwZGF0ZTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG52YXIgUmVhY3ROb2RlVHlwZXMgPSB7XHJcbiAgSE9TVDogMCxcclxuICBDT01QT1NJVEU6IDEsXHJcbiAgRU1QVFk6IDIsXHJcblxyXG4gIGdldFR5cGU6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xyXG4gICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuRU1QVFk7XHJcbiAgICB9IGVsc2UgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygbm9kZS50eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkNPTVBPU0lURTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuSE9TVDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgIWZhbHNlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgbm9kZTogJXMnLCBub2RlKSA6IF9wcm9kSW52YXJpYW50KCcyNicsIG5vZGUpIDogdm9pZCAwO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROb2RlVHlwZXM7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxyXG4gKiBAZmluYWxcclxuICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRPd25lcihvYmplY3QpIHtcclxuICByZXR1cm4gISEob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuYXR0YWNoUmVmID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmplY3QuZGV0YWNoUmVmID09PSAnZnVuY3Rpb24nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBBbGwgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL2JlaW5nLy8gcmVmZXJlbmNlZCBieSBvd25lciBjb21wb25lbnRzLCBidXRcclxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXHJcbiAqIFRoZSBuYW1lZCByZWZlcmVuY2UgaXMga25vd24gYXMgYSBcInJlZlwiLlxyXG4gKlxyXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cclxuICpcclxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgICByZXR1cm4gKFxyXG4gKiAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XHJcbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XHJcbiAqICAgICAgICAgPC9kaXY+XHJcbiAqICAgICAgICk7XHJcbiAqICAgICB9LFxyXG4gKiAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmhhbmRsZUNsaWNrKCk7XHJcbiAqICAgICB9LFxyXG4gKiAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmluaXRpYWxpemUoKTtcclxuICogICAgIH1cclxuICogICB9KTtcclxuICpcclxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXHJcbiAqIGNvbnRyb2wgZGF0YSB0aGF0IGlzIG5vdCBoYW5kbGVkIGJ5IFJlYWN0J3MgZGF0YSBmbG93LlxyXG4gKlxyXG4gKiBAY2xhc3MgUmVhY3RPd25lclxyXG4gKi9cclxudmFyIFJlYWN0T3duZXIgPSB7XHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIGNvbXBvbmVudCBieSByZWYgdG8gYW4gb3duZXIgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byByZWZlcmVuY2UuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIGJ5IHdoaWNoIHRvIHJlZmVyIHRvIHRoZSBjb21wb25lbnQuXHJcbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXHJcbiAgICogQGZpbmFsXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgYWRkQ29tcG9uZW50QXNSZWZUbzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xyXG4gICAgIWlzVmFsaWRPd25lcihvd25lcikgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWRkQ29tcG9uZW50QXNSZWZUbyguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTknKSA6IHZvaWQgMDtcclxuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBieSByZWYgZnJvbSBhbiBvd25lciBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBvZiB0aGUgcmVmIHRvIHJlbW92ZS5cclxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0aGUgcmVmIGlzIHJlY29yZGVkLlxyXG4gICAqIEBmaW5hbFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xyXG4gICAgIWlzVmFsaWRPd25lcihvd25lcikgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSByZW1vdmluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTIwJykgOiB2b2lkIDA7XHJcbiAgICB2YXIgb3duZXJQdWJsaWNJbnN0YW5jZSA9IG93bmVyLmdldFB1YmxpY0luc3RhbmNlKCk7XHJcbiAgICAvLyBDaGVjayB0aGF0IGBjb21wb25lbnRgJ3Mgb3duZXIgaXMgc3RpbGwgYWxpdmUgYW5kIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmXHJcbiAgICAvLyBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvIGRldGFjaCB0aGUgcmVmIGlmIGFub3RoZXIgY29tcG9uZW50IHN0b2xlIGl0LlxyXG4gICAgaWYgKG93bmVyUHVibGljSW5zdGFuY2UgJiYgb3duZXJQdWJsaWNJbnN0YW5jZS5yZWZzW3JlZl0gPT09IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKSB7XHJcbiAgICAgIG93bmVyLmRldGFjaFJlZihyZWYpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xyXG5cclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcclxuICAgIHByb3A6ICdwcm9wJyxcclxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcclxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXHJcbiAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xyXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XHJcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xyXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xyXG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XHJcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcclxudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcclxuXHJcbi8qKlxyXG4gKiBFbnN1cmVzIHRoYXQsIHdoZW4gcG9zc2libGUsIHRoZSBzZWxlY3Rpb24gcmFuZ2UgKGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0XHJcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxyXG4gKi9cclxudmFyIFNFTEVDVElPTl9SRVNUT1JBVElPTiA9IHtcclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cclxuICAgKi9cclxuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9ufSBzZWwgU2VsZWN0aW9uIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gYGluaXRpYWxpemVgLlxyXG4gICAqL1xyXG4gIGNsb3NlOiBSZWFjdElucHV0U2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb25cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdXBwcmVzc2VzIGV2ZW50cyAoYmx1ci9mb2N1cykgdGhhdCBjb3VsZCBiZSBpbmFkdmVydGVudGx5IGRpc3BhdGNoZWQgZHVlIHRvXHJcbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXHJcbiAqIERPTSkuXHJcbiAqL1xyXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVuYWJsZWQgc3RhdHVzIG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZVxyXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cclxuICAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcclxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKGZhbHNlKTtcclxuICAgIHJldHVybiBjdXJyZW50bHlFbmFibGVkO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcclxuICAgKiAgIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZSB0aGUgcmVjb25jaWxpYXRpb24gb2NjdXJyZWQuIGBjbG9zZWBcclxuICAgKiAgIHJlc3RvcmVzIHRoZSBwcmV2aW91cyB2YWx1ZS5cclxuICAgKi9cclxuICBjbG9zZTogZnVuY3Rpb24gKHByZXZpb3VzbHlFbmFibGVkKSB7XHJcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChwcmV2aW91c2x5RW5hYmxlZCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcclxuICogYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGR1cmluZyB0aGUgdHJhbnNhY3Rpb24uXHJcbiAqL1xyXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXHJcbiAgICovXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBBZnRlciBET00gaXMgZmx1c2hlZCwgaW52b2tlIGFsbCByZWdpc3RlcmVkIGBvbkRPTVJlYWR5YCBjYWxsYmFja3MuXHJcbiAgICovXHJcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5Lm5vdGlmeUFsbCgpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xyXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXHJcbiAqIGVhY2ggb3RoZXIuXHJcbiAqL1xyXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbU0VMRUNUSU9OX1JFU1RPUkFUSU9OLCBFVkVOVF9TVVBQUkVTU0lPTiwgT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XHJcbiAgICBpbml0aWFsaXplOiBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkZsdXNoLFxyXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDdXJyZW50bHk6XHJcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XHJcbiAqIC0gU3VwcHJlc3NlcyBldmVudHMuXHJcbiAqIC0gUmVzdG9yZXMgc2VsZWN0aW9uIHJhbmdlLlxyXG4gKlxyXG4gKiBGdXR1cmU6XHJcbiAqIC0gUmVzdG9yZSBkb2N1bWVudC9vdmVyZmxvdyBzY3JvbGwgcG9zaXRpb25zIHRoYXQgd2VyZSB1bmludGVudGlvbmFsbHlcclxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cclxuICogLSBJbXBsZW1lbnQvaW50ZWdyYXRlIHdpdGggY3VzdG9taXplZCBjb25zdHJhaW50IGJhc2VkIGxheW91dCBzeXN0ZW0gYW5kIGtlZXBcclxuICogICB0cmFjayBvZiB3aGljaCBkaW1lbnNpb25zIG11c3QgYmUgcmVtZWFzdXJlZC5cclxuICpcclxuICogQGNsYXNzIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24odXNlQ3JlYXRlRWxlbWVudCkge1xyXG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcclxuICAvLyBPbmx5IHNlcnZlci1zaWRlIHJlbmRlcmluZyByZWFsbHkgbmVlZHMgdGhpcyBvcHRpb24gKHNlZVxyXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ2ApLCBidXQgc2VydmVyLXNpZGUgdXNlc1xyXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uYCBpbnN0ZWFkLiBUaGlzIG9wdGlvbiBpcyBoZXJlIHNvIHRoYXQgaXQnc1xyXG4gIC8vIGFjY2Vzc2libGUgYW5kIGRlZmF1bHRzIHRvIGZhbHNlIHdoZW4gYFJlYWN0RE9NQ29tcG9uZW50YCBhbmRcclxuICAvLyBgUmVhY3RET01UZXh0Q29tcG9uZW50YCBjaGVja3MgaXQgaW4gYG1vdW50Q29tcG9uZW50YC5gXHJcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZhbHNlO1xyXG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XHJcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gdXNlQ3JlYXRlRWxlbWVudDtcclxufVxyXG5cclxudmFyIE1peGluID0ge1xyXG4gIC8qKlxyXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAZmluYWxcclxuICAgKiBAcmV0dXJuIHthcnJheTxvYmplY3Q+fSBMaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXHJcbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cclxuICAgKi9cclxuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXHJcbiAgICovXHJcbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBSZWFjdCBhc3luYyBldmVudHMuXHJcbiAgICovXHJcbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBSZWFjdFVwZGF0ZVF1ZXVlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNhdmUgY3VycmVudCB0cmFuc2FjdGlvbiBzdGF0ZSAtLSBpZiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhpcyBtZXRob2QgaXNcclxuICAgKiBwYXNzZWQgdG8gYHJvbGxiYWNrYCwgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmVzZXQgdG8gdGhhdCBzdGF0ZS5cclxuICAgKi9cclxuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyByZWFjdE1vdW50UmVhZHkgaXMgdGhlIG91ciBvbmx5IHN0YXRlZnVsIHdyYXBwZXJcclxuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeS5jaGVja3BvaW50KCk7XHJcbiAgfSxcclxuXHJcbiAgcm9sbGJhY2s6IGZ1bmN0aW9uIChjaGVja3BvaW50KSB7XHJcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yb2xsYmFjayhjaGVja3BvaW50KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xyXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cclxuICAgKi9cclxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5yZWFjdE1vdW50UmVhZHkpO1xyXG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xyXG4gIH1cclxufTtcclxuXHJcbl9hc3NpZ24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCBNaXhpbik7XHJcblxyXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb247IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0UmVmID0gcmVxdWlyZSgnLi9SZWFjdFJlZicpO1xyXG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XHJcblxyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gY2FsbCBSZWFjdFJlZi5hdHRhY2hSZWZzIHdpdGggdGhpcyBjb21wb3NpdGUgY29tcG9uZW50LCBzcGxpdCBvdXRcclxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxyXG4gKi9cclxuZnVuY3Rpb24gYXR0YWNoUmVmcygpIHtcclxuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcclxufVxyXG5cclxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdGhlIGNvbnRhaW5pbmcgaG9zdCBjb21wb25lbnQgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gez9vYmplY3R9IGluZm8gYWJvdXQgdGhlIGhvc3QgY29udGFpbmVyXHJcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cclxuICAgKiBAZmluYWxcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgcGFyZW50RGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xyXG4gICkge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcclxuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVNb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCwgcGFyZW50RGVidWdJRCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBtYXJrdXAgPSBpbnRlcm5hbEluc3RhbmNlLm1vdW50Q29tcG9uZW50KHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgcGFyZW50RGVidWdJRCk7XHJcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcclxuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XHJcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtYXJrdXA7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIHBhc3NlZCB0b1xyXG4gICAqIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwLlxyXG4gICAqL1xyXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIGludGVybmFsSW5zdGFuY2UuZ2V0SG9zdE5vZGUoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxyXG4gICAqXHJcbiAgICogQGZpbmFsXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHNhZmVseSkge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcclxuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVbm1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcclxuICAgIGludGVybmFsSW5zdGFuY2UudW5tb3VudENvbXBvbmVudChzYWZlbHkpO1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcclxuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGEgY29tcG9uZW50IHVzaW5nIGEgbmV3IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXHJcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xyXG4gICAgdmFyIHByZXZFbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XHJcblxyXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBjb250ZXh0ID09PSBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSB7XHJcbiAgICAgIC8vIFNpbmNlIGVsZW1lbnRzIGFyZSBpbW11dGFibGUgYWZ0ZXIgdGhlIG93bmVyIGlzIHJlbmRlcmVkLFxyXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxyXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcclxuICAgICAgLy8gY2hhbmdlIHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSBvZiB0aGUgb3duZXIgd2hpY2ggd291bGQgcmVjcmVhdGVcclxuICAgICAgLy8gdGhlIGVsZW1lbnQuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcclxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcclxuICAgICAgLy8gZGVlcGx5IG11dGF0ZWQgYW5kIHJldXNlZC5cclxuXHJcbiAgICAgIC8vIFRPRE86IEJhaWxpbmcgb3V0IGVhcmx5IGlzIGp1c3QgYSBwZXJmIG9wdGltaXphdGlvbiByaWdodD9cclxuICAgICAgLy8gVE9ETzogUmVtb3ZpbmcgdGhlIHJldHVybiBzdGF0ZW1lbnQgc2hvdWxkIGFmZmVjdCBjb3JyZWN0bmVzcz9cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XHJcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIG5leHRFbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciByZWZzQ2hhbmdlZCA9IFJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KTtcclxuXHJcbiAgICBpZiAocmVmc0NoYW5nZWQpIHtcclxuICAgICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBwcmV2RWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XHJcblxyXG4gICAgaWYgKHJlZnNDaGFuZ2VkICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnJlZiAhPSBudWxsKSB7XHJcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcclxuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBGbHVzaCBhbnkgZGlydHkgY2hhbmdlcyBpbiBhIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIHVwZGF0ZUJhdGNoTnVtYmVyKSB7XHJcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgIT09IHVwZGF0ZUJhdGNoTnVtYmVyKSB7XHJcbiAgICAgIC8vIFRoZSBjb21wb25lbnQncyBlbnF1ZXVlZCBiYXRjaCBudW1iZXIgc2hvdWxkIGFsd2F5cyBiZSB0aGUgY3VycmVudFxyXG4gICAgICAvLyBiYXRjaCBvciB0aGUgZm9sbG93aW5nIG9uZS5cclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCB8fCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PT0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxLCAncGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBVbmV4cGVjdGVkIGJhdGNoIG51bWJlciAoY3VycmVudCAlcywgJyArICdwZW5kaW5nICVzKScsIHVwZGF0ZUJhdGNoTnVtYmVyLCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlcikgOiB2b2lkIDA7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XHJcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkodHJhbnNhY3Rpb24pO1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcclxuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZXI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdE93bmVyJyk7XHJcblxyXG52YXIgUmVhY3RSZWYgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcclxuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmVmKGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gTGVnYWN5IHJlZlxyXG4gICAgUmVhY3RPd25lci5hZGRDb21wb25lbnRBc1JlZlRvKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZXRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XHJcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJlZihudWxsKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gTGVnYWN5IHJlZlxyXG4gICAgUmVhY3RPd25lci5yZW1vdmVDb21wb25lbnRBc1JlZkZyb20oY29tcG9uZW50LCByZWYsIG93bmVyKTtcclxuICB9XHJcbn1cclxuXHJcblJlYWN0UmVmLmF0dGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcclxuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xyXG4gIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgYXR0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcclxuICB9XHJcbn07XHJcblxyXG5SZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzID0gZnVuY3Rpb24gKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xyXG4gIC8vIElmIGVpdGhlciB0aGUgb3duZXIgb3IgYSBgcmVmYCBoYXMgY2hhbmdlZCwgbWFrZSBzdXJlIHRoZSBuZXdlc3Qgb3duZXJcclxuICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxyXG4gIC8vIGhhcyBmb3Jnb3R0ZW4gdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AuIFdlIHVzZSB0aGUgZWxlbWVudCBpbnN0ZWFkXHJcbiAgLy8gb2YgdGhlIHB1YmxpYyB0aGlzLnByb3BzIGJlY2F1c2UgdGhlIHBvc3QgcHJvY2Vzc2luZyBjYW5ub3QgZGV0ZXJtaW5lXHJcbiAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBlbGVtZW50LlxyXG5cclxuICAvLyBUT0RPOiBTaG91bGQgdGhpcyBldmVuIGJlIHBvc3NpYmxlPyBUaGUgb3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlXHJcbiAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxyXG4gIC8vIGlmIHlvdSBzd2FwIHRoZSBrZXlzIG9mIGJ1dCBub3QgdGhlIHJlZnMuIFJlY29uc2lkZXIgd2hlcmUgdGhpcyBjaGVja1xyXG4gIC8vIGlzIG1hZGUuIEl0IHByb2JhYmx5IGJlbG9uZ3Mgd2hlcmUgdGhlIGtleSBjaGVja2luZyBhbmRcclxuICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXHJcblxyXG4gIHZhciBwcmV2UmVmID0gbnVsbDtcclxuICB2YXIgcHJldk93bmVyID0gbnVsbDtcclxuICBpZiAocHJldkVsZW1lbnQgIT09IG51bGwgJiYgdHlwZW9mIHByZXZFbGVtZW50ID09PSAnb2JqZWN0Jykge1xyXG4gICAgcHJldlJlZiA9IHByZXZFbGVtZW50LnJlZjtcclxuICAgIHByZXZPd25lciA9IHByZXZFbGVtZW50Ll9vd25lcjtcclxuICB9XHJcblxyXG4gIHZhciBuZXh0UmVmID0gbnVsbDtcclxuICB2YXIgbmV4dE93bmVyID0gbnVsbDtcclxuICBpZiAobmV4dEVsZW1lbnQgIT09IG51bGwgJiYgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnb2JqZWN0Jykge1xyXG4gICAgbmV4dFJlZiA9IG5leHRFbGVtZW50LnJlZjtcclxuICAgIG5leHRPd25lciA9IG5leHRFbGVtZW50Ll9vd25lcjtcclxuICB9XHJcblxyXG4gIHJldHVybiBwcmV2UmVmICE9PSBuZXh0UmVmIHx8XHJcbiAgLy8gSWYgb3duZXIgY2hhbmdlcyBidXQgd2UgaGF2ZSBhbiB1bmNoYW5nZWQgZnVuY3Rpb24gcmVmLCBkb24ndCB1cGRhdGUgcmVmc1xyXG4gIHR5cGVvZiBuZXh0UmVmID09PSAnc3RyaW5nJyAmJiBuZXh0T3duZXIgIT09IHByZXZPd25lcjtcclxufTtcclxuXHJcblJlYWN0UmVmLmRldGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcclxuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xyXG4gIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgZGV0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xyXG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XHJcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcclxudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyVXBkYXRlUXVldWUnKTtcclxuXHJcbi8qKlxyXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xyXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXHJcbiAqIGVhY2ggb3RoZXIuXHJcbiAqL1xyXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbXTtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XHJcbiAgICBpbml0aWFsaXplOiBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkZsdXNoLFxyXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXHJcbiAgfSk7XHJcbn1cclxuXHJcbnZhciBub29wQ2FsbGJhY2tRdWV1ZSA9IHtcclxuICBlbnF1ZXVlOiBmdW5jdGlvbiAoKSB7fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcclxuICovXHJcbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcclxuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XHJcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IHJlbmRlclRvU3RhdGljTWFya3VwO1xyXG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IGZhbHNlO1xyXG4gIHRoaXMudXBkYXRlUXVldWUgPSBuZXcgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0aGlzKTtcclxufVxyXG5cclxudmFyIE1peGluID0ge1xyXG4gIC8qKlxyXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAZmluYWxcclxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxyXG4gICAqL1xyXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cclxuICAgKi9cclxuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBub29wQ2FsbGJhY2tRdWV1ZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IFJlYWN0IGFzeW5jIGV2ZW50cy5cclxuICAgKi9cclxuICBnZXRVcGRhdGVRdWV1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlUXVldWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcclxuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXHJcbiAgICovXHJcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge30sXHJcblxyXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuICByb2xsYmFjazogZnVuY3Rpb24gKCkge31cclxufTtcclxuXHJcbl9hc3NpZ24oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCBNaXhpbik7XHJcblxyXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb247IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xyXG5cclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb3V0c2lkZSBjb21wb25lbnRXaWxsTW91bnQoKSBvbiB0aGUgc2VydmVyLiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIHVwZGF0ZSBxdWV1ZSB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxyXG4gKiBJdCBkZWxlZ2F0ZXMgdG8gUmVhY3RVcGRhdGVRdWV1ZSB3aGlsZSBzZXJ2ZXIgcmVuZGVyaW5nIGlzIGluIHByb2dyZXNzIGFuZFxyXG4gKiBzd2l0Y2hlcyB0byBSZWFjdE5vb3BVcGRhdGVRdWV1ZSBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cclxuICogQGNsYXNzIFJlYWN0U2VydmVyVXBkYXRlUXVldWVcclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cclxuICovXHJcblxyXG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKHRyYW5zYWN0aW9uKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSk7XHJcblxyXG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQGZpbmFsXHJcbiAgICovXHJcblxyXG5cclxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5pc01vdW50ZWQgPSBmdW5jdGlvbiBpc01vdW50ZWQocHVibGljSW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXHJcbiAgICogaGF2ZSBwcm9jZXNzZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG5cclxuXHJcbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUNhbGxiYWNrID0gZnVuY3Rpb24gZW5xdWV1ZUNhbGxiYWNrKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xyXG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcclxuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2socHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXHJcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXHJcbiAgICpcclxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXHJcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXHJcbiAgICpcclxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXHJcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG5cclxuXHJcbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUZvcmNlVXBkYXRlID0gZnVuY3Rpb24gZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKSB7XHJcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xyXG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxyXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cclxuICAgKlxyXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXHJcbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcblxyXG5cclxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlUmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVJlcGxhY2VTdGF0ZShwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xyXG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcclxuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVN0YXRlKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXHJcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXHJcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XHJcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG5cclxuXHJcbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVNldFN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVNldFN0YXRlKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcclxuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XHJcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFN0YXRlKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlO1xyXG59KCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyVXBkYXRlUXVldWU7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xyXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xyXG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XHJcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xyXG4gIFJlYWN0VXBkYXRlcy5lbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoYXJnKSB7XHJcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xyXG4gIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgcmV0dXJuIHR5cGU7XHJcbiAgfVxyXG4gIHZhciBkaXNwbGF5TmFtZSA9IGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY29uc3RydWN0b3IubmFtZSB8fCB0eXBlO1xyXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYXJnKTtcclxuICBpZiAoa2V5cy5sZW5ndGggPiAwICYmIGtleXMubGVuZ3RoIDwgMjApIHtcclxuICAgIHJldHVybiBkaXNwbGF5TmFtZSArICcgKGtleXM6ICcgKyBrZXlzLmpvaW4oJywgJykgKyAnKSc7XHJcbiAgfVxyXG4gIHJldHVybiBkaXNwbGF5TmFtZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XHJcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XHJcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YXIgY3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xyXG4gICAgICAvLyBPbmx5IHdhcm4gd2hlbiB3ZSBoYXZlIGEgY2FsbGVyTmFtZS4gT3RoZXJ3aXNlIHdlIHNob3VsZCBiZSBzaWxlbnQuXHJcbiAgICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNhbGxpbmcgZnJvbSBlbnF1ZXVlQ2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gd2FyblxyXG4gICAgICAvLyB0aGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBsaWZlY3ljbGUgbWV0aG9kLlxyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY2FsbGVyTmFtZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjdG9yICYmIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJyVzKC4uLik6IENhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgJyArICd3aXRoaW4gYHJlbmRlcmAgb3IgYW5vdGhlciBjb21wb25lbnRcXCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgJyArICdzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgY29uc3RydWN0b3IgJyArICdzaWRlLWVmZmVjdHMgYXJlIGFuIGFudGktcGF0dGVybiwgYnV0IGNhbiBiZSBtb3ZlZCB0byAnICsgJ2Bjb21wb25lbnRXaWxsTW91bnRgLicsIGNhbGxlck5hbWUpIDogdm9pZCAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGludGVybmFsSW5zdGFuY2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWFjdFVwZGF0ZVF1ZXVlIGFsbG93cyBmb3Igc3RhdGUgdXBkYXRlcyB0byBiZSBzY2hlZHVsZWQgaW50byBhIGxhdGVyXHJcbiAqIHJlY29uY2lsaWF0aW9uIHN0ZXAuXHJcbiAqL1xyXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQGZpbmFsXHJcbiAgICovXHJcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XHJcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICAgICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcclxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XHJcbiAgICAgIC8vIER1cmluZyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlciB0aGlzIHdpbGwgc3RpbGwgYmUgbnVsbCBidXQgYWZ0ZXJcclxuICAgICAgLy8gdGhhdCB3aWxsIGFsd2F5cyByZW5kZXIgdG8gc29tZXRoaW5nLiBBdCBsZWFzdCBmb3Igbm93LiBTbyB3ZSBjYW4gdXNlXHJcbiAgICAgIC8vIHRoaXMgaGFjay5cclxuICAgICAgcmV0dXJuICEhaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xyXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FsbGVyTmFtZSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xyXG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcclxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcclxuXHJcbiAgICAvLyBQcmV2aW91c2x5IHdlIHdvdWxkIHRocm93IGFuIGVycm9yIGlmIHdlIGRpZG4ndCBoYXZlIGFuIGludGVybmFsXHJcbiAgICAvLyBpbnN0YW5jZS4gU2luY2Ugd2Ugd2FudCB0byBtYWtlIGl0IGEgbm8tb3AgaW5zdGVhZCwgd2UgbWlycm9yIHRoZSBzYW1lXHJcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXHJcbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gaWdub3JlIGNhbGxiYWNrcyBpbiBjb21wb25lbnRXaWxsTW91bnQuIFNlZVxyXG4gICAgLy8gZW5xdWV1ZVVwZGF0ZXMuXHJcbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcclxuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXHJcbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQuIEVpdGhlciBmaXggaXQgb3IgZGlzYWxsb3cgZG9pbmcgc28gY29tcGxldGVseSBpblxyXG4gICAgLy8gZmF2b3Igb2YgZ2V0SW5pdGlhbFN0YXRlLiBBbHRlcm5hdGl2ZWx5LCB3ZSBjYW4gZGlzYWxsb3dcclxuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxyXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcclxuICB9LFxyXG5cclxuICBlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xyXG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XHJcbiAgICB9XHJcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcclxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cclxuICAgKlxyXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcclxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cclxuICAgKlxyXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcclxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcclxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcclxuXHJcbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXHJcbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxyXG4gICAqXHJcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cclxuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcclxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XHJcblxyXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcclxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xyXG5cclxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXHJcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXHJcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XHJcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldFN0YXRlKCk7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB2b2lkIDA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xyXG5cclxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgfHwgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW10pO1xyXG4gICAgcXVldWUucHVzaChwYXJ0aWFsU3RhdGUpO1xyXG5cclxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XHJcbiAgfSxcclxuXHJcbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCkge1xyXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0VsZW1lbnQgPSBuZXh0RWxlbWVudDtcclxuICAgIC8vIFRPRE86IGludHJvZHVjZSBfcGVuZGluZ0NvbnRleHQgaW5zdGVhZCBvZiBzZXR0aW5nIGl0IGRpcmVjdGx5LlxyXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCA9IG5leHRDb250ZXh0O1xyXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcclxuICB9LFxyXG5cclxuICB2YWxpZGF0ZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcclxuICAgICEoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IF9wcm9kSW52YXJpYW50KCcxMjInLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IHZvaWQgMDtcclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZVF1ZXVlOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXHJcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcclxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xyXG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RmVhdHVyZUZsYWdzJyk7XHJcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xyXG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XHJcbnZhciB1cGRhdGVCYXRjaE51bWJlciA9IDA7XHJcbnZhciBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XHJcbnZhciBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcclxuXHJcbnZhciBiYXRjaGluZ1N0cmF0ZWd5ID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xyXG4gICEoUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gJiYgYmF0Y2hpbmdTdHJhdGVneSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IGluamVjdCBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcyBhbmQgYmF0Y2hpbmcgc3RyYXRlZ3knKSA6IF9wcm9kSW52YXJpYW50KCcxMjMnKSA6IHZvaWQgMDtcclxufVxyXG5cclxudmFyIE5FU1RFRF9VUERBVEVTID0ge1xyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcclxuICB9LFxyXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcclxuICAgICAgLy8gQWRkaXRpb25hbCB1cGRhdGVzIHdlcmUgZW5xdWV1ZWQgYnkgY29tcG9uZW50RGlkVXBkYXRlIGhhbmRsZXJzIG9yXHJcbiAgICAgIC8vIHNpbWlsYXI7IGJlZm9yZSBvdXIgb3duIFVQREFURV9RVUVVRUlORyB3cmFwcGVyIGNsb3Nlcywgd2Ugd2FudCB0byBydW5cclxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXHJcbiAgICAgIC8vIEIsIEIgd2lsbCB1cGRhdGUgYmVmb3JlIHRoZSBjYWxsYmFjayBBJ3MgdXBkYXRlciBwcm92aWRlZCB3aGVuIGNhbGxpbmdcclxuICAgICAgLy8gc2V0U3RhdGUuXHJcbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xyXG4gICAgICBmbHVzaEJhdGNoZWRVcGRhdGVzKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG52YXIgVVBEQVRFX1FVRVVFSU5HID0ge1xyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5yZXNldCgpO1xyXG4gIH0sXHJcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5ub3RpZnlBbGwoKTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbTkVTVEVEX1VQREFURVMsIFVQREFURV9RVUVVRUlOR107XHJcblxyXG5mdW5jdGlvbiBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKCkge1xyXG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcclxuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XHJcbiAgdGhpcy5jYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcclxuICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxyXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi90cnVlKTtcclxufVxyXG5cclxuX2Fzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIHtcclxuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XHJcbiAgfSxcclxuXHJcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xyXG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMuY2FsbGJhY2tRdWV1ZSk7XHJcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUgPSBudWxsO1xyXG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcclxuICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBudWxsO1xyXG4gIH0sXHJcblxyXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhKSB7XHJcbiAgICAvLyBFc3NlbnRpYWxseSBjYWxscyBgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtKG1ldGhvZCwgc2NvcGUsIGEpYFxyXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxyXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLnBlcmZvcm0uY2FsbCh0aGlzLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0sIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24sIG1ldGhvZCwgc2NvcGUsIGEpO1xyXG4gIH1cclxufSk7XHJcblxyXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbik7XHJcblxyXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xyXG4gIGVuc3VyZUluamVjdGVkKCk7XHJcbiAgcmV0dXJuIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpO1xyXG59XHJcblxyXG4vKipcclxuICogQXJyYXkgY29tcGFyYXRvciBmb3IgUmVhY3RDb21wb25lbnRzIGJ5IG1vdW50IG9yZGVyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMSBmaXJzdCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xyXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMiBzZWNvbmQgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcclxuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm4gdmFsdWUgdXNhYmxlIGJ5IEFycmF5LnByb3RvdHlwZS5zb3J0KCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtb3VudE9yZGVyQ29tcGFyYXRvcihjMSwgYzIpIHtcclxuICByZXR1cm4gYzEuX21vdW50T3JkZXIgLSBjMi5fbW91bnRPcmRlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gcnVuQmF0Y2hlZFVwZGF0ZXModHJhbnNhY3Rpb24pIHtcclxuICB2YXIgbGVuID0gdHJhbnNhY3Rpb24uZGlydHlDb21wb25lbnRzTGVuZ3RoO1xyXG4gICEobGVuID09PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBmbHVzaCB0cmFuc2FjdGlvblxcJ3Mgc3RvcmVkIGRpcnR5LWNvbXBvbmVudHMgbGVuZ3RoICglcykgdG8gbWF0Y2ggZGlydHktY29tcG9uZW50cyBhcnJheSBsZW5ndGggKCVzKS4nLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogX3Byb2RJbnZhcmlhbnQoJzEyNCcsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiB2b2lkIDA7XHJcblxyXG4gIC8vIFNpbmNlIHJlY29uY2lsaW5nIGEgY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgb3duZXIgaGllcmFyY2h5IHVzdWFsbHkgKG5vdFxyXG4gIC8vIGFsd2F5cyAtLSBzZWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkpIHdpbGwgcmVjb25jaWxlIGNoaWxkcmVuLCByZWNvbmNpbGVcclxuICAvLyB0aGVtIGJlZm9yZSB0aGVpciBjaGlsZHJlbiBieSBzb3J0aW5nIHRoZSBhcnJheS5cclxuICBkaXJ0eUNvbXBvbmVudHMuc29ydChtb3VudE9yZGVyQ29tcGFyYXRvcik7XHJcblxyXG4gIC8vIEFueSB1cGRhdGVzIGVucXVldWVkIHdoaWxlIHJlY29uY2lsaW5nIG11c3QgYmUgcGVyZm9ybWVkIGFmdGVyIHRoaXMgZW50aXJlXHJcbiAgLy8gYmF0Y2guIE90aGVyd2lzZSwgaWYgZGlydHlDb21wb25lbnRzIGlzIFtBLCBCXSB3aGVyZSBBIGhhcyBjaGlsZHJlbiBCIGFuZFxyXG4gIC8vIEMsIEIgY291bGQgdXBkYXRlIHR3aWNlIGluIGEgc2luZ2xlIGJhdGNoIGlmIEMncyByZW5kZXIgZW5xdWV1ZXMgYW4gdXBkYXRlXHJcbiAgLy8gdG8gQiAoc2luY2UgQiB3b3VsZCBoYXZlIGFscmVhZHkgdXBkYXRlZCwgd2Ugc2hvdWxkIHNraXAgaXQsIGFuZCB0aGUgb25seVxyXG4gIC8vIHdheSB3ZSBjYW4ga25vdyB0byBkbyBzbyBpcyBieSBjaGVja2luZyB0aGUgYmF0Y2ggY291bnRlcikuXHJcbiAgdXBkYXRlQmF0Y2hOdW1iZXIrKztcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgLy8gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBwZW5kaW5nIGNoYW5nZXMgYXBwbHksIGl0IHdpbGwgc3RpbGxcclxuICAgIC8vIGJlIGhlcmUsIGJ1dCB3ZSBhc3N1bWUgdGhhdCBpdCBoYXMgY2xlYXJlZCBpdHMgX3BlbmRpbmdDYWxsYmFja3MgYW5kXHJcbiAgICAvLyB0aGF0IHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBpcyBhIG5vb3AuXHJcbiAgICB2YXIgY29tcG9uZW50ID0gZGlydHlDb21wb25lbnRzW2ldO1xyXG5cclxuICAgIC8vIElmIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBoYXBwZW5zIHRvIGVucXVldWUgYW55IG5ldyB1cGRhdGVzLCB3ZVxyXG4gICAgLy8gc2hvdWxkbid0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgaGFwcGVucywgc29cclxuICAgIC8vIHN0YXNoIHRoZSBjYWxsYmFja3MgZmlyc3RcclxuICAgIHZhciBjYWxsYmFja3MgPSBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3M7XHJcbiAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xyXG5cclxuICAgIHZhciBtYXJrZXJOYW1lO1xyXG4gICAgaWYgKFJlYWN0RmVhdHVyZUZsYWdzLmxvZ1RvcExldmVsUmVuZGVycykge1xyXG4gICAgICB2YXIgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgIC8vIER1Y2sgdHlwZSBUb3BMZXZlbFdyYXBwZXIuIFRoaXMgaXMgcHJvYmFibHkgYWx3YXlzIHRydWUuXHJcbiAgICAgIGlmIChjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnR5cGUuaXNSZWFjdFRvcExldmVsV3JhcHBlcikge1xyXG4gICAgICAgIG5hbWVkQ29tcG9uZW50ID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudDtcclxuICAgICAgfVxyXG4gICAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IHVwZGF0ZTogJyArIG5hbWVkQ29tcG9uZW50LmdldE5hbWUoKTtcclxuICAgICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIFJlYWN0UmVjb25jaWxlci5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoY29tcG9uZW50LCB0cmFuc2FjdGlvbi5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpO1xyXG5cclxuICAgIGlmIChtYXJrZXJOYW1lKSB7XHJcbiAgICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uY2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrc1tqXSwgY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG52YXIgZmx1c2hCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAvLyBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgd2lsbCBjbGVhciB0aGUgZGlydHlDb21wb25lbnRzXHJcbiAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXHJcbiAgLy8gY29tcG9uZW50RGlkVXBkYXRlKSBidXQgd2UgbmVlZCB0byBjaGVjayBoZXJlIHRvbyBpbiBvcmRlciB0byBjYXRjaFxyXG4gIC8vIHVwZGF0ZXMgZW5xdWV1ZWQgYnkgc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCBhc2FwIGNhbGxzLlxyXG4gIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoIHx8IGFzYXBFbnF1ZXVlZCkge1xyXG4gICAgaWYgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcclxuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcclxuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xyXG4gICAgICBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhc2FwRW5xdWV1ZWQpIHtcclxuICAgICAgYXNhcEVucXVldWVkID0gZmFsc2U7XHJcbiAgICAgIHZhciBxdWV1ZSA9IGFzYXBDYWxsYmFja1F1ZXVlO1xyXG4gICAgICBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XHJcbiAgICAgIHF1ZXVlLm5vdGlmeUFsbCgpO1xyXG4gICAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UocXVldWUpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXJrIGEgY29tcG9uZW50IGFzIG5lZWRpbmcgYSByZXJlbmRlciwgYWRkaW5nIGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGFcclxuICogbGlzdCBvZiBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIHRoZSByZXJlbmRlciBvY2N1cnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGNvbXBvbmVudCkge1xyXG4gIGVuc3VyZUluamVjdGVkKCk7XHJcblxyXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xyXG4gIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xyXG4gIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFRoaXMgaXMgY2FsbGVkIGJ5IGVhY2ggdG9wLWxldmVsIHVwZGF0ZVxyXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFN0YXRlLCBmb3JjZVVwZGF0ZSwgZXRjLjsgY3JlYXRpb24gYW5kXHJcbiAgLy8gZGVzdHJ1Y3Rpb24gb2YgdG9wLWxldmVsIGNvbXBvbmVudHMgaXMgZ3VhcmRlZCBpbiBSZWFjdE1vdW50LilcclxuXHJcbiAgaWYgKCFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzKSB7XHJcbiAgICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGVucXVldWVVcGRhdGUsIGNvbXBvbmVudCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xyXG4gIGlmIChjb21wb25lbnQuX3VwZGF0ZUJhdGNoTnVtYmVyID09IG51bGwpIHtcclxuICAgIGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPSB1cGRhdGVCYXRjaE51bWJlciArIDE7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRvIGJlIHJ1biBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJhdGNoaW5nIGN5Y2xlLiBUaHJvd3NcclxuICogaWYgbm8gdXBkYXRlcyBhcmUgY3VycmVudGx5IGJlaW5nIHBlcmZvcm1lZC5cclxuICovXHJcbmZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAhYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXMuYXNhcDogQ2FuXFwndCBlbnF1ZXVlIGFuIGFzYXAgY2FsbGJhY2sgaW4gYSBjb250ZXh0IHdoZXJldXBkYXRlcyBhcmUgbm90IGJlaW5nIGJhdGNoZWQuJykgOiBfcHJvZEludmFyaWFudCgnMTI1JykgOiB2b2lkIDA7XHJcbiAgYXNhcENhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCk7XHJcbiAgYXNhcEVucXVldWVkID0gdHJ1ZTtcclxufVxyXG5cclxudmFyIFJlYWN0VXBkYXRlc0luamVjdGlvbiA9IHtcclxuICBpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKFJlY29uY2lsZVRyYW5zYWN0aW9uKSB7XHJcbiAgICAhUmVjb25jaWxlVHJhbnNhY3Rpb24gPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnKSA6IF9wcm9kSW52YXJpYW50KCcxMjYnKSA6IHZvaWQgMDtcclxuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVjb25jaWxlVHJhbnNhY3Rpb247XHJcbiAgfSxcclxuXHJcbiAgaW5qZWN0QmF0Y2hpbmdTdHJhdGVneTogZnVuY3Rpb24gKF9iYXRjaGluZ1N0cmF0ZWd5KSB7XHJcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogX3Byb2RJbnZhcmlhbnQoJzEyNycpIDogdm9pZCAwO1xyXG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMgPT09ICdmdW5jdGlvbicpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hlZFVwZGF0ZXMoKSBmdW5jdGlvbicpIDogX3Byb2RJbnZhcmlhbnQoJzEyOCcpIDogdm9pZCAwO1xyXG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPT09ICdib29sZWFuJykgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYW4gaXNCYXRjaGluZ1VwZGF0ZXMgYm9vbGVhbiBhdHRyaWJ1dGUnKSA6IF9wcm9kSW52YXJpYW50KCcxMjknKSA6IHZvaWQgMDtcclxuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgUmVhY3RVcGRhdGVzID0ge1xyXG4gIC8qKlxyXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcclxuICAgKiB0byBhbGxvdyBkZXBlbmRlbmN5IGluamVjdGlvbi5cclxuICAgKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IG51bGwsXHJcblxyXG4gIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcclxuICBlbnF1ZXVlVXBkYXRlOiBlbnF1ZXVlVXBkYXRlLFxyXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXHJcbiAgaW5qZWN0aW9uOiBSZWFjdFVwZGF0ZXNJbmplY3Rpb24sXHJcbiAgYXNhcDogYXNhcFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZXM7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAnMTUuNC4yJzsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTlMgPSB7XHJcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcclxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXHJcbn07XHJcblxyXG4vLyBXZSB1c2UgYXR0cmlidXRlcyBmb3IgZXZlcnl0aGluZyBTVkcgc28gbGV0J3MgYXZvaWQgc29tZSBkdXBsaWNhdGlvbiBhbmQgcnVuXHJcbi8vIGNvZGUgaW5zdGVhZC5cclxuLy8gVGhlIGZvbGxvd2luZyBhcmUgYWxsIHNwZWNpZmllZCBpbiB0aGUgSFRNTCBjb25maWcgYWxyZWFkeSBzbyB3ZSBleGNsdWRlIGhlcmUuXHJcbi8vIC0gY2xhc3MgKGFzIGNsYXNzTmFtZSlcclxuLy8gLSBjb2xvclxyXG4vLyAtIGhlaWdodFxyXG4vLyAtIGlkXHJcbi8vIC0gbGFuZ1xyXG4vLyAtIG1heFxyXG4vLyAtIG1lZGlhXHJcbi8vIC0gbWV0aG9kXHJcbi8vIC0gbWluXHJcbi8vIC0gbmFtZVxyXG4vLyAtIHN0eWxlXHJcbi8vIC0gdGFyZ2V0XHJcbi8vIC0gdHlwZVxyXG4vLyAtIHdpZHRoXHJcbnZhciBBVFRSUyA9IHtcclxuICBhY2NlbnRIZWlnaHQ6ICdhY2NlbnQtaGVpZ2h0JyxcclxuICBhY2N1bXVsYXRlOiAwLFxyXG4gIGFkZGl0aXZlOiAwLFxyXG4gIGFsaWdubWVudEJhc2VsaW5lOiAnYWxpZ25tZW50LWJhc2VsaW5lJyxcclxuICBhbGxvd1Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxyXG4gIGFscGhhYmV0aWM6IDAsXHJcbiAgYW1wbGl0dWRlOiAwLFxyXG4gIGFyYWJpY0Zvcm06ICdhcmFiaWMtZm9ybScsXHJcbiAgYXNjZW50OiAwLFxyXG4gIGF0dHJpYnV0ZU5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcclxuICBhdHRyaWJ1dGVUeXBlOiAnYXR0cmlidXRlVHlwZScsXHJcbiAgYXV0b1JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXHJcbiAgYXppbXV0aDogMCxcclxuICBiYXNlRnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXHJcbiAgYmFzZVByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXHJcbiAgYmFzZWxpbmVTaGlmdDogJ2Jhc2VsaW5lLXNoaWZ0JyxcclxuICBiYm94OiAwLFxyXG4gIGJlZ2luOiAwLFxyXG4gIGJpYXM6IDAsXHJcbiAgYnk6IDAsXHJcbiAgY2FsY01vZGU6ICdjYWxjTW9kZScsXHJcbiAgY2FwSGVpZ2h0OiAnY2FwLWhlaWdodCcsXHJcbiAgY2xpcDogMCxcclxuICBjbGlwUGF0aDogJ2NsaXAtcGF0aCcsXHJcbiAgY2xpcFJ1bGU6ICdjbGlwLXJ1bGUnLFxyXG4gIGNsaXBQYXRoVW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcclxuICBjb2xvckludGVycG9sYXRpb246ICdjb2xvci1pbnRlcnBvbGF0aW9uJyxcclxuICBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzOiAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcclxuICBjb2xvclByb2ZpbGU6ICdjb2xvci1wcm9maWxlJyxcclxuICBjb2xvclJlbmRlcmluZzogJ2NvbG9yLXJlbmRlcmluZycsXHJcbiAgY29udGVudFNjcmlwdFR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXHJcbiAgY29udGVudFN0eWxlVHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxyXG4gIGN1cnNvcjogMCxcclxuICBjeDogMCxcclxuICBjeTogMCxcclxuICBkOiAwLFxyXG4gIGRlY2VsZXJhdGU6IDAsXHJcbiAgZGVzY2VudDogMCxcclxuICBkaWZmdXNlQ29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxyXG4gIGRpcmVjdGlvbjogMCxcclxuICBkaXNwbGF5OiAwLFxyXG4gIGRpdmlzb3I6IDAsXHJcbiAgZG9taW5hbnRCYXNlbGluZTogJ2RvbWluYW50LWJhc2VsaW5lJyxcclxuICBkdXI6IDAsXHJcbiAgZHg6IDAsXHJcbiAgZHk6IDAsXHJcbiAgZWRnZU1vZGU6ICdlZGdlTW9kZScsXHJcbiAgZWxldmF0aW9uOiAwLFxyXG4gIGVuYWJsZUJhY2tncm91bmQ6ICdlbmFibGUtYmFja2dyb3VuZCcsXHJcbiAgZW5kOiAwLFxyXG4gIGV4cG9uZW50OiAwLFxyXG4gIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcclxuICBmaWxsOiAwLFxyXG4gIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcclxuICBmaWxsUnVsZTogJ2ZpbGwtcnVsZScsXHJcbiAgZmlsdGVyOiAwLFxyXG4gIGZpbHRlclJlczogJ2ZpbHRlclJlcycsXHJcbiAgZmlsdGVyVW5pdHM6ICdmaWx0ZXJVbml0cycsXHJcbiAgZmxvb2RDb2xvcjogJ2Zsb29kLWNvbG9yJyxcclxuICBmbG9vZE9wYWNpdHk6ICdmbG9vZC1vcGFjaXR5JyxcclxuICBmb2N1c2FibGU6IDAsXHJcbiAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcclxuICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXHJcbiAgZm9udFNpemVBZGp1c3Q6ICdmb250LXNpemUtYWRqdXN0JyxcclxuICBmb250U3RyZXRjaDogJ2ZvbnQtc3RyZXRjaCcsXHJcbiAgZm9udFN0eWxlOiAnZm9udC1zdHlsZScsXHJcbiAgZm9udFZhcmlhbnQ6ICdmb250LXZhcmlhbnQnLFxyXG4gIGZvbnRXZWlnaHQ6ICdmb250LXdlaWdodCcsXHJcbiAgZm9ybWF0OiAwLFxyXG4gIGZyb206IDAsXHJcbiAgZng6IDAsXHJcbiAgZnk6IDAsXHJcbiAgZzE6IDAsXHJcbiAgZzI6IDAsXHJcbiAgZ2x5cGhOYW1lOiAnZ2x5cGgtbmFtZScsXHJcbiAgZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6ICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJyxcclxuICBnbHlwaE9yaWVudGF0aW9uVmVydGljYWw6ICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsXHJcbiAgZ2x5cGhSZWY6ICdnbHlwaFJlZicsXHJcbiAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXHJcbiAgZ3JhZGllbnRVbml0czogJ2dyYWRpZW50VW5pdHMnLFxyXG4gIGhhbmdpbmc6IDAsXHJcbiAgaG9yaXpBZHZYOiAnaG9yaXotYWR2LXgnLFxyXG4gIGhvcml6T3JpZ2luWDogJ2hvcml6LW9yaWdpbi14JyxcclxuICBpZGVvZ3JhcGhpYzogMCxcclxuICBpbWFnZVJlbmRlcmluZzogJ2ltYWdlLXJlbmRlcmluZycsXHJcbiAgJ2luJzogMCxcclxuICBpbjI6IDAsXHJcbiAgaW50ZXJjZXB0OiAwLFxyXG4gIGs6IDAsXHJcbiAgazE6IDAsXHJcbiAgazI6IDAsXHJcbiAgazM6IDAsXHJcbiAgazQ6IDAsXHJcbiAga2VybmVsTWF0cml4OiAna2VybmVsTWF0cml4JyxcclxuICBrZXJuZWxVbml0TGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXHJcbiAga2VybmluZzogMCxcclxuICBrZXlQb2ludHM6ICdrZXlQb2ludHMnLFxyXG4gIGtleVNwbGluZXM6ICdrZXlTcGxpbmVzJyxcclxuICBrZXlUaW1lczogJ2tleVRpbWVzJyxcclxuICBsZW5ndGhBZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxyXG4gIGxldHRlclNwYWNpbmc6ICdsZXR0ZXItc3BhY2luZycsXHJcbiAgbGlnaHRpbmdDb2xvcjogJ2xpZ2h0aW5nLWNvbG9yJyxcclxuICBsaW1pdGluZ0NvbmVBbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcclxuICBsb2NhbDogMCxcclxuICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcclxuICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcclxuICBtYXJrZXJTdGFydDogJ21hcmtlci1zdGFydCcsXHJcbiAgbWFya2VySGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcclxuICBtYXJrZXJVbml0czogJ21hcmtlclVuaXRzJyxcclxuICBtYXJrZXJXaWR0aDogJ21hcmtlcldpZHRoJyxcclxuICBtYXNrOiAwLFxyXG4gIG1hc2tDb250ZW50VW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcclxuICBtYXNrVW5pdHM6ICdtYXNrVW5pdHMnLFxyXG4gIG1hdGhlbWF0aWNhbDogMCxcclxuICBtb2RlOiAwLFxyXG4gIG51bU9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcclxuICBvZmZzZXQ6IDAsXHJcbiAgb3BhY2l0eTogMCxcclxuICBvcGVyYXRvcjogMCxcclxuICBvcmRlcjogMCxcclxuICBvcmllbnQ6IDAsXHJcbiAgb3JpZW50YXRpb246IDAsXHJcbiAgb3JpZ2luOiAwLFxyXG4gIG92ZXJmbG93OiAwLFxyXG4gIG92ZXJsaW5lUG9zaXRpb246ICdvdmVybGluZS1wb3NpdGlvbicsXHJcbiAgb3ZlcmxpbmVUaGlja25lc3M6ICdvdmVybGluZS10aGlja25lc3MnLFxyXG4gIHBhaW50T3JkZXI6ICdwYWludC1vcmRlcicsXHJcbiAgcGFub3NlMTogJ3Bhbm9zZS0xJyxcclxuICBwYXRoTGVuZ3RoOiAncGF0aExlbmd0aCcsXHJcbiAgcGF0dGVybkNvbnRlbnRVbml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxyXG4gIHBhdHRlcm5UcmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcclxuICBwYXR0ZXJuVW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxyXG4gIHBvaW50ZXJFdmVudHM6ICdwb2ludGVyLWV2ZW50cycsXHJcbiAgcG9pbnRzOiAwLFxyXG4gIHBvaW50c0F0WDogJ3BvaW50c0F0WCcsXHJcbiAgcG9pbnRzQXRZOiAncG9pbnRzQXRZJyxcclxuICBwb2ludHNBdFo6ICdwb2ludHNBdFonLFxyXG4gIHByZXNlcnZlQWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcclxuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXHJcbiAgcHJpbWl0aXZlVW5pdHM6ICdwcmltaXRpdmVVbml0cycsXHJcbiAgcjogMCxcclxuICByYWRpdXM6IDAsXHJcbiAgcmVmWDogJ3JlZlgnLFxyXG4gIHJlZlk6ICdyZWZZJyxcclxuICByZW5kZXJpbmdJbnRlbnQ6ICdyZW5kZXJpbmctaW50ZW50JyxcclxuICByZXBlYXRDb3VudDogJ3JlcGVhdENvdW50JyxcclxuICByZXBlYXREdXI6ICdyZXBlYXREdXInLFxyXG4gIHJlcXVpcmVkRXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXHJcbiAgcmVxdWlyZWRGZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxyXG4gIHJlc3RhcnQ6IDAsXHJcbiAgcmVzdWx0OiAwLFxyXG4gIHJvdGF0ZTogMCxcclxuICByeDogMCxcclxuICByeTogMCxcclxuICBzY2FsZTogMCxcclxuICBzZWVkOiAwLFxyXG4gIHNoYXBlUmVuZGVyaW5nOiAnc2hhcGUtcmVuZGVyaW5nJyxcclxuICBzbG9wZTogMCxcclxuICBzcGFjaW5nOiAwLFxyXG4gIHNwZWN1bGFyQ29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcclxuICBzcGVjdWxhckV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXHJcbiAgc3BlZWQ6IDAsXHJcbiAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcclxuICBzdGFydE9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcclxuICBzdGREZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxyXG4gIHN0ZW1oOiAwLFxyXG4gIHN0ZW12OiAwLFxyXG4gIHN0aXRjaFRpbGVzOiAnc3RpdGNoVGlsZXMnLFxyXG4gIHN0b3BDb2xvcjogJ3N0b3AtY29sb3InLFxyXG4gIHN0b3BPcGFjaXR5OiAnc3RvcC1vcGFjaXR5JyxcclxuICBzdHJpa2V0aHJvdWdoUG9zaXRpb246ICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJyxcclxuICBzdHJpa2V0aHJvdWdoVGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLFxyXG4gIHN0cmluZzogMCxcclxuICBzdHJva2U6IDAsXHJcbiAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXHJcbiAgc3Ryb2tlRGFzaG9mZnNldDogJ3N0cm9rZS1kYXNob2Zmc2V0JyxcclxuICBzdHJva2VMaW5lY2FwOiAnc3Ryb2tlLWxpbmVjYXAnLFxyXG4gIHN0cm9rZUxpbmVqb2luOiAnc3Ryb2tlLWxpbmVqb2luJyxcclxuICBzdHJva2VNaXRlcmxpbWl0OiAnc3Ryb2tlLW1pdGVybGltaXQnLFxyXG4gIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXHJcbiAgc3Ryb2tlV2lkdGg6ICdzdHJva2Utd2lkdGgnLFxyXG4gIHN1cmZhY2VTY2FsZTogJ3N1cmZhY2VTY2FsZScsXHJcbiAgc3lzdGVtTGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXHJcbiAgdGFibGVWYWx1ZXM6ICd0YWJsZVZhbHVlcycsXHJcbiAgdGFyZ2V0WDogJ3RhcmdldFgnLFxyXG4gIHRhcmdldFk6ICd0YXJnZXRZJyxcclxuICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxyXG4gIHRleHREZWNvcmF0aW9uOiAndGV4dC1kZWNvcmF0aW9uJyxcclxuICB0ZXh0UmVuZGVyaW5nOiAndGV4dC1yZW5kZXJpbmcnLFxyXG4gIHRleHRMZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcclxuICB0bzogMCxcclxuICB0cmFuc2Zvcm06IDAsXHJcbiAgdTE6IDAsXHJcbiAgdTI6IDAsXHJcbiAgdW5kZXJsaW5lUG9zaXRpb246ICd1bmRlcmxpbmUtcG9zaXRpb24nLFxyXG4gIHVuZGVybGluZVRoaWNrbmVzczogJ3VuZGVybGluZS10aGlja25lc3MnLFxyXG4gIHVuaWNvZGU6IDAsXHJcbiAgdW5pY29kZUJpZGk6ICd1bmljb2RlLWJpZGknLFxyXG4gIHVuaWNvZGVSYW5nZTogJ3VuaWNvZGUtcmFuZ2UnLFxyXG4gIHVuaXRzUGVyRW06ICd1bml0cy1wZXItZW0nLFxyXG4gIHZBbHBoYWJldGljOiAndi1hbHBoYWJldGljJyxcclxuICB2SGFuZ2luZzogJ3YtaGFuZ2luZycsXHJcbiAgdklkZW9ncmFwaGljOiAndi1pZGVvZ3JhcGhpYycsXHJcbiAgdk1hdGhlbWF0aWNhbDogJ3YtbWF0aGVtYXRpY2FsJyxcclxuICB2YWx1ZXM6IDAsXHJcbiAgdmVjdG9yRWZmZWN0OiAndmVjdG9yLWVmZmVjdCcsXHJcbiAgdmVyc2lvbjogMCxcclxuICB2ZXJ0QWR2WTogJ3ZlcnQtYWR2LXknLFxyXG4gIHZlcnRPcmlnaW5YOiAndmVydC1vcmlnaW4teCcsXHJcbiAgdmVydE9yaWdpblk6ICd2ZXJ0LW9yaWdpbi15JyxcclxuICB2aWV3Qm94OiAndmlld0JveCcsXHJcbiAgdmlld1RhcmdldDogJ3ZpZXdUYXJnZXQnLFxyXG4gIHZpc2liaWxpdHk6IDAsXHJcbiAgd2lkdGhzOiAwLFxyXG4gIHdvcmRTcGFjaW5nOiAnd29yZC1zcGFjaW5nJyxcclxuICB3cml0aW5nTW9kZTogJ3dyaXRpbmctbW9kZScsXHJcbiAgeDogMCxcclxuICB4SGVpZ2h0OiAneC1oZWlnaHQnLFxyXG4gIHgxOiAwLFxyXG4gIHgyOiAwLFxyXG4gIHhDaGFubmVsU2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcclxuICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcclxuICB4bGlua0FyY3JvbGU6ICd4bGluazphcmNyb2xlJyxcclxuICB4bGlua0hyZWY6ICd4bGluazpocmVmJyxcclxuICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcclxuICB4bGlua1Nob3c6ICd4bGluazpzaG93JyxcclxuICB4bGlua1RpdGxlOiAneGxpbms6dGl0bGUnLFxyXG4gIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxyXG4gIHhtbEJhc2U6ICd4bWw6YmFzZScsXHJcbiAgeG1sbnM6IDAsXHJcbiAgeG1sbnNYbGluazogJ3htbG5zOnhsaW5rJyxcclxuICB4bWxMYW5nOiAneG1sOmxhbmcnLFxyXG4gIHhtbFNwYWNlOiAneG1sOnNwYWNlJyxcclxuICB5OiAwLFxyXG4gIHkxOiAwLFxyXG4gIHkyOiAwLFxyXG4gIHlDaGFubmVsU2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcclxuICB6OiAwLFxyXG4gIHpvb21BbmRQYW46ICd6b29tQW5kUGFuJ1xyXG59O1xyXG5cclxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xyXG4gIFByb3BlcnRpZXM6IHt9LFxyXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcclxuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXHJcbiAgICB4bGlua0FyY3JvbGU6IE5TLnhsaW5rLFxyXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcclxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXHJcbiAgICB4bGlua1Nob3c6IE5TLnhsaW5rLFxyXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXHJcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxyXG4gICAgeG1sQmFzZTogTlMueG1sLFxyXG4gICAgeG1sTGFuZzogTlMueG1sLFxyXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxyXG4gIH0sXHJcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHt9XHJcbn07XHJcblxyXG5PYmplY3Qua2V5cyhBVFRSUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1trZXldID0gMDtcclxuICBpZiAoQVRUUlNba2V5XSkge1xyXG4gICAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNba2V5XSA9IEFUVFJTW2tleV07XHJcbiAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU1ZHRE9NUHJvcGVydHlDb25maWc7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcclxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XHJcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcclxuXHJcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xyXG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcclxudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xyXG5cclxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XHJcblxyXG52YXIgZXZlbnRUeXBlcyA9IHtcclxuICBzZWxlY3Q6IHtcclxuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XHJcbiAgICAgIGJ1YmJsZWQ6ICdvblNlbGVjdCcsXHJcbiAgICAgIGNhcHR1cmVkOiAnb25TZWxlY3RDYXB0dXJlJ1xyXG4gICAgfSxcclxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbnRleHRNZW51JywgJ3RvcEZvY3VzJywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJywgJ3RvcE1vdXNlVXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cclxuICB9XHJcbn07XHJcblxyXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XHJcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XHJcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcclxudmFyIG1vdXNlRG93biA9IGZhbHNlO1xyXG5cclxuLy8gVHJhY2sgd2hldGhlciBhIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXHJcbi8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxyXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICpcclxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XHJcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcclxuICogQHJldHVybiB7b2JqZWN0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcclxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcclxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxyXG4gICAgfTtcclxuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcclxuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcclxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxyXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXHJcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcclxuICAgIH07XHJcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcclxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGFyZW50RWxlbWVudDogcmFuZ2UucGFyZW50RWxlbWVudCgpLFxyXG4gICAgICB0ZXh0OiByYW5nZS50ZXh0LFxyXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxyXG4gICAgICBsZWZ0OiByYW5nZS5ib3VuZGluZ0xlZnRcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcclxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXHJcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxyXG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcclxuICAvLyB3b24ndCBkaXNwYXRjaC5cclxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ICE9PSBnZXRBY3RpdmVFbGVtZW50KCkpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxyXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQpO1xyXG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XHJcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcclxuXHJcbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5zZWxlY3QsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG5cclxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcclxuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQ7XHJcblxyXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcclxuXHJcbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xyXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cclxuICpcclxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcclxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxyXG4gKiAtIHRleHRhcmVhXHJcbiAqIC0gY29udGVudEVkaXRhYmxlXHJcbiAqXHJcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XHJcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cclxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cclxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxyXG4gKi9cclxudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xyXG5cclxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxyXG5cclxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICAgIGlmICghaGFzTGlzdGVuZXIpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XHJcblxyXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcclxuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXHJcbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcclxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcclxuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xyXG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0b3BCbHVyJzpcclxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XHJcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxyXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXHJcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XHJcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxyXG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcclxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxuXHJcbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXHJcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxyXG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cclxuICAgICAgLy9cclxuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXHJcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXHJcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXHJcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxyXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXHJcbiAgICAgIGNhc2UgJ3RvcFNlbGVjdGlvbkNoYW5nZSc6XHJcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAvLyBmYWxscyB0aHJvdWdoXHJcbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxyXG4gICAgICBjYXNlICd0b3BLZXlVcCc6XHJcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSxcclxuXHJcbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvblNlbGVjdCcpIHtcclxuICAgICAgaGFzTGlzdGVuZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0RXZlbnRQbHVnaW47IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcclxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcclxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XHJcbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQW5pbWF0aW9uRXZlbnQnKTtcclxudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudCcpO1xyXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XHJcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNGb2N1c0V2ZW50Jyk7XHJcbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNLZXlib2FyZEV2ZW50Jyk7XHJcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XHJcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0RyYWdFdmVudCcpO1xyXG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVG91Y2hFdmVudCcpO1xyXG52YXIgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQnKTtcclxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcclxudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1doZWVsRXZlbnQnKTtcclxuXHJcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xyXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG4vKipcclxuICogVHVybnNcclxuICogWydhYm9ydCcsIC4uLl1cclxuICogaW50b1xyXG4gKiBldmVudFR5cGVzID0ge1xyXG4gKiAgICdhYm9ydCc6IHtcclxuICogICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XHJcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcclxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXHJcbiAqICAgICB9LFxyXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXHJcbiAqICAgfSxcclxuICogICAuLi5cclxuICogfTtcclxuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xyXG4gKiAgICd0b3BBYm9ydCc6IHsgc2FtZUNvbmZpZyB9XHJcbiAqIH07XHJcbiAqL1xyXG52YXIgZXZlbnRUeXBlcyA9IHt9O1xyXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge307XHJcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnY2xpY2snLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZycsICdkcmFnRW5kJywgJ2RyYWdFbnRlcicsICdkcmFnRXhpdCcsICdkcmFnTGVhdmUnLCAnZHJhZ092ZXInLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25DaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnZm9jdXMnLCAnaW5wdXQnLCAnaW52YWxpZCcsICdrZXlEb3duJywgJ2tleVByZXNzJywgJ2tleVVwJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VEb3duJywgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAnbW91c2VVcCcsICdwYXN0ZScsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdzY3JvbGwnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoRW5kJywgJ3RvdWNoTW92ZScsICd0b3VjaFN0YXJ0JywgJ3RyYW5zaXRpb25FbmQnLCAndm9sdW1lQ2hhbmdlJywgJ3dhaXRpbmcnLCAnd2hlZWwnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xyXG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xyXG4gIHZhciBvbkV2ZW50ID0gJ29uJyArIGNhcGl0YWxpemVkRXZlbnQ7XHJcbiAgdmFyIHRvcEV2ZW50ID0gJ3RvcCcgKyBjYXBpdGFsaXplZEV2ZW50O1xyXG5cclxuICB2YXIgdHlwZSA9IHtcclxuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XHJcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXHJcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXHJcbiAgICB9LFxyXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdXHJcbiAgfTtcclxuICBldmVudFR5cGVzW2V2ZW50XSA9IHR5cGU7XHJcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcEV2ZW50XSA9IHR5cGU7XHJcbn0pO1xyXG5cclxudmFyIG9uQ2xpY2tMaXN0ZW5lcnMgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGdldERpY3Rpb25hcnlLZXkoaW5zdCkge1xyXG4gIC8vIFByZXZlbnRzIFY4IHBlcmZvcm1hbmNlIGlzc3VlOlxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcclxuICByZXR1cm4gJy4nICsgaW5zdC5fcm9vdE5vZGVJRDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcclxuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XHJcbn1cclxuXHJcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcclxuXHJcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcclxuXHJcbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcclxuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcclxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XHJcbiAgICAgIGNhc2UgJ3RvcEFib3J0JzpcclxuICAgICAgY2FzZSAndG9wQ2FuUGxheSc6XHJcbiAgICAgIGNhc2UgJ3RvcENhblBsYXlUaHJvdWdoJzpcclxuICAgICAgY2FzZSAndG9wRHVyYXRpb25DaGFuZ2UnOlxyXG4gICAgICBjYXNlICd0b3BFbXB0aWVkJzpcclxuICAgICAgY2FzZSAndG9wRW5jcnlwdGVkJzpcclxuICAgICAgY2FzZSAndG9wRW5kZWQnOlxyXG4gICAgICBjYXNlICd0b3BFcnJvcic6XHJcbiAgICAgIGNhc2UgJ3RvcElucHV0JzpcclxuICAgICAgY2FzZSAndG9wSW52YWxpZCc6XHJcbiAgICAgIGNhc2UgJ3RvcExvYWQnOlxyXG4gICAgICBjYXNlICd0b3BMb2FkZWREYXRhJzpcclxuICAgICAgY2FzZSAndG9wTG9hZGVkTWV0YWRhdGEnOlxyXG4gICAgICBjYXNlICd0b3BMb2FkU3RhcnQnOlxyXG4gICAgICBjYXNlICd0b3BQYXVzZSc6XHJcbiAgICAgIGNhc2UgJ3RvcFBsYXknOlxyXG4gICAgICBjYXNlICd0b3BQbGF5aW5nJzpcclxuICAgICAgY2FzZSAndG9wUHJvZ3Jlc3MnOlxyXG4gICAgICBjYXNlICd0b3BSYXRlQ2hhbmdlJzpcclxuICAgICAgY2FzZSAndG9wUmVzZXQnOlxyXG4gICAgICBjYXNlICd0b3BTZWVrZWQnOlxyXG4gICAgICBjYXNlICd0b3BTZWVraW5nJzpcclxuICAgICAgY2FzZSAndG9wU3RhbGxlZCc6XHJcbiAgICAgIGNhc2UgJ3RvcFN1Ym1pdCc6XHJcbiAgICAgIGNhc2UgJ3RvcFN1c3BlbmQnOlxyXG4gICAgICBjYXNlICd0b3BUaW1lVXBkYXRlJzpcclxuICAgICAgY2FzZSAndG9wVm9sdW1lQ2hhbmdlJzpcclxuICAgICAgY2FzZSAndG9wV2FpdGluZyc6XHJcbiAgICAgICAgLy8gSFRNTCBFdmVudHNcclxuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcclxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcclxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xyXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXHJcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cclxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcclxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxyXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0b3BCbHVyJzpcclxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxyXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0b3BDbGljayc6XHJcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXHJcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxyXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICBjYXNlICd0b3BEb3VibGVDbGljayc6XHJcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XHJcbiAgICAgIGNhc2UgJ3RvcE1vdXNlTW92ZSc6XHJcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxyXG4gICAgICAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXHJcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgY2FzZSAndG9wTW91c2VPdXQnOlxyXG4gICAgICBjYXNlICd0b3BNb3VzZU92ZXInOlxyXG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XHJcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RvcERyYWcnOlxyXG4gICAgICBjYXNlICd0b3BEcmFnRW5kJzpcclxuICAgICAgY2FzZSAndG9wRHJhZ0VudGVyJzpcclxuICAgICAgY2FzZSAndG9wRHJhZ0V4aXQnOlxyXG4gICAgICBjYXNlICd0b3BEcmFnTGVhdmUnOlxyXG4gICAgICBjYXNlICd0b3BEcmFnT3Zlcic6XHJcbiAgICAgIGNhc2UgJ3RvcERyYWdTdGFydCc6XHJcbiAgICAgIGNhc2UgJ3RvcERyb3AnOlxyXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RvcFRvdWNoQ2FuY2VsJzpcclxuICAgICAgY2FzZSAndG9wVG91Y2hFbmQnOlxyXG4gICAgICBjYXNlICd0b3BUb3VjaE1vdmUnOlxyXG4gICAgICBjYXNlICd0b3BUb3VjaFN0YXJ0JzpcclxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uRW5kJzpcclxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uSXRlcmF0aW9uJzpcclxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uU3RhcnQnOlxyXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndG9wVHJhbnNpdGlvbkVuZCc6XHJcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndG9wU2Nyb2xsJzpcclxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndG9wV2hlZWwnOlxyXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd0b3BDb3B5JzpcclxuICAgICAgY2FzZSAndG9wQ3V0JzpcclxuICAgICAgY2FzZSAndG9wUGFzdGUnOlxyXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgICFFdmVudENvbnN0cnVjdG9yID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4nLCB0b3BMZXZlbFR5cGUpIDogX3Byb2RJbnZhcmlhbnQoJzg2JywgdG9wTGV2ZWxUeXBlKSA6IHZvaWQgMDtcclxuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcclxuICAgIHJldHVybiBldmVudDtcclxuICB9LFxyXG5cclxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxyXG4gICAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxyXG4gICAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xyXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxyXG4gICAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcclxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25DbGljaycgJiYgIWlzSW50ZXJhY3RpdmUoaW5zdC5fdGFnKSkge1xyXG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcclxuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcclxuICAgICAgaWYgKCFvbkNsaWNrTGlzdGVuZXJzW2tleV0pIHtcclxuICAgICAgICBvbkNsaWNrTGlzdGVuZXJzW2tleV0gPSBFdmVudExpc3RlbmVyLmxpc3Rlbihub2RlLCAnY2xpY2snLCBlbXB0eUZ1bmN0aW9uKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHdpbGxEZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcclxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25DbGljaycgJiYgIWlzSW50ZXJhY3RpdmUoaW5zdC5fdGFnKSkge1xyXG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcclxuICAgICAgb25DbGlja0xpc3RlbmVyc1trZXldLnJlbW92ZSgpO1xyXG4gICAgICBkZWxldGUgb25DbGlja0xpc3RlbmVyc1trZXldO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUV2ZW50UGx1Z2luOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJmYWNlIEV2ZW50XHJcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcclxuICovXHJcbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcclxuICBhbmltYXRpb25OYW1lOiBudWxsLFxyXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxyXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxufVxyXG5cclxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJmYWNlIEV2ZW50XHJcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXHJcbiAqL1xyXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XHJcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cclxuICovXHJcbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgRXZlbnRcclxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xyXG4gKi9cclxudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XHJcbiAgZGF0YTogbnVsbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxufVxyXG5cclxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XHJcblxyXG4vKipcclxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcclxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXHJcbiAqL1xyXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xyXG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XHJcbn1cclxuXHJcblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRHJhZ0V2ZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xyXG5cclxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XHJcbnZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nO1xyXG5cclxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgRXZlbnRcclxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXHJcbiAqL1xyXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XHJcbiAgdHlwZTogbnVsbCxcclxuICB0YXJnZXQ6IG51bGwsXHJcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxyXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxyXG4gIGV2ZW50UGhhc2U6IG51bGwsXHJcbiAgYnViYmxlczogbnVsbCxcclxuICBjYW5jZWxhYmxlOiBudWxsLFxyXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XHJcbiAgfSxcclxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxyXG4gIGlzVHJ1c3RlZDogbnVsbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcclxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cclxuICpcclxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcclxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXHJcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcclxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cclxuICpcclxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxyXG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxyXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHsqfSB0YXJnZXRJbnN0IE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IG5hdGl2ZUV2ZW50VGFyZ2V0IFRhcmdldCBub2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcclxuICAgIGRlbGV0ZSB0aGlzLm5hdGl2ZUV2ZW50O1xyXG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XHJcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XHJcbiAgfVxyXG5cclxuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XHJcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XHJcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xyXG5cclxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XHJcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XHJcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcclxuICAgIH1cclxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xyXG4gICAgaWYgKG5vcm1hbGl6ZSkge1xyXG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xyXG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcclxuICB9XHJcbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcclxuXHJcbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XHJcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xyXG4gICAgaWYgKCFldmVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAhPT0gJ3Vua25vd24nKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgdmFsaWQtdHlwZW9mXHJcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xyXG4gIH0sXHJcblxyXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcclxuICAgIGlmICghZXZlbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcclxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHZhbGlkLXR5cGVvZlxyXG4gICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxyXG4gICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxyXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXHJcbiAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xyXG4gICAgICAvLyBJRSBzcGVjaWZpYykuXHJcbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcclxuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcclxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXHJcbiAgICovXHJcbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKi9cclxuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcclxuXHJcbiAgLyoqXHJcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXHJcbiAgICovXHJcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xyXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHRoaXNbc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXNbaV1dID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbikpO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0b3BQcm9wYWdhdGlvbicsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3N0b3BQcm9wYWdhdGlvbicsIGVtcHR5RnVuY3Rpb24pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG59KTtcclxuXHJcblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xyXG5cclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBpZiAoaXNQcm94eVN1cHBvcnRlZCkge1xyXG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xyXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcclxuICAgICAgY29uc3RydWN0OiBmdW5jdGlvbiAodGFyZ2V0LCBhcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcclxuICAgICAgfSxcclxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIChjb25zdHJ1Y3RvciwgdGhhdCwgYXJncykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcclxuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHByb3AgIT09ICdpc1BlcnNpc3RlbnQnICYmICF0YXJnZXQuY29uc3RydWN0b3IuSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3ApICYmIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgfHwgdGFyZ2V0LmlzUGVyc2lzdGVudCgpLCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSAnICsgJ3NlZWluZyB0aGlzLCB5b3VcXCdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuICcgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xyXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxyXG4gKi9cclxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24gKENsYXNzLCBJbnRlcmZhY2UpIHtcclxuICB2YXIgU3VwZXIgPSB0aGlzO1xyXG5cclxuICB2YXIgRSA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xyXG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xyXG5cclxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcclxuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XHJcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XHJcblxyXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcclxuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XHJcblxyXG4gIFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDbGFzcywgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcclxufTtcclxuXHJcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRXZlbnQ7XHJcblxyXG4vKipcclxuICAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xyXG4gICpcclxuICAqIEBwYXJhbSB7b2JqZWN0fSBTeW50aGV0aWNFdmVudFxyXG4gICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXHJcbiAgKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxyXG4gICovXHJcbmZ1bmN0aW9uIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIGdldFZhbCkge1xyXG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcclxuICByZXR1cm4ge1xyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgc2V0OiBzZXQsXHJcbiAgICBnZXQ6IGdldFxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcclxuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ3NldHRpbmcgdGhlIG1ldGhvZCcgOiAnc2V0dGluZyB0aGUgcHJvcGVydHknO1xyXG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcclxuICAgIHJldHVybiB2YWw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdhY2Nlc3NpbmcgdGhlIG1ldGhvZCcgOiAnYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eSc7XHJcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xyXG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XHJcbiAgICByZXR1cm4gZ2V0VmFsO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xyXG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5pbmdDb25kaXRpb24sICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlIHNlZWluZyB0aGlzLCAnICsgJ3lvdVxcJ3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gJyArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KSA6IHZvaWQgMDtcclxuICB9XHJcbn0iLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxyXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cclxuICovXHJcbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xyXG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cclxuICovXHJcbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxufVxyXG5cclxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgRXZlbnRcclxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxyXG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXHJcbiAqL1xyXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcclxuICBkYXRhOiBudWxsXHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cclxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljSW5wdXRFdmVudCwgSW5wdXRFdmVudEludGVyZmFjZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcclxuXHJcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XHJcbnZhciBnZXRFdmVudEtleSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRLZXknKTtcclxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XHJcblxyXG4vKipcclxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XHJcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xyXG4gKi9cclxudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XHJcbiAga2V5OiBnZXRFdmVudEtleSxcclxuICBsb2NhdGlvbjogbnVsbCxcclxuICBjdHJsS2V5OiBudWxsLFxyXG4gIHNoaWZ0S2V5OiBudWxsLFxyXG4gIGFsdEtleTogbnVsbCxcclxuICBtZXRhS2V5OiBudWxsLFxyXG4gIHJlcGVhdDogbnVsbCxcclxuICBsb2NhbGU6IG51bGwsXHJcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxyXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcclxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcclxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cclxuXHJcbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxyXG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxyXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcclxuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfSxcclxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcclxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cclxuXHJcbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcclxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxyXG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxyXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cclxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xyXG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG4gIH0sXHJcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcclxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcclxuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XHJcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xyXG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcclxuXHJcbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxyXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cclxuICovXHJcbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xyXG4gIHNjcmVlblg6IG51bGwsXHJcbiAgc2NyZWVuWTogbnVsbCxcclxuICBjbGllbnRYOiBudWxsLFxyXG4gIGNsaWVudFk6IG51bGwsXHJcbiAgY3RybEtleTogbnVsbCxcclxuICBzaGlmdEtleTogbnVsbCxcclxuICBhbHRLZXk6IG51bGwsXHJcbiAgbWV0YUtleTogbnVsbCxcclxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXHJcbiAgYnV0dG9uOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xyXG4gICAgLy8gd2hpY2g6ICAxIDIgM1xyXG4gICAgLy8gYnV0dG9uOiAwIDEgMiAoc3RhbmRhcmQpXHJcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xyXG4gICAgaWYgKCd3aGljaCcgaW4gZXZlbnQpIHtcclxuICAgICAgcmV0dXJuIGJ1dHRvbjtcclxuICAgIH1cclxuICAgIC8vIElFPDlcclxuICAgIC8vIHdoaWNoOiAgdW5kZWZpbmVkXHJcbiAgICAvLyBidXR0b246IDAgMCAwXHJcbiAgICAvLyBidXR0b246IDEgNCAyIChvbm1vdXNldXApXHJcbiAgICByZXR1cm4gYnV0dG9uID09PSAyID8gMiA6IGJ1dHRvbiA9PT0gNCA/IDEgOiAwO1xyXG4gIH0sXHJcbiAgYnV0dG9uczogbnVsbCxcclxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcclxuICB9LFxyXG4gIC8vIFwiUHJvcHJpZXRhcnlcIiBJbnRlcmZhY2UuXHJcbiAgcGFnZVg6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgcmV0dXJuICdwYWdlWCcgaW4gZXZlbnQgPyBldmVudC5wYWdlWCA6IGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XHJcbiAgfSxcclxuICBwYWdlWTogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gJ3BhZ2VZJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VZIDogZXZlbnQuY2xpZW50WSArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cclxuICovXHJcbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxufVxyXG5cclxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcclxuXHJcbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xyXG5cclxuLyoqXHJcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxyXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cclxuICovXHJcbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xyXG4gIHRvdWNoZXM6IG51bGwsXHJcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcclxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcclxuICBhbHRLZXk6IG51bGwsXHJcbiAgbWV0YUtleTogbnVsbCxcclxuICBjdHJsS2V5OiBudWxsLFxyXG4gIHNoaWZ0S2V5OiBudWxsLFxyXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVG91Y2hFdmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XHJcblxyXG4vKipcclxuICogQGludGVyZmFjZSBFdmVudFxyXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxyXG4gKi9cclxudmFyIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IHtcclxuICBwcm9wZXJ0eU5hbWU6IG51bGwsXHJcbiAgZWxhcHNlZFRpbWU6IG51bGwsXHJcbiAgcHNldWRvRWxlbWVudDogbnVsbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXHJcbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cclxuICovXHJcbmZ1bmN0aW9uIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xyXG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxufVxyXG5cclxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCwgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcclxuXHJcbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJmYWNlIFVJRXZlbnRcclxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXHJcbiAqL1xyXG52YXIgVUlFdmVudEludGVyZmFjZSA9IHtcclxuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGlmIChldmVudC52aWV3KSB7XHJcbiAgICAgIHJldHVybiBldmVudC52aWV3O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XHJcbiAgICBpZiAodGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XHJcbiAgICAgIC8vIHRhcmdldCBpcyBhIHdpbmRvdyBvYmplY3RcclxuICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XHJcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXHJcbiAgICBpZiAoZG9jKSB7XHJcbiAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgfSxcclxuICBkZXRhaWw6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCAwO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XHJcbiAqL1xyXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XHJcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xyXG59XHJcblxyXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVUlFdmVudCwgVUlFdmVudEludGVyZmFjZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcclxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXHJcbiAqL1xyXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcclxuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDpcclxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXHJcbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcclxuICB9LFxyXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOlxyXG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxyXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6XHJcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXHJcbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XHJcbiAgfSxcclxuICBkZWx0YVo6IG51bGwsXHJcblxyXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxyXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXHJcbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cclxuICBkZWx0YU1vZGU6IG51bGxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cclxuICovXHJcbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcclxuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcclxufVxyXG5cclxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcblxyXG52YXIgT0JTRVJWRURfRVJST1IgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBgVHJhbnNhY3Rpb25gIGNyZWF0ZXMgYSBibGFjayBib3ggdGhhdCBpcyBhYmxlIHRvIHdyYXAgYW55IG1ldGhvZCBzdWNoIHRoYXRcclxuICogY2VydGFpbiBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1ldGhvZCBpcyBpbnZva2VkXHJcbiAqIChFdmVuIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgaW52b2tpbmcgdGhlIHdyYXBwZWQgbWV0aG9kKS4gV2hvZXZlclxyXG4gKiBpbnN0YW50aWF0ZXMgYSB0cmFuc2FjdGlvbiBjYW4gcHJvdmlkZSBlbmZvcmNlcnMgb2YgdGhlIGludmFyaWFudHMgYXRcclxuICogY3JlYXRpb24gdGltZS4gVGhlIGBUcmFuc2FjdGlvbmAgY2xhc3MgaXRzZWxmIHdpbGwgc3VwcGx5IG9uZSBhZGRpdGlvbmFsXHJcbiAqIGF1dG9tYXRpYyBpbnZhcmlhbnQgZm9yIHlvdSAtIHRoZSBpbnZhcmlhbnQgdGhhdCBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2VcclxuICogc2hvdWxkIG5vdCBiZSBydW4gd2hpbGUgaXQgaXMgYWxyZWFkeSBiZWluZyBydW4uIFlvdSB3b3VsZCB0eXBpY2FsbHkgY3JlYXRlIGFcclxuICogc2luZ2xlIGluc3RhbmNlIG9mIGEgYFRyYW5zYWN0aW9uYCBmb3IgcmV1c2UgbXVsdGlwbGUgdGltZXMsIHRoYXQgcG90ZW50aWFsbHlcclxuICogaXMgdXNlZCB0byB3cmFwIHNldmVyYWwgZGlmZmVyZW50IG1ldGhvZHMuIFdyYXBwZXJzIGFyZSBleHRyZW1lbHkgc2ltcGxlIC1cclxuICogdGhleSBvbmx5IHJlcXVpcmUgaW1wbGVtZW50aW5nIHR3byBtZXRob2RzLlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcnMgKGluamVjdGVkIGF0IGNyZWF0aW9uIHRpbWUpXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICArXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tLS0rXHJcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB2ICAgICAgICB8ICAgICAgICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICB8ICAgICAgICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgKy0tfCAgICB3cmFwcGVyMSAgIHwtLS18LS0tLSsgICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgKy0tLS0tLS0tLS0tLS0tLSsgICB2ICAgIHwgICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgICAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgICAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgKy0tLS18ICAgd3JhcHBlcjIgIHwtLS0tLS0tLSsgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgIHwgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgIHYgICAgIHYgICB8IHdyYXBwZXJcclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHwgaW52YXJpYW50c1xyXG4gKiBwZXJmb3JtKGFueU1ldGhvZCkgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfCBtYWludGFpbmVkXHJcbiAqICstLS0tLS0tLS0tLS0tLS0tLT58LXwtLS18LXwtLS18LS0+fGFueU1ldGhvZHwtLS18LS0tfC18LS0tfC18LS0tLS0tLS0+XHJcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8XHJcbiAqICAgICAgICAgICAgICAgICAgICB8ICBpbml0aWFsaXplICAgICAgICAgICAgICAgICAgICBjbG9zZSAgICB8XHJcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBVc2UgY2FzZXM6XHJcbiAqIC0gUHJlc2VydmluZyB0aGUgaW5wdXQgc2VsZWN0aW9uIHJhbmdlcyBiZWZvcmUvYWZ0ZXIgcmVjb25jaWxpYXRpb24uXHJcbiAqICAgUmVzdG9yaW5nIHNlbGVjdGlvbiBldmVuIGluIHRoZSBldmVudCBvZiBhbiB1bmV4cGVjdGVkIGVycm9yLlxyXG4gKiAtIERlYWN0aXZhdGluZyBldmVudHMgd2hpbGUgcmVhcnJhbmdpbmcgdGhlIERPTSwgcHJldmVudGluZyBibHVycy9mb2N1c2VzLFxyXG4gKiAgIHdoaWxlIGd1YXJhbnRlZWluZyB0aGF0IGFmdGVyd2FyZHMsIHRoZSBldmVudCBzeXN0ZW0gaXMgcmVhY3RpdmF0ZWQuXHJcbiAqIC0gRmx1c2hpbmcgYSBxdWV1ZSBvZiBjb2xsZWN0ZWQgRE9NIG11dGF0aW9ucyB0byB0aGUgbWFpbiBVSSB0aHJlYWQgYWZ0ZXIgYVxyXG4gKiAgIHJlY29uY2lsaWF0aW9uIHRha2VzIHBsYWNlIGluIGEgd29ya2VyIHRocmVhZC5cclxuICogLSBJbnZva2luZyBhbnkgY29sbGVjdGVkIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBhZnRlciByZW5kZXJpbmcgbmV3XHJcbiAqICAgY29udGVudC5cclxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogV3JhcHBpbmcgcGFydGljdWxhciBmbHVzaGVzIG9mIHRoZSBgUmVhY3RXb3JrZXJgIHF1ZXVlXHJcbiAqICAgdG8gcHJlc2VydmUgdGhlIGBzY3JvbGxUb3BgIChhbiBhdXRvbWF0aWMgc2Nyb2xsIGF3YXJlIERPTSkuXHJcbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IExheW91dCBjYWxjdWxhdGlvbnMgYmVmb3JlIGFuZCBhZnRlciBET00gdXBkYXRlcy5cclxuICpcclxuICogVHJhbnNhY3Rpb25hbCBwbHVnaW4gQVBJOlxyXG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cclxuICogLSBhbmQgYSBgY2xvc2VgIG1ldGhvZCB0aGF0IGFjY2VwdHMgdGhlIHByZWNvbXB1dGF0aW9uLiBgY2xvc2VgIGlzIGludm9rZWRcclxuICogICB3aGVuIHRoZSB3cmFwcGVkIHByb2Nlc3MgaXMgY29tcGxldGVkLCBvciBoYXMgZmFpbGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uYWxXcmFwcGVyPn0gdHJhbnNhY3Rpb25XcmFwcGVyIFdyYXBwZXIgbW9kdWxlc1xyXG4gKiB0aGF0IGltcGxlbWVudCBgaW5pdGlhbGl6ZWAgYW5kIGBjbG9zZWAuXHJcbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cclxuICpcclxuICogQGNsYXNzIFRyYW5zYWN0aW9uXHJcbiAqL1xyXG52YXIgVHJhbnNhY3Rpb25JbXBsID0ge1xyXG4gIC8qKlxyXG4gICAqIFNldHMgdXAgdGhpcyBpbnN0YW5jZSBzbyB0aGF0IGl0IGlzIHByZXBhcmVkIGZvciBjb2xsZWN0aW5nIG1ldHJpY3MuIERvZXNcclxuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XHJcbiAgICogaW5pdGlhbGl6ZWQsIGluIGEgd2F5IHRoYXQgZG9lcyBub3QgY29uc3VtZSBhZGRpdGlvbmFsIG1lbW9yeSB1cG9uIHJldXNlLlxyXG4gICAqIFRoYXQgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgZGVjaWRlIHRvIG1ha2UgeW91ciBzdWJjbGFzcyBvZiB0aGlzIG1peGluIGFcclxuICAgKiBcIlBvb2xlZENsYXNzXCIuXHJcbiAgICovXHJcbiAgcmVpbml0aWFsaXplVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25XcmFwcGVycygpO1xyXG4gICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhKSB7XHJcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YSA9IFtdO1xyXG4gICAgfVxyXG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXHJcblxyXG4gIC8qKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEByZXR1cm4ge0FycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj59IEFycmF5IG9mIHRyYW5zYWN0aW9uIHdyYXBwZXJzLlxyXG4gICAqL1xyXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXHJcblxyXG4gIGlzSW5UcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxyXG4gICAqIG1ldGhvZHMgdGhhdCByZXN1bHQgaW4gbGFyZ2UgYW1vdW50cyBvZiBjb21wdXRhdGlvbi9tdXRhdGlvbnMgdGhhdCB3b3VsZFxyXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgaGVscHMgcHJldmVudCB0aGUgbmVlZFxyXG4gICAqIHRvIGJpbmQgaW4gbWFueSBjYXNlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXHJcbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYyBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZCBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfSBSZXR1cm4gdmFsdWUgZnJvbSBgbWV0aG9kYC5cclxuICAgKi9cclxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgISF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlIGlzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24uJykgOiBfcHJvZEludmFyaWFudCgnMjcnKSA6IHZvaWQgMDtcclxuICAgIHZhciBlcnJvclRocm93bjtcclxuICAgIHZhciByZXQ7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSB0cnVlO1xyXG4gICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXHJcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcclxuICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcclxuICAgICAgLy8gb25lIG9mIHRoZXNlIGNhbGxzIHRocmV3LlxyXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbCgwKTtcclxuICAgICAgcmV0ID0gbWV0aG9kLmNhbGwoc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpO1xyXG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcclxuICAgICAgICAgIC8vIElmIGBtZXRob2RgIHRocm93cywgcHJlZmVyIHRvIHNob3cgdGhhdCBzdGFjayB0cmFjZSBvdmVyIGFueSB0aHJvd25cclxuICAgICAgICAgIC8vIGJ5IGludm9raW5nIGBjbG9zZUFsbGAuXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBTaW5jZSBgbWV0aG9kYCBkaWRuJ3QgdGhyb3csIHdlIGRvbid0IHdhbnQgdG8gc2lsZW5jZSB0aGUgZXhjZXB0aW9uXHJcbiAgICAgICAgICAvLyBoZXJlLlxyXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcclxuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xyXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoIHRoZVxyXG4gICAgICAgIC8vIE9CU0VSVkVEX0VSUk9SIHN0YXRlIGJlZm9yZSBvdmVyd3JpdGluZyBpdCB3aXRoIHRoZSByZWFsIHJldHVybiB2YWx1ZVxyXG4gICAgICAgIC8vIG9mIGluaXRpYWxpemUgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gT0JTRVJWRURfRVJST1IgaW4gdGhlIGZpbmFsbHlcclxuICAgICAgICAvLyBibG9jaywgaXQgbWVhbnMgd3JhcHBlci5pbml0aWFsaXplIHRocmV3LlxyXG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gT0JTRVJWRURfRVJST1I7XHJcbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSB3cmFwcGVyLmluaXRpYWxpemUgPyB3cmFwcGVyLmluaXRpYWxpemUuY2FsbCh0aGlzKSA6IG51bGw7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBPQlNFUlZFRF9FUlJPUikge1xyXG4gICAgICAgICAgLy8gVGhlIGluaXRpYWxpemVyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGluaXRpYWxpemUgdGhlXHJcbiAgICAgICAgICAvLyByZW1haW5pbmcgd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZVxyXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBbGwoaSArIDEpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZXMgZWFjaCBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmNsb3NlW2ldYCBmdW5jdGlvbnMsIHBhc3NpbmcgaW50b1xyXG4gICAqIHRoZW0gdGhlIHJlc3BlY3RpdmUgcmV0dXJuIHZhbHVlcyBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmluaXRbaV1gXHJcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXHJcbiAgICogaW52b2tlZCkuXHJcbiAgICovXHJcbiAgY2xvc2VBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XHJcbiAgICAhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5jbG9zZUFsbCgpOiBDYW5ub3QgY2xvc2UgdHJhbnNhY3Rpb24gd2hlbiBub25lIGFyZSBvcGVuLicpIDogX3Byb2RJbnZhcmlhbnQoJzI4JykgOiB2b2lkIDA7XHJcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcclxuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XHJcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMud3JhcHBlckluaXREYXRhW2ldO1xyXG4gICAgICB2YXIgZXJyb3JUaHJvd247XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxyXG4gICAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcclxuICAgICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xyXG4gICAgICAgIC8vIHdyYXBwZXIuY2xvc2UgdGhyZXcuXHJcbiAgICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xyXG4gICAgICAgIGlmIChpbml0RGF0YSAhPT0gT0JTRVJWRURfRVJST1IgJiYgd3JhcHBlci5jbG9zZSkge1xyXG4gICAgICAgICAgd3JhcHBlci5jbG9zZS5jYWxsKHRoaXMsIGluaXREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcclxuICAgICAgICAgIC8vIFRoZSBjbG9zZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgY2xvc2UgdGhlIHJlbWFpbmluZ1xyXG4gICAgICAgICAgLy8gd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZSB0aGF0IHRoZVxyXG4gICAgICAgICAgLy8gZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKGkgKyAxKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb25JbXBsOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSB7XHJcblxyXG4gIGN1cnJlbnRTY3JvbGxMZWZ0OiAwLFxyXG5cclxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxyXG5cclxuICByZWZyZXNoU2Nyb2xsVmFsdWVzOiBmdW5jdGlvbiAoc2Nyb2xsUG9zaXRpb24pIHtcclxuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XHJcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcCA9IHNjcm9sbFBvc2l0aW9uLnk7XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG5cclxuLyoqXHJcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXHJcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXHJcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcclxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxyXG4gKlxyXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcclxuICpcclxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cclxuICpcclxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcclxuICAhKG5leHQgIT0gbnVsbCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiBfcHJvZEludmFyaWFudCgnMzAnKSA6IHZvaWQgMDtcclxuXHJcbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG5leHQ7XHJcbiAgfVxyXG5cclxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxyXG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XHJcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcclxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICB9XHJcbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XHJcbiAgICByZXR1cm4gY3VycmVudDtcclxuICB9XHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XHJcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXHJcbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBNT0QgPSA2NTUyMTtcclxuXHJcbi8vIGFkbGVyMzIgaXMgbm90IGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZywgYW5kIGlzIG9ubHkgdXNlZCB0byBzYW5pdHkgY2hlY2sgdGhhdFxyXG4vLyBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgbWF0Y2hlcyB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LlxyXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIChhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIFNoZWV0SlMgdmVyc2lvbikgaGFzIGJlZW4gb3B0aW1pemVkXHJcbi8vIGZvciBvdXIgdXNlIGNhc2UsIGF0IHRoZSBleHBlbnNlIG9mIGNvbmZvcm1pbmcgdG8gdGhlIGFkbGVyMzIgc3BlY2lmaWNhdGlvblxyXG4vLyBmb3Igbm9uLWFzY2lpIGlucHV0cy5cclxuZnVuY3Rpb24gYWRsZXIzMihkYXRhKSB7XHJcbiAgdmFyIGEgPSAxO1xyXG4gIHZhciBiID0gMDtcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcclxuICB2YXIgbSA9IGwgJiB+MHgzO1xyXG4gIHdoaWxlIChpIDwgbSkge1xyXG4gICAgdmFyIG4gPSBNYXRoLm1pbihpICsgNDA5NiwgbSk7XHJcbiAgICBmb3IgKDsgaSA8IG47IGkgKz0gNCkge1xyXG4gICAgICBiICs9IChhICs9IGRhdGEuY2hhckNvZGVBdChpKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDEpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMikpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAzKSk7XHJcbiAgICB9XHJcbiAgICBhICU9IE1PRDtcclxuICAgIGIgJT0gTU9EO1xyXG4gIH1cclxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xyXG4gICAgYiArPSBhICs9IGRhdGEuY2hhckNvZGVBdChpKTtcclxuICB9XHJcbiAgYSAlPSBNT0Q7XHJcbiAgYiAlPSBNT0Q7XHJcbiAgcmV0dXJuIGEgfCBiIDw8IDE2O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcclxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xyXG5cclxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBcInByb2R1Y3Rpb25cIiA9PT0gJ3Rlc3QnKSB7XHJcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXHJcbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXHJcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XHJcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XHJcbn1cclxuXHJcbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXHJcbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcclxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxyXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcclxuICogQHBhcmFtIHs/bnVtYmVyfSBkZWJ1Z0lEIFRoZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQsIGRlYnVnSUQpIHtcclxuICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XHJcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcclxuICAgICAgdmFyIGVycm9yO1xyXG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xyXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXHJcbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcclxuICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXHJcbiAgICAgICAgISh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzg0JywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcclxuICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICBlcnJvciA9IGV4O1xyXG4gICAgICB9XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKSA6IHZvaWQgMDtcclxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcclxuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcclxuICAgICAgICAvLyBzYW1lIGVycm9yLlxyXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XHJcblxyXG4gICAgICAgIHZhciBjb21wb25lbnRTdGFja0luZm8gPSAnJztcclxuXHJcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xyXG4gICAgICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChkZWJ1Z0lEICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgY29tcG9uZW50U3RhY2tJbmZvKSA6IHZvaWQgMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1JlYWN0VHlwZVNwZWM7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuLyogZ2xvYmFscyBNU0FwcCAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHdoaWNoIGhhcyAndW5zYWZlJyBwcml2aWxlZ2VzIChyZXF1aXJlZCBieSB3aW5kb3dzOCBhcHBzKVxyXG4gKi9cclxuXHJcbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XHJcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZnVuYztcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb247IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBpc1VuaXRsZXNzTnVtYmVyID0gQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcjtcclxudmFyIHN0eWxlV2FybmluZ3MgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXHJcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXHJcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXHJcbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcclxuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXHJcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xyXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcclxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcclxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxyXG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xyXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcclxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cclxuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcclxuXHJcbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcclxuICBpZiAoaXNFbXB0eSkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuXHJcbiAgdmFyIGlzTm9uTnVtZXJpYyA9IGlzTmFOKHZhbHVlKTtcclxuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8IGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkge1xyXG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgLy8gQWxsb3cgJzAnIHRvIHBhc3MgdGhyb3VnaCB3aXRob3V0IHdhcm5pbmcuIDAgaXMgYWxyZWFkeSBzcGVjaWFsIGFuZFxyXG4gICAgICAvLyBkb2Vzbid0IHJlcXVpcmUgdW5pdHMsIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FybiBhYm91dCBpdC5cclxuICAgICAgaWYgKGNvbXBvbmVudCAmJiB2YWx1ZSAhPT0gJzAnKSB7XHJcbiAgICAgICAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XHJcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gb3duZXIuZ2V0TmFtZSgpIDogbnVsbDtcclxuICAgICAgICBpZiAob3duZXJOYW1lICYmICFzdHlsZVdhcm5pbmdzW293bmVyTmFtZV0pIHtcclxuICAgICAgICAgIHN0eWxlV2FybmluZ3Nbb3duZXJOYW1lXSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd2FybmVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKG93bmVyTmFtZSkge1xyXG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdO1xyXG4gICAgICAgICAgd2FybmVkID0gd2FybmluZ3NbbmFtZV07XHJcbiAgICAgICAgICBpZiAoIXdhcm5lZCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nc1tuYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghd2FybmVkKSB7XHJcbiAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2EgYCVzYCB0YWcgKG93bmVyOiBgJXNgKSB3YXMgcGFzc2VkIGEgbnVtZXJpYyBzdHJpbmcgdmFsdWUgJyArICdmb3IgQ1NTIHByb3BlcnR5IGAlc2AgKHZhbHVlOiBgJXNgKSB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgJyArICdhcyBhIHVuaXRsZXNzIG51bWJlciBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0LicsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQudHlwZSwgb3duZXJOYW1lIHx8ICd1bmtub3duJywgbmFtZSwgdmFsdWUpIDogdm9pZCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZSArICdweCc7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQmFzZWQgb24gdGhlIGVzY2FwZS1odG1sIGxpYnJhcnksIHdoaWNoIGlzIHVzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIGJlbG93OlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxMyBUSiBIb2xvd2F5Y2h1a1xyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQW5kcmVhcyBMdWJiZVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgVGlhbmNoZW5nIFwiVGltb3RoeVwiIEd1XHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cclxuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXHJcbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXHJcbiAqIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXHJcbiAqIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXHJcbiAqIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXHJcbi8qKlxyXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xyXG5cclxuLyoqXHJcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZSBmb3IgaW5zZXJ0aW5nIGludG8gSFRNTFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqIEBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xyXG4gIHZhciBzdHIgPSAnJyArIHN0cmluZztcclxuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xyXG5cclxuICBpZiAoIW1hdGNoKSB7XHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuXHJcbiAgdmFyIGVzY2FwZTtcclxuICB2YXIgaHRtbCA9ICcnO1xyXG4gIHZhciBpbmRleCA9IDA7XHJcbiAgdmFyIGxhc3RJbmRleCA9IDA7XHJcblxyXG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xyXG4gICAgICBjYXNlIDM0OlxyXG4gICAgICAgIC8vIFwiXHJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzg6XHJcbiAgICAgICAgLy8gJlxyXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMzk6XHJcbiAgICAgICAgLy8gJ1xyXG4gICAgICAgIGVzY2FwZSA9ICcmI3gyNzsnOyAvLyBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sOyB1c2VkIHRvIGJlICcmIzM5J1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDYwOlxyXG4gICAgICAgIC8vIDxcclxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNjI6XHJcbiAgICAgICAgLy8gPlxyXG4gICAgICAgIGVzY2FwZSA9ICcmZ3Q7JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xyXG4gICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgaHRtbCArPSBlc2NhcGU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcclxufVxyXG4vLyBlbmQgY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcclxuXHJcblxyXG4vKipcclxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cclxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSB7XHJcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XHJcbiAgICAvLyB0aGlzIHNob3J0Y2lyY3VpdCBoZWxwcyBwZXJmIGZvciB0eXBlcyB0aGF0IHdlIGtub3cgd2lsbCBuZXZlciBoYXZlXHJcbiAgICAvLyBzcGVjaWFsIGNoYXJhY3RlcnMsIGVzcGVjaWFsbHkgZ2l2ZW4gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgb2Z0ZW5cclxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXHJcbiAgICByZXR1cm4gJycgKyB0ZXh0O1xyXG4gIH1cclxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xyXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcclxudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcclxuXHJcbnZhciBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUnKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGVsZW1lbnQuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5maW5kZG9tbm9kZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fERPTUVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxyXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGVsZW1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnRPckVsZW1lbnQpIHtcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcclxuICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcclxuICB9XHJcblxyXG4gIHZhciBpbnN0ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoY29tcG9uZW50T3JFbGVtZW50KTtcclxuICBpZiAoaW5zdCkge1xyXG4gICAgaW5zdCA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpO1xyXG4gICAgcmV0dXJuIGluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSA6IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICFmYWxzZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kRE9NTm9kZSB3YXMgY2FsbGVkIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnNDQnKSA6IHZvaWQgMDtcclxuICB9IGVsc2Uge1xyXG4gICAgIWZhbHNlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlIChrZXlzOiAlcyknLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IF9wcm9kSW52YXJpYW50KCc0NScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogdm9pZCAwO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmaW5kRE9NTm9kZTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xyXG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xyXG5cclxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBcInByb2R1Y3Rpb25cIiA9PT0gJ3Rlc3QnKSB7XHJcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXHJcbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXHJcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XHJcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBwYXNzZWQgdGhyb3VnaCB0cmF2ZXJzYWwuXHJcbiAqIEBwYXJhbSB7P1JlYWN0Q29tcG9uZW50fSBjaGlsZCBSZWFjdCBjaGlsZCBjb21wb25lbnQuXHJcbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cclxuICogQHBhcmFtIHtudW1iZXI9fSBzZWxmRGVidWdJRCBPcHRpb25hbCBkZWJ1Z0lEIG9mIHRoZSBjdXJyZW50IGludGVybmFsIGluc3RhbmNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcclxuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cclxuICBpZiAodHJhdmVyc2VDb250ZXh0ICYmIHR5cGVvZiB0cmF2ZXJzZUNvbnRleHQgPT09ICdvYmplY3QnKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gdHJhdmVyc2VDb250ZXh0O1xyXG4gICAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XHJcbiAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFrZXlVbmlxdWUpIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGtleVVuaXF1ZSAmJiBjaGlsZCAhPSBudWxsKSB7XHJcbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNoaWxkO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZsYXR0ZW5zIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC4gQW55IG51bGxcclxuICogY2hpbGRyZW4gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QuXHJcbiAqIEByZXR1cm4geyFvYmplY3R9IGZsYXR0ZW5lZCBjaGlsZHJlbiBrZXllZCBieSBuYW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuLCBzZWxmRGVidWdJRCkge1xyXG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgfVxyXG4gIHZhciByZXN1bHQgPSB7fTtcclxuXHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XHJcbiAgICAgIHJldHVybiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XHJcbiAgICB9LCByZXN1bHQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgcmVzdWx0KTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuQ2hpbGRyZW47IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxyXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcclxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cclxuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcclxuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XHJcbiAgfSBlbHNlIGlmIChhcnIpIHtcclxuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hBY2N1bXVsYXRlZDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXHJcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcclxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXHJcbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXHJcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cclxuICovXHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XHJcbiAgdmFyIGNoYXJDb2RlO1xyXG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcclxuXHJcbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcclxuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XHJcblxyXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxyXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XHJcbiAgICAgIGNoYXJDb2RlID0gMTM7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXHJcbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XHJcbiAgfVxyXG5cclxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cclxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxyXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcclxuICAgIHJldHVybiBjaGFyQ29kZTtcclxuICB9XHJcblxyXG4gIHJldHVybiAwO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50Q2hhckNvZGU7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXHJcbiAqL1xyXG52YXIgbm9ybWFsaXplS2V5ID0ge1xyXG4gICdFc2MnOiAnRXNjYXBlJyxcclxuICAnU3BhY2ViYXInOiAnICcsXHJcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcclxuICAnVXAnOiAnQXJyb3dVcCcsXHJcbiAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxyXG4gICdEb3duJzogJ0Fycm93RG93bicsXHJcbiAgJ0RlbCc6ICdEZWxldGUnLFxyXG4gICdXaW4nOiAnT1MnLFxyXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcclxuICAnQXBwcyc6ICdDb250ZXh0TWVudScsXHJcbiAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcclxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcclxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xyXG4gKi9cclxudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xyXG4gIDg6ICdCYWNrc3BhY2UnLFxyXG4gIDk6ICdUYWInLFxyXG4gIDEyOiAnQ2xlYXInLFxyXG4gIDEzOiAnRW50ZXInLFxyXG4gIDE2OiAnU2hpZnQnLFxyXG4gIDE3OiAnQ29udHJvbCcsXHJcbiAgMTg6ICdBbHQnLFxyXG4gIDE5OiAnUGF1c2UnLFxyXG4gIDIwOiAnQ2Fwc0xvY2snLFxyXG4gIDI3OiAnRXNjYXBlJyxcclxuICAzMjogJyAnLFxyXG4gIDMzOiAnUGFnZVVwJyxcclxuICAzNDogJ1BhZ2VEb3duJyxcclxuICAzNTogJ0VuZCcsXHJcbiAgMzY6ICdIb21lJyxcclxuICAzNzogJ0Fycm93TGVmdCcsXHJcbiAgMzg6ICdBcnJvd1VwJyxcclxuICAzOTogJ0Fycm93UmlnaHQnLFxyXG4gIDQwOiAnQXJyb3dEb3duJyxcclxuICA0NTogJ0luc2VydCcsXHJcbiAgNDY6ICdEZWxldGUnLFxyXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXHJcbiAgMTE4OiAnRjcnLCAxMTk6ICdGOCcsIDEyMDogJ0Y5JywgMTIxOiAnRjEwJywgMTIyOiAnRjExJywgMTIzOiAnRjEyJyxcclxuICAxNDQ6ICdOdW1Mb2NrJyxcclxuICAxNDU6ICdTY3JvbGxMb2NrJyxcclxuICAyMjQ6ICdNZXRhJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cclxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcclxuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XHJcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cclxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cclxuXHJcbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxyXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXHJcbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xyXG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcclxuICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cclxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xyXG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XHJcblxyXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXHJcbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cclxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XHJcbiAgfVxyXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xyXG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxyXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cclxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcclxuICB9XHJcbiAgcmV0dXJuICcnO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50S2V5OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXHJcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xyXG4gKi9cclxuXHJcbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcclxuICAnQWx0JzogJ2FsdEtleScsXHJcbiAgJ0NvbnRyb2wnOiAnY3RybEtleScsXHJcbiAgJ01ldGEnOiAnbWV0YUtleScsXHJcbiAgJ1NoaWZ0JzogJ3NoaWZ0S2V5J1xyXG59O1xyXG5cclxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcclxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxyXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxyXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xyXG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XHJcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XHJcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcclxuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XHJcbiAgfVxyXG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcclxuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XHJcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRNb2RpZmllclN0YXRlOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cclxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XHJcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcclxuXHJcbiAgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xyXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcclxuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuICB9XHJcblxyXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXHJcbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcclxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xyXG5cclxuZnVuY3Rpb24gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCkge1xyXG4gIHZhciB0eXBlO1xyXG5cclxuICB3aGlsZSAoKHR5cGUgPSBpbnN0Ll9yZW5kZXJlZE5vZGVUeXBlKSA9PT0gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFKSB7XHJcbiAgICBpbnN0ID0gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuSE9TVCkge1xyXG4gICAgcmV0dXJuIGluc3QuX3JlbmRlcmVkQ29tcG9uZW50O1xyXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZTsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogZ2xvYmFsIFN5bWJvbCAqL1xyXG5cclxudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xyXG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXHJcbiAqXHJcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxyXG4gKlxyXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xyXG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcclxuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xyXG4gKiAgICAgICAuLi5cclxuICogICAgIH1cclxuICpcclxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXHJcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cclxuICovXHJcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xyXG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XHJcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIG5leHREZWJ1Z0lEID0gMTtcclxuXHJcbmZ1bmN0aW9uIGdldE5leHREZWJ1Z0lEKCkge1xyXG4gIHJldHVybiBuZXh0RGVidWdJRCsrO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5leHREZWJ1Z0lEOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcclxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cclxuICovXHJcblxyXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XHJcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XHJcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xyXG4gIH1cclxuICByZXR1cm4gbm9kZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXHJcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcclxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XHJcbiAgd2hpbGUgKG5vZGUpIHtcclxuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XHJcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xyXG4gICAgfVxyXG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XHJcbiAqIEByZXR1cm4gez9vYmplY3R9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xyXG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XHJcbiAgdmFyIG5vZGVTdGFydCA9IDA7XHJcbiAgdmFyIG5vZGVFbmQgPSAwO1xyXG5cclxuICB3aGlsZSAobm9kZSkge1xyXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcclxuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcclxuICAgIH1cclxuXHJcbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcblxyXG52YXIgY29udGVudEtleSA9IG51bGw7XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XHJcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xyXG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxyXG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cclxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcclxuICB9XHJcbiAgcmV0dXJuIGNvbnRlbnRLZXk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcclxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xyXG4gIHZhciBwcmVmaXhlcyA9IHt9O1xyXG5cclxuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcclxuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcclxuICBwcmVmaXhlc1snbXMnICsgc3R5bGVQcm9wXSA9ICdNUycgKyBldmVudE5hbWU7XHJcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICByZXR1cm4gcHJlZml4ZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXHJcbiAqL1xyXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XHJcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXHJcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXHJcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxyXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXHJcbn07XHJcblxyXG4vKipcclxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxyXG4gKi9cclxudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxyXG4gKi9cclxudmFyIHN0eWxlID0ge307XHJcblxyXG4vKipcclxuICogQm9vdHN0cmFwIGlmIGEgRE9NIGV4aXN0cy5cclxuICovXHJcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcclxuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xyXG5cclxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxyXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxyXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxyXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXHJcbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XHJcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcclxuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xyXG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcclxuICB9XHJcblxyXG4gIC8vIFNhbWUgYXMgYWJvdmVcclxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XHJcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XHJcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XHJcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XHJcbiAgfSBlbHNlIGlmICghdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSkge1xyXG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcclxuICB9XHJcblxyXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xyXG5cclxuICBmb3IgKHZhciBzdHlsZVByb3AgaW4gcHJlZml4TWFwKSB7XHJcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XHJcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuICcnO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXHJcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpO1xyXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xyXG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RDb21wb25lbnQnKTtcclxuXHJcbnZhciBnZXROZXh0RGVidWdJRCA9IHJlcXVpcmUoJy4vZ2V0TmV4dERlYnVnSUQnKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbi8vIFRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3ksIHdlIGNyZWF0ZSB0aGUgZmluYWwgY2xhc3MgaW4gdGhpcyBtb2R1bGVcclxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgdGhpcy5jb25zdHJ1Y3QoZWxlbWVudCk7XHJcbn07XHJcbl9hc3NpZ24oUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZSwgUmVhY3RDb21wb3NpdGVDb21wb25lbnQsIHtcclxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xyXG4gIGlmIChvd25lcikge1xyXG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgdHlwZSByZWZlcmVuY2UgaXMgYSBrbm93biBpbnRlcm5hbCB0eXBlLiBJLmUuIG5vdCBhIHVzZXJcclxuICogcHJvdmlkZWQgY29tcG9zaXRlIHR5cGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVcclxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBpbnRlcm5hbCB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNJbnRlcm5hbENvbXBvbmVudFR5cGUodHlwZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgUmVhY3ROb2RlLCBjcmVhdGUgYW4gaW5zdGFuY2UgdGhhdCB3aWxsIGFjdHVhbGx5IGJlIG1vdW50ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkSGF2ZURlYnVnSURcclxuICogQHJldHVybiB7b2JqZWN0fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yLlxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5vZGUsIHNob3VsZEhhdmVEZWJ1Z0lEKSB7XHJcbiAgdmFyIGluc3RhbmNlO1xyXG5cclxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xyXG4gICAgaW5zdGFuY2UgPSBSZWFjdEVtcHR5Q29tcG9uZW50LmNyZWF0ZShpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSAnb2JqZWN0Jykge1xyXG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xyXG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XHJcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHZhciBpbmZvID0gJyc7XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgJ2l0XFwncyBkZWZpbmVkIGluLic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKTtcclxuICAgICAgIWZhbHNlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pIDogX3Byb2RJbnZhcmlhbnQoJzEzMCcsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbykgOiB2b2lkIDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3BlY2lhbCBjYXNlIHN0cmluZyB2YWx1ZXNcclxuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICBpbnN0YW5jZSA9IFJlYWN0SG9zdENvbXBvbmVudC5jcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KTtcclxuICAgIH0gZWxzZSBpZiAoaXNJbnRlcm5hbENvbXBvbmVudFR5cGUoZWxlbWVudC50eXBlKSkge1xyXG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xyXG4gICAgICAvLyByZXByZXNlbnRhdGlvbnMuIEkuZS4gQVJULiBPbmNlIHRob3NlIGFyZSB1cGRhdGVkIHRvIHVzZSB0aGUgc3RyaW5nXHJcbiAgICAgIC8vIHJlcHJlc2VudGF0aW9uLCB3ZSBjYW4gZHJvcCB0aGlzIGNvZGUgcGF0aC5cclxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xyXG5cclxuICAgICAgLy8gV2UgcmVuYW1lZCB0aGlzLiBBbGxvdyB0aGUgb2xkIG5hbWUgZm9yIGNvbXBhdC4gOihcclxuICAgICAgaWYgKCFpbnN0YW5jZS5nZXRIb3N0Tm9kZSkge1xyXG4gICAgICAgIGluc3RhbmNlLmdldEhvc3ROb2RlID0gaW5zdGFuY2UuZ2V0TmF0aXZlTm9kZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5zdGFuY2UgPSBuZXcgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xyXG4gICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW5zdGFuY2VGb3JUZXh0KG5vZGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAhZmFsc2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMTMxJywgdHlwZW9mIG5vZGUpIDogdm9pZCAwO1xyXG4gIH1cclxuXHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0YW5jZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0SG9zdE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnVubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicsICdPbmx5IFJlYWN0IENvbXBvbmVudHMgY2FuIGJlIG1vdW50ZWQuJykgOiB2b2lkIDA7XHJcbiAgfVxyXG5cclxuICAvLyBUaGVzZSB0d28gZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBET00gYW5kIEFSVCBkaWZmaW5nIGFsZ29yaXRobXNcclxuICAvLyByZXNwZWN0aXZlbHkuIEluc3RlYWQgb2YgdXNpbmcgZXhwYW5kb3Mgb24gY29tcG9uZW50cywgd2Ugc2hvdWxkIGJlXHJcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxyXG4gIGluc3RhbmNlLl9tb3VudEluZGV4ID0gMDtcclxuICBpbnN0YW5jZS5fbW91bnRJbWFnZSA9IG51bGw7XHJcblxyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBpbnN0YW5jZS5fZGVidWdJRCA9IHNob3VsZEhhdmVEZWJ1Z0lEID8gZ2V0TmV4dERlYnVnSUQoKSA6IDA7XHJcbiAgfVxyXG5cclxuICAvLyBJbnRlcm5hbCBpbnN0YW5jZXMgc2hvdWxkIGZ1bGx5IGNvbnN0cnVjdGVkIGF0IHRoaXMgcG9pbnQsIHNvIHRoZXkgc2hvdWxkXHJcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGlmIChPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcclxuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBpbnN0YW5jZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcblxyXG52YXIgdXNlSGFzRmVhdHVyZTtcclxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xyXG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXHJcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxyXG4gIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXHJcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXHJcbiAqXHJcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxyXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cclxuICpcclxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cclxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cclxuICogQGludGVybmFsXHJcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxyXG4gKi9cclxuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgsIGNhcHR1cmUpIHtcclxuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XHJcbiAgdmFyIGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xyXG5cclxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xyXG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFpc1N1cHBvcnRlZCAmJiB1c2VIYXNGZWF0dXJlICYmIGV2ZW50TmFtZVN1ZmZpeCA9PT0gJ3doZWVsJykge1xyXG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxyXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxyXG4gKi9cclxuXHJcbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xyXG4gICdjb2xvcic6IHRydWUsXHJcbiAgJ2RhdGUnOiB0cnVlLFxyXG4gICdkYXRldGltZSc6IHRydWUsXHJcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcclxuICAnZW1haWwnOiB0cnVlLFxyXG4gICdtb250aCc6IHRydWUsXHJcbiAgJ251bWJlcic6IHRydWUsXHJcbiAgJ3Bhc3N3b3JkJzogdHJ1ZSxcclxuICAncmFuZ2UnOiB0cnVlLFxyXG4gICdzZWFyY2gnOiB0cnVlLFxyXG4gICd0ZWwnOiB0cnVlLFxyXG4gICd0ZXh0JzogdHJ1ZSxcclxuICAndGltZSc6IHRydWUsXHJcbiAgJ3VybCc6IHRydWUsXHJcbiAgJ3dlZWsnOiB0cnVlXHJcbn07XHJcblxyXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xyXG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xyXG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHRJbnB1dEVsZW1lbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XHJcblxyXG4vKipcclxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBlc2NhcGUuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSkge1xyXG4gIHJldHVybiAnXCInICsgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXI7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cclxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXHJcbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxyXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHJlYWN0UHJvZEludmFyaWFudChjb2RlKSB7XHJcbiAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XHJcblxyXG4gIHZhciBtZXNzYWdlID0gJ01pbmlmaWVkIFJlYWN0IGVycm9yICMnICsgY29kZSArICc7IHZpc2l0ICcgKyAnaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9JyArIGNvZGU7XHJcblxyXG4gIGZvciAodmFyIGFyZ0lkeCA9IDA7IGFyZ0lkeCA8IGFyZ0NvdW50OyBhcmdJZHgrKykge1xyXG4gICAgbWVzc2FnZSArPSAnJmFyZ3NbXT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1thcmdJZHggKyAxXSk7XHJcbiAgfVxyXG5cclxuICBtZXNzYWdlICs9ICcgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50JyArICcgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJztcclxuXHJcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XHJcbiAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHJlYWN0UHJvZEludmFyaWFudCdzIG93biBmcmFtZVxyXG5cclxuICB0aHJvdyBlcnJvcjtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZWFjdFByb2RJbnZhcmlhbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudC5yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xyXG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xyXG5cclxudmFyIFdISVRFU1BBQ0VfVEVTVCA9IC9eWyBcXHJcXG5cXHRcXGZdLztcclxudmFyIE5PTlZJU0lCTEVfVEVTVCA9IC88KCEtLXxsaW5rfG5vc2NyaXB0fG1ldGF8c2NyaXB0fHN0eWxlKVsgXFxyXFxuXFx0XFxmXFwvPl0vO1xyXG5cclxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcclxuXHJcbi8vIFNWRyB0ZW1wIGNvbnRhaW5lciBmb3IgSUUgbGFja2luZyBpbm5lckhUTUxcclxudmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyO1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxyXG4gKiBldmVuIGluIElFOC5cclxuICpcclxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcclxuICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcclxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXHJcbiAgLy8gdGhlIHRhcmdldCBub2RlXHJcbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiAhKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XHJcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcclxuICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcclxuICAgIHdoaWxlIChzdmdOb2RlLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XHJcbiAgfVxyXG59KTtcclxuXHJcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcclxuICAvLyBJRTg6IFdoZW4gdXBkYXRpbmcgYSBqdXN0IGNyZWF0ZWQgbm9kZSB3aXRoIGlubmVySFRNTCBvbmx5IGxlYWRpbmdcclxuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxyXG4gIC8vIHdoaXRlc3BhY2UgaW4gcm9vdCBUZXh0Tm9kZXMgaXMgYWxzbyBjb2xsYXBzZWQuXHJcbiAgLy8gQHNlZSBxdWlya3Ntb2RlLm9yZy9idWdyZXBvcnRzL2FyY2hpdmVzLzIwMDQvMTEvaW5uZXJodG1sX2FuZF90Lmh0bWxcclxuXHJcbiAgLy8gRmVhdHVyZSBkZXRlY3Rpb247IG9ubHkgSUU4IGlzIGtub3duIHRvIGJlaGF2ZSBpbXByb3Blcmx5IGxpa2UgdGhpcy5cclxuICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XHJcbiAgaWYgKHRlc3RFbGVtZW50LmlubmVySFRNTCA9PT0gJycpIHtcclxuICAgIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XHJcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxyXG4gICAgICAvLyBub2RlcyB3aGVuIHByb2Nlc3NpbmcgaW5uZXJIVE1MLCBpbm5lckhUTUwgb24gdXBkYXRlZCBub2RlcyBzdWZmZXJzXHJcbiAgICAgIC8vIGZyb20gd29yc2Ugd2hpdGVzcGFjZSBiZWhhdmlvci4gUmUtYWRkaW5nIGEgbm9kZSBsaWtlIHRoaXMgdHJpZ2dlcnNcclxuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXHJcbiAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gb24gYSBkZXRhY2hlZCBub2RlP1xyXG4gICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXHJcbiAgICAgIC8vIHRoaW4gYWlyIG9uIElFOCwgdGhpcyBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSB0ZXh0XHJcbiAgICAgIC8vIGluLWZyb250IG9mIHRoZSBub24tdmlzaWJsZSB0YWdzLiBQaWdneWJhY2sgb24gdGhlIHdoaXRlc3BhY2UgZml4XHJcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXHJcbiAgICAgIGlmIChXSElURVNQQUNFX1RFU1QudGVzdChodG1sKSB8fCBodG1sWzBdID09PSAnPCcgJiYgTk9OVklTSUJMRV9URVNULnRlc3QoaHRtbCkpIHtcclxuICAgICAgICAvLyBSZWNvdmVyIGxlYWRpbmcgd2hpdGVzcGFjZSBieSB0ZW1wb3JhcmlseSBwcmVwZW5kaW5nIGFueSBjaGFyYWN0ZXIuXHJcbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXHJcbiAgICAgICAgLy8gVWdsaWZ5SlMgZHJvcHMgVStGRUZGIGNoYXJzIHdoZW4gcGFyc2luZywgc28gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcclxuICAgICAgICAvLyBpbiBob3BlcyB0aGF0IHRoaXMgaXMgcHJlc2VydmVkIGV2ZW4gaWYgXCJcXHVGRUZGXCIgaXMgdHJhbnNmb3JtZWQgdG9cclxuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2Jsb2IvdjIuNC4yMC9saWIvcGFyc2UuanMjTDIxNlxyXG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpICsgaHRtbDtcclxuXHJcbiAgICAgICAgLy8gZGVsZXRlRGF0YSBsZWF2ZXMgYW4gZW1wdHkgYFRleHROb2RlYCB3aGljaCBvZmZzZXRzIHRoZSBpbmRleCBvZiBhbGxcclxuICAgICAgICAvLyBjaGlsZHJlbi4gRGVmaW5pdGVseSB3YW50IHRvIGF2b2lkIHRoaXMuXHJcbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xyXG4gICAgICAgIGlmICh0ZXh0Tm9kZS5kYXRhLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgdGVzdEVsZW1lbnQgPSBudWxsO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHNldElubmVySFRNTDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xyXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcclxudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XHJcblxyXG4vKipcclxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcclxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XHJcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcclxuICogYXMgaXQgc2hvdWxkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xyXG4gIGlmICh0ZXh0KSB7XHJcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcclxuXHJcbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSAzKSB7XHJcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcclxufTtcclxuXHJcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcclxuICBpZiAoISgndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcclxuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcclxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcclxuICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHNldElubmVySFRNTChub2RlLCBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkpO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgYHByZXZFbGVtZW50YCBhbmQgYG5leHRFbGVtZW50YCwgZGV0ZXJtaW5lcyBpZiB0aGUgZXhpc3RpbmdcclxuICogaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQgYXMgb3Bwb3NlZCB0byBiZWluZyBkZXN0cm95ZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXdcclxuICogaW5zdGFuY2UuIEJvdGggYXJndW1lbnRzIGFyZSBlbGVtZW50cy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBsb2dpYyBjYW5cclxuICogb3BlcmF0ZSBvbiBzdGF0ZWxlc3MgdHJlZXMgd2l0aG91dCBhbnkgYmFja2luZyBpbnN0YW5jZS5cclxuICpcclxuICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2RWxlbWVudFxyXG4gKiBAcGFyYW0gez9vYmplY3R9IG5leHRFbGVtZW50XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkLlxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XHJcbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcclxuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xyXG4gIGlmIChwcmV2RW1wdHkgfHwgbmV4dEVtcHR5KSB7XHJcbiAgICByZXR1cm4gcHJldkVtcHR5ID09PSBuZXh0RW1wdHk7XHJcbiAgfVxyXG5cclxuICB2YXIgcHJldlR5cGUgPSB0eXBlb2YgcHJldkVsZW1lbnQ7XHJcbiAgdmFyIG5leHRUeXBlID0gdHlwZW9mIG5leHRFbGVtZW50O1xyXG4gIGlmIChwcmV2VHlwZSA9PT0gJ3N0cmluZycgfHwgcHJldlR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdzdHJpbmcnIHx8IG5leHRUeXBlID09PSAnbnVtYmVyJztcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnb2JqZWN0JyAmJiBwcmV2RWxlbWVudC50eXBlID09PSBuZXh0RWxlbWVudC50eXBlICYmIHByZXZFbGVtZW50LmtleSA9PT0gbmV4dEVsZW1lbnQua2V5O1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XHJcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xyXG5cclxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIFNFUEFSQVRPUiA9ICcuJztcclxudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQgc2luY2UgdGhpcyBmaWxlIGlzIHNoYXJlZCBiZXR3ZWVuXHJcbiAqIGlzb21vcnBoaWMgYW5kIHJlbmRlcmVycy4gV2UgY291bGQgZXh0cmFjdCB0aGlzIHRvIGFcclxuICpcclxuICovXHJcblxyXG4vKipcclxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XHJcbiAqIHBhdHRlcm4uXHJcbiAqL1xyXG5cclxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cclxuICpcclxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xyXG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXHJcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXHJcbiAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcclxuICAgIC8vIEV4cGxpY2l0IGtleVxyXG4gICAgcmV0dXJuIEtleUVzY2FwZVV0aWxzLmVzY2FwZShjb21wb25lbnQua2V5KTtcclxuICB9XHJcbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcclxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXHJcbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cclxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXHJcbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXHJcbiAqIHByb2Nlc3MuXHJcbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xyXG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xyXG5cclxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cclxuICAgIGNoaWxkcmVuID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fFxyXG4gIC8vIFRoZSBmb2xsb3dpbmcgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudC4gVGhpcyBtZWFucyB3ZSBjYW4gb3B0aW1pemVcclxuICAvLyBzb21lIGNoZWNrcy4gUmVhY3QgRmliZXIgYWxzbyBpbmxpbmVzIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgcHVycG9zZXMuXHJcbiAgdHlwZSA9PT0gJ29iamVjdCcgJiYgY2hpbGRyZW4uJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xyXG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcclxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XHJcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxyXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xyXG4gICAgcmV0dXJuIDE7XHJcbiAgfVxyXG5cclxuICB2YXIgY2hpbGQ7XHJcbiAgdmFyIG5leHROYW1lO1xyXG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxyXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcclxuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XHJcbiAgICBpZiAoaXRlcmF0b3JGbikge1xyXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xyXG4gICAgICB2YXIgc3RlcDtcclxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcclxuICAgICAgICB2YXIgaWkgPSAwO1xyXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcclxuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcclxuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xyXG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcnO1xyXG4gICAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSkge1xyXG4gICAgICAgICAgICAgIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgKyAnYC4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3QgeWV0IGZ1bGx5IHN1cHBvcnRlZC4gSXQgaXMgYW4gJyArICdleHBlcmltZW50YWwgZmVhdHVyZSB0aGF0IG1pZ2h0IGJlIHJlbW92ZWQuIENvbnZlcnQgaXQgdG8gYSAnICsgJ3NlcXVlbmNlIC8gaXRlcmFibGUgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSkgOiB2b2lkIDA7XHJcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXHJcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xyXG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcclxuICAgICAgICAgIGlmIChlbnRyeSkge1xyXG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xyXG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XHJcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xyXG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEl0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYW4gZWxlbWVudCBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50ICcgKyAndmVyc2lvbiBvZiBSZWFjdC4gTWFrZSBzdXJlIHRvIHVzZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0Lic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XHJcbiAgICAgICAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xyXG4gICAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xyXG4gICAgICAhZmFsc2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IF9wcm9kSW52YXJpYW50KCczMScsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogdm9pZCAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxyXG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XHJcbiAqXHJcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcclxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxyXG4gKlxyXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcclxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcclxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxyXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxyXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxyXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcclxuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XHJcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcclxuICAvL1xyXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXHJcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcclxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcclxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXHJcbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxyXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxyXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXHJcblxyXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcclxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XHJcblxyXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXHJcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcclxuXHJcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxyXG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxyXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcclxuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XHJcblxyXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxyXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XHJcblxyXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcclxuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XHJcblxyXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcclxuICAgIGN1cnJlbnQ6IG51bGwsXHJcblxyXG4gICAgZm9ybVRhZzogbnVsbCxcclxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxyXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcclxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxyXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXHJcblxyXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcclxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXHJcbiAgfTtcclxuXHJcbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xyXG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xyXG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcclxuXHJcbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xyXG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xyXG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XHJcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcclxuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxyXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxyXG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xyXG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XHJcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xyXG5cclxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xyXG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XHJcbiAgICB9XHJcbiAgICBpZiAodGFnID09PSAnYScpIHtcclxuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcclxuICAgIH1cclxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XHJcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcclxuICAgIH1cclxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xyXG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XHJcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XHJcbiAgICB9XHJcbiAgICBpZiAodGFnID09PSAnbGknKSB7XHJcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcclxuICAgIH1cclxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XHJcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXJcclxuICAgKi9cclxuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcclxuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxyXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcclxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XHJcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XHJcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcclxuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxyXG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcclxuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxyXG4gICAgICAvLyBidXRcclxuICAgICAgY2FzZSAnb3B0aW9uJzpcclxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xyXG5cclxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcclxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxyXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxyXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxyXG5cclxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcclxuICAgICAgY2FzZSAndHInOlxyXG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcclxuXHJcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XHJcbiAgICAgIGNhc2UgJ3Rib2R5JzpcclxuICAgICAgY2FzZSAndGhlYWQnOlxyXG4gICAgICBjYXNlICd0Zm9vdCc6XHJcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XHJcblxyXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxyXG4gICAgICBjYXNlICdjb2xncm91cCc6XHJcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xyXG5cclxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcclxuICAgICAgY2FzZSAndGFibGUnOlxyXG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xyXG5cclxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxyXG4gICAgICBjYXNlICdoZWFkJzpcclxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcclxuXHJcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcclxuICAgICAgY2FzZSAnaHRtbCc6XHJcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xyXG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxyXG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXHJcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXHJcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XHJcbiAgICBzd2l0Y2ggKHRhZykge1xyXG4gICAgICBjYXNlICdoMSc6XHJcbiAgICAgIGNhc2UgJ2gyJzpcclxuICAgICAgY2FzZSAnaDMnOlxyXG4gICAgICBjYXNlICdoNCc6XHJcbiAgICAgIGNhc2UgJ2g1JzpcclxuICAgICAgY2FzZSAnaDYnOlxyXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcclxuXHJcbiAgICAgIGNhc2UgJ3JwJzpcclxuICAgICAgY2FzZSAncnQnOlxyXG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xyXG5cclxuICAgICAgY2FzZSAnYm9keSc6XHJcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxyXG4gICAgICBjYXNlICdjb2wnOlxyXG4gICAgICBjYXNlICdjb2xncm91cCc6XHJcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcclxuICAgICAgY2FzZSAnaGVhZCc6XHJcbiAgICAgIGNhc2UgJ2h0bWwnOlxyXG4gICAgICBjYXNlICd0Ym9keSc6XHJcbiAgICAgIGNhc2UgJ3RkJzpcclxuICAgICAgY2FzZSAndGZvb3QnOlxyXG4gICAgICBjYXNlICd0aCc6XHJcbiAgICAgIGNhc2UgJ3RoZWFkJzpcclxuICAgICAgY2FzZSAndHInOlxyXG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXHJcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxyXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxyXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXJcclxuICAgKi9cclxuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xyXG4gICAgc3dpdGNoICh0YWcpIHtcclxuICAgICAgY2FzZSAnYWRkcmVzcyc6XHJcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxyXG4gICAgICBjYXNlICdhc2lkZSc6XHJcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxyXG4gICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICBjYXNlICdkZXRhaWxzJzpcclxuICAgICAgY2FzZSAnZGlhbG9nJzpcclxuICAgICAgY2FzZSAnZGlyJzpcclxuICAgICAgY2FzZSAnZGl2JzpcclxuICAgICAgY2FzZSAnZGwnOlxyXG4gICAgICBjYXNlICdmaWVsZHNldCc6XHJcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxyXG4gICAgICBjYXNlICdmaWd1cmUnOlxyXG4gICAgICBjYXNlICdmb290ZXInOlxyXG4gICAgICBjYXNlICdoZWFkZXInOlxyXG4gICAgICBjYXNlICdoZ3JvdXAnOlxyXG4gICAgICBjYXNlICdtYWluJzpcclxuICAgICAgY2FzZSAnbWVudSc6XHJcbiAgICAgIGNhc2UgJ25hdic6XHJcbiAgICAgIGNhc2UgJ29sJzpcclxuICAgICAgY2FzZSAncCc6XHJcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxyXG4gICAgICBjYXNlICdzdW1tYXJ5JzpcclxuICAgICAgY2FzZSAndWwnOlxyXG5cclxuICAgICAgY2FzZSAncHJlJzpcclxuICAgICAgY2FzZSAnbGlzdGluZyc6XHJcblxyXG4gICAgICBjYXNlICd0YWJsZSc6XHJcblxyXG4gICAgICBjYXNlICdocic6XHJcblxyXG4gICAgICBjYXNlICd4bXAnOlxyXG5cclxuICAgICAgY2FzZSAnaDEnOlxyXG4gICAgICBjYXNlICdoMic6XHJcbiAgICAgIGNhc2UgJ2gzJzpcclxuICAgICAgY2FzZSAnaDQnOlxyXG4gICAgICBjYXNlICdoNSc6XHJcbiAgICAgIGNhc2UgJ2g2JzpcclxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xyXG5cclxuICAgICAgY2FzZSAnZm9ybSc6XHJcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcclxuXHJcbiAgICAgIGNhc2UgJ2xpJzpcclxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XHJcblxyXG4gICAgICBjYXNlICdkZCc6XHJcbiAgICAgIGNhc2UgJ2R0JzpcclxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xyXG5cclxuICAgICAgY2FzZSAnYnV0dG9uJzpcclxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XHJcblxyXG4gICAgICBjYXNlICdhJzpcclxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcclxuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXHJcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcclxuXHJcbiAgICAgIGNhc2UgJ25vYnInOlxyXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXHJcbiAgICogb3duZXJzLCBzdGFydGluZyBhdCB0aGUgcm9vdCBhbmQgZW5kaW5nIHdpdGggdGhlIGluc3RhbmNlIGl0c2VsZi5cclxuICAgKi9cclxuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdGFjayA9IFtdO1xyXG4gICAgZG8ge1xyXG4gICAgICBzdGFjay5wdXNoKGluc3RhbmNlKTtcclxuICAgIH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XHJcbiAgICBzdGFjay5yZXZlcnNlKCk7XHJcbiAgICByZXR1cm4gc3RhY2s7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGRpZFdhcm4gPSB7fTtcclxuXHJcbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGNoaWxkSW5zdGFuY2UsIGFuY2VzdG9ySW5mbykge1xyXG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xyXG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcclxuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xyXG5cclxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjaGlsZFRhZyA9PSBudWxsLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJykgOiB2b2lkIDA7XHJcbiAgICAgIGNoaWxkVGFnID0gJyN0ZXh0JztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XHJcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xyXG4gICAgdmFyIHByb2JsZW1hdGljID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XHJcblxyXG4gICAgaWYgKHByb2JsZW1hdGljKSB7XHJcbiAgICAgIHZhciBhbmNlc3RvclRhZyA9IHByb2JsZW1hdGljLnRhZztcclxuICAgICAgdmFyIGFuY2VzdG9ySW5zdGFuY2UgPSBwcm9ibGVtYXRpYy5pbnN0YW5jZTtcclxuXHJcbiAgICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XHJcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyID0gYW5jZXN0b3JJbnN0YW5jZSAmJiBhbmNlc3Rvckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XHJcblxyXG4gICAgICB2YXIgY2hpbGRPd25lcnMgPSBmaW5kT3duZXJTdGFjayhjaGlsZE93bmVyKTtcclxuICAgICAgdmFyIGFuY2VzdG9yT3duZXJzID0gZmluZE93bmVyU3RhY2soYW5jZXN0b3JPd25lcik7XHJcblxyXG4gICAgICB2YXIgbWluU3RhY2tMZW4gPSBNYXRoLm1pbihjaGlsZE93bmVycy5sZW5ndGgsIGFuY2VzdG9yT3duZXJzLmxlbmd0aCk7XHJcbiAgICAgIHZhciBpO1xyXG5cclxuICAgICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IG1pblN0YWNrTGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoY2hpbGRPd25lcnNbaV0gPT09IGFuY2VzdG9yT3duZXJzW2ldKSB7XHJcbiAgICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgVU5LTk9XTiA9ICcodW5rbm93biknO1xyXG4gICAgICB2YXIgY2hpbGRPd25lck5hbWVzID0gY2hpbGRPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xyXG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xyXG4gICAgICB9KTtcclxuICAgICAgdmFyIGFuY2VzdG9yT3duZXJOYW1lcyA9IGFuY2VzdG9yT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcclxuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcclxuICAgICAgfSk7XHJcbiAgICAgIHZhciBvd25lckluZm8gPSBbXS5jb25jYXQoXHJcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgYW5kIGNoaWxkIGluc3RhbmNlcyBoYXZlIGEgY29tbW9uIG93bmVyIGFuY2VzdG9yLCBzdGFydFxyXG4gICAgICAvLyB3aXRoIHRoYXQgLS0gb3RoZXJ3aXNlIHdlIGp1c3Qgc3RhcnQgd2l0aCB0aGUgcGFyZW50J3Mgb3duZXJzLlxyXG4gICAgICBkZWVwZXN0Q29tbW9uICE9PSAtMSA/IGNoaWxkT3duZXJzW2RlZXBlc3RDb21tb25dLmdldE5hbWUoKSB8fCBVTktOT1dOIDogW10sIGFuY2VzdG9yT3duZXJOYW1lcywgYW5jZXN0b3JUYWcsXHJcbiAgICAgIC8vIElmIHdlJ3JlIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCAobm9uLXBhcmVudCkgYW5jZXN0cnksIGFkZCAnLi4uJ1xyXG4gICAgICBpbnZhbGlkQW5jZXN0b3IgPyBbJy4uLiddIDogW10sIGNoaWxkT3duZXJOYW1lcywgY2hpbGRUYWcpLmpvaW4oJyA+ICcpO1xyXG5cclxuICAgICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgb3duZXJJbmZvO1xyXG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xyXG4gICAgICB2YXIgd2hpdGVzcGFjZUluZm8gPSAnJztcclxuICAgICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XHJcbiAgICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xyXG4gICAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnVGV4dCBub2Rlcyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XHJcbiAgICAgICAgICB3aGl0ZXNwYWNlSW5mbyA9ICcgTWFrZSBzdXJlIHlvdSBkb25cXCd0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uICcgKyAnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGludmFsaWRQYXJlbnQpIHtcclxuICAgICAgICB2YXIgaW5mbyA9ICcnO1xyXG4gICAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xyXG4gICAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyAnICsgJ1NlZSAlcy4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgd2hpdGVzcGFjZUluZm8sIG93bmVySW5mbywgaW5mbykgOiB2b2lkIDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiBTZWUgJXMuJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBvd25lckluZm8pIDogdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvO1xyXG5cclxuICAvLyBGb3IgdGVzdGluZ1xyXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XHJcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XHJcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xyXG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XHJcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcclxuICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlRE9NTmVzdGluZzsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHMubG9vcEFzeW5jID0gbG9vcEFzeW5jO1xyXG5leHBvcnRzLm1hcEFzeW5jID0gbWFwQXN5bmM7XHJcbmZ1bmN0aW9uIGxvb3BBc3luYyh0dXJucywgd29yaywgY2FsbGJhY2spIHtcclxuICB2YXIgY3VycmVudFR1cm4gPSAwLFxyXG4gICAgICBpc0RvbmUgPSBmYWxzZTtcclxuICB2YXIgc3luYyA9IGZhbHNlLFxyXG4gICAgICBoYXNOZXh0ID0gZmFsc2UsXHJcbiAgICAgIGRvbmVBcmdzID0gdm9pZCAwO1xyXG5cclxuICBmdW5jdGlvbiBkb25lKCkge1xyXG4gICAgaXNEb25lID0gdHJ1ZTtcclxuICAgIGlmIChzeW5jKSB7XHJcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXHJcbiAgICAgIGRvbmVBcmdzID0gW10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICBpZiAoaXNEb25lKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBoYXNOZXh0ID0gdHJ1ZTtcclxuICAgIGlmIChzeW5jKSB7XHJcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzeW5jID0gdHJ1ZTtcclxuXHJcbiAgICB3aGlsZSAoIWlzRG9uZSAmJiBjdXJyZW50VHVybiA8IHR1cm5zICYmIGhhc05leHQpIHtcclxuICAgICAgaGFzTmV4dCA9IGZhbHNlO1xyXG4gICAgICB3b3JrLmNhbGwodGhpcywgY3VycmVudFR1cm4rKywgbmV4dCwgZG9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3luYyA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChpc0RvbmUpIHtcclxuICAgICAgLy8gVGhpcyBtZWFucyB0aGUgbG9vcCBmaW5pc2hlZCBzeW5jaHJvbm91c2x5LlxyXG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBkb25lQXJncyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY3VycmVudFR1cm4gPj0gdHVybnMgJiYgaGFzTmV4dCkge1xyXG4gICAgICBpc0RvbmUgPSB0cnVlO1xyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmV4dCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBBc3luYyhhcnJheSwgd29yaywgY2FsbGJhY2spIHtcclxuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG4gIHZhciB2YWx1ZXMgPSBbXTtcclxuXHJcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHZhbHVlcyk7XHJcblxyXG4gIHZhciBpc0RvbmUgPSBmYWxzZSxcclxuICAgICAgZG9uZUNvdW50ID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gZG9uZShpbmRleCwgZXJyb3IsIHZhbHVlKSB7XHJcbiAgICBpZiAoaXNEb25lKSByZXR1cm47XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGlzRG9uZSA9IHRydWU7XHJcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcclxuXHJcbiAgICAgIGlzRG9uZSA9ICsrZG9uZUNvdW50ID09PSBsZW5ndGg7XHJcblxyXG4gICAgICBpZiAoaXNEb25lKSBjYWxsYmFjayhudWxsLCB2YWx1ZXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcclxuICAgIHdvcmsoaXRlbSwgaW5kZXgsIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcclxuICAgICAgZG9uZShpbmRleCwgZXJyb3IsIHZhbHVlKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XHJcbmV4cG9ydHMuQ29udGV4dFN1YnNjcmliZXIgPSBDb250ZXh0U3Vic2NyaWJlcjtcclxuXHJcbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG5cclxuLy8gV29ya3MgYXJvdW5kIGlzc3VlcyB3aXRoIGNvbnRleHQgdXBkYXRlcyBmYWlsaW5nIHRvIHByb3BhZ2F0ZS5cclxuLy8gQ2F2ZWF0OiB0aGUgY29udGV4dCB2YWx1ZSBpcyBleHBlY3RlZCB0byBuZXZlciBjaGFuZ2UgaXRzIGlkZW50aXR5LlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzI1MTdcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy80NzBcclxuXHJcbnZhciBjb250ZXh0UHJvdmlkZXJTaGFwZSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGUoe1xyXG4gIHN1YnNjcmliZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXHJcbiAgZXZlbnRJbmRleDogX3JlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIG1ha2VDb250ZXh0TmFtZShuYW1lKSB7XHJcbiAgcmV0dXJuICdAQGNvbnRleHRTdWJzY3JpYmVyLycgKyBuYW1lO1xyXG59XHJcblxyXG5mdW5jdGlvbiBDb250ZXh0UHJvdmlkZXIobmFtZSkge1xyXG4gIHZhciBfY2hpbGRDb250ZXh0VHlwZXMsIF9yZWYyO1xyXG5cclxuICB2YXIgY29udGV4dE5hbWUgPSBtYWtlQ29udGV4dE5hbWUobmFtZSk7XHJcbiAgdmFyIGxpc3RlbmVyc0tleSA9IGNvbnRleHROYW1lICsgJy9saXN0ZW5lcnMnO1xyXG4gIHZhciBldmVudEluZGV4S2V5ID0gY29udGV4dE5hbWUgKyAnL2V2ZW50SW5kZXgnO1xyXG4gIHZhciBzdWJzY3JpYmVLZXkgPSBjb250ZXh0TmFtZSArICcvc3Vic2NyaWJlJztcclxuXHJcbiAgcmV0dXJuIF9yZWYyID0ge1xyXG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IChfY2hpbGRDb250ZXh0VHlwZXMgPSB7fSwgX2NoaWxkQ29udGV4dFR5cGVzW2NvbnRleHROYW1lXSA9IGNvbnRleHRQcm92aWRlclNoYXBlLmlzUmVxdWlyZWQsIF9jaGlsZENvbnRleHRUeXBlcyksXHJcblxyXG4gICAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XHJcbiAgICAgIHZhciBfcmVmO1xyXG5cclxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltjb250ZXh0TmFtZV0gPSB7XHJcbiAgICAgICAgZXZlbnRJbmRleDogdGhpc1tldmVudEluZGV4S2V5XSxcclxuICAgICAgICBzdWJzY3JpYmU6IHRoaXNbc3Vic2NyaWJlS2V5XVxyXG4gICAgICB9LCBfcmVmO1xyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xyXG4gICAgICB0aGlzW2xpc3RlbmVyc0tleV0gPSBbXTtcclxuICAgICAgdGhpc1tldmVudEluZGV4S2V5XSA9IDA7XHJcbiAgICB9LFxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcclxuICAgICAgdGhpc1tldmVudEluZGV4S2V5XSsrO1xyXG4gICAgfSxcclxuICAgIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgdGhpc1tsaXN0ZW5lcnNLZXldLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKF90aGlzW2V2ZW50SW5kZXhLZXldKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwgX3JlZjJbc3Vic2NyaWJlS2V5XSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcblxyXG4gICAgLy8gTm8gbmVlZCB0byBpbW1lZGlhdGVseSBjYWxsIGxpc3RlbmVyIGhlcmUuXHJcbiAgICB0aGlzW2xpc3RlbmVyc0tleV0ucHVzaChsaXN0ZW5lcik7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgX3RoaXMyW2xpc3RlbmVyc0tleV0gPSBfdGhpczJbbGlzdGVuZXJzS2V5XS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICB9LCBfcmVmMjtcclxufVxyXG5cclxuZnVuY3Rpb24gQ29udGV4dFN1YnNjcmliZXIobmFtZSkge1xyXG4gIHZhciBfY29udGV4dFR5cGVzLCBfcmVmNDtcclxuXHJcbiAgdmFyIGNvbnRleHROYW1lID0gbWFrZUNvbnRleHROYW1lKG5hbWUpO1xyXG4gIHZhciBsYXN0UmVuZGVyZWRFdmVudEluZGV4S2V5ID0gY29udGV4dE5hbWUgKyAnL2xhc3RSZW5kZXJlZEV2ZW50SW5kZXgnO1xyXG4gIHZhciBoYW5kbGVDb250ZXh0VXBkYXRlS2V5ID0gY29udGV4dE5hbWUgKyAnL2hhbmRsZUNvbnRleHRVcGRhdGUnO1xyXG4gIHZhciB1bnN1YnNjcmliZUtleSA9IGNvbnRleHROYW1lICsgJy91bnN1YnNjcmliZSc7XHJcblxyXG4gIHJldHVybiBfcmVmNCA9IHtcclxuICAgIGNvbnRleHRUeXBlczogKF9jb250ZXh0VHlwZXMgPSB7fSwgX2NvbnRleHRUeXBlc1tjb250ZXh0TmFtZV0gPSBjb250ZXh0UHJvdmlkZXJTaGFwZSwgX2NvbnRleHRUeXBlcyksXHJcblxyXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XHJcbiAgICAgIHZhciBfcmVmMztcclxuXHJcbiAgICAgIGlmICghdGhpcy5jb250ZXh0W2NvbnRleHROYW1lXSkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIF9yZWYzID0ge30sIF9yZWYzW2xhc3RSZW5kZXJlZEV2ZW50SW5kZXhLZXldID0gdGhpcy5jb250ZXh0W2NvbnRleHROYW1lXS5ldmVudEluZGV4LCBfcmVmMztcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgIGlmICghdGhpcy5jb250ZXh0W2NvbnRleHROYW1lXSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpc1t1bnN1YnNjcmliZUtleV0gPSB0aGlzLmNvbnRleHRbY29udGV4dE5hbWVdLnN1YnNjcmliZSh0aGlzW2hhbmRsZUNvbnRleHRVcGRhdGVLZXldKTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xyXG4gICAgICB2YXIgX3NldFN0YXRlO1xyXG5cclxuICAgICAgaWYgKCF0aGlzLmNvbnRleHRbY29udGV4dE5hbWVdKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnNldFN0YXRlKChfc2V0U3RhdGUgPSB7fSwgX3NldFN0YXRlW2xhc3RSZW5kZXJlZEV2ZW50SW5kZXhLZXldID0gdGhpcy5jb250ZXh0W2NvbnRleHROYW1lXS5ldmVudEluZGV4LCBfc2V0U3RhdGUpKTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgIGlmICghdGhpc1t1bnN1YnNjcmliZUtleV0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXNbdW5zdWJzY3JpYmVLZXldKCk7XHJcbiAgICAgIHRoaXNbdW5zdWJzY3JpYmVLZXldID0gbnVsbDtcclxuICAgIH1cclxuICB9LCBfcmVmNFtoYW5kbGVDb250ZXh0VXBkYXRlS2V5XSA9IGZ1bmN0aW9uIChldmVudEluZGV4KSB7XHJcbiAgICBpZiAoZXZlbnRJbmRleCAhPT0gdGhpcy5zdGF0ZVtsYXN0UmVuZGVyZWRFdmVudEluZGV4S2V5XSkge1xyXG4gICAgICB2YXIgX3NldFN0YXRlMjtcclxuXHJcbiAgICAgIHRoaXMuc2V0U3RhdGUoKF9zZXRTdGF0ZTIgPSB7fSwgX3NldFN0YXRlMltsYXN0UmVuZGVyZWRFdmVudEluZGV4S2V5XSA9IGV2ZW50SW5kZXgsIF9zZXRTdGF0ZTIpKTtcclxuICAgIH1cclxuICB9LCBfcmVmNDtcclxufSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcblxyXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcclxuXHJcbnZhciBfTGluayA9IHJlcXVpcmUoJy4vTGluaycpO1xyXG5cclxudmFyIF9MaW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpbmspO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBBbiA8SW5kZXhMaW5rPiBpcyB1c2VkIHRvIGxpbmsgdG8gYW4gPEluZGV4Um91dGU+LlxyXG4gKi9cclxudmFyIEluZGV4TGluayA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XHJcbiAgZGlzcGxheU5hbWU6ICdJbmRleExpbmsnLFxyXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9MaW5rMi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyBvbmx5QWN0aXZlT25JbmRleDogdHJ1ZSB9KSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4TGluaztcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG5cclxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XHJcblxyXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcclxuXHJcbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcclxuXHJcbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XHJcblxyXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xyXG5cclxudmFyIF9SZWRpcmVjdCA9IHJlcXVpcmUoJy4vUmVkaXJlY3QnKTtcclxuXHJcbnZhciBfUmVkaXJlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVkaXJlY3QpO1xyXG5cclxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMsXHJcbiAgICBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xyXG5cclxuLyoqXHJcbiAqIEFuIDxJbmRleFJlZGlyZWN0PiBpcyB1c2VkIHRvIHJlZGlyZWN0IGZyb20gYW4gaW5kZXhSb3V0ZS5cclxuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3JlcXVpcmUtcmVuZGVyLXJldHVybiAqL1xyXG5cclxudmFyIEluZGV4UmVkaXJlY3QgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xyXG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhSZWRpcmVjdCcsXHJcblxyXG5cclxuICBzdGF0aWNzOiB7XHJcbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50LCBwYXJlbnRSb3V0ZSkge1xyXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogc2FuaXR5IGNoZWNrICovXHJcbiAgICAgIGlmIChwYXJlbnRSb3V0ZSkge1xyXG4gICAgICAgIHBhcmVudFJvdXRlLmluZGV4Um91dGUgPSBfUmVkaXJlY3QyLmRlZmF1bHQuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnQW4gPEluZGV4UmVkaXJlY3Q+IGRvZXMgbm90IG1ha2Ugc2Vuc2UgYXQgdGhlIHJvb3Qgb2YgeW91ciByb3V0ZSBjb25maWcnKSA6IHZvaWQgMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHByb3BUeXBlczoge1xyXG4gICAgdG86IHN0cmluZy5pc1JlcXVpcmVkLFxyXG4gICAgcXVlcnk6IG9iamVjdCxcclxuICAgIHN0YXRlOiBvYmplY3QsXHJcbiAgICBvbkVudGVyOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXHJcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5XHJcbiAgfSxcclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xyXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgIWZhbHNlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxJbmRleFJlZGlyZWN0PiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XHJcbiAgfVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4UmVkaXJlY3Q7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxuXHJcbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xyXG5cclxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XHJcblxyXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XHJcblxyXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xyXG5cclxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcclxuXHJcbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xyXG5cclxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgZnVuYyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMuZnVuYztcclxuXHJcbi8qKlxyXG4gKiBBbiA8SW5kZXhSb3V0ZT4gaXMgdXNlZCB0byBzcGVjaWZ5IGl0cyBwYXJlbnQncyA8Um91dGUgaW5kZXhSb3V0ZT4gaW5cclxuICogYSBKU1ggcm91dGUgY29uZmlnLlxyXG4gKi9cclxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcmVxdWlyZS1yZW5kZXItcmV0dXJuICovXHJcblxyXG52YXIgSW5kZXhSb3V0ZSA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XHJcbiAgZGlzcGxheU5hbWU6ICdJbmRleFJvdXRlJyxcclxuXHJcblxyXG4gIHN0YXRpY3M6IHtcclxuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKSB7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBzYW5pdHkgY2hlY2sgKi9cclxuICAgICAgaWYgKHBhcmVudFJvdXRlKSB7XHJcbiAgICAgICAgcGFyZW50Um91dGUuaW5kZXhSb3V0ZSA9ICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpKGVsZW1lbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnQW4gPEluZGV4Um91dGU+IGRvZXMgbm90IG1ha2Ugc2Vuc2UgYXQgdGhlIHJvb3Qgb2YgeW91ciByb3V0ZSBjb25maWcnKSA6IHZvaWQgMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHByb3BUeXBlczoge1xyXG4gICAgcGF0aDogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5LFxyXG4gICAgY29tcG9uZW50OiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50LFxyXG4gICAgY29tcG9uZW50czogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudHMsXHJcbiAgICBnZXRDb21wb25lbnQ6IGZ1bmMsXHJcbiAgICBnZXRDb21wb25lbnRzOiBmdW5jXHJcbiAgfSxcclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xyXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgIWZhbHNlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxJbmRleFJvdXRlPiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XHJcbiAgfVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4Um91dGU7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHMucm91dGVzID0gZXhwb3J0cy5yb3V0ZSA9IGV4cG9ydHMuY29tcG9uZW50cyA9IGV4cG9ydHMuY29tcG9uZW50ID0gZXhwb3J0cy5oaXN0b3J5ID0gdW5kZWZpbmVkO1xyXG5leHBvcnRzLmZhbHN5ID0gZmFsc3k7XHJcblxyXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxuXHJcbnZhciBmdW5jID0gX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxyXG4gICAgb2JqZWN0ID0gX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBhcnJheU9mID0gX3JlYWN0LlByb3BUeXBlcy5hcnJheU9mLFxyXG4gICAgb25lT2ZUeXBlID0gX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGUsXHJcbiAgICBlbGVtZW50ID0gX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50LFxyXG4gICAgc2hhcGUgPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlLFxyXG4gICAgc3RyaW5nID0gX3JlYWN0LlByb3BUeXBlcy5zdHJpbmc7XHJcbmZ1bmN0aW9uIGZhbHN5KHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xyXG4gIGlmIChwcm9wc1twcm9wTmFtZV0pIHJldHVybiBuZXcgRXJyb3IoJzwnICsgY29tcG9uZW50TmFtZSArICc+IHNob3VsZCBub3QgaGF2ZSBhIFwiJyArIHByb3BOYW1lICsgJ1wiIHByb3AnKTtcclxufVxyXG5cclxudmFyIGhpc3RvcnkgPSBleHBvcnRzLmhpc3RvcnkgPSBzaGFwZSh7XHJcbiAgbGlzdGVuOiBmdW5jLmlzUmVxdWlyZWQsXHJcbiAgcHVzaDogZnVuYy5pc1JlcXVpcmVkLFxyXG4gIHJlcGxhY2U6IGZ1bmMuaXNSZXF1aXJlZCxcclxuICBnbzogZnVuYy5pc1JlcXVpcmVkLFxyXG4gIGdvQmFjazogZnVuYy5pc1JlcXVpcmVkLFxyXG4gIGdvRm9yd2FyZDogZnVuYy5pc1JlcXVpcmVkXHJcbn0pO1xyXG5cclxudmFyIGNvbXBvbmVudCA9IGV4cG9ydHMuY29tcG9uZW50ID0gb25lT2ZUeXBlKFtmdW5jLCBzdHJpbmddKTtcclxudmFyIGNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBvbmVPZlR5cGUoW2NvbXBvbmVudCwgb2JqZWN0XSk7XHJcbnZhciByb3V0ZSA9IGV4cG9ydHMucm91dGUgPSBvbmVPZlR5cGUoW29iamVjdCwgZWxlbWVudF0pO1xyXG52YXIgcm91dGVzID0gZXhwb3J0cy5yb3V0ZXMgPSBvbmVPZlR5cGUoW3JvdXRlLCBhcnJheU9mKHJvdXRlKV0pOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcblxyXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcclxuXHJcbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XHJcblxyXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xyXG5cclxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xyXG5cclxudmFyIF9Db250ZXh0VXRpbHMgPSByZXF1aXJlKCcuL0NvbnRleHRVdGlscycpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cclxuXHJcbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcyxcclxuICAgIGJvb2wgPSBfUmVhY3QkUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdCxcclxuICAgIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYyxcclxuICAgIG9uZU9mVHlwZSA9IF9SZWFjdCRQcm9wVHlwZXMub25lT2ZUeXBlO1xyXG5cclxuXHJcbmZ1bmN0aW9uIGlzTGVmdENsaWNrRXZlbnQoZXZlbnQpIHtcclxuICByZXR1cm4gZXZlbnQuYnV0dG9uID09PSAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcclxuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XHJcbn1cclxuXHJcbi8vIFRPRE86IERlLWR1cGxpY2F0ZSBhZ2FpbnN0IGhhc0FueVByb3BlcnRpZXMgaW4gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuXHJcbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqZWN0KSB7XHJcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSkgcmV0dXJuIGZhbHNlO1xyXG4gIH1yZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVRvTG9jYXRpb24odG8sIHJvdXRlcikge1xyXG4gIHJldHVybiB0eXBlb2YgdG8gPT09ICdmdW5jdGlvbicgPyB0byhyb3V0ZXIubG9jYXRpb24pIDogdG87XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIDxMaW5rPiBpcyB1c2VkIHRvIGNyZWF0ZSBhbiA8YT4gZWxlbWVudCB0aGF0IGxpbmtzIHRvIGEgcm91dGUuXHJcbiAqIFdoZW4gdGhhdCByb3V0ZSBpcyBhY3RpdmUsIHRoZSBsaW5rIGdldHMgdGhlIHZhbHVlIG9mIGl0c1xyXG4gKiBhY3RpdmVDbGFzc05hbWUgcHJvcC5cclxuICpcclxuICogRm9yIGV4YW1wbGUsIGFzc3VtaW5nIHlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgcm91dGU6XHJcbiAqXHJcbiAqICAgPFJvdXRlIHBhdGg9XCIvcG9zdHMvOnBvc3RJRFwiIGNvbXBvbmVudD17UG9zdH0gLz5cclxuICpcclxuICogWW91IGNvdWxkIHVzZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudCB0byBsaW5rIHRvIHRoYXQgcm91dGU6XHJcbiAqXHJcbiAqICAgPExpbmsgdG89e2AvcG9zdHMvJHtwb3N0LmlkfWB9IC8+XHJcbiAqXHJcbiAqIExpbmtzIG1heSBwYXNzIGFsb25nIGxvY2F0aW9uIHN0YXRlIGFuZC9vciBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyc1xyXG4gKiBpbiB0aGUgc3RhdGUvcXVlcnkgcHJvcHMsIHJlc3BlY3RpdmVseS5cclxuICpcclxuICogICA8TGluayAuLi4gcXVlcnk9e3sgc2hvdzogdHJ1ZSB9fSBzdGF0ZT17eyB0aGU6ICdzdGF0ZScgfX0gLz5cclxuICovXHJcbnZhciBMaW5rID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcclxuICBkaXNwbGF5TmFtZTogJ0xpbmsnLFxyXG5cclxuXHJcbiAgbWl4aW5zOiBbKDAsIF9Db250ZXh0VXRpbHMuQ29udGV4dFN1YnNjcmliZXIpKCdyb3V0ZXInKV0sXHJcblxyXG4gIGNvbnRleHRUeXBlczoge1xyXG4gICAgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlXHJcbiAgfSxcclxuXHJcbiAgcHJvcFR5cGVzOiB7XHJcbiAgICB0bzogb25lT2ZUeXBlKFtzdHJpbmcsIG9iamVjdCwgZnVuY10pLFxyXG4gICAgcXVlcnk6IG9iamVjdCxcclxuICAgIGhhc2g6IHN0cmluZyxcclxuICAgIHN0YXRlOiBvYmplY3QsXHJcbiAgICBhY3RpdmVTdHlsZTogb2JqZWN0LFxyXG4gICAgYWN0aXZlQ2xhc3NOYW1lOiBzdHJpbmcsXHJcbiAgICBvbmx5QWN0aXZlT25JbmRleDogYm9vbC5pc1JlcXVpcmVkLFxyXG4gICAgb25DbGljazogZnVuYyxcclxuICAgIHRhcmdldDogc3RyaW5nXHJcbiAgfSxcclxuXHJcbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvbmx5QWN0aXZlT25JbmRleDogZmFsc2UsXHJcbiAgICAgIHN0eWxlOiB7fVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGhhbmRsZUNsaWNrOiBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG4gICAgaWYgKHRoaXMucHJvcHMub25DbGljaykgdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcclxuXHJcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xyXG5cclxuICAgIHZhciByb3V0ZXIgPSB0aGlzLmNvbnRleHQucm91dGVyO1xyXG5cclxuICAgICFyb3V0ZXIgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPExpbms+cyByZW5kZXJlZCBvdXRzaWRlIG9mIGEgcm91dGVyIGNvbnRleHQgY2Fubm90IG5hdmlnYXRlLicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcclxuXHJcbiAgICBpZiAoaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB8fCAhaXNMZWZ0Q2xpY2tFdmVudChldmVudCkpIHJldHVybjtcclxuXHJcbiAgICAvLyBJZiB0YXJnZXQgcHJvcCBpcyBzZXQgKGUuZy4gdG8gXCJfYmxhbmtcIiksIGxldCBicm93c2VyIGhhbmRsZSBsaW5rLlxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB1bnRlc3RhYmxlIHdpdGggS2FybWEgKi9cclxuICAgIGlmICh0aGlzLnByb3BzLnRhcmdldCkgcmV0dXJuO1xyXG5cclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgcm91dGVyLnB1c2gocmVzb2x2ZVRvTG9jYXRpb24odGhpcy5wcm9wcy50bywgcm91dGVyKSk7XHJcbiAgfSxcclxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxyXG4gICAgICAgIHRvID0gX3Byb3BzLnRvLFxyXG4gICAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9wcm9wcy5hY3RpdmVDbGFzc05hbWUsXHJcbiAgICAgICAgYWN0aXZlU3R5bGUgPSBfcHJvcHMuYWN0aXZlU3R5bGUsXHJcbiAgICAgICAgb25seUFjdGl2ZU9uSW5kZXggPSBfcHJvcHMub25seUFjdGl2ZU9uSW5kZXgsXHJcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ3RvJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdhY3RpdmVTdHlsZScsICdvbmx5QWN0aXZlT25JbmRleCddKTtcclxuXHJcbiAgICAvLyBJZ25vcmUgaWYgcmVuZGVyZWQgb3V0c2lkZSB0aGUgY29udGV4dCBvZiByb3V0ZXIgdG8gc2ltcGxpZnkgdW5pdCB0ZXN0aW5nLlxyXG5cclxuXHJcbiAgICB2YXIgcm91dGVyID0gdGhpcy5jb250ZXh0LnJvdXRlcjtcclxuXHJcblxyXG4gICAgaWYgKHJvdXRlcikge1xyXG4gICAgICAvLyBJZiB1c2VyIGRvZXMgbm90IHNwZWNpZnkgYSBgdG9gIHByb3AsIHJldHVybiBhbiBlbXB0eSBhbmNob3IgdGFnLlxyXG4gICAgICBpZiAoIXRvKSB7XHJcbiAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdhJywgcHJvcHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgdG9Mb2NhdGlvbiA9IHJlc29sdmVUb0xvY2F0aW9uKHRvLCByb3V0ZXIpO1xyXG4gICAgICBwcm9wcy5ocmVmID0gcm91dGVyLmNyZWF0ZUhyZWYodG9Mb2NhdGlvbik7XHJcblxyXG4gICAgICBpZiAoYWN0aXZlQ2xhc3NOYW1lIHx8IGFjdGl2ZVN0eWxlICE9IG51bGwgJiYgIWlzRW1wdHlPYmplY3QoYWN0aXZlU3R5bGUpKSB7XHJcbiAgICAgICAgaWYgKHJvdXRlci5pc0FjdGl2ZSh0b0xvY2F0aW9uLCBvbmx5QWN0aXZlT25JbmRleCkpIHtcclxuICAgICAgICAgIGlmIChhY3RpdmVDbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BzLmNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgIHByb3BzLmNsYXNzTmFtZSArPSAnICcgKyBhY3RpdmVDbGFzc05hbWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lID0gYWN0aXZlQ2xhc3NOYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGFjdGl2ZVN0eWxlKSBwcm9wcy5zdHlsZSA9IF9leHRlbmRzKHt9LCBwcm9wcy5zdHlsZSwgYWN0aXZlU3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYScsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrIH0pKTtcclxuICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gTGluaztcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0cy5jb21waWxlUGF0dGVybiA9IGNvbXBpbGVQYXR0ZXJuO1xyXG5leHBvcnRzLm1hdGNoUGF0dGVybiA9IG1hdGNoUGF0dGVybjtcclxuZXhwb3J0cy5nZXRQYXJhbU5hbWVzID0gZ2V0UGFyYW1OYW1lcztcclxuZXhwb3J0cy5nZXRQYXJhbXMgPSBnZXRQYXJhbXM7XHJcbmV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IGZvcm1hdFBhdHRlcm47XHJcblxyXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xyXG5cclxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XHJcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xyXG4gIHZhciByZWdleHBTb3VyY2UgPSAnJztcclxuICB2YXIgcGFyYW1OYW1lcyA9IFtdO1xyXG4gIHZhciB0b2tlbnMgPSBbXTtcclxuXHJcbiAgdmFyIG1hdGNoID0gdm9pZCAwLFxyXG4gICAgICBsYXN0SW5kZXggPSAwLFxyXG4gICAgICBtYXRjaGVyID0gLzooW2EtekEtWl8kXVthLXpBLVowLTlfJF0qKXxcXCpcXCp8XFwqfFxcKHxcXCl8XFxcXFxcKHxcXFxcXFwpL2c7XHJcbiAgd2hpbGUgKG1hdGNoID0gbWF0Y2hlci5leGVjKHBhdHRlcm4pKSB7XHJcbiAgICBpZiAobWF0Y2guaW5kZXggIT09IGxhc3RJbmRleCkge1xyXG4gICAgICB0b2tlbnMucHVzaChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcclxuICAgICAgcmVnZXhwU291cmNlICs9IGVzY2FwZVJlZ0V4cChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWF0Y2hbMV0pIHtcclxuICAgICAgcmVnZXhwU291cmNlICs9ICcoW14vXSspJztcclxuICAgICAgcGFyYW1OYW1lcy5wdXNoKG1hdGNoWzFdKTtcclxuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcqKicpIHtcclxuICAgICAgcmVnZXhwU291cmNlICs9ICcoLiopJztcclxuICAgICAgcGFyYW1OYW1lcy5wdXNoKCdzcGxhdCcpO1xyXG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyonKSB7XHJcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKC4qPyknO1xyXG4gICAgICBwYXJhbU5hbWVzLnB1c2goJ3NwbGF0Jyk7XHJcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKCcpIHtcclxuICAgICAgcmVnZXhwU291cmNlICs9ICcoPzonO1xyXG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyknKSB7XHJcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKT8nO1xyXG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJ1xcXFwoJykge1xyXG4gICAgICByZWdleHBTb3VyY2UgKz0gJ1xcXFwoJztcclxuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICdcXFxcKScpIHtcclxuICAgICAgcmVnZXhwU291cmNlICs9ICdcXFxcKSc7XHJcbiAgICB9XHJcblxyXG4gICAgdG9rZW5zLnB1c2gobWF0Y2hbMF0pO1xyXG5cclxuICAgIGxhc3RJbmRleCA9IG1hdGNoZXIubGFzdEluZGV4O1xyXG4gIH1cclxuXHJcbiAgaWYgKGxhc3RJbmRleCAhPT0gcGF0dGVybi5sZW5ndGgpIHtcclxuICAgIHRva2Vucy5wdXNoKHBhdHRlcm4uc2xpY2UobGFzdEluZGV4LCBwYXR0ZXJuLmxlbmd0aCkpO1xyXG4gICAgcmVnZXhwU291cmNlICs9IGVzY2FwZVJlZ0V4cChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgcGF0dGVybi5sZW5ndGgpKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxyXG4gICAgcmVnZXhwU291cmNlOiByZWdleHBTb3VyY2UsXHJcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxyXG4gICAgdG9rZW5zOiB0b2tlbnNcclxuICB9O1xyXG59XHJcblxyXG52YXIgQ29tcGlsZWRQYXR0ZXJuc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbmZ1bmN0aW9uIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pIHtcclxuICBpZiAoIUNvbXBpbGVkUGF0dGVybnNDYWNoZVtwYXR0ZXJuXSkgQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dID0gX2NvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pO1xyXG5cclxuICByZXR1cm4gQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dO1xyXG59XHJcblxyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gbWF0Y2ggYSBwYXR0ZXJuIG9uIHRoZSBnaXZlbiBwYXRobmFtZS4gUGF0dGVybnMgbWF5IHVzZVxyXG4gKiB0aGUgZm9sbG93aW5nIHNwZWNpYWwgY2hhcmFjdGVyczpcclxuICpcclxuICogLSA6cGFyYW1OYW1lICAgICBNYXRjaGVzIGEgVVJMIHNlZ21lbnQgdXAgdG8gdGhlIG5leHQgLywgPywgb3IgIy4gVGhlXHJcbiAqICAgICAgICAgICAgICAgICAgY2FwdHVyZWQgc3RyaW5nIGlzIGNvbnNpZGVyZWQgYSBcInBhcmFtXCJcclxuICogLSAoKSAgICAgICAgICAgICBXcmFwcyBhIHNlZ21lbnQgb2YgdGhlIFVSTCB0aGF0IGlzIG9wdGlvbmFsXHJcbiAqIC0gKiAgICAgICAgICAgICAgQ29uc3VtZXMgKG5vbi1ncmVlZHkpIGFsbCBjaGFyYWN0ZXJzIHVwIHRvIHRoZSBuZXh0XHJcbiAqICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyIGluIHRoZSBwYXR0ZXJuLCBvciB0byB0aGUgZW5kIG9mIHRoZSBVUkwgaWZcclxuICogICAgICAgICAgICAgICAgICB0aGVyZSBpcyBub25lXHJcbiAqIC0gKiogICAgICAgICAgICAgQ29uc3VtZXMgKGdyZWVkeSkgYWxsIGNoYXJhY3RlcnMgdXAgdG8gdGhlIG5leHQgY2hhcmFjdGVyXHJcbiAqICAgICAgICAgICAgICAgICAgaW4gdGhlIHBhdHRlcm4sIG9yIHRvIHRoZSBlbmQgb2YgdGhlIFVSTCBpZiB0aGVyZSBpcyBub25lXHJcbiAqXHJcbiAqICBUaGUgZnVuY3Rpb24gY2FsbHMgY2FsbGJhY2soZXJyb3IsIG1hdGNoZWQpIHdoZW4gZmluaXNoZWQuXHJcbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKlxyXG4gKiAtIHJlbWFpbmluZ1BhdGhuYW1lXHJcbiAqIC0gcGFyYW1OYW1lc1xyXG4gKiAtIHBhcmFtVmFsdWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpIHtcclxuICAvLyBFbnN1cmUgcGF0dGVybiBzdGFydHMgd2l0aCBsZWFkaW5nIHNsYXNoIGZvciBjb25zaXN0ZW5jeSB3aXRoIHBhdGhuYW1lLlxyXG4gIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSAhPT0gJy8nKSB7XHJcbiAgICBwYXR0ZXJuID0gJy8nICsgcGF0dGVybjtcclxuICB9XHJcblxyXG4gIHZhciBfY29tcGlsZVBhdHRlcm4yID0gY29tcGlsZVBhdHRlcm4ocGF0dGVybiksXHJcbiAgICAgIHJlZ2V4cFNvdXJjZSA9IF9jb21waWxlUGF0dGVybjIucmVnZXhwU291cmNlLFxyXG4gICAgICBwYXJhbU5hbWVzID0gX2NvbXBpbGVQYXR0ZXJuMi5wYXJhbU5hbWVzLFxyXG4gICAgICB0b2tlbnMgPSBfY29tcGlsZVBhdHRlcm4yLnRva2VucztcclxuXHJcbiAgaWYgKHBhdHRlcm4uY2hhckF0KHBhdHRlcm4ubGVuZ3RoIC0gMSkgIT09ICcvJykge1xyXG4gICAgcmVnZXhwU291cmNlICs9ICcvPyc7IC8vIEFsbG93IG9wdGlvbmFsIHBhdGggc2VwYXJhdG9yIGF0IGVuZC5cclxuICB9XHJcblxyXG4gIC8vIFNwZWNpYWwtY2FzZSBwYXR0ZXJucyBsaWtlICcqJyBmb3IgY2F0Y2gtYWxsIHJvdXRlcy5cclxuICBpZiAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9PT0gJyonKSB7XHJcbiAgICByZWdleHBTb3VyY2UgKz0gJyQnO1xyXG4gIH1cclxuXHJcbiAgdmFyIG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyByZWdleHBTb3VyY2UsICdpJykpO1xyXG4gIGlmIChtYXRjaCA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHZhciBtYXRjaGVkUGF0aCA9IG1hdGNoWzBdO1xyXG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cihtYXRjaGVkUGF0aC5sZW5ndGgpO1xyXG5cclxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUpIHtcclxuICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgbWF0Y2ggZW5kcyBhdCBhIHBhdGggc2VwYXJhdG9yLCBpZiB3ZSBkaWRuJ3QgbWF0Y2hcclxuICAgIC8vIHRoZSBmdWxsIHBhdGgsIHNvIGFueSByZW1haW5pbmcgcGF0aG5hbWUgaXMgYSBuZXcgcGF0aCBzZWdtZW50LlxyXG4gICAgaWYgKG1hdGNoZWRQYXRoLmNoYXJBdChtYXRjaGVkUGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluaW5nIHBhdGhuYW1lLCB0cmVhdCB0aGUgcGF0aCBzZXBhcmF0b3IgYXMgcGFydCBvZlxyXG4gICAgLy8gdGhlIHJlbWFpbmluZyBwYXRobmFtZSBmb3IgcHJvcGVybHkgY29udGludWluZyB0aGUgbWF0Y2guXHJcbiAgICByZW1haW5pbmdQYXRobmFtZSA9ICcvJyArIHJlbWFpbmluZ1BhdGhuYW1lO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHJlbWFpbmluZ1BhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSxcclxuICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMsXHJcbiAgICBwYXJhbVZhbHVlczogbWF0Y2guc2xpY2UoMSkubWFwKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIHJldHVybiB2ICYmIGRlY29kZVVSSUNvbXBvbmVudCh2KTtcclxuICAgIH0pXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UGFyYW1OYW1lcyhwYXR0ZXJuKSB7XHJcbiAgcmV0dXJuIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pLnBhcmFtTmFtZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFBhcmFtcyhwYXR0ZXJuLCBwYXRobmFtZSkge1xyXG4gIHZhciBtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwYXRobmFtZSk7XHJcbiAgaWYgKCFtYXRjaCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICB2YXIgcGFyYW1OYW1lcyA9IG1hdGNoLnBhcmFtTmFtZXMsXHJcbiAgICAgIHBhcmFtVmFsdWVzID0gbWF0Y2gucGFyYW1WYWx1ZXM7XHJcblxyXG4gIHZhciBwYXJhbXMgPSB7fTtcclxuXHJcbiAgcGFyYW1OYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbU5hbWUsIGluZGV4KSB7XHJcbiAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWVzW2luZGV4XTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHBhcmFtcztcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBwYXR0ZXJuIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC4gVGhyb3dzXHJcbiAqIGlmIHRoZXJlIGlzIGEgZHluYW1pYyBzZWdtZW50IG9mIHRoZSBwYXR0ZXJuIGZvciB3aGljaCB0aGVyZSBpcyBubyBwYXJhbS5cclxuICovXHJcbmZ1bmN0aW9uIGZvcm1hdFBhdHRlcm4ocGF0dGVybiwgcGFyYW1zKSB7XHJcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xyXG5cclxuICB2YXIgX2NvbXBpbGVQYXR0ZXJuMyA9IGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pLFxyXG4gICAgICB0b2tlbnMgPSBfY29tcGlsZVBhdHRlcm4zLnRva2VucztcclxuXHJcbiAgdmFyIHBhcmVuQ291bnQgPSAwLFxyXG4gICAgICBwYXRobmFtZSA9ICcnLFxyXG4gICAgICBzcGxhdEluZGV4ID0gMCxcclxuICAgICAgcGFyZW5IaXN0b3J5ID0gW107XHJcblxyXG4gIHZhciB0b2tlbiA9IHZvaWQgMCxcclxuICAgICAgcGFyYW1OYW1lID0gdm9pZCAwLFxyXG4gICAgICBwYXJhbVZhbHVlID0gdm9pZCAwO1xyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgIHRva2VuID0gdG9rZW5zW2ldO1xyXG5cclxuICAgIGlmICh0b2tlbiA9PT0gJyonIHx8IHRva2VuID09PSAnKionKSB7XHJcbiAgICAgIHBhcmFtVmFsdWUgPSBBcnJheS5pc0FycmF5KHBhcmFtcy5zcGxhdCkgPyBwYXJhbXMuc3BsYXRbc3BsYXRJbmRleCsrXSA6IHBhcmFtcy5zcGxhdDtcclxuXHJcbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIHNwbGF0ICMlcyBmb3IgcGF0aCBcIiVzXCInLCBzcGxhdEluZGV4LCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XHJcblxyXG4gICAgICBpZiAocGFyYW1WYWx1ZSAhPSBudWxsKSBwYXRobmFtZSArPSBlbmNvZGVVUkkocGFyYW1WYWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKCcpIHtcclxuICAgICAgcGFyZW5IaXN0b3J5W3BhcmVuQ291bnRdID0gJyc7XHJcbiAgICAgIHBhcmVuQ291bnQgKz0gMTtcclxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcpJykge1xyXG4gICAgICB2YXIgcGFyZW5UZXh0ID0gcGFyZW5IaXN0b3J5LnBvcCgpO1xyXG4gICAgICBwYXJlbkNvdW50IC09IDE7XHJcblxyXG4gICAgICBpZiAocGFyZW5Db3VudCkgcGFyZW5IaXN0b3J5W3BhcmVuQ291bnQgLSAxXSArPSBwYXJlblRleHQ7ZWxzZSBwYXRobmFtZSArPSBwYXJlblRleHQ7XHJcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnXFxcXCgnKSB7XHJcbiAgICAgIHBhdGhuYW1lICs9ICcoJztcclxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICdcXFxcKScpIHtcclxuICAgICAgcGF0aG5hbWUgKz0gJyknO1xyXG4gICAgfSBlbHNlIGlmICh0b2tlbi5jaGFyQXQoMCkgPT09ICc6Jykge1xyXG4gICAgICBwYXJhbU5hbWUgPSB0b2tlbi5zdWJzdHJpbmcoMSk7XHJcbiAgICAgIHBhcmFtVmFsdWUgPSBwYXJhbXNbcGFyYW1OYW1lXTtcclxuXHJcbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIFwiJXNcIiBwYXJhbWV0ZXIgZm9yIHBhdGggXCIlc1wiJywgcGFyYW1OYW1lLCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XHJcblxyXG4gICAgICBpZiAocGFyYW1WYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHBhcmVuQ291bnQpIHtcclxuICAgICAgICAgIHBhcmVuSGlzdG9yeVtwYXJlbkNvdW50IC0gMV0gPSAnJztcclxuXHJcbiAgICAgICAgICB2YXIgY3VyVG9rZW5JZHggPSB0b2tlbnMuaW5kZXhPZih0b2tlbik7XHJcbiAgICAgICAgICB2YXIgdG9rZW5zU3Vic2V0ID0gdG9rZW5zLnNsaWNlKGN1clRva2VuSWR4LCB0b2tlbnMubGVuZ3RoKTtcclxuICAgICAgICAgIHZhciBuZXh0UGFyZW5JZHggPSAtMTtcclxuXHJcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdG9rZW5zU3Vic2V0Lmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBpZiAodG9rZW5zU3Vic2V0W19pXSA9PSAnKScpIHtcclxuICAgICAgICAgICAgICBuZXh0UGFyZW5JZHggPSBfaTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICEobmV4dFBhcmVuSWR4ID4gMCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnUGF0aCBcIiVzXCIgaXMgbWlzc2luZyBlbmQgcGFyZW4gYXQgc2VnbWVudCBcIiVzXCInLCBwYXR0ZXJuLCB0b2tlbnNTdWJzZXQuam9pbignJykpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcclxuXHJcbiAgICAgICAgICAvLyBqdW1wIHRvIGVuZGluZyBwYXJlblxyXG4gICAgICAgICAgaSA9IGN1clRva2VuSWR4ICsgbmV4dFBhcmVuSWR4IC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAocGFyZW5Db3VudCkgcGFyZW5IaXN0b3J5W3BhcmVuQ291bnQgLSAxXSArPSBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWx1ZSk7ZWxzZSBwYXRobmFtZSArPSBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocGFyZW5Db3VudCkgcGFyZW5IaXN0b3J5W3BhcmVuQ291bnQgLSAxXSArPSB0b2tlbjtlbHNlIHBhdGhuYW1lICs9IHRva2VuO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgIShwYXJlbkNvdW50IDw9IDApID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1BhdGggXCIlc1wiIGlzIG1pc3NpbmcgZW5kIHBhcmVuJywgcGF0dGVybikgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xyXG5cclxuICByZXR1cm4gcGF0aG5hbWUucmVwbGFjZSgvXFwvKy9nLCAnLycpO1xyXG59IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XHJcbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcclxuICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcclxufSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHMubG9jYXRpb25TaGFwZSA9IGV4cG9ydHMucm91dGVyU2hhcGUgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxuXHJcbnZhciBmdW5jID0gX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxyXG4gICAgb2JqZWN0ID0gX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBzaGFwZSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGUsXHJcbiAgICBzdHJpbmcgPSBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZztcclxudmFyIHJvdXRlclNoYXBlID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IHNoYXBlKHtcclxuICBwdXNoOiBmdW5jLmlzUmVxdWlyZWQsXHJcbiAgcmVwbGFjZTogZnVuYy5pc1JlcXVpcmVkLFxyXG4gIGdvOiBmdW5jLmlzUmVxdWlyZWQsXHJcbiAgZ29CYWNrOiBmdW5jLmlzUmVxdWlyZWQsXHJcbiAgZ29Gb3J3YXJkOiBmdW5jLmlzUmVxdWlyZWQsXHJcbiAgc2V0Um91dGVMZWF2ZUhvb2s6IGZ1bmMuaXNSZXF1aXJlZCxcclxuICBpc0FjdGl2ZTogZnVuYy5pc1JlcXVpcmVkXHJcbn0pO1xyXG5cclxudmFyIGxvY2F0aW9uU2hhcGUgPSBleHBvcnRzLmxvY2F0aW9uU2hhcGUgPSBzaGFwZSh7XHJcbiAgcGF0aG5hbWU6IHN0cmluZy5pc1JlcXVpcmVkLFxyXG4gIHNlYXJjaDogc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgc3RhdGU6IG9iamVjdCxcclxuICBhY3Rpb246IHN0cmluZy5pc1JlcXVpcmVkLFxyXG4gIGtleTogc3RyaW5nXHJcbn0pOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxuXHJcbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xyXG5cclxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcclxuXHJcbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XHJcblxyXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcclxuXHJcbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcclxuXHJcbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLFxyXG4gICAgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcclxuXHJcbi8qKlxyXG4gKiBBIDxSZWRpcmVjdD4gaXMgdXNlZCB0byBkZWNsYXJlIGFub3RoZXIgVVJMIHBhdGggYSBjbGllbnQgc2hvdWxkXHJcbiAqIGJlIHNlbnQgdG8gd2hlbiB0aGV5IHJlcXVlc3QgYSBnaXZlbiBVUkwuXHJcbiAqXHJcbiAqIFJlZGlyZWN0cyBhcmUgcGxhY2VkIGFsb25nc2lkZSByb3V0ZXMgaW4gdGhlIHJvdXRlIGNvbmZpZ3VyYXRpb25cclxuICogYW5kIGFyZSB0cmF2ZXJzZWQgaW4gdGhlIHNhbWUgbWFubmVyLlxyXG4gKi9cclxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcmVxdWlyZS1yZW5kZXItcmV0dXJuICovXHJcblxyXG52YXIgUmVkaXJlY3QgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xyXG4gIGRpc3BsYXlOYW1lOiAnUmVkaXJlY3QnLFxyXG5cclxuXHJcbiAgc3RhdGljczoge1xyXG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgICB2YXIgcm91dGUgPSAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KShlbGVtZW50KTtcclxuXHJcbiAgICAgIGlmIChyb3V0ZS5mcm9tKSByb3V0ZS5wYXRoID0gcm91dGUuZnJvbTtcclxuXHJcbiAgICAgIHJvdXRlLm9uRW50ZXIgPSBmdW5jdGlvbiAobmV4dFN0YXRlLCByZXBsYWNlKSB7XHJcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gbmV4dFN0YXRlLmxvY2F0aW9uLFxyXG4gICAgICAgICAgICBwYXJhbXMgPSBuZXh0U3RhdGUucGFyYW1zO1xyXG5cclxuXHJcbiAgICAgICAgdmFyIHBhdGhuYW1lID0gdm9pZCAwO1xyXG4gICAgICAgIGlmIChyb3V0ZS50by5jaGFyQXQoMCkgPT09ICcvJykge1xyXG4gICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuKShyb3V0ZS50bywgcGFyYW1zKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFyb3V0ZS50bykge1xyXG4gICAgICAgICAgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHJvdXRlSW5kZXggPSBuZXh0U3RhdGUucm91dGVzLmluZGV4T2Yocm91dGUpO1xyXG4gICAgICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSBSZWRpcmVjdC5nZXRSb3V0ZVBhdHRlcm4obmV4dFN0YXRlLnJvdXRlcywgcm91dGVJbmRleCAtIDEpO1xyXG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBwYXJlbnRQYXR0ZXJuLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHJvdXRlLnRvO1xyXG4gICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuKShwYXR0ZXJuLCBwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVwbGFjZSh7XHJcbiAgICAgICAgICBwYXRobmFtZTogcGF0aG5hbWUsXHJcbiAgICAgICAgICBxdWVyeTogcm91dGUucXVlcnkgfHwgbG9jYXRpb24ucXVlcnksXHJcbiAgICAgICAgICBzdGF0ZTogcm91dGUuc3RhdGUgfHwgbG9jYXRpb24uc3RhdGVcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiByb3V0ZTtcclxuICAgIH0sXHJcbiAgICBnZXRSb3V0ZVBhdHRlcm46IGZ1bmN0aW9uIGdldFJvdXRlUGF0dGVybihyb3V0ZXMsIHJvdXRlSW5kZXgpIHtcclxuICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSAnJztcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSByb3V0ZUluZGV4OyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpXTtcclxuICAgICAgICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XHJcblxyXG4gICAgICAgIHBhcmVudFBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHBhcmVudFBhdHRlcm47XHJcblxyXG4gICAgICAgIGlmIChwYXR0ZXJuLmluZGV4T2YoJy8nKSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAnLycgKyBwYXJlbnRQYXR0ZXJuO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHByb3BUeXBlczoge1xyXG4gICAgcGF0aDogc3RyaW5nLFxyXG4gICAgZnJvbTogc3RyaW5nLCAvLyBBbGlhcyBmb3IgcGF0aFxyXG4gICAgdG86IHN0cmluZy5pc1JlcXVpcmVkLFxyXG4gICAgcXVlcnk6IG9iamVjdCxcclxuICAgIHN0YXRlOiBvYmplY3QsXHJcbiAgICBvbkVudGVyOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXHJcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5XHJcbiAgfSxcclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xyXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgIWZhbHNlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxSZWRpcmVjdD4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xyXG4gIH1cclxufSk7XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBSZWRpcmVjdDtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG5cclxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XHJcblxyXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xyXG5cclxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcclxuXHJcbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xyXG5cclxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMsXHJcbiAgICBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XHJcblxyXG4vKipcclxuICogQSA8Um91dGU+IGlzIHVzZWQgdG8gZGVjbGFyZSB3aGljaCBjb21wb25lbnRzIGFyZSByZW5kZXJlZCB0byB0aGVcclxuICogcGFnZSB3aGVuIHRoZSBVUkwgbWF0Y2hlcyBhIGdpdmVuIHBhdHRlcm4uXHJcbiAqXHJcbiAqIFJvdXRlcyBhcmUgYXJyYW5nZWQgaW4gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUuIFdoZW4gYSBuZXcgVVJMIGlzXHJcbiAqIHJlcXVlc3RlZCwgdGhlIHRyZWUgaXMgc2VhcmNoZWQgZGVwdGgtZmlyc3QgdG8gZmluZCBhIHJvdXRlIHdob3NlXHJcbiAqIHBhdGggbWF0Y2hlcyB0aGUgVVJMLiAgV2hlbiBvbmUgaXMgZm91bmQsIGFsbCByb3V0ZXMgaW4gdGhlIHRyZWVcclxuICogdGhhdCBsZWFkIHRvIGl0IGFyZSBjb25zaWRlcmVkIFwiYWN0aXZlXCIgYW5kIHRoZWlyIGNvbXBvbmVudHMgYXJlXHJcbiAqIHJlbmRlcmVkIGludG8gdGhlIERPTSwgbmVzdGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIGluIHRoZSB0cmVlLlxyXG4gKi9cclxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcmVxdWlyZS1yZW5kZXItcmV0dXJuICovXHJcblxyXG52YXIgUm91dGUgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xyXG4gIGRpc3BsYXlOYW1lOiAnUm91dGUnLFxyXG5cclxuXHJcbiAgc3RhdGljczoge1xyXG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnRcclxuICB9LFxyXG5cclxuICBwcm9wVHlwZXM6IHtcclxuICAgIHBhdGg6IHN0cmluZyxcclxuICAgIGNvbXBvbmVudDogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudCxcclxuICAgIGNvbXBvbmVudHM6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzLFxyXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jLFxyXG4gICAgZ2V0Q29tcG9uZW50czogZnVuY1xyXG4gIH0sXHJcblxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cclxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICAgICFmYWxzZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8Um91dGU+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcclxuICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGU7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxuZXhwb3J0cy5pc1JlYWN0Q2hpbGRyZW4gPSBpc1JlYWN0Q2hpbGRyZW47XHJcbmV4cG9ydHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50ID0gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50O1xyXG5leHBvcnRzLmNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW47XHJcbmV4cG9ydHMuY3JlYXRlUm91dGVzID0gY3JlYXRlUm91dGVzO1xyXG5cclxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcblxyXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkQ2hpbGQob2JqZWN0KSB7XHJcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChvYmplY3QpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1JlYWN0Q2hpbGRyZW4ob2JqZWN0KSB7XHJcbiAgcmV0dXJuIGlzVmFsaWRDaGlsZChvYmplY3QpIHx8IEFycmF5LmlzQXJyYXkob2JqZWN0KSAmJiBvYmplY3QuZXZlcnkoaXNWYWxpZENoaWxkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUm91dGUoZGVmYXVsdFByb3BzLCBwcm9wcykge1xyXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdFByb3BzLCBwcm9wcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSB7XHJcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XHJcbiAgdmFyIHJvdXRlID0gY3JlYXRlUm91dGUodHlwZS5kZWZhdWx0UHJvcHMsIGVsZW1lbnQucHJvcHMpO1xyXG5cclxuICBpZiAocm91dGUuY2hpbGRyZW4pIHtcclxuICAgIHZhciBjaGlsZFJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKHJvdXRlLmNoaWxkcmVuLCByb3V0ZSk7XHJcblxyXG4gICAgaWYgKGNoaWxkUm91dGVzLmxlbmd0aCkgcm91dGUuY2hpbGRSb3V0ZXMgPSBjaGlsZFJvdXRlcztcclxuXHJcbiAgICBkZWxldGUgcm91dGUuY2hpbGRyZW47XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcm91dGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgcm91dGVzIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBSZWFjdENoaWxkcmVuLiBKU1hcclxuICogcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSB0byB2aXN1YWxpemUgaG93IHJvdXRlcyBpbiB0aGUgaGllcmFyY2h5IGFyZVxyXG4gKiBuZXN0ZWQuXHJcbiAqXHJcbiAqICAgaW1wb3J0IHsgUm91dGUsIGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuIH0gZnJvbSAncmVhY3Qtcm91dGVyJ1xyXG4gKlxyXG4gKiAgIGNvbnN0IHJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKFxyXG4gKiAgICAgPFJvdXRlIGNvbXBvbmVudD17QXBwfT5cclxuICogICAgICAgPFJvdXRlIHBhdGg9XCJob21lXCIgY29tcG9uZW50PXtEYXNoYm9hcmR9Lz5cclxuICogICAgICAgPFJvdXRlIHBhdGg9XCJuZXdzXCIgY29tcG9uZW50PXtOZXdzRmVlZH0vPlxyXG4gKiAgICAgPC9Sb3V0ZT5cclxuICogICApXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgdXNlZCB3aGVuIHlvdSBwcm92aWRlIDxSb3V0ZT4gY2hpbGRyZW5cclxuICogdG8gYSA8Um91dGVyPiBjb21wb25lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Um91dGUpIHtcclxuICB2YXIgcm91dGVzID0gW107XHJcblxyXG4gIF9yZWFjdDIuZGVmYXVsdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgaWYgKF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xyXG4gICAgICAvLyBDb21wb25lbnQgY2xhc3NlcyBtYXkgaGF2ZSBhIHN0YXRpYyBjcmVhdGUqIG1ldGhvZC5cclxuICAgICAgaWYgKGVsZW1lbnQudHlwZS5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgcm91dGUgPSBlbGVtZW50LnR5cGUuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKTtcclxuXHJcbiAgICAgICAgaWYgKHJvdXRlKSByb3V0ZXMucHVzaChyb3V0ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcm91dGVzLnB1c2goY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gcm91dGVzO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiByb3V0ZXMgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0IHdoaWNoXHJcbiAqIG1heSBiZSBhIEpTWCByb3V0ZSwgYSBwbGFpbiBvYmplY3Qgcm91dGUsIG9yIGFuIGFycmF5IG9mIGVpdGhlci5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcyhyb3V0ZXMpIHtcclxuICBpZiAoaXNSZWFjdENoaWxkcmVuKHJvdXRlcykpIHtcclxuICAgIHJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKHJvdXRlcyk7XHJcbiAgfSBlbHNlIGlmIChyb3V0ZXMgJiYgIUFycmF5LmlzQXJyYXkocm91dGVzKSkge1xyXG4gICAgcm91dGVzID0gW3JvdXRlc107XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcm91dGVzO1xyXG59IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xyXG5cclxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcclxuXHJcbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG5cclxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XHJcblxyXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcclxuXHJcbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyKTtcclxuXHJcbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XHJcblxyXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcclxuXHJcbnZhciBfUm91dGVyQ29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0KTtcclxuXHJcbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xyXG5cclxudmFyIF9Sb3V0ZXJVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVyVXRpbHMnKTtcclxuXHJcbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xyXG5cclxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cclxuXHJcbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcyxcclxuICAgIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcclxuXHJcbi8qKlxyXG4gKiBBIDxSb3V0ZXI+IGlzIGEgaGlnaC1sZXZlbCBBUEkgZm9yIGF1dG9tYXRpY2FsbHkgc2V0dGluZyB1cFxyXG4gKiBhIHJvdXRlciB0aGF0IHJlbmRlcnMgYSA8Um91dGVyQ29udGV4dD4gd2l0aCBhbGwgdGhlIHByb3BzXHJcbiAqIGl0IG5lZWRzIGVhY2ggdGltZSB0aGUgVVJMIGNoYW5nZXMuXHJcbiAqL1xyXG5cclxudmFyIFJvdXRlciA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XHJcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZXInLFxyXG5cclxuXHJcbiAgcHJvcFR5cGVzOiB7XHJcbiAgICBoaXN0b3J5OiBvYmplY3QsXHJcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLnJvdXRlcyxcclxuICAgIHJvdXRlczogX0ludGVybmFsUHJvcFR5cGVzLnJvdXRlcywgLy8gYWxpYXMgZm9yIGNoaWxkcmVuXHJcbiAgICByZW5kZXI6IGZ1bmMsXHJcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jLFxyXG4gICAgb25FcnJvcjogZnVuYyxcclxuICAgIG9uVXBkYXRlOiBmdW5jLFxyXG5cclxuICAgIC8vIFBSSVZBVEU6IEZvciBjbGllbnQtc2lkZSByZWh5ZHJhdGlvbiBvZiBzZXJ2ZXIgbWF0Y2guXHJcbiAgICBtYXRjaENvbnRleHQ6IG9iamVjdFxyXG4gIH0sXHJcblxyXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1JvdXRlckNvbnRleHQyLmRlZmF1bHQsIHByb3BzKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbG9jYXRpb246IG51bGwsXHJcbiAgICAgIHJvdXRlczogbnVsbCxcclxuICAgICAgcGFyYW1zOiBudWxsLFxyXG4gICAgICBjb21wb25lbnRzOiBudWxsXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgaGFuZGxlRXJyb3I6IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XHJcbiAgICBpZiAodGhpcy5wcm9wcy5vbkVycm9yKSB7XHJcbiAgICAgIHRoaXMucHJvcHMub25FcnJvci5jYWxsKHRoaXMsIGVycm9yKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFRocm93IGVycm9ycyBieSBkZWZhdWx0IHNvIHdlIGRvbid0IHNpbGVudGx5IHN3YWxsb3cgdGhlbSFcclxuICAgICAgdGhyb3cgZXJyb3I7IC8vIFRoaXMgZXJyb3IgcHJvYmFibHkgb2NjdXJyZWQgaW4gZ2V0Q2hpbGRSb3V0ZXMgb3IgZ2V0Q29tcG9uZW50cy5cclxuICAgIH1cclxuICB9LFxyXG4gIGNyZWF0ZVJvdXRlck9iamVjdDogZnVuY3Rpb24gY3JlYXRlUm91dGVyT2JqZWN0KHN0YXRlKSB7XHJcbiAgICB2YXIgbWF0Y2hDb250ZXh0ID0gdGhpcy5wcm9wcy5tYXRjaENvbnRleHQ7XHJcblxyXG4gICAgaWYgKG1hdGNoQ29udGV4dCkge1xyXG4gICAgICByZXR1cm4gbWF0Y2hDb250ZXh0LnJvdXRlcjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMucHJvcHMuaGlzdG9yeTtcclxuXHJcbiAgICByZXR1cm4gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0ZXJPYmplY3QpKGhpc3RvcnksIHRoaXMudHJhbnNpdGlvbk1hbmFnZXIsIHN0YXRlKTtcclxuICB9LFxyXG4gIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyOiBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcclxuICAgIHZhciBtYXRjaENvbnRleHQgPSB0aGlzLnByb3BzLm1hdGNoQ29udGV4dDtcclxuXHJcbiAgICBpZiAobWF0Y2hDb250ZXh0KSB7XHJcbiAgICAgIHJldHVybiBtYXRjaENvbnRleHQudHJhbnNpdGlvbk1hbmFnZXI7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLnByb3BzLmhpc3Rvcnk7XHJcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICByb3V0ZXMgPSBfcHJvcHMucm91dGVzLFxyXG4gICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuO1xyXG5cclxuXHJcbiAgICAhaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24gPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnWW91IGhhdmUgcHJvdmlkZWQgYSBoaXN0b3J5IG9iamVjdCBjcmVhdGVkIHdpdGggaGlzdG9yeSB2Mi54IG9yICcgKyAnZWFybGllci4gVGhpcyB2ZXJzaW9uIG9mIFJlYWN0IFJvdXRlciBpcyBvbmx5IGNvbXBhdGlibGUgd2l0aCB2MyAnICsgJ2hpc3Rvcnkgb2JqZWN0cy4gUGxlYXNlIHVwZ3JhZGUgdG8gaGlzdG9yeSB2My54LicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcclxuXHJcbiAgICByZXR1cm4gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjMuZGVmYXVsdCkoaGlzdG9yeSwgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykocm91dGVzIHx8IGNoaWxkcmVuKSk7XHJcbiAgfSxcclxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy50cmFuc2l0aW9uTWFuYWdlciA9IHRoaXMuY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcclxuICAgIHRoaXMucm91dGVyID0gdGhpcy5jcmVhdGVSb3V0ZXJPYmplY3QodGhpcy5zdGF0ZSk7XHJcblxyXG4gICAgdGhpcy5fdW5saXN0ZW4gPSB0aGlzLnRyYW5zaXRpb25NYW5hZ2VyLmxpc3RlbihmdW5jdGlvbiAoZXJyb3IsIHN0YXRlKSB7XHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIF90aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBLZWVwIHRoZSBpZGVudGl0eSBvZiB0aGlzLnJvdXRlciBiZWNhdXNlIG9mIGEgY2F2ZWF0IGluIENvbnRleHRVdGlsczpcclxuICAgICAgICAvLyB0aGV5IG9ubHkgd29yayBpZiB0aGUgb2JqZWN0IGlkZW50aXR5IGlzIHByZXNlcnZlZC5cclxuICAgICAgICAoMCwgX1JvdXRlclV0aWxzLmFzc2lnblJvdXRlclN0YXRlKShfdGhpcy5yb3V0ZXIsIHN0YXRlKTtcclxuICAgICAgICBfdGhpcy5zZXRTdGF0ZShzdGF0ZSwgX3RoaXMucHJvcHMub25VcGRhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuXHJcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xyXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShuZXh0UHJvcHMuaGlzdG9yeSA9PT0gdGhpcy5wcm9wcy5oaXN0b3J5LCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciBoaXN0b3J5PjsgaXQgd2lsbCBiZSBpZ25vcmVkJykgOiB2b2lkIDA7XHJcblxyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoKG5leHRQcm9wcy5yb3V0ZXMgfHwgbmV4dFByb3BzLmNoaWxkcmVuKSA9PT0gKHRoaXMucHJvcHMucm91dGVzIHx8IHRoaXMucHJvcHMuY2hpbGRyZW4pLCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciByb3V0ZXM+OyBpdCB3aWxsIGJlIGlnbm9yZWQnKSA6IHZvaWQgMDtcclxuICB9LFxyXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgIGlmICh0aGlzLl91bmxpc3RlbikgdGhpcy5fdW5saXN0ZW4oKTtcclxuICB9LFxyXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgdmFyIF9zdGF0ZSA9IHRoaXMuc3RhdGUsXHJcbiAgICAgICAgbG9jYXRpb24gPSBfc3RhdGUubG9jYXRpb24sXHJcbiAgICAgICAgcm91dGVzID0gX3N0YXRlLnJvdXRlcyxcclxuICAgICAgICBwYXJhbXMgPSBfc3RhdGUucGFyYW1zLFxyXG4gICAgICAgIGNvbXBvbmVudHMgPSBfc3RhdGUuY29tcG9uZW50cztcclxuXHJcbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHMsXHJcbiAgICAgICAgY3JlYXRlRWxlbWVudCA9IF9wcm9wczIuY3JlYXRlRWxlbWVudCxcclxuICAgICAgICByZW5kZXIgPSBfcHJvcHMyLnJlbmRlcixcclxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMyLCBbJ2NyZWF0ZUVsZW1lbnQnLCAncmVuZGVyJ10pO1xyXG5cclxuICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSByZXR1cm4gbnVsbDsgLy8gQXN5bmMgbWF0Y2hcclxuXHJcbiAgICAvLyBPbmx5IGZvcndhcmQgbm9uLVJvdXRlci1zcGVjaWZpYyBwcm9wcyB0byByb3V0aW5nIGNvbnRleHQsIGFzIHRob3NlIGFyZVxyXG4gICAgLy8gdGhlIG9ubHkgb25lcyB0aGF0IG1pZ2h0IGJlIGN1c3RvbSByb3V0aW5nIGNvbnRleHQgcHJvcHMuXHJcbiAgICBPYmplY3Qua2V5cyhSb3V0ZXIucHJvcFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wVHlwZSkge1xyXG4gICAgICByZXR1cm4gZGVsZXRlIHByb3BzW3Byb3BUeXBlXTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZW5kZXIoX2V4dGVuZHMoe30sIHByb3BzLCB7XHJcbiAgICAgIHJvdXRlcjogdGhpcy5yb3V0ZXIsXHJcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcclxuICAgICAgcm91dGVzOiByb3V0ZXMsXHJcbiAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxyXG4gICAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50XHJcbiAgICB9KSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlcjtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XHJcblxyXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xyXG5cclxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcclxuXHJcbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG5cclxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XHJcblxyXG52YXIgX2dldFJvdXRlUGFyYW1zID0gcmVxdWlyZSgnLi9nZXRSb3V0ZVBhcmFtcycpO1xyXG5cclxudmFyIF9nZXRSb3V0ZVBhcmFtczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRSb3V0ZVBhcmFtcyk7XHJcblxyXG52YXIgX0NvbnRleHRVdGlscyA9IHJlcXVpcmUoJy4vQ29udGV4dFV0aWxzJyk7XHJcblxyXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMsXHJcbiAgICBhcnJheSA9IF9SZWFjdCRQcm9wVHlwZXMuYXJyYXksXHJcbiAgICBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XHJcblxyXG4vKipcclxuICogQSA8Um91dGVyQ29udGV4dD4gcmVuZGVycyB0aGUgY29tcG9uZW50IHRyZWUgZm9yIGEgZ2l2ZW4gcm91dGVyIHN0YXRlXHJcbiAqIGFuZCBzZXRzIHRoZSBoaXN0b3J5IG9iamVjdCBhbmQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gY29udGV4dC5cclxuICovXHJcblxyXG52YXIgUm91dGVyQ29udGV4dCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XHJcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZXJDb250ZXh0JyxcclxuXHJcblxyXG4gIG1peGluczogWygwLCBfQ29udGV4dFV0aWxzLkNvbnRleHRQcm92aWRlcikoJ3JvdXRlcicpXSxcclxuXHJcbiAgcHJvcFR5cGVzOiB7XHJcbiAgICByb3V0ZXI6IG9iamVjdC5pc1JlcXVpcmVkLFxyXG4gICAgbG9jYXRpb246IG9iamVjdC5pc1JlcXVpcmVkLFxyXG4gICAgcm91dGVzOiBhcnJheS5pc1JlcXVpcmVkLFxyXG4gICAgcGFyYW1zOiBvYmplY3QuaXNSZXF1aXJlZCxcclxuICAgIGNvbXBvbmVudHM6IGFycmF5LmlzUmVxdWlyZWQsXHJcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jLmlzUmVxdWlyZWRcclxuICB9LFxyXG5cclxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50XHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG5cclxuICBjaGlsZENvbnRleHRUeXBlczoge1xyXG4gICAgcm91dGVyOiBvYmplY3QuaXNSZXF1aXJlZFxyXG4gIH0sXHJcblxyXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcm91dGVyOiB0aGlzLnByb3BzLnJvdXRlclxyXG4gICAgfTtcclxuICB9LFxyXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcykge1xyXG4gICAgcmV0dXJuIGNvbXBvbmVudCA9PSBudWxsID8gbnVsbCA6IHRoaXMucHJvcHMuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcclxuICB9LFxyXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcclxuICAgICAgICBsb2NhdGlvbiA9IF9wcm9wcy5sb2NhdGlvbixcclxuICAgICAgICByb3V0ZXMgPSBfcHJvcHMucm91dGVzLFxyXG4gICAgICAgIHBhcmFtcyA9IF9wcm9wcy5wYXJhbXMsXHJcbiAgICAgICAgY29tcG9uZW50cyA9IF9wcm9wcy5jb21wb25lbnRzLFxyXG4gICAgICAgIHJvdXRlciA9IF9wcm9wcy5yb3V0ZXI7XHJcblxyXG4gICAgdmFyIGVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIGlmIChjb21wb25lbnRzKSB7XHJcbiAgICAgIGVsZW1lbnQgPSBjb21wb25lbnRzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChlbGVtZW50LCBjb21wb25lbnRzLCBpbmRleCkge1xyXG4gICAgICAgIGlmIChjb21wb25lbnRzID09IG51bGwpIHJldHVybiBlbGVtZW50OyAvLyBEb24ndCBjcmVhdGUgbmV3IGNoaWxkcmVuOyB1c2UgdGhlIGdyYW5kY2hpbGRyZW4uXHJcblxyXG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpbmRleF07XHJcbiAgICAgICAgdmFyIHJvdXRlUGFyYW1zID0gKDAsIF9nZXRSb3V0ZVBhcmFtczIuZGVmYXVsdCkocm91dGUsIHBhcmFtcyk7XHJcbiAgICAgICAgdmFyIHByb3BzID0ge1xyXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxyXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXHJcbiAgICAgICAgICByb3V0ZTogcm91dGUsXHJcbiAgICAgICAgICByb3V0ZXI6IHJvdXRlcixcclxuICAgICAgICAgIHJvdXRlUGFyYW1zOiByb3V0ZVBhcmFtcyxcclxuICAgICAgICAgIHJvdXRlczogcm91dGVzXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCgwLCBfUm91dGVVdGlscy5pc1JlYWN0Q2hpbGRyZW4pKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGVsZW1lbnQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbGVtZW50LCBwcm9wKSkgcHJvcHNbcHJvcF0gPSBlbGVtZW50W3Byb3BdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCh0eXBlb2YgY29tcG9uZW50cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29tcG9uZW50cykpID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0ge307XHJcblxyXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb21wb25lbnRzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHRoZSBrZXkgYXMgYSBwcm9wIHRvIGNyZWF0ZUVsZW1lbnQgdG8gYWxsb3dcclxuICAgICAgICAgICAgICAvLyBjdXN0b20gY3JlYXRlRWxlbWVudCBmdW5jdGlvbnMgdG8ga25vdyB3aGljaCBuYW1lZCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAvLyB0aGV5J3JlIHJlbmRlcmluZywgZm9yIGUuZy4gbWF0Y2hpbmcgdXAgdG8gZmV0Y2hlZCBkYXRhLlxyXG4gICAgICAgICAgICAgIGVsZW1lbnRzW2tleV0gPSBfdGhpcy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNba2V5XSwgX2V4dGVuZHMoe1xyXG4gICAgICAgICAgICAgICAga2V5OiBrZXkgfSwgcHJvcHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBlbGVtZW50cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMsIHByb3BzKTtcclxuICAgICAgfSwgZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlIHx8IF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIHJvb3Qgcm91dGUgbXVzdCByZW5kZXIgYSBzaW5nbGUgZWxlbWVudCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcclxuXHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcbn0pO1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyQ29udGV4dDtcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlUm91dGVyT2JqZWN0ID0gY3JlYXRlUm91dGVyT2JqZWN0O1xyXG5leHBvcnRzLmFzc2lnblJvdXRlclN0YXRlID0gYXNzaWduUm91dGVyU3RhdGU7XHJcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlck9iamVjdChoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlciwgc3RhdGUpIHtcclxuICB2YXIgcm91dGVyID0gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcclxuICAgIHNldFJvdXRlTGVhdmVIb29rOiB0cmFuc2l0aW9uTWFuYWdlci5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUsXHJcbiAgICBpc0FjdGl2ZTogdHJhbnNpdGlvbk1hbmFnZXIuaXNBY3RpdmVcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGFzc2lnblJvdXRlclN0YXRlKHJvdXRlciwgc3RhdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhc3NpZ25Sb3V0ZXJTdGF0ZShyb3V0ZXIsIF9yZWYpIHtcclxuICB2YXIgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uLFxyXG4gICAgICBwYXJhbXMgPSBfcmVmLnBhcmFtcyxcclxuICAgICAgcm91dGVzID0gX3JlZi5yb3V0ZXM7XHJcblxyXG4gIHJvdXRlci5sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gIHJvdXRlci5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgcm91dGVyLnJvdXRlcyA9IHJvdXRlcztcclxuXHJcbiAgcmV0dXJuIHJvdXRlcjtcclxufSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHMucnVuRW50ZXJIb29rcyA9IHJ1bkVudGVySG9va3M7XHJcbmV4cG9ydHMucnVuQ2hhbmdlSG9va3MgPSBydW5DaGFuZ2VIb29rcztcclxuZXhwb3J0cy5ydW5MZWF2ZUhvb2tzID0gcnVuTGVhdmVIb29rcztcclxuXHJcbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xyXG5cclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbnZhciBQZW5kaW5nSG9va3MgPSBmdW5jdGlvbiBQZW5kaW5nSG9va3MoKSB7XHJcbiAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBlbmRpbmdIb29rcyk7XHJcblxyXG4gIHRoaXMuaG9va3MgPSBbXTtcclxuXHJcbiAgdGhpcy5hZGQgPSBmdW5jdGlvbiAoaG9vaykge1xyXG4gICAgcmV0dXJuIF90aGlzLmhvb2tzLnB1c2goaG9vayk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAoaG9vaykge1xyXG4gICAgcmV0dXJuIF90aGlzLmhvb2tzID0gX3RoaXMuaG9va3MuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XHJcbiAgICAgIHJldHVybiBoICE9PSBob29rO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5oYXMgPSBmdW5jdGlvbiAoaG9vaykge1xyXG4gICAgcmV0dXJuIF90aGlzLmhvb2tzLmluZGV4T2YoaG9vaykgIT09IC0xO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX3RoaXMuaG9va3MgPSBbXTtcclxuICB9O1xyXG59O1xyXG5cclxudmFyIGVudGVySG9va3MgPSBuZXcgUGVuZGluZ0hvb2tzKCk7XHJcbnZhciBjaGFuZ2VIb29rcyA9IG5ldyBQZW5kaW5nSG9va3MoKTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25Ib29rKGhvb2ssIHJvdXRlLCBhc3luY0FyaXR5LCBwZW5kaW5nSG9va3MpIHtcclxuICB2YXIgaXNTeW5jID0gaG9vay5sZW5ndGggPCBhc3luY0FyaXR5O1xyXG5cclxuICB2YXIgdHJhbnNpdGlvbkhvb2sgPSBmdW5jdGlvbiB0cmFuc2l0aW9uSG9vaygpIHtcclxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgaG9vay5hcHBseShyb3V0ZSwgYXJncyk7XHJcblxyXG4gICAgaWYgKGlzU3luYykge1xyXG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XHJcbiAgICAgIC8vIEFzc3VtZSBob29rIGV4ZWN1dGVzIHN5bmNocm9ub3VzbHkgYW5kXHJcbiAgICAgIC8vIGF1dG9tYXRpY2FsbHkgY2FsbCB0aGUgY2FsbGJhY2suXHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcGVuZGluZ0hvb2tzLmFkZCh0cmFuc2l0aW9uSG9vayk7XHJcblxyXG4gIHJldHVybiB0cmFuc2l0aW9uSG9vaztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RW50ZXJIb29rcyhyb3V0ZXMpIHtcclxuICByZXR1cm4gcm91dGVzLnJlZHVjZShmdW5jdGlvbiAoaG9va3MsIHJvdXRlKSB7XHJcbiAgICBpZiAocm91dGUub25FbnRlcikgaG9va3MucHVzaChjcmVhdGVUcmFuc2l0aW9uSG9vayhyb3V0ZS5vbkVudGVyLCByb3V0ZSwgMywgZW50ZXJIb29rcykpO1xyXG4gICAgcmV0dXJuIGhvb2tzO1xyXG4gIH0sIFtdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q2hhbmdlSG9va3Mocm91dGVzKSB7XHJcbiAgcmV0dXJuIHJvdXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGhvb2tzLCByb3V0ZSkge1xyXG4gICAgaWYgKHJvdXRlLm9uQ2hhbmdlKSBob29rcy5wdXNoKGNyZWF0ZVRyYW5zaXRpb25Ib29rKHJvdXRlLm9uQ2hhbmdlLCByb3V0ZSwgNCwgY2hhbmdlSG9va3MpKTtcclxuICAgIHJldHVybiBob29rcztcclxuICB9LCBbXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJ1blRyYW5zaXRpb25Ib29rcyhsZW5ndGgsIGl0ZXIsIGNhbGxiYWNrKSB7XHJcbiAgaWYgKCFsZW5ndGgpIHtcclxuICAgIGNhbGxiYWNrKCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgcmVkaXJlY3RJbmZvID0gdm9pZCAwO1xyXG4gIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcclxuICAgIHJlZGlyZWN0SW5mbyA9IGxvY2F0aW9uO1xyXG4gIH1cclxuXHJcbiAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykobGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcclxuICAgIGl0ZXIoaW5kZXgsIHJlcGxhY2UsIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSB7XHJcbiAgICAgICAgZG9uZShlcnJvciwgcmVkaXJlY3RJbmZvKTsgLy8gTm8gbmVlZCB0byBjb250aW51ZS5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuZXh0KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0sIGNhbGxiYWNrKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1bnMgYWxsIG9uRW50ZXIgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlclxyXG4gKiB3aXRoIG9uRW50ZXIobmV4dFN0YXRlLCByZXBsYWNlLCBjYWxsYmFjaykgYW5kIGNhbGxzXHJcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdEluZm8pIHdoZW4gZmluaXNoZWQuIFRoZSBmaXJzdCBob29rXHJcbiAqIHRvIHVzZSByZXBsYWNlIHNob3J0LWNpcmN1aXRzIHRoZSBsb29wLlxyXG4gKlxyXG4gKiBJZiBhIGhvb2sgbmVlZHMgdG8gcnVuIGFzeW5jaHJvbm91c2x5LCBpdCBtYXkgdXNlIHRoZSBjYWxsYmFja1xyXG4gKiBmdW5jdGlvbi4gSG93ZXZlciwgZG9pbmcgc28gd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBwYXVzZSxcclxuICogd2hpY2ggY291bGQgbGVhZCB0byBhIG5vbi1yZXNwb25zaXZlIFVJIGlmIHRoZSBob29rIGlzIHNsb3cuXHJcbiAqL1xyXG5mdW5jdGlvbiBydW5FbnRlckhvb2tzKHJvdXRlcywgbmV4dFN0YXRlLCBjYWxsYmFjaykge1xyXG4gIGVudGVySG9va3MuY2xlYXIoKTtcclxuICB2YXIgaG9va3MgPSBnZXRFbnRlckhvb2tzKHJvdXRlcyk7XHJcbiAgcmV0dXJuIHJ1blRyYW5zaXRpb25Ib29rcyhob29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZSwgbmV4dCkge1xyXG4gICAgdmFyIHdyYXBwZWROZXh0ID0gZnVuY3Rpb24gd3JhcHBlZE5leHQoKSB7XHJcbiAgICAgIGlmIChlbnRlckhvb2tzLmhhcyhob29rc1tpbmRleF0pKSB7XHJcbiAgICAgICAgbmV4dC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgZW50ZXJIb29rcy5yZW1vdmUoaG9va3NbaW5kZXhdKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGhvb2tzW2luZGV4XShuZXh0U3RhdGUsIHJlcGxhY2UsIHdyYXBwZWROZXh0KTtcclxuICB9LCBjYWxsYmFjayk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW5zIGFsbCBvbkNoYW5nZSBob29rcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygcm91dGVzIGluIG9yZGVyXHJcbiAqIHdpdGggb25DaGFuZ2UocHJldlN0YXRlLCBuZXh0U3RhdGUsIHJlcGxhY2UsIGNhbGxiYWNrKSBhbmQgY2FsbHNcclxuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0SW5mbykgd2hlbiBmaW5pc2hlZC4gVGhlIGZpcnN0IGhvb2tcclxuICogdG8gdXNlIHJlcGxhY2Ugc2hvcnQtY2lyY3VpdHMgdGhlIGxvb3AuXHJcbiAqXHJcbiAqIElmIGEgaG9vayBuZWVkcyB0byBydW4gYXN5bmNocm9ub3VzbHksIGl0IG1heSB1c2UgdGhlIGNhbGxiYWNrXHJcbiAqIGZ1bmN0aW9uLiBIb3dldmVyLCBkb2luZyBzbyB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIHBhdXNlLFxyXG4gKiB3aGljaCBjb3VsZCBsZWFkIHRvIGEgbm9uLXJlc3BvbnNpdmUgVUkgaWYgdGhlIGhvb2sgaXMgc2xvdy5cclxuICovXHJcbmZ1bmN0aW9uIHJ1bkNoYW5nZUhvb2tzKHJvdXRlcywgc3RhdGUsIG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcclxuICBjaGFuZ2VIb29rcy5jbGVhcigpO1xyXG4gIHZhciBob29rcyA9IGdldENoYW5nZUhvb2tzKHJvdXRlcyk7XHJcbiAgcmV0dXJuIHJ1blRyYW5zaXRpb25Ib29rcyhob29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZSwgbmV4dCkge1xyXG4gICAgdmFyIHdyYXBwZWROZXh0ID0gZnVuY3Rpb24gd3JhcHBlZE5leHQoKSB7XHJcbiAgICAgIGlmIChjaGFuZ2VIb29rcy5oYXMoaG9va3NbaW5kZXhdKSkge1xyXG4gICAgICAgIG5leHQuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGNoYW5nZUhvb2tzLnJlbW92ZShob29rc1tpbmRleF0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgaG9va3NbaW5kZXhdKHN0YXRlLCBuZXh0U3RhdGUsIHJlcGxhY2UsIHdyYXBwZWROZXh0KTtcclxuICB9LCBjYWxsYmFjayk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW5zIGFsbCBvbkxlYXZlIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBydW5MZWF2ZUhvb2tzKHJvdXRlcywgcHJldlN0YXRlKSB7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgaWYgKHJvdXRlc1tpXS5vbkxlYXZlKSByb3V0ZXNbaV0ub25MZWF2ZS5jYWxsKHJvdXRlc1tpXSwgcHJldlN0YXRlKTtcclxuICB9XHJcbn0iLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG5cclxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XHJcblxyXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcclxuXHJcbnZhciBfUm91dGVyQ29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0KTtcclxuXHJcbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xyXG5cclxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gIH1cclxuXHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIG1pZGRsZXdhcmVzLmZvckVhY2goZnVuY3Rpb24gKG1pZGRsZXdhcmUsIGluZGV4KSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKG1pZGRsZXdhcmUucmVuZGVyUm91dGVyQ29udGV4dCB8fCBtaWRkbGV3YXJlLnJlbmRlclJvdXRlQ29tcG9uZW50LCAnVGhlIG1pZGRsZXdhcmUgc3BlY2lmaWVkIGF0IGluZGV4ICcgKyBpbmRleCArICcgZG9lcyBub3QgYXBwZWFyIHRvIGJlICcgKyAnYSB2YWxpZCBSZWFjdCBSb3V0ZXIgbWlkZGxld2FyZS4nKSA6IHZvaWQgMDtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIHdpdGhDb250ZXh0ID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XHJcbiAgICByZXR1cm4gbWlkZGxld2FyZS5yZW5kZXJSb3V0ZXJDb250ZXh0O1xyXG4gIH0pLmZpbHRlcihCb29sZWFuKTtcclxuICB2YXIgd2l0aENvbXBvbmVudCA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xyXG4gICAgcmV0dXJuIG1pZGRsZXdhcmUucmVuZGVyUm91dGVDb21wb25lbnQ7XHJcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuICB2YXIgbWFrZUNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBtYWtlQ3JlYXRlRWxlbWVudCgpIHtcclxuICAgIHZhciBiYXNlQ3JlYXRlRWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogX3JlYWN0LmNyZWF0ZUVsZW1lbnQ7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMpIHtcclxuICAgICAgcmV0dXJuIHdpdGhDb21wb25lbnQucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHByZXZpb3VzLCByZW5kZXJSb3V0ZUNvbXBvbmVudCkge1xyXG4gICAgICAgIHJldHVybiByZW5kZXJSb3V0ZUNvbXBvbmVudChwcmV2aW91cywgcHJvcHMpO1xyXG4gICAgICB9LCBiYXNlQ3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzKSk7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAocmVuZGVyUHJvcHMpIHtcclxuICAgIHJldHVybiB3aXRoQ29udGV4dC5yZWR1Y2VSaWdodChmdW5jdGlvbiAocHJldmlvdXMsIHJlbmRlclJvdXRlckNvbnRleHQpIHtcclxuICAgICAgcmV0dXJuIHJlbmRlclJvdXRlckNvbnRleHQocHJldmlvdXMsIHJlbmRlclByb3BzKTtcclxuICAgIH0sIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Sb3V0ZXJDb250ZXh0Mi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgcmVuZGVyUHJvcHMsIHtcclxuICAgICAgY3JlYXRlRWxlbWVudDogbWFrZUNyZWF0ZUVsZW1lbnQocmVuZGVyUHJvcHMuY3JlYXRlRWxlbWVudClcclxuICAgIH0pKSk7XHJcbiAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG52YXIgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlQnJvd3Nlckhpc3RvcnknKTtcclxuXHJcbnZhciBfY3JlYXRlQnJvd3Nlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQnJvd3Nlckhpc3RvcnkpO1xyXG5cclxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVSb3V0ZXJIaXN0b3J5Jyk7XHJcblxyXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9jcmVhdGVSb3V0ZXJIaXN0b3J5Mi5kZWZhdWx0KShfY3JlYXRlQnJvd3Nlckhpc3RvcnkyLmRlZmF1bHQpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xyXG5cclxuZnVuY3Rpb24gcm91dGVQYXJhbXNDaGFuZ2VkKHJvdXRlLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSkge1xyXG4gIGlmICghcm91dGUucGF0aCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICB2YXIgcGFyYW1OYW1lcyA9ICgwLCBfUGF0dGVyblV0aWxzLmdldFBhcmFtTmFtZXMpKHJvdXRlLnBhdGgpO1xyXG5cclxuICByZXR1cm4gcGFyYW1OYW1lcy5zb21lKGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcclxuICAgIHJldHVybiBwcmV2U3RhdGUucGFyYW1zW3BhcmFtTmFtZV0gIT09IG5leHRTdGF0ZS5wYXJhbXNbcGFyYW1OYW1lXTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHsgbGVhdmVSb3V0ZXMsIGNoYW5nZVJvdXRlcywgZW50ZXJSb3V0ZXMgfSBkZXRlcm1pbmVkIGJ5XHJcbiAqIHRoZSBjaGFuZ2UgZnJvbSBwcmV2U3RhdGUgdG8gbmV4dFN0YXRlLiBXZSBsZWF2ZSByb3V0ZXMgaWYgZWl0aGVyXHJcbiAqIDEpIHRoZXkgYXJlIG5vdCBpbiB0aGUgbmV4dCBzdGF0ZSBvciAyKSB0aGV5IGFyZSBpbiB0aGUgbmV4dCBzdGF0ZVxyXG4gKiBidXQgdGhlaXIgcGFyYW1zIGhhdmUgY2hhbmdlZCAoaS5lLiAvdXNlcnMvMTIzID0+IC91c2Vycy80NTYpLlxyXG4gKlxyXG4gKiBsZWF2ZVJvdXRlcyBhcmUgb3JkZXJlZCBzdGFydGluZyBhdCB0aGUgbGVhZiByb3V0ZSBvZiB0aGUgdHJlZVxyXG4gKiB3ZSdyZSBsZWF2aW5nIHVwIHRvIHRoZSBjb21tb24gcGFyZW50IHJvdXRlLiBlbnRlclJvdXRlcyBhcmUgb3JkZXJlZFxyXG4gKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHRyZWUgd2UncmUgZW50ZXJpbmcgZG93biB0byB0aGUgbGVhZiByb3V0ZS5cclxuICpcclxuICogY2hhbmdlUm91dGVzIGFyZSBhbnkgcm91dGVzIHRoYXQgZGlkbid0IGxlYXZlIG9yIGVudGVyIGR1cmluZ1xyXG4gKiB0aGUgdHJhbnNpdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVDaGFuZ2VkUm91dGVzKHByZXZTdGF0ZSwgbmV4dFN0YXRlKSB7XHJcbiAgdmFyIHByZXZSb3V0ZXMgPSBwcmV2U3RhdGUgJiYgcHJldlN0YXRlLnJvdXRlcztcclxuICB2YXIgbmV4dFJvdXRlcyA9IG5leHRTdGF0ZS5yb3V0ZXM7XHJcblxyXG4gIHZhciBsZWF2ZVJvdXRlcyA9IHZvaWQgMCxcclxuICAgICAgY2hhbmdlUm91dGVzID0gdm9pZCAwLFxyXG4gICAgICBlbnRlclJvdXRlcyA9IHZvaWQgMDtcclxuICBpZiAocHJldlJvdXRlcykge1xyXG4gICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBhcmVudElzTGVhdmluZyA9IGZhbHNlO1xyXG4gICAgICBsZWF2ZVJvdXRlcyA9IHByZXZSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xyXG4gICAgICAgIGlmIChwYXJlbnRJc0xlYXZpbmcpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgaXNMZWF2aW5nID0gbmV4dFJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTEgfHwgcm91dGVQYXJhbXNDaGFuZ2VkKHJvdXRlLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSk7XHJcbiAgICAgICAgICBpZiAoaXNMZWF2aW5nKSBwYXJlbnRJc0xlYXZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgcmV0dXJuIGlzTGVhdmluZztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gb25MZWF2ZSBob29rcyBzdGFydCBhdCB0aGUgbGVhZiByb3V0ZS5cclxuICAgICAgbGVhdmVSb3V0ZXMucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgZW50ZXJSb3V0ZXMgPSBbXTtcclxuICAgICAgY2hhbmdlUm91dGVzID0gW107XHJcblxyXG4gICAgICBuZXh0Um91dGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgICAgdmFyIGlzTmV3ID0gcHJldlJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTE7XHJcbiAgICAgICAgdmFyIHBhcmFtc0NoYW5nZWQgPSBsZWF2ZVJvdXRlcy5pbmRleE9mKHJvdXRlKSAhPT0gLTE7XHJcblxyXG4gICAgICAgIGlmIChpc05ldyB8fCBwYXJhbXNDaGFuZ2VkKSBlbnRlclJvdXRlcy5wdXNoKHJvdXRlKTtlbHNlIGNoYW5nZVJvdXRlcy5wdXNoKHJvdXRlKTtcclxuICAgICAgfSk7XHJcbiAgICB9KSgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsZWF2ZVJvdXRlcyA9IFtdO1xyXG4gICAgY2hhbmdlUm91dGVzID0gW107XHJcbiAgICBlbnRlclJvdXRlcyA9IG5leHRSb3V0ZXM7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbGVhdmVSb3V0ZXM6IGxlYXZlUm91dGVzLFxyXG4gICAgY2hhbmdlUm91dGVzOiBjaGFuZ2VSb3V0ZXMsXHJcbiAgICBlbnRlclJvdXRlczogZW50ZXJSb3V0ZXNcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBjb21wdXRlQ2hhbmdlZFJvdXRlcztcclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlTWVtb3J5SGlzdG9yeTtcclxuXHJcbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcclxuXHJcbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcclxuXHJcbnZhciBfdXNlQmFzZW5hbWUgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VCYXNlbmFtZScpO1xyXG5cclxudmFyIF91c2VCYXNlbmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VCYXNlbmFtZSk7XHJcblxyXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XHJcblxyXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XHJcbiAgLy8gc2lnbmF0dXJlcyBhbmQgdHlwZSBjaGVja2luZyBkaWZmZXIgYmV0d2VlbiBgdXNlUXVlcmllc2AgYW5kXHJcbiAgLy8gYGNyZWF0ZU1lbW9yeUhpc3RvcnlgLCBoYXZlIHRvIGNyZWF0ZSBgbWVtb3J5SGlzdG9yeWAgZmlyc3QgYmVjYXVzZVxyXG4gIC8vIGB1c2VRdWVyaWVzYCBkb2Vzbid0IHVuZGVyc3RhbmQgdGhlIHNpZ25hdHVyZVxyXG4gIHZhciBtZW1vcnlIaXN0b3J5ID0gKDAsIF9jcmVhdGVNZW1vcnlIaXN0b3J5Mi5kZWZhdWx0KShvcHRpb25zKTtcclxuICB2YXIgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XHJcbiAgICByZXR1cm4gbWVtb3J5SGlzdG9yeTtcclxuICB9O1xyXG4gIHZhciBoaXN0b3J5ID0gKDAsIF91c2VRdWVyaWVzMi5kZWZhdWx0KSgoMCwgX3VzZUJhc2VuYW1lMi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSkob3B0aW9ucyk7XHJcbiAgcmV0dXJuIGhpc3Rvcnk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjcmVhdGVIaXN0b3J5KSB7XHJcbiAgdmFyIGhpc3RvcnkgPSB2b2lkIDA7XHJcbiAgaWYgKGNhblVzZURPTSkgaGlzdG9yeSA9ICgwLCBfdXNlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkoKTtcclxuICByZXR1cm4gaGlzdG9yeTtcclxufTtcclxuXHJcbnZhciBfdXNlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vdXNlUm91dGVySGlzdG9yeScpO1xyXG5cclxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVJvdXRlckhpc3RvcnkpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcclxuXHJcbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xyXG5cclxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xyXG5cclxudmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlczIgPSByZXF1aXJlKCcuL2NvbXB1dGVDaGFuZ2VkUm91dGVzJyk7XHJcblxyXG52YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXB1dGVDaGFuZ2VkUm91dGVzMik7XHJcblxyXG52YXIgX1RyYW5zaXRpb25VdGlscyA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvblV0aWxzJyk7XHJcblxyXG52YXIgX2lzQWN0aXZlMiA9IHJlcXVpcmUoJy4vaXNBY3RpdmUnKTtcclxuXHJcbnZhciBfaXNBY3RpdmUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNBY3RpdmUyKTtcclxuXHJcbnZhciBfZ2V0Q29tcG9uZW50cyA9IHJlcXVpcmUoJy4vZ2V0Q29tcG9uZW50cycpO1xyXG5cclxudmFyIF9nZXRDb21wb25lbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldENvbXBvbmVudHMpO1xyXG5cclxudmFyIF9tYXRjaFJvdXRlcyA9IHJlcXVpcmUoJy4vbWF0Y2hSb3V0ZXMnKTtcclxuXHJcbnZhciBfbWF0Y2hSb3V0ZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2hSb3V0ZXMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIGhhc0FueVByb3BlcnRpZXMob2JqZWN0KSB7XHJcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSkgcmV0dXJuIHRydWU7XHJcbiAgfXJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoaGlzdG9yeSwgcm91dGVzKSB7XHJcbiAgdmFyIHN0YXRlID0ge307XHJcblxyXG4gIC8vIFNpZ25hdHVyZSBzaG91bGQgYmUgKGxvY2F0aW9uLCBpbmRleE9ubHkpLCBidXQgbmVlZHMgdG8gc3VwcG9ydCAocGF0aCxcclxuICAvLyBxdWVyeSwgaW5kZXhPbmx5KVxyXG4gIGZ1bmN0aW9uIGlzQWN0aXZlKGxvY2F0aW9uLCBpbmRleE9ubHkpIHtcclxuICAgIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XHJcblxyXG4gICAgcmV0dXJuICgwLCBfaXNBY3RpdmUzLmRlZmF1bHQpKGxvY2F0aW9uLCBpbmRleE9ubHksIHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5yb3V0ZXMsIHN0YXRlLnBhcmFtcyk7XHJcbiAgfVxyXG5cclxuICB2YXIgcGFydGlhbE5leHRTdGF0ZSA9IHZvaWQgMDtcclxuXHJcbiAgZnVuY3Rpb24gbWF0Y2gobG9jYXRpb24sIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAocGFydGlhbE5leHRTdGF0ZSAmJiBwYXJ0aWFsTmV4dFN0YXRlLmxvY2F0aW9uID09PSBsb2NhdGlvbikge1xyXG4gICAgICAvLyBDb250aW51ZSBmcm9tIHdoZXJlIHdlIGxlZnQgb2ZmLlxyXG4gICAgICBmaW5pc2hNYXRjaChwYXJ0aWFsTmV4dFN0YXRlLCBjYWxsYmFjayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFN0YXRlKSB7XHJcbiAgICAgICAgICBmaW5pc2hNYXRjaChfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGxvY2F0aW9uOiBsb2NhdGlvbiB9KSwgY2FsbGJhY2spO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaW5pc2hNYXRjaChuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzID0gKDAsIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMuZGVmYXVsdCkoc3RhdGUsIG5leHRTdGF0ZSksXHJcbiAgICAgICAgbGVhdmVSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMubGVhdmVSb3V0ZXMsXHJcbiAgICAgICAgY2hhbmdlUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmNoYW5nZVJvdXRlcyxcclxuICAgICAgICBlbnRlclJvdXRlcyA9IF9jb21wdXRlQ2hhbmdlZFJvdXRlcy5lbnRlclJvdXRlcztcclxuXHJcbiAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5MZWF2ZUhvb2tzKShsZWF2ZVJvdXRlcywgc3RhdGUpO1xyXG5cclxuICAgIC8vIFRlYXIgZG93biBjb25maXJtYXRpb24gaG9va3MgZm9yIGxlZnQgcm91dGVzXHJcbiAgICBsZWF2ZVJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgIHJldHVybiBlbnRlclJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTE7XHJcbiAgICB9KS5mb3JFYWNoKHJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUpO1xyXG5cclxuICAgIC8vIGNoYW5nZSBhbmQgZW50ZXIgaG9va3MgYXJlIHJ1biBpbiBzZXJpZXNcclxuICAgICgwLCBfVHJhbnNpdGlvblV0aWxzLnJ1bkNoYW5nZUhvb2tzKShjaGFuZ2VSb3V0ZXMsIHN0YXRlLCBuZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RJbmZvKSB7XHJcbiAgICAgIGlmIChlcnJvciB8fCByZWRpcmVjdEluZm8pIHJldHVybiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbyk7XHJcblxyXG4gICAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5FbnRlckhvb2tzKShlbnRlclJvdXRlcywgbmV4dFN0YXRlLCBmaW5pc2hFbnRlckhvb2tzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmlzaEVudGVySG9va3MoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xyXG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSByZXR1cm4gaGFuZGxlRXJyb3JPclJlZGlyZWN0KGVycm9yLCByZWRpcmVjdEluZm8pO1xyXG5cclxuICAgICAgLy8gVE9ETzogRmV0Y2ggY29tcG9uZW50cyBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxyXG4gICAgICAoMCwgX2dldENvbXBvbmVudHMyLmRlZmF1bHQpKG5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCBjb21wb25lbnRzKSB7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFRPRE86IE1ha2UgbWF0Y2ggYSBwdXJlIGZ1bmN0aW9uIGFuZCBoYXZlIHNvbWUgb3RoZXIgQVBJXHJcbiAgICAgICAgICAvLyBmb3IgXCJtYXRjaCBhbmQgdXBkYXRlIHN0YXRlXCIuXHJcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBudWxsLCBzdGF0ZSA9IF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHsgY29tcG9uZW50czogY29tcG9uZW50cyB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xyXG4gICAgICBpZiAoZXJyb3IpIGNhbGxiYWNrKGVycm9yKTtlbHNlIGNhbGxiYWNrKG51bGwsIHJlZGlyZWN0SW5mbyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgUm91dGVHdWlkID0gMTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0Um91dGVJRChyb3V0ZSkge1xyXG4gICAgdmFyIGNyZWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuIHJvdXRlLl9faWRfXyB8fCBjcmVhdGUgJiYgKHJvdXRlLl9faWRfXyA9IFJvdXRlR3VpZCsrKTtcclxuICB9XHJcblxyXG4gIHZhciBSb3V0ZUhvb2tzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0Um91dGVIb29rc0ZvclJvdXRlcyhyb3V0ZXMpIHtcclxuICAgIHJldHVybiByb3V0ZXMubWFwKGZ1bmN0aW9uIChyb3V0ZSkge1xyXG4gICAgICByZXR1cm4gUm91dGVIb29rc1tnZXRSb3V0ZUlEKHJvdXRlKV07XHJcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHtcclxuICAgICAgcmV0dXJuIGhvb2s7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25Ib29rKGxvY2F0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgKDAsIF9tYXRjaFJvdXRlczIuZGVmYXVsdCkocm91dGVzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBuZXh0U3RhdGUpIHtcclxuICAgICAgaWYgKG5leHRTdGF0ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgLy8gVE9ETzogV2UgZGlkbid0IGFjdHVhbGx5IG1hdGNoIGFueXRoaW5nLCBidXQgaGFuZ1xyXG4gICAgICAgIC8vIG9udG8gZXJyb3IvbmV4dFN0YXRlIHNvIHdlIGRvbid0IGhhdmUgdG8gbWF0Y2hSb3V0ZXNcclxuICAgICAgICAvLyBhZ2FpbiBpbiB0aGUgbGlzdGVuIGNhbGxiYWNrLlxyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWNoZSBzb21lIHN0YXRlIGhlcmUgc28gd2UgZG9uJ3QgaGF2ZSB0b1xyXG4gICAgICAvLyBtYXRjaFJvdXRlcygpIGFnYWluIGluIHRoZSBsaXN0ZW4gY2FsbGJhY2suXHJcbiAgICAgIHBhcnRpYWxOZXh0U3RhdGUgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcclxuXHJcbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoKDAsIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMuZGVmYXVsdCkoc3RhdGUsIHBhcnRpYWxOZXh0U3RhdGUpLmxlYXZlUm91dGVzKTtcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob29rcy5sZW5ndGg7IHJlc3VsdCA9PSBudWxsICYmIGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGxvY2F0aW9uIGFyZyBoZXJlIGluZGljYXRlcyB0b1xyXG4gICAgICAgIC8vIHRoZSB1c2VyIHRoYXQgdGhpcyBpcyBhIHRyYW5zaXRpb24gaG9vay5cclxuICAgICAgICByZXN1bHQgPSBob29rc1tpXShsb2NhdGlvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiB1bnRlc3RhYmxlIHdpdGggS2FybWEgKi9cclxuICBmdW5jdGlvbiBiZWZvcmVVbmxvYWRIb29rKCkge1xyXG4gICAgLy8gU3luY2hyb25vdXNseSBjaGVjayB0byBzZWUgaWYgYW55IHJvdXRlIGhvb2tzIHdhbnRcclxuICAgIC8vIHRvIHByZXZlbnQgdGhlIGN1cnJlbnQgd2luZG93L3RhYiBmcm9tIGNsb3NpbmcuXHJcbiAgICBpZiAoc3RhdGUucm91dGVzKSB7XHJcbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoc3RhdGUucm91dGVzKTtcclxuXHJcbiAgICAgIHZhciBtZXNzYWdlID0gdm9pZCAwO1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9va3MubGVuZ3RoOyB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycgJiYgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgLy8gUGFzc2luZyBubyBhcmdzIGluZGljYXRlcyB0byB0aGUgdXNlciB0aGF0IHRoaXMgaXMgYVxyXG4gICAgICAgIC8vIGJlZm9yZXVubG9hZCBob29rLiBXZSBkb24ndCBrbm93IHRoZSBuZXh0IGxvY2F0aW9uLlxyXG4gICAgICAgIG1lc3NhZ2UgPSBob29rc1tpXSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciB1bmxpc3RlbkJlZm9yZSA9IHZvaWQgMCxcclxuICAgICAgdW5saXN0ZW5CZWZvcmVVbmxvYWQgPSB2b2lkIDA7XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUocm91dGUpIHtcclxuICAgIHZhciByb3V0ZUlEID0gZ2V0Um91dGVJRChyb3V0ZSk7XHJcbiAgICBpZiAoIXJvdXRlSUQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZSBSb3V0ZUhvb2tzW3JvdXRlSURdO1xyXG5cclxuICAgIGlmICghaGFzQW55UHJvcGVydGllcyhSb3V0ZUhvb2tzKSkge1xyXG4gICAgICAvLyB0ZWFyZG93biB0cmFuc2l0aW9uICYgYmVmb3JldW5sb2FkIGhvb2tzXHJcbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZSkge1xyXG4gICAgICAgIHVubGlzdGVuQmVmb3JlKCk7XHJcbiAgICAgICAgdW5saXN0ZW5CZWZvcmUgPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodW5saXN0ZW5CZWZvcmVVbmxvYWQpIHtcclxuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCgpO1xyXG4gICAgICAgIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBob29rIGZ1bmN0aW9uIHRvIHJ1biBiZWZvcmUgbGVhdmluZyB0aGUgZ2l2ZW4gcm91dGUuXHJcbiAgICpcclxuICAgKiBEdXJpbmcgYSBub3JtYWwgdHJhbnNpdGlvbiwgdGhlIGhvb2sgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG5leHQgbG9jYXRpb25cclxuICAgKiBhcyBpdHMgb25seSBhcmd1bWVudCBhbmQgY2FuIHJldHVybiBlaXRoZXIgYSBwcm9tcHQgbWVzc2FnZSAoc3RyaW5nKSB0byBzaG93IHRoZSB1c2VyLFxyXG4gICAqIHRvIG1ha2Ugc3VyZSB0aGV5IHdhbnQgdG8gbGVhdmUgdGhlIHBhZ2U7IG9yIGBmYWxzZWAsIHRvIHByZXZlbnQgdGhlIHRyYW5zaXRpb24uXHJcbiAgICogQW55IG90aGVyIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxyXG4gICAqXHJcbiAgICogRHVyaW5nIHRoZSBiZWZvcmV1bmxvYWQgZXZlbnQgKGluIGJyb3dzZXJzKSB0aGUgaG9vayByZWNlaXZlcyBubyBhcmd1bWVudHMuXHJcbiAgICogSW4gdGhpcyBjYXNlIGl0IG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cclxuICAgKlxyXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIHVuYmluZCB0aGUgbGlzdGVuZXIuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKHJvdXRlLCBob29rKSB7XHJcbiAgICB2YXIgdGhlcmVXZXJlTm9Sb3V0ZUhvb2tzID0gIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcyk7XHJcbiAgICB2YXIgcm91dGVJRCA9IGdldFJvdXRlSUQocm91dGUsIHRydWUpO1xyXG5cclxuICAgIFJvdXRlSG9va3Nbcm91dGVJRF0gPSBob29rO1xyXG5cclxuICAgIGlmICh0aGVyZVdlcmVOb1JvdXRlSG9va3MpIHtcclxuICAgICAgLy8gc2V0dXAgdHJhbnNpdGlvbiAmIGJlZm9yZXVubG9hZCBob29rc1xyXG4gICAgICB1bmxpc3RlbkJlZm9yZSA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKHRyYW5zaXRpb25Ib29rKTtcclxuXHJcbiAgICAgIGlmIChoaXN0b3J5Lmxpc3RlbkJlZm9yZVVubG9hZCkgdW5saXN0ZW5CZWZvcmVVbmxvYWQgPSBoaXN0b3J5Lmxpc3RlbkJlZm9yZVVubG9hZChiZWZvcmVVbmxvYWRIb29rKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKHJvdXRlKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGlzIHRoZSBBUEkgZm9yIHN0YXRlZnVsIGVudmlyb25tZW50cy4gQXMgdGhlIGxvY2F0aW9uXHJcbiAgICogY2hhbmdlcywgd2UgdXBkYXRlIHN0YXRlIGFuZCBjYWxsIHRoZSBsaXN0ZW5lci4gV2UgY2FuIGFsc29cclxuICAgKiBncmFjZWZ1bGx5IGhhbmRsZSBlcnJvcnMgYW5kIHJlZGlyZWN0cy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcclxuICAgIGZ1bmN0aW9uIGhpc3RvcnlMaXN0ZW5lcihsb2NhdGlvbikge1xyXG4gICAgICBpZiAoc3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XHJcbiAgICAgICAgbGlzdGVuZXIobnVsbCwgc3RhdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xyXG4gICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKGVycm9yKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xyXG4gICAgICAgICAgICBoaXN0b3J5LnJlcGxhY2UocmVkaXJlY3RMb2NhdGlvbik7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHRTdGF0ZSkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcihudWxsLCBuZXh0U3RhdGUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdMb2NhdGlvbiBcIiVzXCIgZGlkIG5vdCBtYXRjaCBhbnkgcm91dGVzJywgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoKSA6IHZvaWQgMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IE9ubHkgdXNlIGEgc2luZ2xlIGhpc3RvcnkgbGlzdGVuZXIuIE90aGVyd2lzZSB3ZSdsbCBlbmQgdXAgd2l0aFxyXG4gICAgLy8gbXVsdGlwbGUgY29uY3VycmVudCBjYWxscyB0byBtYXRjaC5cclxuXHJcbiAgICAvLyBTZXQgdXAgdGhlIGhpc3RvcnkgbGlzdGVuZXIgZmlyc3QgaW4gY2FzZSB0aGUgaW5pdGlhbCBtYXRjaCByZWRpcmVjdHMuXHJcbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBoaXN0b3J5Lmxpc3RlbihoaXN0b3J5TGlzdGVuZXIpO1xyXG5cclxuICAgIGlmIChzdGF0ZS5sb2NhdGlvbikge1xyXG4gICAgICAvLyBQaWNraW5nIHVwIG9uIGEgbWF0Y2hDb250ZXh0LlxyXG4gICAgICBsaXN0ZW5lcihudWxsLCBzdGF0ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoaXN0b3J5TGlzdGVuZXIoaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcclxuICAgIG1hdGNoOiBtYXRjaCxcclxuICAgIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZTogbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlLFxyXG4gICAgbGlzdGVuOiBsaXN0ZW5cclxuICB9O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcclxuXHJcbnZhciBfUHJvbWlzZVV0aWxzID0gcmVxdWlyZSgnLi9Qcm9taXNlVXRpbHMnKTtcclxuXHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudHNGb3JSb3V0ZShuZXh0U3RhdGUsIHJvdXRlLCBjYWxsYmFjaykge1xyXG4gIGlmIChyb3V0ZS5jb21wb25lbnQgfHwgcm91dGUuY29tcG9uZW50cykge1xyXG4gICAgY2FsbGJhY2sobnVsbCwgcm91dGUuY29tcG9uZW50IHx8IHJvdXRlLmNvbXBvbmVudHMpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdmFyIGdldENvbXBvbmVudCA9IHJvdXRlLmdldENvbXBvbmVudCB8fCByb3V0ZS5nZXRDb21wb25lbnRzO1xyXG4gIGlmIChnZXRDb21wb25lbnQpIHtcclxuICAgIHZhciBjb21wb25lbnRSZXR1cm4gPSBnZXRDb21wb25lbnQuY2FsbChyb3V0ZSwgbmV4dFN0YXRlLCBjYWxsYmFjayk7XHJcbiAgICBpZiAoKDAsIF9Qcm9taXNlVXRpbHMuaXNQcm9taXNlKShjb21wb25lbnRSZXR1cm4pKSBjb21wb25lbnRSZXR1cm4udGhlbihmdW5jdGlvbiAoY29tcG9uZW50KSB7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjb21wb25lbnQpO1xyXG4gICAgfSwgY2FsbGJhY2spO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjYWxsYmFjaygpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFzeW5jaHJvbm91c2x5IGZldGNoZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciB0aGUgZ2l2ZW4gcm91dGVyXHJcbiAqIHN0YXRlIGFuZCBjYWxscyBjYWxsYmFjayhlcnJvciwgY29tcG9uZW50cykgd2hlbiBmaW5pc2hlZC5cclxuICpcclxuICogTm90ZTogVGhpcyBvcGVyYXRpb24gbWF5IGZpbmlzaCBzeW5jaHJvbm91c2x5IGlmIG5vIHJvdXRlcyBoYXZlIGFuXHJcbiAqIGFzeW5jaHJvbm91cyBnZXRDb21wb25lbnRzIG1ldGhvZC5cclxuICovXHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudHMobmV4dFN0YXRlLCBjYWxsYmFjaykge1xyXG4gICgwLCBfQXN5bmNVdGlscy5tYXBBc3luYykobmV4dFN0YXRlLnJvdXRlcywgZnVuY3Rpb24gKHJvdXRlLCBpbmRleCwgY2FsbGJhY2spIHtcclxuICAgIGdldENvbXBvbmVudHNGb3JSb3V0ZShuZXh0U3RhdGUsIHJvdXRlLCBjYWxsYmFjayk7XHJcbiAgfSwgY2FsbGJhY2spO1xyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBnZXRDb21wb25lbnRzO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3RzIGFuIG9iamVjdCBvZiBwYXJhbXMgdGhlIGdpdmVuIHJvdXRlIGNhcmVzIGFib3V0IGZyb21cclxuICogdGhlIGdpdmVuIHBhcmFtcyBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSb3V0ZVBhcmFtcyhyb3V0ZSwgcGFyYW1zKSB7XHJcbiAgdmFyIHJvdXRlUGFyYW1zID0ge307XHJcblxyXG4gIGlmICghcm91dGUucGF0aCkgcmV0dXJuIHJvdXRlUGFyYW1zO1xyXG5cclxuICAoMCwgX1BhdHRlcm5VdGlscy5nZXRQYXJhbU5hbWVzKShyb3V0ZS5wYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgcCkpIHtcclxuICAgICAgcm91dGVQYXJhbXNbcF0gPSBwYXJhbXNbcF07XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiByb3V0ZVBhcmFtcztcclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0Um91dGVQYXJhbXM7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnknKTtcclxuXHJcbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGFzaEhpc3RvcnkpO1xyXG5cclxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVSb3V0ZXJIaXN0b3J5Jyk7XHJcblxyXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9jcmVhdGVSb3V0ZXJIaXN0b3J5Mi5kZWZhdWx0KShfY3JlYXRlSGFzaEhpc3RvcnkyLmRlZmF1bHQpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5leHBvcnRzLmNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBleHBvcnRzLmhhc2hIaXN0b3J5ID0gZXhwb3J0cy5icm93c2VySGlzdG9yeSA9IGV4cG9ydHMuYXBwbHlSb3V0ZXJNaWRkbGV3YXJlID0gZXhwb3J0cy5mb3JtYXRQYXR0ZXJuID0gZXhwb3J0cy51c2VSb3V0ZXJIaXN0b3J5ID0gZXhwb3J0cy5tYXRjaCA9IGV4cG9ydHMucm91dGVyU2hhcGUgPSBleHBvcnRzLmxvY2F0aW9uU2hhcGUgPSBleHBvcnRzLlJvdXRlckNvbnRleHQgPSBleHBvcnRzLmNyZWF0ZVJvdXRlcyA9IGV4cG9ydHMuUm91dGUgPSBleHBvcnRzLlJlZGlyZWN0ID0gZXhwb3J0cy5JbmRleFJvdXRlID0gZXhwb3J0cy5JbmRleFJlZGlyZWN0ID0gZXhwb3J0cy53aXRoUm91dGVyID0gZXhwb3J0cy5JbmRleExpbmsgPSBleHBvcnRzLkxpbmsgPSBleHBvcnRzLlJvdXRlciA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVSb3V0ZXMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXM7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9Qcm9wVHlwZXMnKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbG9jYXRpb25TaGFwZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9Qcm9wVHlwZXMubG9jYXRpb25TaGFwZTtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3JvdXRlclNoYXBlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZTtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmb3JtYXRQYXR0ZXJuJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuO1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1JvdXRlcjIgPSByZXF1aXJlKCcuL1JvdXRlcicpO1xyXG5cclxudmFyIF9Sb3V0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyMik7XHJcblxyXG52YXIgX0xpbmsyID0gcmVxdWlyZSgnLi9MaW5rJyk7XHJcblxyXG52YXIgX0xpbmszID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGluazIpO1xyXG5cclxudmFyIF9JbmRleExpbmsyID0gcmVxdWlyZSgnLi9JbmRleExpbmsnKTtcclxuXHJcbnZhciBfSW5kZXhMaW5rMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0luZGV4TGluazIpO1xyXG5cclxudmFyIF93aXRoUm91dGVyMiA9IHJlcXVpcmUoJy4vd2l0aFJvdXRlcicpO1xyXG5cclxudmFyIF93aXRoUm91dGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dpdGhSb3V0ZXIyKTtcclxuXHJcbnZhciBfSW5kZXhSZWRpcmVjdDIgPSByZXF1aXJlKCcuL0luZGV4UmVkaXJlY3QnKTtcclxuXHJcbnZhciBfSW5kZXhSZWRpcmVjdDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJlZGlyZWN0Mik7XHJcblxyXG52YXIgX0luZGV4Um91dGUyID0gcmVxdWlyZSgnLi9JbmRleFJvdXRlJyk7XHJcblxyXG52YXIgX0luZGV4Um91dGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhSb3V0ZTIpO1xyXG5cclxudmFyIF9SZWRpcmVjdDIgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XHJcblxyXG52YXIgX1JlZGlyZWN0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZGlyZWN0Mik7XHJcblxyXG52YXIgX1JvdXRlMiA9IHJlcXVpcmUoJy4vUm91dGUnKTtcclxuXHJcbnZhciBfUm91dGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGUyKTtcclxuXHJcbnZhciBfUm91dGVyQ29udGV4dDIgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcclxuXHJcbnZhciBfUm91dGVyQ29udGV4dDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0Mik7XHJcblxyXG52YXIgX21hdGNoMiA9IHJlcXVpcmUoJy4vbWF0Y2gnKTtcclxuXHJcbnZhciBfbWF0Y2gzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2gyKTtcclxuXHJcbnZhciBfdXNlUm91dGVySGlzdG9yeTIgPSByZXF1aXJlKCcuL3VzZVJvdXRlckhpc3RvcnknKTtcclxuXHJcbnZhciBfdXNlUm91dGVySGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXJIaXN0b3J5Mik7XHJcblxyXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTIgPSByZXF1aXJlKCcuL2FwcGx5Um91dGVyTWlkZGxld2FyZScpO1xyXG5cclxudmFyIF9hcHBseVJvdXRlck1pZGRsZXdhcmUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMik7XHJcblxyXG52YXIgX2Jyb3dzZXJIaXN0b3J5MiA9IHJlcXVpcmUoJy4vYnJvd3Nlckhpc3RvcnknKTtcclxuXHJcbnZhciBfYnJvd3Nlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJvd3Nlckhpc3RvcnkyKTtcclxuXHJcbnZhciBfaGFzaEhpc3RvcnkyID0gcmVxdWlyZSgnLi9oYXNoSGlzdG9yeScpO1xyXG5cclxudmFyIF9oYXNoSGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNoSGlzdG9yeTIpO1xyXG5cclxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xyXG5cclxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZU1lbW9yeUhpc3RvcnkyKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLlJvdXRlciA9IF9Sb3V0ZXIzLmRlZmF1bHQ7IC8qIGNvbXBvbmVudHMgKi9cclxuXHJcbmV4cG9ydHMuTGluayA9IF9MaW5rMy5kZWZhdWx0O1xyXG5leHBvcnRzLkluZGV4TGluayA9IF9JbmRleExpbmszLmRlZmF1bHQ7XHJcbmV4cG9ydHMud2l0aFJvdXRlciA9IF93aXRoUm91dGVyMy5kZWZhdWx0O1xyXG5cclxuLyogY29tcG9uZW50cyAoY29uZmlndXJhdGlvbikgKi9cclxuXHJcbmV4cG9ydHMuSW5kZXhSZWRpcmVjdCA9IF9JbmRleFJlZGlyZWN0My5kZWZhdWx0O1xyXG5leHBvcnRzLkluZGV4Um91dGUgPSBfSW5kZXhSb3V0ZTMuZGVmYXVsdDtcclxuZXhwb3J0cy5SZWRpcmVjdCA9IF9SZWRpcmVjdDMuZGVmYXVsdDtcclxuZXhwb3J0cy5Sb3V0ZSA9IF9Sb3V0ZTMuZGVmYXVsdDtcclxuXHJcbi8qIHV0aWxzICovXHJcblxyXG5leHBvcnRzLlJvdXRlckNvbnRleHQgPSBfUm91dGVyQ29udGV4dDMuZGVmYXVsdDtcclxuZXhwb3J0cy5tYXRjaCA9IF9tYXRjaDMuZGVmYXVsdDtcclxuZXhwb3J0cy51c2VSb3V0ZXJIaXN0b3J5ID0gX3VzZVJvdXRlckhpc3RvcnkzLmRlZmF1bHQ7XHJcbmV4cG9ydHMuYXBwbHlSb3V0ZXJNaWRkbGV3YXJlID0gX2FwcGx5Um91dGVyTWlkZGxld2FyZTMuZGVmYXVsdDtcclxuXHJcbi8qIGhpc3RvcmllcyAqL1xyXG5cclxuZXhwb3J0cy5icm93c2VySGlzdG9yeSA9IF9icm93c2VySGlzdG9yeTMuZGVmYXVsdDtcclxuZXhwb3J0cy5oYXNoSGlzdG9yeSA9IF9oYXNoSGlzdG9yeTMuZGVmYXVsdDtcclxuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gX2NyZWF0ZU1lbW9yeUhpc3RvcnkzLmRlZmF1bHQ7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQWN0aXZlO1xyXG5cclxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xyXG5cclxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcclxuICBpZiAoYSA9PSBiKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xyXG4gICAgICByZXR1cm4gZGVlcEVxdWFsKGl0ZW0sIGJbaW5kZXhdKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKCh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSkpID09PSAnb2JqZWN0Jykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBhKSB7XHJcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIHApKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhW3BdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoYltwXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChhW3BdLCBiW3BdKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHBhdGhuYW1lIG1hdGNoZXMgdGhlIHN1cHBsaWVkIG9uZSwgbmV0IG9mXHJcbiAqIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoIG5vcm1hbGl6YXRpb24uIFRoaXMgaXMgc3VmZmljaWVudCBmb3IgYW5cclxuICogaW5kZXhPbmx5IHJvdXRlIG1hdGNoLlxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aElzQWN0aXZlKHBhdGhuYW1lLCBjdXJyZW50UGF0aG5hbWUpIHtcclxuICAvLyBOb3JtYWxpemUgbGVhZGluZyBzbGFzaCBmb3IgY29uc2lzdGVuY3kuIExlYWRpbmcgc2xhc2ggb24gcGF0aG5hbWUgaGFzXHJcbiAgLy8gYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQgaW4gaXNBY3RpdmUuIFNlZSBjYXZlYXQgdGhlcmUuXHJcbiAgaWYgKGN1cnJlbnRQYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xyXG4gICAgY3VycmVudFBhdGhuYW1lID0gJy8nICsgY3VycmVudFBhdGhuYW1lO1xyXG4gIH1cclxuXHJcbiAgLy8gTm9ybWFsaXplIHRoZSBlbmQgb2YgYm90aCBwYXRoIG5hbWVzIHRvby4gTWF5YmUgYC9mb28vYCBzaG91bGRuJ3Qgc2hvd1xyXG4gIC8vIGAvZm9vYCBhcyBhY3RpdmUsIGJ1dCBpbiB0aGlzIGNhc2UsIHdlIHdvdWxkIGFscmVhZHkgaGF2ZSBmYWlsZWQgdGhlXHJcbiAgLy8gbWF0Y2guXHJcbiAgaWYgKHBhdGhuYW1lLmNoYXJBdChwYXRobmFtZS5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XHJcbiAgICBwYXRobmFtZSArPSAnLyc7XHJcbiAgfVxyXG4gIGlmIChjdXJyZW50UGF0aG5hbWUuY2hhckF0KGN1cnJlbnRQYXRobmFtZS5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XHJcbiAgICBjdXJyZW50UGF0aG5hbWUgKz0gJy8nO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGN1cnJlbnRQYXRobmFtZSA9PT0gcGF0aG5hbWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGhuYW1lIG1hdGNoZXMgdGhlIGFjdGl2ZSByb3V0ZXMgYW5kIHBhcmFtcy5cclxuICovXHJcbmZ1bmN0aW9uIHJvdXRlSXNBY3RpdmUocGF0aG5hbWUsIHJvdXRlcywgcGFyYW1zKSB7XHJcbiAgdmFyIHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWUsXHJcbiAgICAgIHBhcmFtTmFtZXMgPSBbXSxcclxuICAgICAgcGFyYW1WYWx1ZXMgPSBbXTtcclxuXHJcbiAgLy8gZm9yLi4ub2Ygd291bGQgd29yayBoZXJlIGJ1dCBpdCdzIHByb2JhYmx5IHNsb3dlciBwb3N0LXRyYW5zcGlsYXRpb24uXHJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgdmFyIHJvdXRlID0gcm91dGVzW2ldO1xyXG4gICAgdmFyIHBhdHRlcm4gPSByb3V0ZS5wYXRoIHx8ICcnO1xyXG5cclxuICAgIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy8nKSB7XHJcbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWU7XHJcbiAgICAgIHBhcmFtTmFtZXMgPSBbXTtcclxuICAgICAgcGFyYW1WYWx1ZXMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT09IG51bGwgJiYgcGF0dGVybikge1xyXG4gICAgICB2YXIgbWF0Y2hlZCA9ICgwLCBfUGF0dGVyblV0aWxzLm1hdGNoUGF0dGVybikocGF0dGVybiwgcmVtYWluaW5nUGF0aG5hbWUpO1xyXG4gICAgICBpZiAobWF0Y2hlZCkge1xyXG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZC5yZW1haW5pbmdQYXRobmFtZTtcclxuICAgICAgICBwYXJhbU5hbWVzID0gW10uY29uY2F0KHBhcmFtTmFtZXMsIG1hdGNoZWQucGFyYW1OYW1lcyk7XHJcbiAgICAgICAgcGFyYW1WYWx1ZXMgPSBbXS5jb25jYXQocGFyYW1WYWx1ZXMsIG1hdGNoZWQucGFyYW1WYWx1ZXMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lID09PSAnJykge1xyXG4gICAgICAgIC8vIFdlIGhhdmUgYW4gZXhhY3QgbWF0Y2ggb24gdGhlIHJvdXRlLiBKdXN0IGNoZWNrIHRoYXQgYWxsIHRoZSBwYXJhbXNcclxuICAgICAgICAvLyBtYXRjaC5cclxuICAgICAgICAvLyBGSVhNRTogVGhpcyBkb2Vzbid0IHdvcmsgb24gcmVwZWF0ZWQgcGFyYW1zLlxyXG4gICAgICAgIHJldHVybiBwYXJhbU5hbWVzLmV2ZXJ5KGZ1bmN0aW9uIChwYXJhbU5hbWUsIGluZGV4KSB7XHJcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHBhcmFtVmFsdWVzW2luZGV4XSkgPT09IFN0cmluZyhwYXJhbXNbcGFyYW1OYW1lXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbGwga2V5L3ZhbHVlIHBhaXJzIGluIHRoZSBnaXZlbiBxdWVyeSBhcmVcclxuICogY3VycmVudGx5IGFjdGl2ZS5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5SXNBY3RpdmUocXVlcnksIGFjdGl2ZVF1ZXJ5KSB7XHJcbiAgaWYgKGFjdGl2ZVF1ZXJ5ID09IG51bGwpIHJldHVybiBxdWVyeSA9PSBudWxsO1xyXG5cclxuICBpZiAocXVlcnkgPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcblxyXG4gIHJldHVybiBkZWVwRXF1YWwocXVlcnksIGFjdGl2ZVF1ZXJ5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIDxMaW5rPiB0byB0aGUgZ2l2ZW4gcGF0aG5hbWUvcXVlcnkgY29tYmluYXRpb24gaXNcclxuICogY3VycmVudGx5IGFjdGl2ZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzQWN0aXZlKF9yZWYsIGluZGV4T25seSwgY3VycmVudExvY2F0aW9uLCByb3V0ZXMsIHBhcmFtcykge1xyXG4gIHZhciBwYXRobmFtZSA9IF9yZWYucGF0aG5hbWUsXHJcbiAgICAgIHF1ZXJ5ID0gX3JlZi5xdWVyeTtcclxuXHJcbiAgaWYgKGN1cnJlbnRMb2NhdGlvbiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gIC8vIFRPRE86IFRoaXMgaXMgYSBiaXQgdWdseS4gSXQga2VlcHMgYXJvdW5kIHN1cHBvcnQgZm9yIHRyZWF0aW5nIHBhdGhuYW1lc1xyXG4gIC8vIHdpdGhvdXQgcHJlY2VkaW5nIHNsYXNoZXMgYXMgYWJzb2x1dGUgcGF0aHMsIGJ1dCBwb3NzaWJseSBhbHNvIHdvcmtzXHJcbiAgLy8gYXJvdW5kIHRoZSBzYW1lIHF1aXJrcyB3aXRoIGJhc2VuYW1lcyBhcyBpbiBtYXRjaFJvdXRlcy5cclxuICBpZiAocGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcclxuICAgIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XHJcbiAgfVxyXG5cclxuICBpZiAoIXBhdGhJc0FjdGl2ZShwYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKSkge1xyXG4gICAgLy8gVGhlIHBhdGggY2hlY2sgaXMgbmVjZXNzYXJ5IGFuZCBzdWZmaWNpZW50IGZvciBpbmRleE9ubHksIGJ1dCBvdGhlcndpc2VcclxuICAgIC8vIHdlIHN0aWxsIG5lZWQgdG8gY2hlY2sgdGhlIHJvdXRlcy5cclxuICAgIGlmIChpbmRleE9ubHkgfHwgIXJvdXRlSXNBY3RpdmUocGF0aG5hbWUsIHJvdXRlcywgcGFyYW1zKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcXVlcnlJc0FjdGl2ZShxdWVyeSwgY3VycmVudExvY2F0aW9uLnF1ZXJ5KTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL0FjdGlvbnMnKTtcclxuXHJcbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XHJcblxyXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xyXG5cclxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XHJcblxyXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeSk7XHJcblxyXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xyXG5cclxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XHJcblxyXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcclxuXHJcbnZhciBfUm91dGVyVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlclV0aWxzJyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5cclxuLyoqXHJcbiAqIEEgaGlnaC1sZXZlbCBBUEkgdG8gYmUgdXNlZCBmb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIG1hdGNoZXMgYSBsb2NhdGlvbiB0byBhIHNldCBvZiByb3V0ZXMgYW5kIGNhbGxzXHJcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCByZW5kZXJQcm9wcykgd2hlbiBmaW5pc2hlZC5cclxuICpcclxuICogTm90ZTogWW91IHByb2JhYmx5IGRvbid0IHdhbnQgdG8gdXNlIHRoaXMgaW4gYSBicm93c2VyIHVubGVzcyB5b3UncmUgdXNpbmdcclxuICogc2VydmVyLXNpZGUgcmVuZGVyaW5nIHdpdGggYXN5bmMgcm91dGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWF0Y2goX3JlZiwgY2FsbGJhY2spIHtcclxuICB2YXIgaGlzdG9yeSA9IF9yZWYuaGlzdG9yeSxcclxuICAgICAgcm91dGVzID0gX3JlZi5yb3V0ZXMsXHJcbiAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcclxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2hpc3RvcnknLCAncm91dGVzJywgJ2xvY2F0aW9uJ10pO1xyXG5cclxuICAhKGhpc3RvcnkgfHwgbG9jYXRpb24pID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ21hdGNoIG5lZWRzIGEgaGlzdG9yeSBvciBhIGxvY2F0aW9uJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xyXG5cclxuICBoaXN0b3J5ID0gaGlzdG9yeSA/IGhpc3RvcnkgOiAoMCwgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyLmRlZmF1bHQpKG9wdGlvbnMpO1xyXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKGhpc3RvcnksICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKHJvdXRlcykpO1xyXG5cclxuICBpZiAobG9jYXRpb24pIHtcclxuICAgIC8vIEFsbG93IG1hdGNoKHsgbG9jYXRpb246ICcvdGhlL3BhdGgnLCAuLi4gfSlcclxuICAgIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGxvY2F0aW9uID0gaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKTtcclxuICB9XHJcblxyXG4gIHRyYW5zaXRpb25NYW5hZ2VyLm1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xyXG4gICAgdmFyIHJlbmRlclByb3BzID0gdm9pZCAwO1xyXG5cclxuICAgIGlmIChuZXh0U3RhdGUpIHtcclxuICAgICAgdmFyIHJvdXRlciA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGVyT2JqZWN0KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlciwgbmV4dFN0YXRlKTtcclxuICAgICAgcmVuZGVyUHJvcHMgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7XHJcbiAgICAgICAgcm91dGVyOiByb3V0ZXIsXHJcbiAgICAgICAgbWF0Y2hDb250ZXh0OiB7IHRyYW5zaXRpb25NYW5hZ2VyOiB0cmFuc2l0aW9uTWFuYWdlciwgcm91dGVyOiByb3V0ZXIgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiAmJiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKHJlZGlyZWN0TG9jYXRpb24sIF9BY3Rpb25zLlJFUExBQ0UpLCByZW5kZXJQcm9wcyk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoUm91dGVzO1xyXG5cclxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XHJcblxyXG52YXIgX1Byb21pc2VVdGlscyA9IHJlcXVpcmUoJy4vUHJvbWlzZVV0aWxzJyk7XHJcblxyXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XHJcblxyXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcclxuXHJcbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcclxuXHJcbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIGdldENoaWxkUm91dGVzKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XHJcbiAgaWYgKHJvdXRlLmNoaWxkUm91dGVzKSB7XHJcbiAgICByZXR1cm4gW251bGwsIHJvdXRlLmNoaWxkUm91dGVzXTtcclxuICB9XHJcbiAgaWYgKCFyb3V0ZS5nZXRDaGlsZFJvdXRlcykge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgdmFyIHN5bmMgPSB0cnVlLFxyXG4gICAgICByZXN1bHQgPSB2b2lkIDA7XHJcblxyXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0ge1xyXG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxyXG4gICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXHJcbiAgfTtcclxuXHJcbiAgdmFyIGNoaWxkUm91dGVzUmV0dXJuID0gcm91dGUuZ2V0Q2hpbGRSb3V0ZXMocGFydGlhbE5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCBjaGlsZFJvdXRlcykge1xyXG4gICAgY2hpbGRSb3V0ZXMgPSAhZXJyb3IgJiYgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykoY2hpbGRSb3V0ZXMpO1xyXG4gICAgaWYgKHN5bmMpIHtcclxuICAgICAgcmVzdWx0ID0gW2Vycm9yLCBjaGlsZFJvdXRlc107XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjYWxsYmFjayhlcnJvciwgY2hpbGRSb3V0ZXMpO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoKDAsIF9Qcm9taXNlVXRpbHMuaXNQcm9taXNlKShjaGlsZFJvdXRlc1JldHVybikpIGNoaWxkUm91dGVzUmV0dXJuLnRoZW4oZnVuY3Rpb24gKGNoaWxkUm91dGVzKSB7XHJcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykoY2hpbGRSb3V0ZXMpKTtcclxuICB9LCBjYWxsYmFjayk7XHJcblxyXG4gIHN5bmMgPSBmYWxzZTtcclxuICByZXR1cm4gcmVzdWx0OyAvLyBNaWdodCBiZSB1bmRlZmluZWQuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEluZGV4Um91dGUocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgY2FsbGJhY2spIHtcclxuICBpZiAocm91dGUuaW5kZXhSb3V0ZSkge1xyXG4gICAgY2FsbGJhY2sobnVsbCwgcm91dGUuaW5kZXhSb3V0ZSk7XHJcbiAgfSBlbHNlIGlmIChyb3V0ZS5nZXRJbmRleFJvdXRlKSB7XHJcbiAgICB2YXIgcGFydGlhbE5leHRTdGF0ZSA9IHtcclxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxyXG4gICAgICBwYXJhbXM6IGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcylcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGluZGV4Um91dGVzUmV0dXJuID0gcm91dGUuZ2V0SW5kZXhSb3V0ZShwYXJ0aWFsTmV4dFN0YXRlLCBmdW5jdGlvbiAoZXJyb3IsIGluZGV4Um91dGUpIHtcclxuICAgICAgY2FsbGJhY2soZXJyb3IsICFlcnJvciAmJiAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShpbmRleFJvdXRlKVswXSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoKDAsIF9Qcm9taXNlVXRpbHMuaXNQcm9taXNlKShpbmRleFJvdXRlc1JldHVybikpIGluZGV4Um91dGVzUmV0dXJuLnRoZW4oZnVuY3Rpb24gKGluZGV4Um91dGUpIHtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKGluZGV4Um91dGUpWzBdKTtcclxuICAgIH0sIGNhbGxiYWNrKTtcclxuICB9IGVsc2UgaWYgKHJvdXRlLmNoaWxkUm91dGVzIHx8IHJvdXRlLmdldENoaWxkUm91dGVzKSB7XHJcbiAgICB2YXIgb25DaGlsZFJvdXRlcyA9IGZ1bmN0aW9uIG9uQ2hpbGRSb3V0ZXMoZXJyb3IsIGNoaWxkUm91dGVzKSB7XHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBwYXRobGVzcyA9IGNoaWxkUm91dGVzLmZpbHRlcihmdW5jdGlvbiAoY2hpbGRSb3V0ZSkge1xyXG4gICAgICAgIHJldHVybiAhY2hpbGRSb3V0ZS5wYXRoO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKHBhdGhsZXNzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XHJcbiAgICAgICAgZ2V0SW5kZXhSb3V0ZShwYXRobGVzc1tpbmRleF0sIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XHJcbiAgICAgICAgICBpZiAoZXJyb3IgfHwgaW5kZXhSb3V0ZSkge1xyXG4gICAgICAgICAgICB2YXIgcm91dGVzID0gW3BhdGhsZXNzW2luZGV4XV0uY29uY2F0KEFycmF5LmlzQXJyYXkoaW5kZXhSb3V0ZSkgPyBpbmRleFJvdXRlIDogW2luZGV4Um91dGVdKTtcclxuICAgICAgICAgICAgZG9uZShlcnJvciwgcm91dGVzKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5leHQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcm91dGVzKSB7XHJcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcm91dGVzKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciByZXN1bHQgPSBnZXRDaGlsZFJvdXRlcyhyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBvbkNoaWxkUm91dGVzKTtcclxuICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgb25DaGlsZFJvdXRlcy5hcHBseSh1bmRlZmluZWQsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGNhbGxiYWNrKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhc3NpZ25QYXJhbXMocGFyYW1zLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcykge1xyXG4gIHJldHVybiBwYXJhbU5hbWVzLnJlZHVjZShmdW5jdGlvbiAocGFyYW1zLCBwYXJhbU5hbWUsIGluZGV4KSB7XHJcbiAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtVmFsdWVzICYmIHBhcmFtVmFsdWVzW2luZGV4XTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXNbcGFyYW1OYW1lXSkpIHtcclxuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0ucHVzaChwYXJhbVZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lIGluIHBhcmFtcykge1xyXG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IFtwYXJhbXNbcGFyYW1OYW1lXSwgcGFyYW1WYWx1ZV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcmFtcztcclxuICB9LCBwYXJhbXMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpIHtcclxuICByZXR1cm4gYXNzaWduUGFyYW1zKHt9LCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hdGNoUm91dGVEZWVwKHJvdXRlLCBsb2NhdGlvbiwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBjYWxsYmFjaykge1xyXG4gIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcclxuXHJcbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApID09PSAnLycpIHtcclxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XHJcbiAgICBwYXJhbU5hbWVzID0gW107XHJcbiAgICBwYXJhbVZhbHVlcyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLy8gT25seSB0cnkgdG8gbWF0Y2ggdGhlIHBhdGggaWYgdGhlIHJvdXRlIGFjdHVhbGx5IGhhcyBhIHBhdHRlcm4sIGFuZCBpZlxyXG4gIC8vIHdlJ3JlIG5vdCBqdXN0IHNlYXJjaGluZyBmb3IgcG90ZW50aWFsIG5lc3RlZCBhYnNvbHV0ZSBwYXRocy5cclxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT09IG51bGwgJiYgcGF0dGVybikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdmFyIG1hdGNoZWQgPSAoMCwgX1BhdHRlcm5VdGlscy5tYXRjaFBhdHRlcm4pKHBhdHRlcm4sIHJlbWFpbmluZ1BhdGhuYW1lKTtcclxuICAgICAgaWYgKG1hdGNoZWQpIHtcclxuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWQucmVtYWluaW5nUGF0aG5hbWU7XHJcbiAgICAgICAgcGFyYW1OYW1lcyA9IFtdLmNvbmNhdChwYXJhbU5hbWVzLCBtYXRjaGVkLnBhcmFtTmFtZXMpO1xyXG4gICAgICAgIHBhcmFtVmFsdWVzID0gW10uY29uY2F0KHBhcmFtVmFsdWVzLCBtYXRjaGVkLnBhcmFtVmFsdWVzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCeSBhc3N1bXB0aW9uLCBwYXR0ZXJuIGlzIG5vbi1lbXB0eSBoZXJlLCB3aGljaCBpcyB0aGUgcHJlcmVxdWlzaXRlIGZvclxyXG4gICAgLy8gYWN0dWFsbHkgdGVybWluYXRpbmcgYSBtYXRjaC5cclxuICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gJycpIHtcclxuICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoID0ge1xyXG4gICAgICAgICAgcm91dGVzOiBbcm91dGVdLFxyXG4gICAgICAgICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZ2V0SW5kZXhSb3V0ZShyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBmdW5jdGlvbiAoZXJyb3IsIGluZGV4Um91dGUpIHtcclxuICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleFJvdXRlKSkge1xyXG4gICAgICAgICAgICAgIHZhciBfbWF0Y2gkcm91dGVzO1xyXG5cclxuICAgICAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShpbmRleFJvdXRlLmV2ZXJ5KGZ1bmN0aW9uIChyb3V0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFyb3V0ZS5wYXRoO1xyXG4gICAgICAgICAgICAgIH0pLCAnSW5kZXggcm91dGVzIHNob3VsZCBub3QgaGF2ZSBwYXRocycpIDogdm9pZCAwO1xyXG4gICAgICAgICAgICAgIChfbWF0Y2gkcm91dGVzID0gbWF0Y2gucm91dGVzKS5wdXNoLmFwcGx5KF9tYXRjaCRyb3V0ZXMsIGluZGV4Um91dGUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4Um91dGUpIHtcclxuICAgICAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSghaW5kZXhSb3V0ZS5wYXRoLCAnSW5kZXggcm91dGVzIHNob3VsZCBub3QgaGF2ZSBwYXRocycpIDogdm9pZCAwO1xyXG4gICAgICAgICAgICAgIG1hdGNoLnJvdXRlcy5wdXNoKGluZGV4Um91dGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtYXRjaCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB2OiB2b2lkIDBcclxuICAgICAgICB9O1xyXG4gICAgICB9KCk7XHJcblxyXG4gICAgICBpZiAoKHR5cGVvZiBfcmV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0KSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT0gbnVsbCB8fCByb3V0ZS5jaGlsZFJvdXRlcykge1xyXG4gICAgLy8gRWl0aGVyIGEpIHRoaXMgcm91dGUgbWF0Y2hlZCBhdCBsZWFzdCBzb21lIG9mIHRoZSBwYXRoIG9yIGIpXHJcbiAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIGxvYWQgdGhpcyByb3V0ZSdzIGNoaWxkcmVuIGFzeW5jaHJvbm91c2x5LiBJblxyXG4gICAgLy8gZWl0aGVyIGNhc2UgY29udGludWUgY2hlY2tpbmcgZm9yIG1hdGNoZXMgaW4gdGhlIHN1YnRyZWUuXHJcbiAgICB2YXIgb25DaGlsZFJvdXRlcyA9IGZ1bmN0aW9uIG9uQ2hpbGRSb3V0ZXMoZXJyb3IsIGNoaWxkUm91dGVzKSB7XHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgfSBlbHNlIGlmIChjaGlsZFJvdXRlcykge1xyXG4gICAgICAgIC8vIENoZWNrIHRoZSBjaGlsZCByb3V0ZXMgdG8gc2VlIGlmIGFueSBvZiB0aGVtIG1hdGNoLlxyXG4gICAgICAgIG1hdGNoUm91dGVzKGNoaWxkUm91dGVzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBtYXRjaCkge1xyXG4gICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgLy8gQSBjaGlsZCByb3V0ZSBtYXRjaGVkISBBdWdtZW50IHRoZSBtYXRjaCBhbmQgcGFzcyBpdCB1cCB0aGUgc3RhY2suXHJcbiAgICAgICAgICAgIG1hdGNoLnJvdXRlcy51bnNoaWZ0KHJvdXRlKTtcclxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWF0Y2gpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IGdldENoaWxkUm91dGVzKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIG9uQ2hpbGRSb3V0ZXMpO1xyXG4gICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICBvbkNoaWxkUm91dGVzLmFwcGx5KHVuZGVmaW5lZCwgcmVzdWx0KTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgY2FsbGJhY2soKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBc3luY2hyb25vdXNseSBtYXRjaGVzIHRoZSBnaXZlbiBsb2NhdGlvbiB0byBhIHNldCBvZiByb3V0ZXMgYW5kIGNhbGxzXHJcbiAqIGNhbGxiYWNrKGVycm9yLCBzdGF0ZSkgd2hlbiBmaW5pc2hlZC4gVGhlIHN0YXRlIG9iamVjdCB3aWxsIGhhdmUgdGhlXHJcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKlxyXG4gKiAtIHJvdXRlcyAgICAgICBBbiBhcnJheSBvZiByb3V0ZXMgdGhhdCBtYXRjaGVkLCBpbiBoaWVyYXJjaGljYWwgb3JkZXJcclxuICogLSBwYXJhbXMgICAgICAgQW4gb2JqZWN0IG9mIFVSTCBwYXJhbWV0ZXJzXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgb3BlcmF0aW9uIG1heSBmaW5pc2ggc3luY2hyb25vdXNseSBpZiBubyByb3V0ZXMgaGF2ZSBhblxyXG4gKiBhc3luY2hyb25vdXMgZ2V0Q2hpbGRSb3V0ZXMgbWV0aG9kLlxyXG4gKi9cclxuZnVuY3Rpb24gbWF0Y2hSb3V0ZXMocm91dGVzLCBsb2NhdGlvbiwgY2FsbGJhY2ssIHJlbWFpbmluZ1BhdGhuYW1lKSB7XHJcbiAgdmFyIHBhcmFtTmFtZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFtdO1xyXG4gIHZhciBwYXJhbVZhbHVlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogW107XHJcblxyXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGEgbGl0dGxlIGJpdCB1Z2x5LCBidXQgaXQgd29ya3MgYXJvdW5kIGEgcXVpcmsgaW4gaGlzdG9yeVxyXG4gICAgLy8gdGhhdCBzdHJpcHMgdGhlIGxlYWRpbmcgc2xhc2ggZnJvbSBwYXRobmFtZXMgd2hlbiB1c2luZyBiYXNlbmFtZXMgd2l0aFxyXG4gICAgLy8gdHJhaWxpbmcgc2xhc2hlcy5cclxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xyXG4gICAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xyXG4gICAgICAgIHBhdGhuYW1lOiAnLycgKyBsb2NhdGlvbi5wYXRobmFtZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XHJcbiAgfVxyXG5cclxuICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShyb3V0ZXMubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcclxuICAgIG1hdGNoUm91dGVEZWVwKHJvdXRlc1tpbmRleF0sIGxvY2F0aW9uLCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgbWF0Y2gpIHtcclxuICAgICAgaWYgKGVycm9yIHx8IG1hdGNoKSB7XHJcbiAgICAgICAgZG9uZShlcnJvciwgbWF0Y2gpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5leHQoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSwgY2FsbGJhY2spO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHJvdXRlcldhcm5pbmc7XHJcbmV4cG9ydHMuX3Jlc2V0V2FybmVkID0gX3Jlc2V0V2FybmVkO1xyXG5cclxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xyXG5cclxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbnZhciB3YXJuZWQgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIHJvdXRlcldhcm5pbmcoZmFsc2VUb1dhcm4sIG1lc3NhZ2UpIHtcclxuICAvLyBPbmx5IGlzc3VlIGRlcHJlY2F0aW9uIHdhcm5pbmdzIG9uY2UuXHJcbiAgaWYgKG1lc3NhZ2UuaW5kZXhPZignZGVwcmVjYXRlZCcpICE9PSAtMSkge1xyXG4gICAgaWYgKHdhcm5lZFttZXNzYWdlXSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgd2FybmVkW21lc3NhZ2VdID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIG1lc3NhZ2UgPSAnW3JlYWN0LXJvdXRlcl0gJyArIG1lc3NhZ2U7XHJcblxyXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgfVxyXG5cclxuICBfd2FybmluZzIuZGVmYXVsdC5hcHBseSh1bmRlZmluZWQsIFtmYWxzZVRvV2FybiwgbWVzc2FnZV0uY29uY2F0KGFyZ3MpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX3Jlc2V0V2FybmVkKCkge1xyXG4gIHdhcm5lZCA9IHt9O1xyXG59IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gdXNlUm91dGVySGlzdG9yeTtcclxuXHJcbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcclxuXHJcbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcclxuXHJcbnZhciBfdXNlQmFzZW5hbWUgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VCYXNlbmFtZScpO1xyXG5cclxudmFyIF91c2VCYXNlbmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VCYXNlbmFtZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gdXNlUm91dGVySGlzdG9yeShjcmVhdGVIaXN0b3J5KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoKDAsIF91c2VCYXNlbmFtZTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkpKG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIGhpc3Rvcnk7XHJcbiAgfTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHdpdGhSb3V0ZXI7XHJcblxyXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xyXG5cclxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcclxuXHJcbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG5cclxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XHJcblxyXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzID0gcmVxdWlyZSgnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnKTtcclxuXHJcbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaG9pc3ROb25SZWFjdFN0YXRpY3MpO1xyXG5cclxudmFyIF9Db250ZXh0VXRpbHMgPSByZXF1aXJlKCcuL0NvbnRleHRVdGlscycpO1xyXG5cclxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcclxuICByZXR1cm4gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdpdGhSb3V0ZXIoV3JhcHBlZENvbXBvbmVudCwgb3B0aW9ucykge1xyXG4gIHZhciB3aXRoUmVmID0gb3B0aW9ucyAmJiBvcHRpb25zLndpdGhSZWY7XHJcblxyXG4gIHZhciBXaXRoUm91dGVyID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcclxuICAgIGRpc3BsYXlOYW1lOiAnV2l0aFJvdXRlcicsXHJcblxyXG4gICAgbWl4aW5zOiBbKDAsIF9Db250ZXh0VXRpbHMuQ29udGV4dFN1YnNjcmliZXIpKCdyb3V0ZXInKV0sXHJcblxyXG4gICAgY29udGV4dFR5cGVzOiB7IHJvdXRlcjogX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZSB9LFxyXG4gICAgcHJvcFR5cGVzOiB7IHJvdXRlcjogX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZSB9LFxyXG5cclxuICAgIGdldFdyYXBwZWRJbnN0YW5jZTogZnVuY3Rpb24gZ2V0V3JhcHBlZEluc3RhbmNlKCkge1xyXG4gICAgICAhd2l0aFJlZiA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUbyBhY2Nlc3MgdGhlIHdyYXBwZWQgaW5zdGFuY2UsIHlvdSBuZWVkIHRvIHNwZWNpZnkgJyArICdgeyB3aXRoUmVmOiB0cnVlIH1gIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgdGhlIHdpdGhSb3V0ZXIoKSBjYWxsLicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWRJbnN0YW5jZTtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnByb3BzLnJvdXRlciB8fCB0aGlzLmNvbnRleHQucm91dGVyO1xyXG4gICAgICBpZiAoIXJvdXRlcikge1xyXG4gICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCB0aGlzLnByb3BzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHBhcmFtcyA9IHJvdXRlci5wYXJhbXMsXHJcbiAgICAgICAgICBsb2NhdGlvbiA9IHJvdXRlci5sb2NhdGlvbixcclxuICAgICAgICAgIHJvdXRlcyA9IHJvdXRlci5yb3V0ZXM7XHJcblxyXG4gICAgICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyByb3V0ZXI6IHJvdXRlciwgcGFyYW1zOiBwYXJhbXMsIGxvY2F0aW9uOiBsb2NhdGlvbiwgcm91dGVzOiByb3V0ZXMgfSk7XHJcblxyXG4gICAgICBpZiAod2l0aFJlZikge1xyXG4gICAgICAgIHByb3BzLnJlZiA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICBfdGhpcy53cmFwcGVkSW5zdGFuY2UgPSBjO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBwcm9wcyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIFdpdGhSb3V0ZXIuZGlzcGxheU5hbWUgPSAnd2l0aFJvdXRlcignICsgZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkgKyAnKSc7XHJcbiAgV2l0aFJvdXRlci5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcclxuXHJcbiAgcmV0dXJuICgwLCBfaG9pc3ROb25SZWFjdFN0YXRpY3MyLmRlZmF1bHQpKFdpdGhSb3V0ZXIsIFdyYXBwZWRDb21wb25lbnQpO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbi8qKlxyXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgYSBjYWxsIHRvIGhpc3RvcnkucHVzaC5cclxuICovXHJcbnZhciBQVVNIID0gZXhwb3J0cy5QVVNIID0gJ1BVU0gnO1xyXG5cclxuLyoqXHJcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5yZXBsYWNlLlxyXG4gKi9cclxudmFyIFJFUExBQ0UgPSBleHBvcnRzLlJFUExBQ0UgPSAnUkVQTEFDRSc7XHJcblxyXG4vKipcclxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IHNvbWUgb3RoZXIgYWN0aW9uIHN1Y2hcclxuICogYXMgdXNpbmcgYSBicm93c2VyJ3MgYmFjay9mb3J3YXJkIGJ1dHRvbnMgYW5kL29yIG1hbnVhbGx5IG1hbmlwdWxhdGluZ1xyXG4gKiB0aGUgVVJMIGluIGEgYnJvd3NlcidzIGxvY2F0aW9uIGJhci4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dFdmVudEhhbmRsZXJzL29ucG9wc3RhdGVcclxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG52YXIgUE9QID0gZXhwb3J0cy5QT1AgPSAnUE9QJzsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBsb29wQXN5bmMgPSBleHBvcnRzLmxvb3BBc3luYyA9IGZ1bmN0aW9uIGxvb3BBc3luYyh0dXJucywgd29yaywgY2FsbGJhY2spIHtcclxuICB2YXIgY3VycmVudFR1cm4gPSAwLFxyXG4gICAgICBpc0RvbmUgPSBmYWxzZTtcclxuICB2YXIgaXNTeW5jID0gZmFsc2UsXHJcbiAgICAgIGhhc05leHQgPSBmYWxzZSxcclxuICAgICAgZG9uZUFyZ3MgPSB2b2lkIDA7XHJcblxyXG4gIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcclxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgaXNEb25lID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoaXNTeW5jKSB7XHJcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXHJcbiAgICAgIGRvbmVBcmdzID0gYXJncztcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgaWYgKGlzRG9uZSkgcmV0dXJuO1xyXG5cclxuICAgIGhhc05leHQgPSB0cnVlO1xyXG5cclxuICAgIGlmIChpc1N5bmMpIHJldHVybjsgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cclxuXHJcbiAgICBpc1N5bmMgPSB0cnVlO1xyXG5cclxuICAgIHdoaWxlICghaXNEb25lICYmIGN1cnJlbnRUdXJuIDwgdHVybnMgJiYgaGFzTmV4dCkge1xyXG4gICAgICBoYXNOZXh0ID0gZmFsc2U7XHJcbiAgICAgIHdvcmsoY3VycmVudFR1cm4rKywgbmV4dCwgZG9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNTeW5jID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKGlzRG9uZSkge1xyXG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsb29wIGZpbmlzaGVkIHN5bmNocm9ub3VzbHkuXHJcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgZG9uZUFyZ3MpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGN1cnJlbnRUdXJuID49IHR1cm5zICYmIGhhc05leHQpIHtcclxuICAgICAgaXNEb25lID0gdHJ1ZTtcclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBuZXh0KCk7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0cy5nbyA9IGV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBleHBvcnRzLnN0YXJ0TGlzdGVuZXIgPSBleHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSBleHBvcnRzLmdldEN1cnJlbnRMb2NhdGlvbiA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xyXG5cclxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcclxuXHJcbnZhciBfRE9NU3RhdGVTdG9yYWdlID0gcmVxdWlyZSgnLi9ET01TdGF0ZVN0b3JhZ2UnKTtcclxuXHJcbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcclxuXHJcbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcblxyXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XHJcbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XHJcblxyXG52YXIgbmVlZHNIYXNoY2hhbmdlTGlzdGVuZXIgPSBfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICEoMCwgX0RPTVV0aWxzLnN1cHBvcnRzUG9wc3RhdGVPbkhhc2hjaGFuZ2UpKCk7XHJcblxyXG52YXIgX2NyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gX2NyZWF0ZUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xyXG4gIHZhciBrZXkgPSBoaXN0b3J5U3RhdGUgJiYgaGlzdG9yeVN0YXRlLmtleTtcclxuXHJcbiAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoe1xyXG4gICAgcGF0aG5hbWU6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxcclxuICAgIHNlYXJjaDogd2luZG93LmxvY2F0aW9uLnNlYXJjaCxcclxuICAgIGhhc2g6IHdpbmRvdy5sb2NhdGlvbi5oYXNoLFxyXG4gICAgc3RhdGU6IGtleSA/ICgwLCBfRE9NU3RhdGVTdG9yYWdlLnJlYWRTdGF0ZSkoa2V5KSA6IHVuZGVmaW5lZFxyXG4gIH0sIHVuZGVmaW5lZCwga2V5KTtcclxufTtcclxuXHJcbnZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBleHBvcnRzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcclxuICB2YXIgaGlzdG9yeVN0YXRlID0gdm9pZCAwO1xyXG4gIHRyeSB7XHJcbiAgICBoaXN0b3J5U3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxyXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL2hpc3RvcnkvcHVsbC8yODlcclxuICAgIGhpc3RvcnlTdGF0ZSA9IHt9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIF9jcmVhdGVMb2NhdGlvbihoaXN0b3J5U3RhdGUpO1xyXG59O1xyXG5cclxudmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBleHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XHJcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcclxufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxyXG5cclxudmFyIHN0YXJ0TGlzdGVuZXIgPSBleHBvcnRzLnN0YXJ0TGlzdGVuZXIgPSBmdW5jdGlvbiBzdGFydExpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5zdGF0ZSAhPT0gdW5kZWZpbmVkKSAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0XHJcbiAgICAgIGxpc3RlbmVyKF9jcmVhdGVMb2NhdGlvbihldmVudC5zdGF0ZSkpO1xyXG4gIH07XHJcblxyXG4gICgwLCBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XHJcblxyXG4gIHZhciBoYW5kbGVVbnBvcHBlZEhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVVbnBvcHBlZEhhc2hDaGFuZ2UoKSB7XHJcbiAgICByZXR1cm4gbGlzdGVuZXIoZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xyXG4gIH07XHJcblxyXG4gIGlmIChuZWVkc0hhc2hjaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlVW5wb3BwZWRIYXNoQ2hhbmdlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xyXG5cclxuICAgIGlmIChuZWVkc0hhc2hjaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgICAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVVbnBvcHBlZEhhc2hDaGFuZ2UpO1xyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcblxyXG52YXIgdXBkYXRlTG9jYXRpb24gPSBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdXBkYXRlU3RhdGUpIHtcclxuICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcclxuICB2YXIga2V5ID0gbG9jYXRpb24ua2V5O1xyXG5cclxuXHJcbiAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpICgwLCBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZSkoa2V5LCBzdGF0ZSk7XHJcblxyXG4gIHVwZGF0ZVN0YXRlKHsga2V5OiBrZXkgfSwgKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcclxufTtcclxuXHJcbnZhciBwdXNoTG9jYXRpb24gPSBleHBvcnRzLnB1c2hMb2NhdGlvbiA9IGZ1bmN0aW9uIHB1c2hMb2NhdGlvbihsb2NhdGlvbikge1xyXG4gIHJldHVybiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgZnVuY3Rpb24gKHN0YXRlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCBudWxsLCBwYXRoKTtcclxuICB9KTtcclxufTtcclxuXHJcbnZhciByZXBsYWNlTG9jYXRpb24gPSBleHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIHJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbikge1xyXG4gIHJldHVybiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgZnVuY3Rpb24gKHN0YXRlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCBudWxsLCBwYXRoKTtcclxuICB9KTtcclxufTtcclxuXHJcbnZhciBnbyA9IGV4cG9ydHMuZ28gPSBmdW5jdGlvbiBnbyhuKSB7XHJcbiAgaWYgKG4pIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHMucmVhZFN0YXRlID0gZXhwb3J0cy5zYXZlU3RhdGUgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XHJcblxyXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxudmFyIFF1b3RhRXhjZWVkZWRFcnJvcnMgPSB7XHJcbiAgUXVvdGFFeGNlZWRlZEVycm9yOiB0cnVlLFxyXG4gIFFVT1RBX0VYQ0VFREVEX0VSUjogdHJ1ZVxyXG59O1xyXG5cclxudmFyIFNlY3VyaXR5RXJyb3JzID0ge1xyXG4gIFNlY3VyaXR5RXJyb3I6IHRydWVcclxufTtcclxuXHJcbnZhciBLZXlQcmVmaXggPSAnQEBIaXN0b3J5Lyc7XHJcblxyXG52YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KGtleSkge1xyXG4gIHJldHVybiBLZXlQcmVmaXggKyBrZXk7XHJcbn07XHJcblxyXG52YXIgc2F2ZVN0YXRlID0gZXhwb3J0cy5zYXZlU3RhdGUgPSBmdW5jdGlvbiBzYXZlU3RhdGUoa2V5LCBzdGF0ZSkge1xyXG4gIGlmICghd2luZG93LnNlc3Npb25TdG9yYWdlKSB7XHJcbiAgICAvLyBTZXNzaW9uIHN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBvciBoaWRkZW4uXHJcbiAgICAvLyBzZXNzaW9uU3RvcmFnZSBpcyB1bmRlZmluZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgd2hlbiBzZXJ2ZWQgdmlhIGZpbGUgcHJvdG9jb2wuXHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gc2F2ZSBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZScpIDogdm9pZCAwO1xyXG5cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBpZiAoc3RhdGUgPT0gbnVsbCkge1xyXG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShjcmVhdGVLZXkoa2V5KSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShjcmVhdGVLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgaWYgKFNlY3VyaXR5RXJyb3JzW2Vycm9yLm5hbWVdKSB7XHJcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxyXG4gICAgICAvLyBhdHRlbXB0IHRvIGFjY2VzcyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuXHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdm9pZCAwO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChRdW90YUV4Y2VlZGVkRXJyb3JzW2Vycm9yLm5hbWVdICYmIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgLy8gU2FmYXJpIFwicHJpdmF0ZSBtb2RlXCIgdGhyb3dzIFF1b3RhRXhjZWVkZWRFcnJvci5cclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgaW4gU2FmYXJpIHByaXZhdGUgbW9kZScpIDogdm9pZCAwO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciByZWFkU3RhdGUgPSBleHBvcnRzLnJlYWRTdGF0ZSA9IGZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcclxuICB2YXIganNvbiA9IHZvaWQgMDtcclxuICB0cnkge1xyXG4gICAganNvbiA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGNyZWF0ZUtleShrZXkpKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgaWYgKFNlY3VyaXR5RXJyb3JzW2Vycm9yLm5hbWVdKSB7XHJcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxyXG4gICAgICAvLyBhdHRlbXB0IHRvIGFjY2VzcyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuXHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byByZWFkIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdm9pZCAwO1xyXG5cclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChqc29uKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIC8vIElnbm9yZSBpbnZhbGlkIEpTT04uXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdW5kZWZpbmVkO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBhZGRFdmVudExpc3RlbmVyID0gZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcclxuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcclxufTtcclxuXHJcbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcclxuICByZXR1cm4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID8gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXHJcbiAqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcclxuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxyXG4gKi9cclxudmFyIHN1cHBvcnRzSGlzdG9yeSA9IGV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xyXG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xyXG5cclxuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cclxuICovXHJcbnZhciBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGV4cG9ydHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBmdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcclxuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgYnJvd3NlciBmaXJlcyBwb3BzdGF0ZSBvbiBoYXNoIGNoYW5nZS5cclxuICogSUUxMCBhbmQgSUUxMSBkbyBub3QuXHJcbiAqL1xyXG52YXIgc3VwcG9ydHNQb3BzdGF0ZU9uSGFzaGNoYW5nZSA9IGV4cG9ydHMuc3VwcG9ydHNQb3BzdGF0ZU9uSGFzaGNoYW5nZSA9IGZ1bmN0aW9uIHN1cHBvcnRzUG9wc3RhdGVPbkhhc2hjaGFuZ2UoKSB7XHJcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIGNhblVzZURPTSA9IGV4cG9ydHMuY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5leHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZXhwb3J0cy5zdGFydExpc3RlbmVyID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSBleHBvcnRzLmdvID0gZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9Ccm93c2VyUHJvdG9jb2wgPSByZXF1aXJlKCcuL0Jyb3dzZXJQcm90b2NvbCcpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnZXRVc2VyQ29uZmlybWF0aW9uJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICByZXR1cm4gX0Jyb3dzZXJQcm90b2NvbC5nZXRVc2VyQ29uZmlybWF0aW9uO1xyXG4gIH1cclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ28nLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfQnJvd3NlclByb3RvY29sLmdvO1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XHJcblxyXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XHJcblxyXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcclxuXHJcbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XHJcblxyXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XHJcblxyXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcclxuXHJcbnZhciBnZXRIYXNoUGF0aCA9IGZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xyXG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcclxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxyXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XHJcbiAgdmFyIGhhc2hJbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xyXG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcclxufTtcclxuXHJcbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xyXG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XHJcbn07XHJcblxyXG52YXIgcmVwbGFjZUhhc2hQYXRoID0gZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcclxuICB2YXIgaGFzaEluZGV4ID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignIycpO1xyXG5cclxuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaHJlZi5zbGljZSgwLCBoYXNoSW5kZXggPj0gMCA/IGhhc2hJbmRleCA6IDApICsgJyMnICsgcGF0aCk7XHJcbn07XHJcblxyXG52YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24ocGF0aENvZGVyLCBxdWVyeUtleSkge1xyXG4gIHZhciBwYXRoID0gcGF0aENvZGVyLmRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XHJcbiAgdmFyIGtleSA9ICgwLCBfUGF0aFV0aWxzLmdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCkocGF0aCwgcXVlcnlLZXkpO1xyXG5cclxuICB2YXIgc3RhdGUgPSB2b2lkIDA7XHJcbiAgaWYgKGtleSkge1xyXG4gICAgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLnN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKShwYXRoLCBxdWVyeUtleSk7XHJcbiAgICBzdGF0ZSA9ICgwLCBfRE9NU3RhdGVTdG9yYWdlLnJlYWRTdGF0ZSkoa2V5KTtcclxuICB9XHJcblxyXG4gIHZhciBpbml0ID0gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShwYXRoKTtcclxuICBpbml0LnN0YXRlID0gc3RhdGU7XHJcblxyXG4gIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGluaXQsIHVuZGVmaW5lZCwga2V5KTtcclxufTtcclxuXHJcbnZhciBwcmV2TG9jYXRpb24gPSB2b2lkIDA7XHJcblxyXG52YXIgc3RhcnRMaXN0ZW5lciA9IGV4cG9ydHMuc3RhcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIHBhdGhDb2RlciwgcXVlcnlLZXkpIHtcclxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XHJcbiAgICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XHJcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBwYXRoQ29kZXIuZW5jb2RlUGF0aChwYXRoKTtcclxuXHJcbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcclxuICAgICAgLy8gQWx3YXlzIGJlIHN1cmUgd2UgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cclxuICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRDdXJyZW50TG9jYXRpb24ocGF0aENvZGVyLCBxdWVyeUtleSk7XHJcblxyXG4gICAgICBpZiAocHJldkxvY2F0aW9uICYmIGN1cnJlbnRMb2NhdGlvbi5rZXkgJiYgcHJldkxvY2F0aW9uLmtleSA9PT0gY3VycmVudExvY2F0aW9uLmtleSkgcmV0dXJuOyAvLyBJZ25vcmUgZXh0cmFuZW91cyBoYXNoY2hhbmdlIGV2ZW50c1xyXG5cclxuICAgICAgcHJldkxvY2F0aW9uID0gY3VycmVudExvY2F0aW9uO1xyXG5cclxuICAgICAgbGlzdGVuZXIoY3VycmVudExvY2F0aW9uKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBFbnN1cmUgdGhlIGhhc2ggaXMgZW5jb2RlZCBwcm9wZXJseS5cclxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XHJcbiAgdmFyIGVuY29kZWRQYXRoID0gcGF0aENvZGVyLmVuY29kZVBhdGgocGF0aCk7XHJcblxyXG4gIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcclxuXHJcbiAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XHJcbiAgfTtcclxufTtcclxuXHJcbnZhciB1cGRhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBwYXRoQ29kZXIsIHF1ZXJ5S2V5LCB1cGRhdGVIYXNoKSB7XHJcbiAgdmFyIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XHJcbiAgdmFyIGtleSA9IGxvY2F0aW9uLmtleTtcclxuXHJcblxyXG4gIHZhciBwYXRoID0gcGF0aENvZGVyLmVuY29kZVBhdGgoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcclxuXHJcbiAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHBhdGggPSAoMCwgX1BhdGhVdGlscy5hZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKShwYXRoLCBxdWVyeUtleSwga2V5KTtcclxuICAgICgwLCBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZSkoa2V5LCBzdGF0ZSk7XHJcbiAgfVxyXG5cclxuICBwcmV2TG9jYXRpb24gPSBsb2NhdGlvbjtcclxuXHJcbiAgdXBkYXRlSGFzaChwYXRoKTtcclxufTtcclxuXHJcbnZhciBwdXNoTG9jYXRpb24gPSBleHBvcnRzLnB1c2hMb2NhdGlvbiA9IGZ1bmN0aW9uIHB1c2hMb2NhdGlvbihsb2NhdGlvbiwgcGF0aENvZGVyLCBxdWVyeUtleSkge1xyXG4gIHJldHVybiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgcGF0aENvZGVyLCBxdWVyeUtleSwgZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgIGlmIChnZXRIYXNoUGF0aCgpICE9PSBwYXRoKSB7XHJcbiAgICAgIHB1c2hIYXNoUGF0aChwYXRoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnWW91IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGggdXNpbmcgaGFzaCBoaXN0b3J5JykgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG52YXIgcmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5yZXBsYWNlTG9jYXRpb24gPSBmdW5jdGlvbiByZXBsYWNlTG9jYXRpb24obG9jYXRpb24sIHBhdGhDb2RlciwgcXVlcnlLZXkpIHtcclxuICByZXR1cm4gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIHBhdGhDb2RlciwgcXVlcnlLZXksIGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICBpZiAoZ2V0SGFzaFBhdGgoKSAhPT0gcGF0aCkgcmVwbGFjZUhhc2hQYXRoKHBhdGgpO1xyXG4gIH0pO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLnN0YXRlc0FyZUVxdWFsID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IGV4cG9ydHMuY3JlYXRlUXVlcnkgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xyXG5cclxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcclxuXHJcbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcclxuXHJcbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcclxuXHJcbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcclxuXHJcbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbnZhciBjcmVhdGVRdWVyeSA9IGV4cG9ydHMuY3JlYXRlUXVlcnkgPSBmdW5jdGlvbiBjcmVhdGVRdWVyeShwcm9wcykge1xyXG4gIHJldHVybiBfZXh0ZW5kcyhPYmplY3QuY3JlYXRlKG51bGwpLCBwcm9wcyk7XHJcbn07XHJcblxyXG52YXIgY3JlYXRlTG9jYXRpb24gPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oKSB7XHJcbiAgdmFyIGlucHV0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJy8nIDogYXJndW1lbnRzWzBdO1xyXG4gIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfQWN0aW9ucy5QT1AgOiBhcmd1bWVudHNbMV07XHJcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMl07XHJcblxyXG4gIHZhciBvYmplY3QgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShpbnB1dCkgOiBpbnB1dDtcclxuXHJcbiAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoIW9iamVjdC5wYXRoLCAnTG9jYXRpb24gZGVzY3JpcHRvciBvYmplY3RzIHNob3VsZCBoYXZlIGEgYHBhdGhuYW1lYCwgbm90IGEgYHBhdGhgLicpIDogdm9pZCAwO1xyXG5cclxuICB2YXIgcGF0aG5hbWUgPSBvYmplY3QucGF0aG5hbWUgfHwgJy8nO1xyXG4gIHZhciBzZWFyY2ggPSBvYmplY3Quc2VhcmNoIHx8ICcnO1xyXG4gIHZhciBoYXNoID0gb2JqZWN0Lmhhc2ggfHwgJyc7XHJcbiAgdmFyIHN0YXRlID0gb2JqZWN0LnN0YXRlO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxyXG4gICAgc2VhcmNoOiBzZWFyY2gsXHJcbiAgICBoYXNoOiBoYXNoLFxyXG4gICAgc3RhdGU6IHN0YXRlLFxyXG4gICAgYWN0aW9uOiBhY3Rpb24sXHJcbiAgICBrZXk6IGtleVxyXG4gIH07XHJcbn07XHJcblxyXG52YXIgaXNEYXRlID0gZnVuY3Rpb24gaXNEYXRlKG9iamVjdCkge1xyXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xyXG59O1xyXG5cclxudmFyIHN0YXRlc0FyZUVxdWFsID0gZXhwb3J0cy5zdGF0ZXNBcmVFcXVhbCA9IGZ1bmN0aW9uIHN0YXRlc0FyZUVxdWFsKGEsIGIpIHtcclxuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XHJcblxyXG4gIHZhciB0eXBlb2ZBID0gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpO1xyXG4gIHZhciB0eXBlb2ZCID0gdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGIpO1xyXG5cclxuICBpZiAodHlwZW9mQSAhPT0gdHlwZW9mQikgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAhKHR5cGVvZkEgIT09ICdmdW5jdGlvbicpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1lvdSBtdXN0IG5vdCBzdG9yZSBmdW5jdGlvbnMgaW4gbG9jYXRpb24gc3RhdGUnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XHJcblxyXG4gIC8vIE5vdCB0aGUgc2FtZSBvYmplY3QsIGJ1dCBzYW1lIHR5cGUuXHJcbiAgaWYgKHR5cGVvZkEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAhIShpc0RhdGUoYSkgJiYgaXNEYXRlKGIpKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdZb3UgbXVzdCBub3Qgc3RvcmUgRGF0ZSBvYmplY3RzIGluIGxvY2F0aW9uIHN0YXRlJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShhKSkge1xyXG4gICAgICB2YXIga2V5c29mQSA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgICB2YXIga2V5c29mQiA9IE9iamVjdC5rZXlzKGIpO1xyXG4gICAgICByZXR1cm4ga2V5c29mQS5sZW5ndGggPT09IGtleXNvZkIubGVuZ3RoICYmIGtleXNvZkEuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiBzdGF0ZXNBcmVFcXVhbChhW2tleV0sIGJba2V5XSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xyXG4gICAgICByZXR1cm4gc3RhdGVzQXJlRXF1YWwoaXRlbSwgYltpbmRleF0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBBbGwgb3RoZXIgc2VyaWFsaXphYmxlIHR5cGVzIChzdHJpbmcsIG51bWJlciwgYm9vbGVhbilcclxuICAvLyBzaG91bGQgYmUgc3RyaWN0IGVxdWFsLlxyXG4gIHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbnZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XHJcbiAgcmV0dXJuIGEua2V5ID09PSBiLmtleSAmJlxyXG4gIC8vIGEuYWN0aW9uID09PSBiLmFjdGlvbiAmJiAvLyBEaWZmZXJlbnQgYWN0aW9uICE9PSBsb2NhdGlvbiBjaGFuZ2UuXHJcbiAgYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgc3RhdGVzQXJlRXF1YWwoYS5zdGF0ZSwgYi5zdGF0ZSk7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuZXhwb3J0cy5jcmVhdGVQYXRoID0gZXhwb3J0cy5wYXJzZVBhdGggPSBleHBvcnRzLmdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCA9IGV4cG9ydHMuc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGggPSBleHBvcnRzLmFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGggPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XHJcblxyXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxudmFyIGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGggPSBleHBvcnRzLmFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGggPSBmdW5jdGlvbiBhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKHBhdGgsIGtleSwgdmFsdWUpIHtcclxuICB2YXIgX3BhcnNlUGF0aCA9IHBhcnNlUGF0aChwYXRoKTtcclxuXHJcbiAgdmFyIHBhdGhuYW1lID0gX3BhcnNlUGF0aC5wYXRobmFtZTtcclxuICB2YXIgc2VhcmNoID0gX3BhcnNlUGF0aC5zZWFyY2g7XHJcbiAgdmFyIGhhc2ggPSBfcGFyc2VQYXRoLmhhc2g7XHJcblxyXG5cclxuICByZXR1cm4gY3JlYXRlUGF0aCh7XHJcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXHJcbiAgICBzZWFyY2g6IHNlYXJjaCArIChzZWFyY2guaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBrZXkgKyAnPScgKyB2YWx1ZSxcclxuICAgIGhhc2g6IGhhc2hcclxuICB9KTtcclxufTtcclxuXHJcbnZhciBzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCA9IGV4cG9ydHMuc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGggPSBmdW5jdGlvbiBzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBrZXkpIHtcclxuICB2YXIgX3BhcnNlUGF0aDIgPSBwYXJzZVBhdGgocGF0aCk7XHJcblxyXG4gIHZhciBwYXRobmFtZSA9IF9wYXJzZVBhdGgyLnBhdGhuYW1lO1xyXG4gIHZhciBzZWFyY2ggPSBfcGFyc2VQYXRoMi5zZWFyY2g7XHJcbiAgdmFyIGhhc2ggPSBfcGFyc2VQYXRoMi5oYXNoO1xyXG5cclxuXHJcbiAgcmV0dXJuIGNyZWF0ZVBhdGgoe1xyXG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxyXG4gICAgc2VhcmNoOiBzZWFyY2gucmVwbGFjZShuZXcgUmVnRXhwKCcoWz8mXSknICsga2V5ICsgJz1bYS16QS1aMC05XSsoJj8pJyksIGZ1bmN0aW9uIChtYXRjaCwgcHJlZml4LCBzdWZmaXgpIHtcclxuICAgICAgcmV0dXJuIHByZWZpeCA9PT0gJz8nID8gcHJlZml4IDogc3VmZml4O1xyXG4gICAgfSksXHJcbiAgICBoYXNoOiBoYXNoXHJcbiAgfSk7XHJcbn07XHJcblxyXG52YXIgZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZXhwb3J0cy5nZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGggPSBmdW5jdGlvbiBnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwga2V5KSB7XHJcbiAgdmFyIF9wYXJzZVBhdGgzID0gcGFyc2VQYXRoKHBhdGgpO1xyXG5cclxuICB2YXIgc2VhcmNoID0gX3BhcnNlUGF0aDMuc2VhcmNoO1xyXG5cclxuICB2YXIgbWF0Y2ggPSBzZWFyY2gubWF0Y2gobmV3IFJlZ0V4cCgnWz8mXScgKyBrZXkgKyAnPShbYS16QS1aMC05XSspJykpO1xyXG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcclxufTtcclxuXHJcbnZhciBleHRyYWN0UGF0aCA9IGZ1bmN0aW9uIGV4dHJhY3RQYXRoKHN0cmluZykge1xyXG4gIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXihodHRwcz86KT9cXC9cXC9bXlxcL10qLyk7XHJcbiAgcmV0dXJuIG1hdGNoID09IG51bGwgPyBzdHJpbmcgOiBzdHJpbmcuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XHJcbn07XHJcblxyXG52YXIgcGFyc2VQYXRoID0gZXhwb3J0cy5wYXJzZVBhdGggPSBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xyXG4gIHZhciBwYXRobmFtZSA9IGV4dHJhY3RQYXRoKHBhdGgpO1xyXG4gIHZhciBzZWFyY2ggPSAnJztcclxuICB2YXIgaGFzaCA9ICcnO1xyXG5cclxuICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShwYXRoID09PSBwYXRobmFtZSwgJ0EgcGF0aCBtdXN0IGJlIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaCBvbmx5LCBub3QgYSBmdWxsIFVSTCBsaWtlIFwiJXNcIicsIHBhdGgpIDogdm9pZCAwO1xyXG5cclxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xyXG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XHJcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyaW5nKGhhc2hJbmRleCk7XHJcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBoYXNoSW5kZXgpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xyXG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcclxuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cmluZyhzZWFyY2hJbmRleCk7XHJcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBzZWFyY2hJbmRleCk7XHJcbiAgfVxyXG5cclxuICBpZiAocGF0aG5hbWUgPT09ICcnKSBwYXRobmFtZSA9ICcvJztcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcclxuICAgIHNlYXJjaDogc2VhcmNoLFxyXG4gICAgaGFzaDogaGFzaFxyXG4gIH07XHJcbn07XHJcblxyXG52YXIgY3JlYXRlUGF0aCA9IGV4cG9ydHMuY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcclxuICBpZiAobG9jYXRpb24gPT0gbnVsbCB8fCB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSByZXR1cm4gbG9jYXRpb247XHJcblxyXG4gIHZhciBiYXNlbmFtZSA9IGxvY2F0aW9uLmJhc2VuYW1lO1xyXG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xyXG4gIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XHJcbiAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xyXG5cclxuICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZTtcclxuXHJcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2g7XHJcblxyXG4gIGlmIChoYXNoKSBwYXRoICs9IGhhc2g7XHJcblxyXG4gIHJldHVybiBwYXRoO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbmV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBleHBvcnRzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGV4cG9ydHMuZ28gPSBleHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Jyb3dzZXJQcm90b2NvbCA9IHJlcXVpcmUoJy4vQnJvd3NlclByb3RvY29sJyk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2dldFVzZXJDb25maXJtYXRpb24nLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgIHJldHVybiBfQnJvd3NlclByb3RvY29sLmdldFVzZXJDb25maXJtYXRpb247XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnbycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgcmV0dXJuIF9Ccm93c2VyUHJvdG9jb2wuZ287XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xyXG5cclxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xyXG5cclxudmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xyXG4gIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHdpbmRvdy5sb2NhdGlvbik7XHJcbn07XHJcblxyXG52YXIgcHVzaExvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBmdW5jdGlvbiBwdXNoTG9jYXRpb24obG9jYXRpb24pIHtcclxuICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcclxuICByZXR1cm4gZmFsc2U7IC8vIERvbid0IHVwZGF0ZSBsb2NhdGlvblxyXG59O1xyXG5cclxudmFyIHJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZnVuY3Rpb24gcmVwbGFjZUxvY2F0aW9uKGxvY2F0aW9uKSB7XHJcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcclxuICByZXR1cm4gZmFsc2U7IC8vIERvbid0IHVwZGF0ZSBsb2NhdGlvblxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcclxuXHJcbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XHJcblxyXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xyXG5cclxudmFyIF9Ccm93c2VyUHJvdG9jb2wgPSByZXF1aXJlKCcuL0Jyb3dzZXJQcm90b2NvbCcpO1xyXG5cclxudmFyIEJyb3dzZXJQcm90b2NvbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9Ccm93c2VyUHJvdG9jb2wpO1xyXG5cclxudmFyIF9SZWZyZXNoUHJvdG9jb2wgPSByZXF1aXJlKCcuL1JlZnJlc2hQcm90b2NvbCcpO1xyXG5cclxudmFyIFJlZnJlc2hQcm90b2NvbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9SZWZyZXNoUHJvdG9jb2wpO1xyXG5cclxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcclxuXHJcbnZhciBfY3JlYXRlSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlSGlzdG9yeScpO1xyXG5cclxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyBIVE1MNSdzIGhpc3RvcnkgQVBJXHJcbiAqIChwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudCkgdG8gbWFuYWdlIGhpc3RvcnkuXHJcbiAqIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIG1ldGhvZCBvZiBtYW5hZ2luZyBoaXN0b3J5IGluIGJyb3dzZXJzIGJlY2F1c2VcclxuICogaXQgcHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXHJcbiAqXHJcbiAqIE5vdGU6IEluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGZ1bGxcclxuICogcGFnZSByZWxvYWRzIHdpbGwgYmUgdXNlZCB0byBwcmVzZXJ2ZSBjbGVhbiBVUkxzLiBZb3UgY2FuIGZvcmNlIHRoaXNcclxuICogYmVoYXZpb3IgdXNpbmcgeyBmb3JjZVJlZnJlc2g6IHRydWUgfSBpbiBvcHRpb25zLlxyXG4gKi9cclxudmFyIGNyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcclxuXHJcbiAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xyXG5cclxuICB2YXIgdXNlUmVmcmVzaCA9IG9wdGlvbnMuZm9yY2VSZWZyZXNoIHx8ICEoMCwgX0RPTVV0aWxzLnN1cHBvcnRzSGlzdG9yeSkoKTtcclxuICB2YXIgUHJvdG9jb2wgPSB1c2VSZWZyZXNoID8gUmVmcmVzaFByb3RvY29sIDogQnJvd3NlclByb3RvY29sO1xyXG5cclxuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IFByb3RvY29sLmdldFVzZXJDb25maXJtYXRpb247XHJcbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IFByb3RvY29sLmdldEN1cnJlbnRMb2NhdGlvbjtcclxuICB2YXIgcHVzaExvY2F0aW9uID0gUHJvdG9jb2wucHVzaExvY2F0aW9uO1xyXG4gIHZhciByZXBsYWNlTG9jYXRpb24gPSBQcm90b2NvbC5yZXBsYWNlTG9jYXRpb247XHJcbiAgdmFyIGdvID0gUHJvdG9jb2wuZ287XHJcblxyXG5cclxuICB2YXIgaGlzdG9yeSA9ICgwLCBfY3JlYXRlSGlzdG9yeTIuZGVmYXVsdCkoX2V4dGVuZHMoe1xyXG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogZ2V0VXNlckNvbmZpcm1hdGlvbiB9LCBvcHRpb25zLCB7XHJcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcclxuICAgIHB1c2hMb2NhdGlvbjogcHVzaExvY2F0aW9uLFxyXG4gICAgcmVwbGFjZUxvY2F0aW9uOiByZXBsYWNlTG9jYXRpb24sXHJcbiAgICBnbzogZ29cclxuICB9KSk7XHJcblxyXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcclxuICAgICAgc3RvcExpc3RlbmVyID0gdm9pZCAwO1xyXG5cclxuICB2YXIgc3RhcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIGJlZm9yZSkge1xyXG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcExpc3RlbmVyID0gQnJvd3NlclByb3RvY29sLnN0YXJ0TGlzdGVuZXIoaGlzdG9yeS50cmFuc2l0aW9uVG8pO1xyXG5cclxuICAgIHZhciB1bmxpc3RlbiA9IGJlZm9yZSA/IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKSA6IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICB1bmxpc3RlbigpO1xyXG5cclxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcExpc3RlbmVyKCk7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcclxuICAgIHJldHVybiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCB0cnVlKTtcclxuICB9O1xyXG5cclxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XHJcbiAgICByZXR1cm4gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgZmFsc2UpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xyXG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXHJcbiAgICBsaXN0ZW46IGxpc3RlblxyXG4gIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnk7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XHJcblxyXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XHJcblxyXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xyXG5cclxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcclxuXHJcbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XHJcblxyXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xyXG5cclxudmFyIF9IYXNoUHJvdG9jb2wgPSByZXF1aXJlKCcuL0hhc2hQcm90b2NvbCcpO1xyXG5cclxudmFyIEhhc2hQcm90b2NvbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9IYXNoUHJvdG9jb2wpO1xyXG5cclxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XHJcblxyXG52YXIgX2NyZWF0ZUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGlzdG9yeSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbnZhciBEZWZhdWx0UXVlcnlLZXkgPSAnX2snO1xyXG5cclxudmFyIGFkZExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XHJcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcclxufTtcclxuXHJcbnZhciBIYXNoUGF0aENvZGVycyA9IHtcclxuICBoYXNoYmFuZzoge1xyXG4gICAgZW5jb2RlUGF0aDogZnVuY3Rpb24gZW5jb2RlUGF0aChwYXRoKSB7XHJcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchJyArIHBhdGg7XHJcbiAgICB9LFxyXG4gICAgZGVjb2RlUGF0aDogZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoKSB7XHJcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRoO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgbm9zbGFzaDoge1xyXG4gICAgZW5jb2RlUGF0aDogZnVuY3Rpb24gZW5jb2RlUGF0aChwYXRoKSB7XHJcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRoO1xyXG4gICAgfSxcclxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxyXG4gIH0sXHJcbiAgc2xhc2g6IHtcclxuICAgIGVuY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaCxcclxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxyXG4gIH1cclxufTtcclxuXHJcbnZhciBjcmVhdGVIYXNoSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KCkge1xyXG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XHJcblxyXG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcclxuXHJcbiAgdmFyIHF1ZXJ5S2V5ID0gb3B0aW9ucy5xdWVyeUtleTtcclxuICB2YXIgaGFzaFR5cGUgPSBvcHRpb25zLmhhc2hUeXBlO1xyXG5cclxuXHJcbiAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkocXVlcnlLZXkgIT09IGZhbHNlLCAnVXNpbmcgeyBxdWVyeUtleTogZmFsc2UgfSBubyBsb25nZXIgd29ya3MuIEluc3RlYWQsIGp1c3QgZG9uXFwndCAnICsgJ3VzZSBsb2NhdGlvbiBzdGF0ZSBpZiB5b3UgZG9uXFwndCB3YW50IGEga2V5IGluIHlvdXIgVVJMIHF1ZXJ5IHN0cmluZycpIDogdm9pZCAwO1xyXG5cclxuICBpZiAodHlwZW9mIHF1ZXJ5S2V5ICE9PSAnc3RyaW5nJykgcXVlcnlLZXkgPSBEZWZhdWx0UXVlcnlLZXk7XHJcblxyXG4gIGlmIChoYXNoVHlwZSA9PSBudWxsKSBoYXNoVHlwZSA9ICdzbGFzaCc7XHJcblxyXG4gIGlmICghKGhhc2hUeXBlIGluIEhhc2hQYXRoQ29kZXJzKSkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdJbnZhbGlkIGhhc2ggdHlwZTogJXMnLCBoYXNoVHlwZSkgOiB2b2lkIDA7XHJcblxyXG4gICAgaGFzaFR5cGUgPSAnc2xhc2gnO1xyXG4gIH1cclxuXHJcbiAgdmFyIHBhdGhDb2RlciA9IEhhc2hQYXRoQ29kZXJzW2hhc2hUeXBlXTtcclxuXHJcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBIYXNoUHJvdG9jb2wuZ2V0VXNlckNvbmZpcm1hdGlvbjtcclxuXHJcblxyXG4gIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XHJcbiAgICByZXR1cm4gSGFzaFByb3RvY29sLmdldEN1cnJlbnRMb2NhdGlvbihwYXRoQ29kZXIsIHF1ZXJ5S2V5KTtcclxuICB9O1xyXG5cclxuICB2YXIgcHVzaExvY2F0aW9uID0gZnVuY3Rpb24gcHVzaExvY2F0aW9uKGxvY2F0aW9uKSB7XHJcbiAgICByZXR1cm4gSGFzaFByb3RvY29sLnB1c2hMb2NhdGlvbihsb2NhdGlvbiwgcGF0aENvZGVyLCBxdWVyeUtleSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHJlcGxhY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIHJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbikge1xyXG4gICAgcmV0dXJuIEhhc2hQcm90b2NvbC5yZXBsYWNlTG9jYXRpb24obG9jYXRpb24sIHBhdGhDb2RlciwgcXVlcnlLZXkpO1xyXG4gIH07XHJcblxyXG4gIHZhciBoaXN0b3J5ID0gKDAsIF9jcmVhdGVIaXN0b3J5Mi5kZWZhdWx0KShfZXh0ZW5kcyh7XHJcbiAgICBnZXRVc2VyQ29uZmlybWF0aW9uOiBnZXRVc2VyQ29uZmlybWF0aW9uIH0sIG9wdGlvbnMsIHtcclxuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxyXG4gICAgcHVzaExvY2F0aW9uOiBwdXNoTG9jYXRpb24sXHJcbiAgICByZXBsYWNlTG9jYXRpb246IHJlcGxhY2VMb2NhdGlvbixcclxuICAgIGdvOiBIYXNoUHJvdG9jb2wuZ29cclxuICB9KSk7XHJcblxyXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcclxuICAgICAgc3RvcExpc3RlbmVyID0gdm9pZCAwO1xyXG5cclxuICB2YXIgc3RhcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIGJlZm9yZSkge1xyXG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcExpc3RlbmVyID0gSGFzaFByb3RvY29sLnN0YXJ0TGlzdGVuZXIoaGlzdG9yeS50cmFuc2l0aW9uVG8sIHBhdGhDb2RlciwgcXVlcnlLZXkpO1xyXG5cclxuICAgIHZhciB1bmxpc3RlbiA9IGJlZm9yZSA/IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKSA6IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICB1bmxpc3RlbigpO1xyXG5cclxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcExpc3RlbmVyKCk7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcclxuICAgIHJldHVybiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCB0cnVlKTtcclxuICB9O1xyXG5cclxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XHJcbiAgICByZXR1cm4gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgZmFsc2UpO1xyXG4gIH07XHJcblxyXG4gIHZhciBnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCA9ICgwLCBfRE9NVXRpbHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2gpKCk7XHJcblxyXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJykgOiB2b2lkIDA7XHJcblxyXG4gICAgaGlzdG9yeS5nbyhuKTtcclxuICB9O1xyXG5cclxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYocGF0aCkge1xyXG4gICAgcmV0dXJuICcjJyArIHBhdGhDb2Rlci5lbmNvZGVQYXRoKGhpc3RvcnkuY3JlYXRlSHJlZihwYXRoKSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XHJcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcclxuICAgIGxpc3RlbjogbGlzdGVuLFxyXG4gICAgZ286IGdvLFxyXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZlxyXG4gIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlSGFzaEhpc3Rvcnk7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xyXG5cclxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xyXG5cclxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcclxuXHJcbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xyXG5cclxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XHJcblxyXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcclxuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gb3B0aW9ucy5nZXRDdXJyZW50TG9jYXRpb247XHJcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBvcHRpb25zLmdldFVzZXJDb25maXJtYXRpb247XHJcbiAgdmFyIHB1c2hMb2NhdGlvbiA9IG9wdGlvbnMucHVzaExvY2F0aW9uO1xyXG4gIHZhciByZXBsYWNlTG9jYXRpb24gPSBvcHRpb25zLnJlcGxhY2VMb2NhdGlvbjtcclxuICB2YXIgZ28gPSBvcHRpb25zLmdvO1xyXG4gIHZhciBrZXlMZW5ndGggPSBvcHRpb25zLmtleUxlbmd0aDtcclxuXHJcblxyXG4gIHZhciBjdXJyZW50TG9jYXRpb24gPSB2b2lkIDA7XHJcbiAgdmFyIHBlbmRpbmdMb2NhdGlvbiA9IHZvaWQgMDtcclxuICB2YXIgYmVmb3JlTGlzdGVuZXJzID0gW107XHJcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xyXG4gIHZhciBhbGxLZXlzID0gW107XHJcblxyXG4gIHZhciBnZXRDdXJyZW50SW5kZXggPSBmdW5jdGlvbiBnZXRDdXJyZW50SW5kZXgoKSB7XHJcbiAgICBpZiAocGVuZGluZ0xvY2F0aW9uICYmIHBlbmRpbmdMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihwZW5kaW5nTG9jYXRpb24ua2V5KTtcclxuXHJcbiAgICBpZiAoY3VycmVudExvY2F0aW9uKSByZXR1cm4gYWxsS2V5cy5pbmRleE9mKGN1cnJlbnRMb2NhdGlvbi5rZXkpO1xyXG5cclxuICAgIHJldHVybiAtMTtcclxuICB9O1xyXG5cclxuICB2YXIgdXBkYXRlTG9jYXRpb24gPSBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvbihuZXh0TG9jYXRpb24pIHtcclxuICAgIHZhciBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcclxuXHJcbiAgICBjdXJyZW50TG9jYXRpb24gPSBuZXh0TG9jYXRpb247XHJcblxyXG4gICAgaWYgKGN1cnJlbnRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcclxuICAgICAgYWxsS2V5cyA9IFtdLmNvbmNhdChhbGxLZXlzLnNsaWNlKDAsIGN1cnJlbnRJbmRleCArIDEpLCBbY3VycmVudExvY2F0aW9uLmtleV0pO1xyXG4gICAgfSBlbHNlIGlmIChjdXJyZW50TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5SRVBMQUNFKSB7XHJcbiAgICAgIGFsbEtleXNbY3VycmVudEluZGV4XSA9IGN1cnJlbnRMb2NhdGlvbi5rZXk7XHJcbiAgICB9XHJcblxyXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgIHJldHVybiBsaXN0ZW5lcihjdXJyZW50TG9jYXRpb24pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGxpc3RlbkJlZm9yZSA9IGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xyXG4gICAgYmVmb3JlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBiZWZvcmVMaXN0ZW5lcnMgPSBiZWZvcmVMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xyXG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykoYmVmb3JlTGlzdGVuZXJzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XHJcbiAgICAgICgwLCBfcnVuVHJhbnNpdGlvbkhvb2syLmRlZmF1bHQpKGJlZm9yZUxpc3RlbmVyc1tpbmRleF0sIGxvY2F0aW9uLCBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsID8gZG9uZShyZXN1bHQpIDogbmV4dCgpO1xyXG4gICAgICB9KTtcclxuICAgIH0sIGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgIGlmIChnZXRVc2VyQ29uZmlybWF0aW9uICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGdldFVzZXJDb25maXJtYXRpb24obWVzc2FnZSwgZnVuY3Rpb24gKG9rKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sob2sgIT09IGZhbHNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYWxsYmFjayhtZXNzYWdlICE9PSBmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIHZhciB0cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiB0cmFuc2l0aW9uVG8obmV4dExvY2F0aW9uKSB7XHJcbiAgICBpZiAoY3VycmVudExvY2F0aW9uICYmICgwLCBfTG9jYXRpb25VdGlscy5sb2NhdGlvbnNBcmVFcXVhbCkoY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24pIHx8IHBlbmRpbmdMb2NhdGlvbiAmJiAoMCwgX0xvY2F0aW9uVXRpbHMubG9jYXRpb25zQXJlRXF1YWwpKHBlbmRpbmdMb2NhdGlvbiwgbmV4dExvY2F0aW9uKSkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvXHJcblxyXG4gICAgcGVuZGluZ0xvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xyXG5cclxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG8obmV4dExvY2F0aW9uLCBmdW5jdGlvbiAob2spIHtcclxuICAgICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAhPT0gbmV4dExvY2F0aW9uKSByZXR1cm47IC8vIFRyYW5zaXRpb24gd2FzIGludGVycnVwdGVkIGR1cmluZyBjb25maXJtYXRpb25cclxuXHJcbiAgICAgIHBlbmRpbmdMb2NhdGlvbiA9IG51bGw7XHJcblxyXG4gICAgICBpZiAob2spIHtcclxuICAgICAgICAvLyBUcmVhdCBQVVNIIHRvIHNhbWUgcGF0aCBsaWtlIFJFUExBQ0UgdG8gYmUgY29uc2lzdGVudCB3aXRoIGJyb3dzZXJzXHJcbiAgICAgICAgaWYgKG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcclxuICAgICAgICAgIHZhciBwcmV2UGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGN1cnJlbnRMb2NhdGlvbik7XHJcbiAgICAgICAgICB2YXIgbmV4dFBhdGggPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShuZXh0TG9jYXRpb24pO1xyXG5cclxuICAgICAgICAgIGlmIChuZXh0UGF0aCA9PT0gcHJldlBhdGggJiYgKDAsIF9Mb2NhdGlvblV0aWxzLnN0YXRlc0FyZUVxdWFsKShjdXJyZW50TG9jYXRpb24uc3RhdGUsIG5leHRMb2NhdGlvbi5zdGF0ZSkpIG5leHRMb2NhdGlvbi5hY3Rpb24gPSBfQWN0aW9ucy5SRVBMQUNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkge1xyXG4gICAgICAgICAgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcclxuICAgICAgICAgIGlmIChwdXNoTG9jYXRpb24obmV4dExvY2F0aW9uKSAhPT0gZmFsc2UpIHVwZGF0ZUxvY2F0aW9uKG5leHRMb2NhdGlvbik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5SRVBMQUNFKSB7XHJcbiAgICAgICAgICBpZiAocmVwbGFjZUxvY2F0aW9uKG5leHRMb2NhdGlvbikgIT09IGZhbHNlKSB1cGRhdGVMb2NhdGlvbihuZXh0TG9jYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50TG9jYXRpb24gJiYgbmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSB7XHJcbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihjdXJyZW50TG9jYXRpb24ua2V5KTtcclxuICAgICAgICB2YXIgbmV4dEluZGV4ID0gYWxsS2V5cy5pbmRleE9mKG5leHRMb2NhdGlvbi5rZXkpO1xyXG5cclxuICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSAmJiBuZXh0SW5kZXggIT09IC0xKSBnbyhwcmV2SW5kZXggLSBuZXh0SW5kZXgpOyAvLyBSZXN0b3JlIHRoZSBVUkxcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKGlucHV0KSB7XHJcbiAgICByZXR1cm4gdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGlucHV0LCBfQWN0aW9ucy5QVVNIKSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKGlucHV0KSB7XHJcbiAgICByZXR1cm4gdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGlucHV0LCBfQWN0aW9ucy5SRVBMQUNFKSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcclxuICAgIHJldHVybiBnbygtMSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcclxuICAgIHJldHVybiBnbygxKTtcclxuICB9O1xyXG5cclxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xyXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGggfHwgNik7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XHJcbiAgICByZXR1cm4gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xyXG4gIH07XHJcblxyXG4gIHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBhY3Rpb24pIHtcclxuICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBjcmVhdGVLZXkoKSA6IGFyZ3VtZW50c1syXTtcclxuICAgIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGxvY2F0aW9uLCBhY3Rpb24sIGtleSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxyXG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXHJcbiAgICBsaXN0ZW46IGxpc3RlbixcclxuICAgIHRyYW5zaXRpb25UbzogdHJhbnNpdGlvblRvLFxyXG4gICAgcHVzaDogcHVzaCxcclxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXHJcbiAgICBnbzogZ28sXHJcbiAgICBnb0JhY2s6IGdvQmFjayxcclxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxyXG4gICAgY3JlYXRlS2V5OiBjcmVhdGVLZXksXHJcbiAgICBjcmVhdGVQYXRoOiBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgsXHJcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxyXG4gICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUhpc3Rvcnk7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XHJcblxyXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XHJcblxyXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xyXG5cclxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcclxuXHJcbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xyXG5cclxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xyXG5cclxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XHJcblxyXG52YXIgX2NyZWF0ZUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGlzdG9yeSk7XHJcblxyXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgY3JlYXRlU3RhdGVTdG9yYWdlID0gZnVuY3Rpb24gY3JlYXRlU3RhdGVTdG9yYWdlKGVudHJpZXMpIHtcclxuICByZXR1cm4gZW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gZW50cnkuc3RhdGU7XHJcbiAgfSkucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBlbnRyeSkge1xyXG4gICAgbWVtb1tlbnRyeS5rZXldID0gZW50cnkuc3RhdGU7XHJcbiAgICByZXR1cm4gbWVtbztcclxuICB9LCB7fSk7XHJcbn07XHJcblxyXG52YXIgY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSB7XHJcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcclxuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IG9wdGlvbnMgfTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xyXG4gICAgb3B0aW9ucyA9IHsgZW50cmllczogW29wdGlvbnNdIH07XHJcbiAgfVxyXG5cclxuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xyXG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tjdXJyZW50XTtcclxuICAgIHZhciBwYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoZW50cnkpO1xyXG5cclxuICAgIHZhciBrZXkgPSB2b2lkIDAsXHJcbiAgICAgICAgc3RhdGUgPSB2b2lkIDA7XHJcbiAgICBpZiAoZW50cnkua2V5KSB7XHJcbiAgICAgIGtleSA9IGVudHJ5LmtleTtcclxuICAgICAgc3RhdGUgPSByZWFkU3RhdGUoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW5pdCA9ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkocGF0aCk7XHJcblxyXG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoX2V4dGVuZHMoe30sIGluaXQsIHsgc3RhdGU6IHN0YXRlIH0pLCB1bmRlZmluZWQsIGtleSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNhbkdvID0gZnVuY3Rpb24gY2FuR28obikge1xyXG4gICAgdmFyIGluZGV4ID0gY3VycmVudCArIG47XHJcbiAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IGVudHJpZXMubGVuZ3RoO1xyXG4gIH07XHJcblxyXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcclxuICAgIGlmICghbikgcmV0dXJuO1xyXG5cclxuICAgIGlmICghY2FuR28obikpIHtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdDYW5ub3QgZ28oJXMpIHRoZXJlIGlzIG5vdCBlbm91Z2ggaGlzdG9yeScsIG4pIDogdm9pZCAwO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGN1cnJlbnQgKz0gbjtcclxuICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRDdXJyZW50TG9jYXRpb24oKTtcclxuXHJcbiAgICAvLyBDaGFuZ2UgYWN0aW9uIHRvIFBPUFxyXG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oX2V4dGVuZHMoe30sIGN1cnJlbnRMb2NhdGlvbiwgeyBhY3Rpb246IF9BY3Rpb25zLlBPUCB9KSk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHB1c2hMb2NhdGlvbiA9IGZ1bmN0aW9uIHB1c2hMb2NhdGlvbihsb2NhdGlvbikge1xyXG4gICAgY3VycmVudCArPSAxO1xyXG5cclxuICAgIGlmIChjdXJyZW50IDwgZW50cmllcy5sZW5ndGgpIGVudHJpZXMuc3BsaWNlKGN1cnJlbnQpO1xyXG5cclxuICAgIGVudHJpZXMucHVzaChsb2NhdGlvbik7XHJcblxyXG4gICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xyXG4gIH07XHJcblxyXG4gIHZhciByZXBsYWNlTG9jYXRpb24gPSBmdW5jdGlvbiByZXBsYWNlTG9jYXRpb24obG9jYXRpb24pIHtcclxuICAgIGVudHJpZXNbY3VycmVudF0gPSBsb2NhdGlvbjtcclxuICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcclxuICB9O1xyXG5cclxuICB2YXIgaGlzdG9yeSA9ICgwLCBfY3JlYXRlSGlzdG9yeTIuZGVmYXVsdCkoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcclxuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxyXG4gICAgcHVzaExvY2F0aW9uOiBwdXNoTG9jYXRpb24sXHJcbiAgICByZXBsYWNlTG9jYXRpb246IHJlcGxhY2VMb2NhdGlvbixcclxuICAgIGdvOiBnb1xyXG4gIH0pKTtcclxuXHJcbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucztcclxuICB2YXIgZW50cmllcyA9IF9vcHRpb25zLmVudHJpZXM7XHJcbiAgdmFyIGN1cnJlbnQgPSBfb3B0aW9ucy5jdXJyZW50O1xyXG5cclxuXHJcbiAgaWYgKHR5cGVvZiBlbnRyaWVzID09PSAnc3RyaW5nJykge1xyXG4gICAgZW50cmllcyA9IFtlbnRyaWVzXTtcclxuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGVudHJpZXMpKSB7XHJcbiAgICBlbnRyaWVzID0gWycvJ107XHJcbiAgfVxyXG5cclxuICBlbnRyaWVzID0gZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSk7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcclxuICAgIGN1cnJlbnQgPSBlbnRyaWVzLmxlbmd0aCAtIDE7XHJcbiAgfSBlbHNlIHtcclxuICAgICEoY3VycmVudCA+PSAwICYmIGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnQ3VycmVudCBpbmRleCBtdXN0IGJlID49IDAgYW5kIDwgJXMsIHdhcyAlcycsIGVudHJpZXMubGVuZ3RoLCBjdXJyZW50KSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XHJcbiAgfVxyXG5cclxuICB2YXIgc3RvcmFnZSA9IGNyZWF0ZVN0YXRlU3RvcmFnZShlbnRyaWVzKTtcclxuXHJcbiAgdmFyIHNhdmVTdGF0ZSA9IGZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc3RvcmFnZVtrZXldID0gc3RhdGU7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHJlYWRTdGF0ZSA9IGZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcclxuICAgIHJldHVybiBzdG9yYWdlW2tleV07XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XHJcbiAgICBjYW5HbzogY2FuR29cclxuICB9KTtcclxufTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcclxuXHJcbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgcnVuVHJhbnNpdGlvbkhvb2sgPSBmdW5jdGlvbiBydW5UcmFuc2l0aW9uSG9vayhob29rLCBsb2NhdGlvbiwgY2FsbGJhY2spIHtcclxuICB2YXIgcmVzdWx0ID0gaG9vayhsb2NhdGlvbiwgY2FsbGJhY2spO1xyXG5cclxuICBpZiAoaG9vay5sZW5ndGggPCAyKSB7XHJcbiAgICAvLyBBc3N1bWUgdGhlIGhvb2sgcnVucyBzeW5jaHJvbm91c2x5IGFuZCBhdXRvbWF0aWNhbGx5XHJcbiAgICAvLyBjYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICBjYWxsYmFjayhyZXN1bHQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShyZXN1bHQgPT09IHVuZGVmaW5lZCwgJ1lvdSBzaG91bGQgbm90IFwicmV0dXJuXCIgaW4gYSB0cmFuc2l0aW9uIGhvb2sgd2l0aCBhIGNhbGxiYWNrIGFyZ3VtZW50OyAnICsgJ2NhbGwgdGhlIGNhbGxiYWNrIGluc3RlYWQnKSA6IHZvaWQgMDtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBydW5UcmFuc2l0aW9uSG9vazsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XHJcblxyXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcclxuXHJcbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG52YXIgdXNlQmFzZW5hbWUgPSBmdW5jdGlvbiB1c2VCYXNlbmFtZShjcmVhdGVIaXN0b3J5KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XHJcblxyXG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xyXG4gICAgdmFyIGJhc2VuYW1lID0gb3B0aW9ucy5iYXNlbmFtZTtcclxuXHJcblxyXG4gICAgdmFyIGFkZEJhc2VuYW1lID0gZnVuY3Rpb24gYWRkQmFzZW5hbWUobG9jYXRpb24pIHtcclxuICAgICAgaWYgKCFsb2NhdGlvbikgcmV0dXJuIGxvY2F0aW9uO1xyXG5cclxuICAgICAgaWYgKGJhc2VuYW1lICYmIGxvY2F0aW9uLmJhc2VuYW1lID09IG51bGwpIHtcclxuICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlbmFtZSkgPT09IDApIHtcclxuICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyaW5nKGJhc2VuYW1lLmxlbmd0aCk7XHJcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9IGJhc2VuYW1lO1xyXG5cclxuICAgICAgICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gJycpIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcHJlcGVuZEJhc2VuYW1lID0gZnVuY3Rpb24gcHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSB7XHJcbiAgICAgIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcclxuXHJcbiAgICAgIHZhciBvYmplY3QgPSB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShsb2NhdGlvbikgOiBsb2NhdGlvbjtcclxuICAgICAgdmFyIHBuYW1lID0gb2JqZWN0LnBhdGhuYW1lO1xyXG4gICAgICB2YXIgbm9ybWFsaXplZEJhc2VuYW1lID0gYmFzZW5hbWUuc2xpY2UoLTEpID09PSAnLycgPyBiYXNlbmFtZSA6IGJhc2VuYW1lICsgJy8nO1xyXG4gICAgICB2YXIgbm9ybWFsaXplZFBhdGhuYW1lID0gcG5hbWUuY2hhckF0KDApID09PSAnLycgPyBwbmFtZS5zbGljZSgxKSA6IHBuYW1lO1xyXG4gICAgICB2YXIgcGF0aG5hbWUgPSBub3JtYWxpemVkQmFzZW5hbWUgKyBub3JtYWxpemVkUGF0aG5hbWU7XHJcblxyXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIG9iamVjdCwge1xyXG4gICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIGJhc2VuYW1lLWF3YXJlIHZlcnNpb25zLlxyXG4gICAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGFkZEJhc2VuYW1lKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgbGlzdGVuQmVmb3JlID0gZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcclxuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuQmVmb3JlKGZ1bmN0aW9uIChsb2NhdGlvbiwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gKDAsIF9ydW5UcmFuc2l0aW9uSG9vazIuZGVmYXVsdCkoaG9vaywgYWRkQmFzZW5hbWUobG9jYXRpb24pLCBjYWxsYmFjayk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XHJcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gbGlzdGVuZXIoYWRkQmFzZW5hbWUobG9jYXRpb24pKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJyaWRlIGFsbCB3cml0ZSBtZXRob2RzIHdpdGggYmFzZW5hbWUtYXdhcmUgdmVyc2lvbnMuXHJcbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcclxuICAgICAgcmV0dXJuIGhpc3RvcnkucHVzaChwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XHJcbiAgICAgIHJldHVybiBoaXN0b3J5LnJlcGxhY2UocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xyXG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcclxuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcclxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhZGRCYXNlbmFtZShoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uLmFwcGx5KGhpc3RvcnksIFtwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pXS5jb25jYXQoYXJncykpKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XHJcbiAgICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxyXG4gICAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcclxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXHJcbiAgICAgIHB1c2g6IHB1c2gsXHJcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXHJcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXHJcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXHJcbiAgICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvblxyXG4gICAgfSk7XHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHVzZUJhc2VuYW1lOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9xdWVyeVN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5LXN0cmluZycpO1xyXG5cclxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcclxuXHJcbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xyXG5cclxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XHJcblxyXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxudmFyIGRlZmF1bHRTdHJpbmdpZnlRdWVyeSA9IGZ1bmN0aW9uIGRlZmF1bHRTdHJpbmdpZnlRdWVyeShxdWVyeSkge1xyXG4gIHJldHVybiAoMCwgX3F1ZXJ5U3RyaW5nLnN0cmluZ2lmeSkocXVlcnkpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xyXG59O1xyXG5cclxudmFyIGRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nID0gX3F1ZXJ5U3RyaW5nLnBhcnNlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgY3JlYXRlSGlzdG9yeSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNyZWF0ZVxyXG4gKiBoaXN0b3J5IG9iamVjdHMgdGhhdCBrbm93IGhvdyB0byBoYW5kbGUgVVJMIHF1ZXJpZXMuXHJcbiAqL1xyXG52YXIgdXNlUXVlcmllcyA9IGZ1bmN0aW9uIHVzZVF1ZXJpZXMoY3JlYXRlSGlzdG9yeSkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xyXG5cclxuICAgIHZhciBoaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShvcHRpb25zKTtcclxuICAgIHZhciBzdHJpbmdpZnlRdWVyeSA9IG9wdGlvbnMuc3RyaW5naWZ5UXVlcnk7XHJcbiAgICB2YXIgcGFyc2VRdWVyeVN0cmluZyA9IG9wdGlvbnMucGFyc2VRdWVyeVN0cmluZztcclxuXHJcblxyXG4gICAgaWYgKHR5cGVvZiBzdHJpbmdpZnlRdWVyeSAhPT0gJ2Z1bmN0aW9uJykgc3RyaW5naWZ5UXVlcnkgPSBkZWZhdWx0U3RyaW5naWZ5UXVlcnk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBwYXJzZVF1ZXJ5U3RyaW5nICE9PSAnZnVuY3Rpb24nKSBwYXJzZVF1ZXJ5U3RyaW5nID0gZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmc7XHJcblxyXG4gICAgdmFyIGRlY29kZVF1ZXJ5ID0gZnVuY3Rpb24gZGVjb2RlUXVlcnkobG9jYXRpb24pIHtcclxuICAgICAgaWYgKCFsb2NhdGlvbikgcmV0dXJuIGxvY2F0aW9uO1xyXG5cclxuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5ID09IG51bGwpIGxvY2F0aW9uLnF1ZXJ5ID0gcGFyc2VRdWVyeVN0cmluZyhsb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcclxuXHJcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGVuY29kZVF1ZXJ5ID0gZnVuY3Rpb24gZW5jb2RlUXVlcnkobG9jYXRpb24sIHF1ZXJ5KSB7XHJcbiAgICAgIGlmIChxdWVyeSA9PSBudWxsKSByZXR1cm4gbG9jYXRpb247XHJcblxyXG4gICAgICB2YXIgb2JqZWN0ID0gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJyA/ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkobG9jYXRpb24pIDogbG9jYXRpb247XHJcbiAgICAgIHZhciBxdWVyeVN0cmluZyA9IHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgdmFyIHNlYXJjaCA9IHF1ZXJ5U3RyaW5nID8gJz8nICsgcXVlcnlTdHJpbmcgOiAnJztcclxuXHJcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgb2JqZWN0LCB7XHJcbiAgICAgICAgc2VhcmNoOiBzZWFyY2hcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJyaWRlIGFsbCByZWFkIG1ldGhvZHMgd2l0aCBxdWVyeS1hd2FyZSB2ZXJzaW9ucy5cclxuICAgIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XHJcbiAgICAgIHJldHVybiBkZWNvZGVRdWVyeShoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGxpc3RlbkJlZm9yZSA9IGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XHJcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbkJlZm9yZShmdW5jdGlvbiAobG9jYXRpb24sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCBfcnVuVHJhbnNpdGlvbkhvb2syLmRlZmF1bHQpKGhvb2ssIGRlY29kZVF1ZXJ5KGxvY2F0aW9uKSwgY2FsbGJhY2spO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xyXG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKGRlY29kZVF1ZXJ5KGxvY2F0aW9uKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBPdmVycmlkZSBhbGwgd3JpdGUgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxyXG4gICAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XHJcbiAgICAgIHJldHVybiBoaXN0b3J5LnB1c2goZW5jb2RlUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xyXG4gICAgICByZXR1cm4gaGlzdG9yeS5yZXBsYWNlKGVuY29kZVF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcclxuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlUGF0aChlbmNvZGVRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XHJcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYoZW5jb2RlUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XHJcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbmV3TG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uLmFwcGx5KGhpc3RvcnksIFtlbmNvZGVRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpXS5jb25jYXQoYXJncykpO1xyXG5cclxuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5KSBuZXdMb2NhdGlvbi5xdWVyeSA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVRdWVyeSkobG9jYXRpb24ucXVlcnkpO1xyXG5cclxuICAgICAgcmV0dXJuIGRlY29kZVF1ZXJ5KG5ld0xvY2F0aW9uKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XHJcbiAgICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxyXG4gICAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcclxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXHJcbiAgICAgIHB1c2g6IHB1c2gsXHJcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXHJcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXHJcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXHJcbiAgICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvblxyXG4gICAgfSk7XHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IHVzZVF1ZXJpZXM7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XHJcblxyXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xyXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XHJcbnZhciBSZWFjdFB1cmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0UHVyZUNvbXBvbmVudCcpO1xyXG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xyXG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmFjdG9yaWVzJyk7XHJcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xyXG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzJyk7XHJcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xyXG5cclxudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoJy4vb25seUNoaWxkJyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxudmFyIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudDtcclxudmFyIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcclxudmFyIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQ7XHJcblxyXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xyXG4gIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudDtcclxuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XHJcbiAgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNsb25lRWxlbWVudDtcclxufVxyXG5cclxudmFyIF9fc3ByZWFkID0gX2Fzc2lnbjtcclxuXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xyXG4gIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmVkLCAnUmVhY3QuX19zcHJlYWQgaXMgZGVwcmVjYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkLiBVc2UgJyArICdPYmplY3QuYXNzaWduIGRpcmVjdGx5IG9yIGFub3RoZXIgaGVscGVyIGZ1bmN0aW9uIHdpdGggc2ltaWxhciAnICsgJ3NlbWFudGljcy4gWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byB5b3VyIGNvbXBpbGVyLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LXNwcmVhZC1kZXByZWNhdGlvbiBmb3IgbW9yZSBkZXRhaWxzLicpIDogdm9pZCAwO1xyXG4gICAgd2FybmVkID0gdHJ1ZTtcclxuICAgIHJldHVybiBfYXNzaWduLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG5cclxudmFyIFJlYWN0ID0ge1xyXG5cclxuICAvLyBNb2Rlcm5cclxuXHJcbiAgQ2hpbGRyZW46IHtcclxuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXHJcbiAgICBmb3JFYWNoOiBSZWFjdENoaWxkcmVuLmZvckVhY2gsXHJcbiAgICBjb3VudDogUmVhY3RDaGlsZHJlbi5jb3VudCxcclxuICAgIHRvQXJyYXk6IFJlYWN0Q2hpbGRyZW4udG9BcnJheSxcclxuICAgIG9ubHk6IG9ubHlDaGlsZFxyXG4gIH0sXHJcblxyXG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXHJcbiAgUHVyZUNvbXBvbmVudDogUmVhY3RQdXJlQ29tcG9uZW50LFxyXG5cclxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxyXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxyXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXHJcblxyXG4gIC8vIENsYXNzaWNcclxuXHJcbiAgUHJvcFR5cGVzOiBSZWFjdFByb3BUeXBlcyxcclxuICBjcmVhdGVDbGFzczogUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyxcclxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxyXG4gIGNyZWF0ZU1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcclxuICAgIC8vIEN1cnJlbnRseSBhIG5vb3AuIFdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdHJhY2UgbWl4aW5zLlxyXG4gICAgcmV0dXJuIG1peGluO1xyXG4gIH0sXHJcblxyXG4gIC8vIFRoaXMgbG9va3MgRE9NIHNwZWNpZmljIGJ1dCB0aGVzZSBhcmUgYWN0dWFsbHkgaXNvbW9ycGhpYyBoZWxwZXJzXHJcbiAgLy8gc2luY2UgdGhleSBhcmUganVzdCBnZW5lcmF0aW5nIERPTSBzdHJpbmdzLlxyXG4gIERPTTogUmVhY3RET01GYWN0b3JpZXMsXHJcblxyXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcclxuXHJcbiAgLy8gRGVwcmVjYXRlZCBob29rIGZvciBKU1ggc3ByZWFkLCBkb24ndCB1c2UgdGhpcyBmb3IgYW55dGhpbmcuXHJcbiAgX19zcHJlYWQ6IF9fc3ByZWFkXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcclxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XHJcblxyXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcclxudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcclxuXHJcbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyO1xyXG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyO1xyXG5cclxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcclxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcclxuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xyXG59XHJcblxyXG4vKipcclxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXHJcbiAqIHRyYXZlcnNhbC4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXHJcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSB0cmF2ZXJzYWwgd2l0aC5cclxuICogQHBhcmFtIHs/Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIGNvbnRleHQgd2l0aC5cclxuICovXHJcbmZ1bmN0aW9uIEZvckVhY2hCb29rS2VlcGluZyhmb3JFYWNoRnVuY3Rpb24sIGZvckVhY2hDb250ZXh0KSB7XHJcbiAgdGhpcy5mdW5jID0gZm9yRWFjaEZ1bmN0aW9uO1xyXG4gIHRoaXMuY29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xyXG4gIHRoaXMuY291bnQgPSAwO1xyXG59XHJcbkZvckVhY2hCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmZ1bmMgPSBudWxsO1xyXG4gIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgdGhpcy5jb3VudCA9IDA7XHJcbn07XHJcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGb3JFYWNoQm9va0tlZXBpbmcsIHR3b0FyZ3VtZW50UG9vbGVyKTtcclxuXHJcbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcclxuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXHJcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xyXG5cclxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xyXG59XHJcblxyXG4vKipcclxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXHJcbiAqXHJcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXHJcbiAqIGxlYWYgY2hpbGQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXHJcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xyXG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgfVxyXG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBGb3JFYWNoQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XHJcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xyXG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcclxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3IgTWFwQm9va0tlZXBpbmdcclxuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxyXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXHJcbiAqIEBwYXJhbSB7Pyp9IG1hcENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cclxuICovXHJcbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xyXG4gIHRoaXMucmVzdWx0ID0gbWFwUmVzdWx0O1xyXG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xyXG4gIHRoaXMuZnVuYyA9IG1hcEZ1bmN0aW9uO1xyXG4gIHRoaXMuY29udGV4dCA9IG1hcENvbnRleHQ7XHJcbiAgdGhpcy5jb3VudCA9IDA7XHJcbn1cclxuTWFwQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5yZXN1bHQgPSBudWxsO1xyXG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcclxuICB0aGlzLmZ1bmMgPSBudWxsO1xyXG4gIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgdGhpcy5jb3VudCA9IDA7XHJcbn07XHJcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhNYXBCb29rS2VlcGluZywgZm91ckFyZ3VtZW50UG9vbGVyKTtcclxuXHJcbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xyXG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXHJcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcclxuICAgICAgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXHJcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xyXG5cclxuXHJcbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcclxuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcclxuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XHJcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XHJcbiAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xyXG4gICAgICBtYXBwZWRDaGlsZCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXHJcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXHJcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxyXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XHJcbiAgICB9XHJcbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XHJcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcclxuICBpZiAocHJlZml4ICE9IG51bGwpIHtcclxuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcclxuICB9XHJcbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IE1hcEJvb2tLZWVwaW5nLmdldFBvb2xlZChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XHJcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcclxuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxyXG4gKlxyXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXHJcbiAqIGxlYWYgY2hpbGQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cclxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcclxuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gIH1cclxuICB2YXIgcmVzdWx0ID0gW107XHJcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcclxuICogYHByb3BzLmNoaWxkcmVuYC5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XHJcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZER1bW15LCBudWxsKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXHJcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi50b2FycmF5XHJcbiAqL1xyXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcclxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXHJcbiAgbWFwOiBtYXBDaGlsZHJlbixcclxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxyXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxyXG4gIHRvQXJyYXk6IHRvQXJyYXlcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZHJlbjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxyXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcclxuXHJcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcclxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XHJcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcclxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xyXG5cclxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBNSVhJTlNfS0VZID0gJ21peGlucyc7XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWxsb3cgdGhlIGNyZWF0aW9uIG9mIGFub255bW91cyBmdW5jdGlvbnMgd2hpY2ggZG8gbm90XHJcbi8vIGhhdmUgLm5hbWUgc2V0IHRvIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSBiZWluZyBhc3NpZ25lZCB0by5cclxuZnVuY3Rpb24gaWRlbnRpdHkoZm4pIHtcclxuICByZXR1cm4gZm47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxyXG4gKi9cclxuXHJcblxyXG52YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcclxuXHJcbi8qKlxyXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxyXG4gKiBvciBob3N0IGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcclxuICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xyXG4gKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cclxuICpcclxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcclxuICogICAgIH1cclxuICogICB9KTtcclxuICpcclxuICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxyXG4gKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxyXG4gKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcclxuICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxyXG4gKlxyXG4gKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7YXJyYXl9XHJcbiAgICogQG9wdGlvbmFsXHJcbiAgICovXHJcbiAgbWl4aW5zOiAnREVGSU5FX01BTlknLFxyXG5cclxuICAvKipcclxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cclxuICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIHN0YXRpY3M6ICdERUZJTkVfTUFOWScsXHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIHByb3BUeXBlczogJ0RFRklORV9NQU5ZJyxcclxuXHJcbiAgLyoqXHJcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICogQG9wdGlvbmFsXHJcbiAgICovXHJcbiAgY29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxyXG5cclxuICAvKipcclxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxyXG4gICAqXHJcbiAgICogQHR5cGUge29iamVjdH1cclxuICAgKiBAb3B0aW9uYWxcclxuICAgKi9cclxuICBjaGlsZENvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcclxuXHJcbiAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cclxuICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXHJcbiAgICpcclxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XHJcbiAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9XHJcbiAgICogQG9wdGlvbmFsXHJcbiAgICovXHJcbiAgZ2V0RGVmYXVsdFByb3BzOiAnREVGSU5FX01BTllfTUVSR0VEJyxcclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXHJcbiAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxyXG4gICAqXHJcbiAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAqICAgICByZXR1cm4ge1xyXG4gICAqICAgICAgIGlzT246IGZhbHNlLFxyXG4gICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXHJcbiAgICogICAgIH1cclxuICAgKiAgIH1cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge29iamVjdH1cclxuICAgKiBAb3B0aW9uYWxcclxuICAgKi9cclxuICBnZXRJbml0aWFsU3RhdGU6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9XHJcbiAgICogQG9wdGlvbmFsXHJcbiAgICovXHJcbiAgZ2V0Q2hpbGRDb250ZXh0OiAnREVGSU5FX01BTllfTUVSR0VEJyxcclxuXHJcbiAgLyoqXHJcbiAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxyXG4gICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xyXG4gICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxyXG4gICAqXHJcbiAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcclxuICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XHJcbiAgICogICB9XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cclxuICAgKiBAbm9zaWRlZWZmZWN0c1xyXG4gICAqIEByZXF1aXJlZFxyXG4gICAqL1xyXG4gIHJlbmRlcjogJ0RFRklORV9PTkNFJyxcclxuXHJcbiAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXHJcbiAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcclxuICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cclxuICAgKlxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIGNvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxyXG4gICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICpcclxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xyXG4gICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIGNvbXBvbmVudERpZE1vdW50OiAnREVGSU5FX01BTlknLFxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cclxuICAgKlxyXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIGEgcHJvcCB0cmFuc2l0aW9uIGJ5IHVwZGF0aW5nIHRoZVxyXG4gICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cclxuICAgKlxyXG4gICAqICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xyXG4gICAqICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxyXG4gICAqICAgICB9KTtcclxuICAgKiAgIH1cclxuICAgKlxyXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgYGNvbXBvbmVudFdpbGxSZWNlaXZlU3RhdGVgLiBBbiBpbmNvbWluZyBwcm9wXHJcbiAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxyXG4gICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdERUZJTkVfTUFOWScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxyXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxyXG4gICAqXHJcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxyXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcclxuICAgKiB1cGRhdGUuXHJcbiAgICpcclxuICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XHJcbiAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxyXG4gICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XHJcbiAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xyXG4gICAqICAgfVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogJ0RFRklORV9PTkNFJyxcclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxyXG4gICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcclxuICAgKiBhbmQgYG5leHRDb250ZXh0YC5cclxuICAgKlxyXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXHJcbiAgICpcclxuICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXHJcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcclxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIGNvbXBvbmVudFdpbGxVcGRhdGU6ICdERUZJTkVfTUFOWScsXHJcblxyXG4gIC8qKlxyXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICpcclxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xyXG4gICAqIGJlZW4gdXBkYXRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2UHJvcHNcclxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxyXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxyXG4gICAqIEBvcHRpb25hbFxyXG4gICAqL1xyXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogJ0RFRklORV9NQU5ZJyxcclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcclxuICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cclxuICAgKlxyXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cclxuICAgKlxyXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxyXG4gICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxyXG4gICAqXHJcbiAgICogQG9wdGlvbmFsXHJcbiAgICovXHJcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6ICdERUZJTkVfTUFOWScsXHJcblxyXG4gIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxyXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBvdmVycmlkYWJsZVxyXG4gICAqL1xyXG4gIHVwZGF0ZUNvbXBvbmVudDogJ09WRVJSSURFX0JBU0UnXHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cclxuICpcclxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxyXG4gKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXHJcbiAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXHJcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXHJcbiAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cclxuICovXHJcbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XHJcbiAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcclxuICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XHJcbiAgfSxcclxuICBtaXhpbnM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XHJcbiAgICBpZiAobWl4aW5zKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzLCAnY2hpbGRDb250ZXh0Jyk7XHJcbiAgICB9XHJcbiAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHRUeXBlcyk7XHJcbiAgfSxcclxuICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgJ2NvbnRleHQnKTtcclxuICAgIH1cclxuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcclxuICB9LFxyXG4gIC8qKlxyXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xyXG4gICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxyXG4gICAqL1xyXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcclxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcclxuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLCBnZXREZWZhdWx0UHJvcHMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcHJvcFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsICdwcm9wJyk7XHJcbiAgICB9XHJcbiAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XHJcbiAgfSxcclxuICBzdGF0aWNzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcclxuICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcclxuICB9LFxyXG4gIGF1dG9iaW5kOiBmdW5jdGlvbiAoKSB7fSB9O1xyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xyXG4gIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcclxuICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xyXG4gICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gaW52YXJpYW50IHNvIGNvbXBvbmVudHNcclxuICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBvbmx5IGluIF9fREVWX19cclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogdm9pZCAwO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKSB7XHJcbiAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXSA6IG51bGw7XHJcblxyXG4gIC8vIERpc2FsbG93IG92ZXJyaWRpbmcgb2YgYmFzZSBjbGFzcyBtZXRob2RzIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXHJcbiAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgIShzcGVjUG9saWN5ID09PSAnT1ZFUlJJREVfQkFTRScpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSBgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyBkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzMnLCBuYW1lKSA6IHZvaWQgMDtcclxuICB9XHJcblxyXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cclxuICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xyXG4gICAgIShzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknIHx8IHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGAlc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc0JywgbmFtZSkgOiB2b2lkIDA7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXHJcbiAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xyXG4gIGlmICghc3BlYykge1xyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgdmFyIHR5cGVvZlNwZWMgPSB0eXBlb2Ygc3BlYztcclxuICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XHJcblxyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpc01peGluVmFsaWQsICclczogWW91XFwncmUgYXR0ZW1wdGluZyB0byBpbmNsdWRlIGEgbWl4aW4gdGhhdCBpcyBlaXRoZXIgbnVsbCAnICsgJ29yIG5vdCBhbiBvYmplY3QuIENoZWNrIHRoZSBtaXhpbnMgaW5jbHVkZWQgYnkgdGhlIGNvbXBvbmVudCwgJyArICdhcyB3ZWxsIGFzIGFueSBtaXhpbnMgdGhleSBpbmNsdWRlIHRoZW1zZWx2ZXMuICcgKyAnRXhwZWN0ZWQgb2JqZWN0IGJ1dCBnb3QgJXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBzcGVjID09PSBudWxsID8gbnVsbCA6IHR5cGVvZlNwZWMpIDogdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gICEodHlwZW9mIHNwZWMgIT09ICdmdW5jdGlvbicpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdXNlIGEgY29tcG9uZW50IGNsYXNzIG9yIGZ1bmN0aW9uIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBfcHJvZEludmFyaWFudCgnNzUnKSA6IHZvaWQgMDtcclxuICAhIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzcGVjKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc2JykgOiB2b2lkIDA7XHJcblxyXG4gIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcclxuICB2YXIgYXV0b0JpbmRQYWlycyA9IHByb3RvLl9fcmVhY3RBdXRvQmluZFBhaXJzO1xyXG5cclxuICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcclxuICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcclxuICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cclxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xyXG4gICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XHJcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcclxuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgbWl4aW5zIGluIGEgc3BlY2lhbCBjYXNlIGFib3ZlLlxyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xyXG4gICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcclxuICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XHJcblxyXG4gICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxyXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcclxuICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXHJcbiAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cclxuICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XHJcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xyXG4gICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPSBpc0Z1bmN0aW9uICYmICFpc1JlYWN0Q2xhc3NNZXRob2QgJiYgIWlzQWxyZWFkeURlZmluZWQgJiYgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcclxuICAgICAgICBhdXRvQmluZFBhaXJzLnB1c2gobmFtZSwgcHJvcGVydHkpO1xyXG4gICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcclxuICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcclxuXHJcbiAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cclxuICAgICAgICAgICEoaXNSZWFjdENsYXNzTWV0aG9kICYmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyB8fCBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzIHdoZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLCBzcGVjUG9saWN5LCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3NycsIHNwZWNQb2xpY3ksIG5hbWUpIDogdm9pZCAwO1xyXG5cclxuICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xyXG4gICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxyXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSB7XHJcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykge1xyXG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xyXG4gICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcclxuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcclxuICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xyXG4gIGlmICghc3RhdGljcykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcclxuICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XHJcbiAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUztcclxuICAgICEhaXNSZXNlcnZlZCA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgcHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0IGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IGluc3RlYWQ7IGl0IHdpbGwgc3RpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IuJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzgnLCBuYW1lKSA6IHZvaWQgMDtcclxuXHJcbiAgICB2YXIgaXNJbmhlcml0ZWQgPSBuYW1lIGluIENvbnN0cnVjdG9yO1xyXG4gICAgISFpc0luaGVyaXRlZCA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGAlc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc5JywgbmFtZSkgOiB2b2lkIDA7XHJcbiAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XHJcbiAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcclxuICAhKG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLicpIDogX3Byb2RJbnZhcmlhbnQoJzgwJykgOiB2b2lkIDA7XHJcblxyXG4gIGZvciAodmFyIGtleSBpbiB0d28pIHtcclxuICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAhKG9uZVtrZXldID09PSB1bmRlZmluZWQpID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvIGdldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgd2l0aCBjbGFzaGluZyBrZXlzLicsIGtleSkgOiBfcHJvZEludmFyaWFudCgnODEnLCBrZXkpIDogdm9pZCAwO1xyXG4gICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gb25lO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cclxuICpcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXHJcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xyXG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XHJcbiAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIGlmIChhID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGI7XHJcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuICAgIHZhciBjID0ge307XHJcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGEpO1xyXG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcclxuICAgIHJldHVybiBjO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cclxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xyXG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XHJcbiAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXHJcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxyXG4gKi9cclxuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XHJcbiAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcclxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcclxuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcclxuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XHJcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcclxuICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XHJcbiAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24gKG5ld1RoaXMpIHtcclxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXHJcbiAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xyXG4gICAgICAvLyBsZXQncyB3YXJuLlxyXG4gICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgKyAnY29tcG9uZW50IGluc3RhbmNlLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcclxuICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcclxuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcclxuICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcclxuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xyXG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcclxuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xyXG4gICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiBib3VuZE1ldGhvZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cclxuICovXHJcbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XHJcbiAgdmFyIHBhaXJzID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgIHZhciBhdXRvQmluZEtleSA9IHBhaXJzW2ldO1xyXG4gICAgdmFyIG1ldGhvZCA9IHBhaXJzW2kgKyAxXTtcclxuICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxyXG4gKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxyXG4gKi9cclxudmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XHJcbiAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxyXG4gICAqL1xyXG4gIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKG5ld1N0YXRlLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUpO1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBmaW5hbFxyXG4gICAqL1xyXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlci5pc01vdW50ZWQodGhpcyk7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIFJlYWN0Q2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7fTtcclxuX2Fzc2lnbihSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENsYXNzTWl4aW4pO1xyXG5cclxuLyoqXHJcbiAqIE1vZHVsZSBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBjbGFzcyBSZWFjdENsYXNzXHJcbiAqL1xyXG52YXIgUmVhY3RDbGFzcyA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxyXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxyXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGNyZWF0ZUNsYXNzOiBmdW5jdGlvbiAoc3BlYykge1xyXG4gICAgLy8gVG8ga2VlcCBvdXIgd2FybmluZ3MgbW9yZSB1bmRlcnN0YW5kYWJsZSwgd2UnbGwgdXNlIGEgbGl0dGxlIGhhY2sgaGVyZSB0b1xyXG4gICAgLy8gZW5zdXJlIHRoYXQgQ29uc3RydWN0b3IubmFtZSAhPT0gJ0NvbnN0cnVjdG9yJy4gVGhpcyBtYWtlcyBzdXJlIHdlIGRvbid0XHJcbiAgICAvLyB1bm5lY2Vzc2FyaWx5IGlkZW50aWZ5IGEgY2xhc3Mgd2l0aG91dCBkaXNwbGF5TmFtZSBhcyAnQ29uc3RydWN0b3InLlxyXG4gICAgdmFyIENvbnN0cnVjdG9yID0gaWRlbnRpdHkoZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XHJcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgZ2V0cyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxyXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXHJcblxyXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHRoaXMgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvciwgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgKyAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5JykgOiB2b2lkIDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXHJcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZFBhaXJzLmxlbmd0aCkge1xyXG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcclxuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XHJcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XHJcblxyXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcclxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXHJcblxyXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcclxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cclxuICAgICAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRJbml0aWFsU3RhdGUuX2lzTW9ja0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxyXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cclxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnODInLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcclxuXHJcbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XHJcbiAgICB9KTtcclxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XHJcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcclxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5fX3JlYWN0QXV0b0JpbmRQYWlycyA9IFtdO1xyXG5cclxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xyXG5cclxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxyXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xyXG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXHJcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXHJcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XHJcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cclxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xyXG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XHJcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nKSA6IF9wcm9kSW52YXJpYW50KCc4MycpIDogdm9pZCAwO1xyXG5cclxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcclxuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxyXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENsYXNzSW50ZXJmYWNlKSB7XHJcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XHJcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcclxuICB9LFxyXG5cclxuICBpbmplY3Rpb246IHtcclxuICAgIGluamVjdE1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcclxuICAgICAgaW5qZWN0ZWRNaXhpbnMucHVzaChtaXhpbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDbGFzczsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xyXG5cclxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xyXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xyXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gUmVhY3RDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcclxuICB0aGlzLnByb3BzID0gcHJvcHM7XHJcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcclxuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxyXG4gIC8vIHJlbmRlcmVyLlxyXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XHJcbn1cclxuXHJcblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XHJcblxyXG4vKipcclxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcclxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cclxuICpcclxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cclxuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cclxuICpcclxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxyXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcclxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcclxuICogY29tcGxldGVkLlxyXG4gKlxyXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cclxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXHJcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XHJcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXHJcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXHJcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXHJcbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxyXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXHJcbiAqIEBmaW5hbFxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqL1xyXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xyXG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiBfcHJvZEludmFyaWFudCgnODUnKSA6IHZvaWQgMDtcclxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XHJcbiAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxyXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cclxuICpcclxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxyXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cclxuICpcclxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxyXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxyXG4gKlxyXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cclxuICogQGZpbmFsXHJcbiAqIEBwcm90ZWN0ZWRcclxuICovXHJcblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XHJcbiAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxyXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xyXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cclxuICovXHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xyXG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxyXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cclxuICB9O1xyXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xyXG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKSA6IHZvaWQgMDtcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xyXG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcclxuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50OyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbmZ1bmN0aW9uIGlzTmF0aXZlKGZuKSB7XHJcbiAgLy8gQmFzZWQgb24gaXNOYXRpdmUoKSBmcm9tIExvZGFzaFxyXG4gIHZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XHJcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgKyBmdW5jVG9TdHJpbmdcclxuICAvLyBUYWtlIGFuIGV4YW1wbGUgbmF0aXZlIGZ1bmN0aW9uIHNvdXJjZSBmb3IgY29tcGFyaXNvblxyXG4gIC5jYWxsKGhhc093blByb3BlcnR5KVxyXG4gIC8vIFN0cmlwIHJlZ2V4IGNoYXJhY3RlcnMgc28gd2UgY2FuIHVzZSBpdCBmb3IgcmVnZXhcclxuICAucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxyXG4gIC8vIFJlbW92ZSBoYXNPd25Qcm9wZXJ0eSBmcm9tIHRoZSB0ZW1wbGF0ZSB0byBtYWtlIGl0IGdlbmVyaWNcclxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCcpO1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgc291cmNlID0gZnVuY1RvU3RyaW5nLmNhbGwoZm4pO1xyXG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChzb3VyY2UpO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGNhblVzZUNvbGxlY3Rpb25zID1cclxuLy8gQXJyYXkuZnJvbVxyXG50eXBlb2YgQXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4vLyBNYXBcclxudHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXApICYmXHJcbi8vIE1hcC5wcm90b3R5cGUua2V5c1xyXG5NYXAucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXAucHJvdG90eXBlLmtleXMpICYmXHJcbi8vIFNldFxyXG50eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldCkgJiZcclxuLy8gU2V0LnByb3RvdHlwZS5rZXlzXHJcblNldC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldC5wcm90b3R5cGUua2V5cyk7XHJcblxyXG52YXIgc2V0SXRlbTtcclxudmFyIGdldEl0ZW07XHJcbnZhciByZW1vdmVJdGVtO1xyXG52YXIgZ2V0SXRlbUlEcztcclxudmFyIGFkZFJvb3Q7XHJcbnZhciByZW1vdmVSb290O1xyXG52YXIgZ2V0Um9vdElEcztcclxuXHJcbmlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xyXG4gIHZhciBpdGVtTWFwID0gbmV3IE1hcCgpO1xyXG4gIHZhciByb290SURTZXQgPSBuZXcgU2V0KCk7XHJcblxyXG4gIHNldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcclxuICAgIGl0ZW1NYXAuc2V0KGlkLCBpdGVtKTtcclxuICB9O1xyXG4gIGdldEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHJldHVybiBpdGVtTWFwLmdldChpZCk7XHJcbiAgfTtcclxuICByZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICBpdGVtTWFwWydkZWxldGUnXShpZCk7XHJcbiAgfTtcclxuICBnZXRJdGVtSURzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oaXRlbU1hcC5rZXlzKCkpO1xyXG4gIH07XHJcblxyXG4gIGFkZFJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHJvb3RJRFNldC5hZGQoaWQpO1xyXG4gIH07XHJcbiAgcmVtb3ZlUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgcm9vdElEU2V0WydkZWxldGUnXShpZCk7XHJcbiAgfTtcclxuICBnZXRSb290SURzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20ocm9vdElEU2V0LmtleXMoKSk7XHJcbiAgfTtcclxufSBlbHNlIHtcclxuICB2YXIgaXRlbUJ5S2V5ID0ge307XHJcbiAgdmFyIHJvb3RCeUtleSA9IHt9O1xyXG5cclxuICAvLyBVc2Ugbm9uLW51bWVyaWMga2V5cyB0byBwcmV2ZW50IFY4IHBlcmZvcm1hbmNlIGlzc3VlczpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXHJcbiAgdmFyIGdldEtleUZyb21JRCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgcmV0dXJuICcuJyArIGlkO1xyXG4gIH07XHJcbiAgdmFyIGdldElERnJvbUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiBwYXJzZUludChrZXkuc3Vic3RyKDEpLCAxMCk7XHJcbiAgfTtcclxuXHJcbiAgc2V0SXRlbSA9IGZ1bmN0aW9uIChpZCwgaXRlbSkge1xyXG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XHJcbiAgICBpdGVtQnlLZXlba2V5XSA9IGl0ZW07XHJcbiAgfTtcclxuICBnZXRJdGVtID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcclxuICAgIHJldHVybiBpdGVtQnlLZXlba2V5XTtcclxuICB9O1xyXG4gIHJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xyXG4gICAgZGVsZXRlIGl0ZW1CeUtleVtrZXldO1xyXG4gIH07XHJcbiAgZ2V0SXRlbUlEcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtQnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xyXG4gIH07XHJcblxyXG4gIGFkZFJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xyXG4gICAgcm9vdEJ5S2V5W2tleV0gPSB0cnVlO1xyXG4gIH07XHJcbiAgcmVtb3ZlUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XHJcbiAgICBkZWxldGUgcm9vdEJ5S2V5W2tleV07XHJcbiAgfTtcclxuICBnZXRSb290SURzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3RCeUtleSkubWFwKGdldElERnJvbUtleSk7XHJcbiAgfTtcclxufVxyXG5cclxudmFyIHVubW91bnRlZElEcyA9IFtdO1xyXG5cclxuZnVuY3Rpb24gcHVyZ2VEZWVwKGlkKSB7XHJcbiAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcclxuICBpZiAoaXRlbSkge1xyXG4gICAgdmFyIGNoaWxkSURzID0gaXRlbS5jaGlsZElEcztcclxuXHJcbiAgICByZW1vdmVJdGVtKGlkKTtcclxuICAgIGNoaWxkSURzLmZvckVhY2gocHVyZ2VEZWVwKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcclxuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShlbGVtZW50KSB7XHJcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuICcjZW1wdHknO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xyXG4gICAgcmV0dXJuICcjdGV4dCc7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZXNjcmliZUlEKGlkKSB7XHJcbiAgdmFyIG5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKTtcclxuICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XHJcbiAgdmFyIG93bmVySUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQoaWQpO1xyXG4gIHZhciBvd25lck5hbWU7XHJcbiAgaWYgKG93bmVySUQpIHtcclxuICAgIG93bmVyTmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUob3duZXJJRCk7XHJcbiAgfVxyXG4gIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQsICdSZWFjdENvbXBvbmVudFRyZWVIb29rOiBNaXNzaW5nIFJlYWN0IGVsZW1lbnQgZm9yIGRlYnVnSUQgJXMgd2hlbiAnICsgJ2J1aWxkaW5nIHN0YWNrJywgaWQpIDogdm9pZCAwO1xyXG4gIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGVsZW1lbnQgJiYgZWxlbWVudC5fc291cmNlLCBvd25lck5hbWUpO1xyXG59XHJcblxyXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHtcclxuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoaWQsIG5leHRDaGlsZElEcykge1xyXG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcclxuICAgICFpdGVtID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0l0ZW0gbXVzdCBoYXZlIGJlZW4gc2V0JykgOiBfcHJvZEludmFyaWFudCgnMTQ0JykgOiB2b2lkIDA7XHJcbiAgICBpdGVtLmNoaWxkSURzID0gbmV4dENoaWxkSURzO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dENoaWxkSURzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBuZXh0Q2hpbGRJRCA9IG5leHRDaGlsZElEc1tpXTtcclxuICAgICAgdmFyIG5leHRDaGlsZCA9IGdldEl0ZW0obmV4dENoaWxkSUQpO1xyXG4gICAgICAhbmV4dENoaWxkID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGhvb2sgZXZlbnRzIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQwJykgOiB2b2lkIDA7XHJcbiAgICAgICEobmV4dENoaWxkLmNoaWxkSURzICE9IG51bGwgfHwgdHlwZW9mIG5leHRDaGlsZC5lbGVtZW50ICE9PSAnb2JqZWN0JyB8fCBuZXh0Q2hpbGQuZWxlbWVudCA9PSBudWxsKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvblNldENoaWxkcmVuKCkgdG8gZmlyZSBmb3IgYSBjb250YWluZXIgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MScpIDogdm9pZCAwO1xyXG4gICAgICAhbmV4dENoaWxkLmlzTW91bnRlZCA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbk1vdW50Q29tcG9uZW50KCkgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCc3MScpIDogdm9pZCAwO1xyXG4gICAgICBpZiAobmV4dENoaWxkLnBhcmVudElEID09IG51bGwpIHtcclxuICAgICAgICBuZXh0Q2hpbGQucGFyZW50SUQgPSBpZDtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgYnV0IG1vdW50aW5nIGEgbmV3IHJvb3QgZHVyaW5nIGluXHJcbiAgICAgICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGN1cnJlbnRseSBjYXVzZXMgbm90LXlldC1tb3VudGVkIGNvbXBvbmVudHMgdG9cclxuICAgICAgICAvLyBiZSBwdXJnZWQgZnJvbSBvdXIgdHJlZSBkYXRhIHNvIHRoZWlyIHBhcmVudCBpZCBpcyBtaXNzaW5nLlxyXG4gICAgICB9XHJcbiAgICAgICEobmV4dENoaWxkLnBhcmVudElEID09PSBpZCkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25CZWZvcmVNb3VudENvbXBvbmVudCgpIHBhcmVudCBhbmQgb25TZXRDaGlsZHJlbigpIHRvIGJlIGNvbnNpc3RlbnQgKCVzIGhhcyBwYXJlbnRzICVzIGFuZCAlcykuJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogX3Byb2RJbnZhcmlhbnQoJzE0MicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IHZvaWQgMDtcclxuICAgIH1cclxuICB9LFxyXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgcGFyZW50SUQpIHtcclxuICAgIHZhciBpdGVtID0ge1xyXG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICBwYXJlbnRJRDogcGFyZW50SUQsXHJcbiAgICAgIHRleHQ6IG51bGwsXHJcbiAgICAgIGNoaWxkSURzOiBbXSxcclxuICAgICAgaXNNb3VudGVkOiBmYWxzZSxcclxuICAgICAgdXBkYXRlQ291bnQ6IDBcclxuICAgIH07XHJcbiAgICBzZXRJdGVtKGlkLCBpdGVtKTtcclxuICB9LFxyXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQpIHtcclxuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XHJcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XHJcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXHJcbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpdGVtLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gIH0sXHJcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xyXG4gICAgIWl0ZW0gPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSXRlbSBtdXN0IGhhdmUgYmVlbiBzZXQnKSA6IF9wcm9kSW52YXJpYW50KCcxNDQnKSA6IHZvaWQgMDtcclxuICAgIGl0ZW0uaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xyXG4gICAgaWYgKGlzUm9vdCkge1xyXG4gICAgICBhZGRSb290KGlkKTtcclxuICAgIH1cclxuICB9LFxyXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XHJcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XHJcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXHJcbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpdGVtLnVwZGF0ZUNvdW50Kys7XHJcbiAgfSxcclxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcclxuICAgIGlmIChpdGVtKSB7XHJcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgaXQgZXhpc3RzLlxyXG4gICAgICAvLyBgaXRlbWAgbWlnaHQgbm90IGV4aXN0IGlmIGl0IGlzIGluc2lkZSBhbiBlcnJvciBib3VuZGFyeSwgYW5kIGEgc2libGluZ1xyXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSBjaGlsZCB0aHJldyB3aGlsZSBtb3VudGluZy4gVGhlbiB0aGlzIGluc3RhbmNlIG5ldmVyXHJcbiAgICAgIC8vIGdvdCBhIGNoYW5jZSB0byBtb3VudCwgYnV0IGl0IHN0aWxsIGdldHMgYW4gdW5tb3VudGluZyBldmVudCBkdXJpbmdcclxuICAgICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGNsZWFudXAuXHJcbiAgICAgIGl0ZW0uaXNNb3VudGVkID0gZmFsc2U7XHJcbiAgICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xyXG4gICAgICBpZiAoaXNSb290KSB7XHJcbiAgICAgICAgcmVtb3ZlUm9vdChpZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHVubW91bnRlZElEcy5wdXNoKGlkKTtcclxuICB9LFxyXG4gIHB1cmdlVW5tb3VudGVkQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKFJlYWN0Q29tcG9uZW50VHJlZUhvb2suX3ByZXZlbnRQdXJnaW5nKSB7XHJcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RpbmcuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVubW91bnRlZElEcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgaWQgPSB1bm1vdW50ZWRJRHNbaV07XHJcbiAgICAgIHB1cmdlRGVlcChpZCk7XHJcbiAgICB9XHJcbiAgICB1bm1vdW50ZWRJRHMubGVuZ3RoID0gMDtcclxuICB9LFxyXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xyXG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlzTW91bnRlZCA6IGZhbHNlO1xyXG4gIH0sXHJcbiAgZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW06IGZ1bmN0aW9uICh0b3BFbGVtZW50KSB7XHJcbiAgICB2YXIgaW5mbyA9ICcnO1xyXG4gICAgaWYgKHRvcEVsZW1lbnQpIHtcclxuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZSh0b3BFbGVtZW50KTtcclxuICAgICAgdmFyIG93bmVyID0gdG9wRWxlbWVudC5fb3duZXI7XHJcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCB0b3BFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGN1cnJlbnRPd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XHJcbiAgICB2YXIgaWQgPSBjdXJyZW50T3duZXIgJiYgY3VycmVudE93bmVyLl9kZWJ1Z0lEO1xyXG5cclxuICAgIGluZm8gKz0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChpZCk7XHJcbiAgICByZXR1cm4gaW5mbztcclxuICB9LFxyXG4gIGdldFN0YWNrQWRkZW5kdW1CeUlEOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHZhciBpbmZvID0gJyc7XHJcbiAgICB3aGlsZSAoaWQpIHtcclxuICAgICAgaW5mbyArPSBkZXNjcmliZUlEKGlkKTtcclxuICAgICAgaWQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbmZvO1xyXG4gIH0sXHJcbiAgZ2V0Q2hpbGRJRHM6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcclxuICAgIHJldHVybiBpdGVtID8gaXRlbS5jaGlsZElEcyA6IFtdO1xyXG4gIH0sXHJcbiAgZ2V0RGlzcGxheU5hbWU6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpO1xyXG4gIH0sXHJcbiAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xyXG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xyXG4gIH0sXHJcbiAgZ2V0T3duZXJJRDogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XHJcbiAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuX293bmVyKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsZW1lbnQuX293bmVyLl9kZWJ1Z0lEO1xyXG4gIH0sXHJcbiAgZ2V0UGFyZW50SUQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcclxuICAgIHJldHVybiBpdGVtID8gaXRlbS5wYXJlbnRJRCA6IG51bGw7XHJcbiAgfSxcclxuICBnZXRTb3VyY2U6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcclxuICAgIHZhciBlbGVtZW50ID0gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XHJcbiAgICB2YXIgc291cmNlID0gZWxlbWVudCAhPSBudWxsID8gZWxlbWVudC5fc291cmNlIDogbnVsbDtcclxuICAgIHJldHVybiBzb3VyY2U7XHJcbiAgfSxcclxuICBnZXRUZXh0OiBmdW5jdGlvbiAoaWQpIHtcclxuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcclxuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xyXG4gICAgICByZXR1cm4gJycgKyBlbGVtZW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfSxcclxuICBnZXRVcGRhdGVDb3VudDogZnVuY3Rpb24gKGlkKSB7XHJcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xyXG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnVwZGF0ZUNvdW50IDogMDtcclxuICB9LFxyXG5cclxuXHJcbiAgZ2V0Um9vdElEczogZ2V0Um9vdElEcyxcclxuICBnZXRSZWdpc3RlcmVkSURzOiBnZXRJdGVtSURzXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cclxuICpcclxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxyXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXHJcbiAqL1xyXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cclxuICAgKi9cclxuICBjdXJyZW50OiBudWxsXHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEN1cnJlbnRPd25lcjsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBIVE1MIHRhZyBlbGVtZW50cy5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XHJcbiAgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cclxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSB7XHJcbiAgYTogY3JlYXRlRE9NRmFjdG9yeSgnYScpLFxyXG4gIGFiYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2FiYnInKSxcclxuICBhZGRyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdhZGRyZXNzJyksXHJcbiAgYXJlYTogY3JlYXRlRE9NRmFjdG9yeSgnYXJlYScpLFxyXG4gIGFydGljbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FydGljbGUnKSxcclxuICBhc2lkZTogY3JlYXRlRE9NRmFjdG9yeSgnYXNpZGUnKSxcclxuICBhdWRpbzogY3JlYXRlRE9NRmFjdG9yeSgnYXVkaW8nKSxcclxuICBiOiBjcmVhdGVET01GYWN0b3J5KCdiJyksXHJcbiAgYmFzZTogY3JlYXRlRE9NRmFjdG9yeSgnYmFzZScpLFxyXG4gIGJkaTogY3JlYXRlRE9NRmFjdG9yeSgnYmRpJyksXHJcbiAgYmRvOiBjcmVhdGVET01GYWN0b3J5KCdiZG8nKSxcclxuICBiaWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2JpZycpLFxyXG4gIGJsb2NrcXVvdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jsb2NrcXVvdGUnKSxcclxuICBib2R5OiBjcmVhdGVET01GYWN0b3J5KCdib2R5JyksXHJcbiAgYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2JyJyksXHJcbiAgYnV0dG9uOiBjcmVhdGVET01GYWN0b3J5KCdidXR0b24nKSxcclxuICBjYW52YXM6IGNyZWF0ZURPTUZhY3RvcnkoJ2NhbnZhcycpLFxyXG4gIGNhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2NhcHRpb24nKSxcclxuICBjaXRlOiBjcmVhdGVET01GYWN0b3J5KCdjaXRlJyksXHJcbiAgY29kZTogY3JlYXRlRE9NRmFjdG9yeSgnY29kZScpLFxyXG4gIGNvbDogY3JlYXRlRE9NRmFjdG9yeSgnY29sJyksXHJcbiAgY29sZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbGdyb3VwJyksXHJcbiAgZGF0YTogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YScpLFxyXG4gIGRhdGFsaXN0OiBjcmVhdGVET01GYWN0b3J5KCdkYXRhbGlzdCcpLFxyXG4gIGRkOiBjcmVhdGVET01GYWN0b3J5KCdkZCcpLFxyXG4gIGRlbDogY3JlYXRlRE9NRmFjdG9yeSgnZGVsJyksXHJcbiAgZGV0YWlsczogY3JlYXRlRE9NRmFjdG9yeSgnZGV0YWlscycpLFxyXG4gIGRmbjogY3JlYXRlRE9NRmFjdG9yeSgnZGZuJyksXHJcbiAgZGlhbG9nOiBjcmVhdGVET01GYWN0b3J5KCdkaWFsb2cnKSxcclxuICBkaXY6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpdicpLFxyXG4gIGRsOiBjcmVhdGVET01GYWN0b3J5KCdkbCcpLFxyXG4gIGR0OiBjcmVhdGVET01GYWN0b3J5KCdkdCcpLFxyXG4gIGVtOiBjcmVhdGVET01GYWN0b3J5KCdlbScpLFxyXG4gIGVtYmVkOiBjcmVhdGVET01GYWN0b3J5KCdlbWJlZCcpLFxyXG4gIGZpZWxkc2V0OiBjcmVhdGVET01GYWN0b3J5KCdmaWVsZHNldCcpLFxyXG4gIGZpZ2NhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ2NhcHRpb24nKSxcclxuICBmaWd1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ3VyZScpLFxyXG4gIGZvb3RlcjogY3JlYXRlRE9NRmFjdG9yeSgnZm9vdGVyJyksXHJcbiAgZm9ybTogY3JlYXRlRE9NRmFjdG9yeSgnZm9ybScpLFxyXG4gIGgxOiBjcmVhdGVET01GYWN0b3J5KCdoMScpLFxyXG4gIGgyOiBjcmVhdGVET01GYWN0b3J5KCdoMicpLFxyXG4gIGgzOiBjcmVhdGVET01GYWN0b3J5KCdoMycpLFxyXG4gIGg0OiBjcmVhdGVET01GYWN0b3J5KCdoNCcpLFxyXG4gIGg1OiBjcmVhdGVET01GYWN0b3J5KCdoNScpLFxyXG4gIGg2OiBjcmVhdGVET01GYWN0b3J5KCdoNicpLFxyXG4gIGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWQnKSxcclxuICBoZWFkZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWRlcicpLFxyXG4gIGhncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnaGdyb3VwJyksXHJcbiAgaHI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hyJyksXHJcbiAgaHRtbDogY3JlYXRlRE9NRmFjdG9yeSgnaHRtbCcpLFxyXG4gIGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2knKSxcclxuICBpZnJhbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ2lmcmFtZScpLFxyXG4gIGltZzogY3JlYXRlRE9NRmFjdG9yeSgnaW1nJyksXHJcbiAgaW5wdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucHV0JyksXHJcbiAgaW5zOiBjcmVhdGVET01GYWN0b3J5KCdpbnMnKSxcclxuICBrYmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2tiZCcpLFxyXG4gIGtleWdlbjogY3JlYXRlRE9NRmFjdG9yeSgna2V5Z2VuJyksXHJcbiAgbGFiZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2xhYmVsJyksXHJcbiAgbGVnZW5kOiBjcmVhdGVET01GYWN0b3J5KCdsZWdlbmQnKSxcclxuICBsaTogY3JlYXRlRE9NRmFjdG9yeSgnbGknKSxcclxuICBsaW5rOiBjcmVhdGVET01GYWN0b3J5KCdsaW5rJyksXHJcbiAgbWFpbjogY3JlYXRlRE9NRmFjdG9yeSgnbWFpbicpLFxyXG4gIG1hcDogY3JlYXRlRE9NRmFjdG9yeSgnbWFwJyksXHJcbiAgbWFyazogY3JlYXRlRE9NRmFjdG9yeSgnbWFyaycpLFxyXG4gIG1lbnU6IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnUnKSxcclxuICBtZW51aXRlbTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudWl0ZW0nKSxcclxuICBtZXRhOiBjcmVhdGVET01GYWN0b3J5KCdtZXRhJyksXHJcbiAgbWV0ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGVyJyksXHJcbiAgbmF2OiBjcmVhdGVET01GYWN0b3J5KCduYXYnKSxcclxuICBub3NjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnbm9zY3JpcHQnKSxcclxuICBvYmplY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ29iamVjdCcpLFxyXG4gIG9sOiBjcmVhdGVET01GYWN0b3J5KCdvbCcpLFxyXG4gIG9wdGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdvcHRncm91cCcpLFxyXG4gIG9wdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnb3B0aW9uJyksXHJcbiAgb3V0cHV0OiBjcmVhdGVET01GYWN0b3J5KCdvdXRwdXQnKSxcclxuICBwOiBjcmVhdGVET01GYWN0b3J5KCdwJyksXHJcbiAgcGFyYW06IGNyZWF0ZURPTUZhY3RvcnkoJ3BhcmFtJyksXHJcbiAgcGljdHVyZTogY3JlYXRlRE9NRmFjdG9yeSgncGljdHVyZScpLFxyXG4gIHByZTogY3JlYXRlRE9NRmFjdG9yeSgncHJlJyksXHJcbiAgcHJvZ3Jlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ3Byb2dyZXNzJyksXHJcbiAgcTogY3JlYXRlRE9NRmFjdG9yeSgncScpLFxyXG4gIHJwOiBjcmVhdGVET01GYWN0b3J5KCdycCcpLFxyXG4gIHJ0OiBjcmVhdGVET01GYWN0b3J5KCdydCcpLFxyXG4gIHJ1Ynk6IGNyZWF0ZURPTUZhY3RvcnkoJ3J1YnknKSxcclxuICBzOiBjcmVhdGVET01GYWN0b3J5KCdzJyksXHJcbiAgc2FtcDogY3JlYXRlRE9NRmFjdG9yeSgnc2FtcCcpLFxyXG4gIHNjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnc2NyaXB0JyksXHJcbiAgc2VjdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnc2VjdGlvbicpLFxyXG4gIHNlbGVjdDogY3JlYXRlRE9NRmFjdG9yeSgnc2VsZWN0JyksXHJcbiAgc21hbGw6IGNyZWF0ZURPTUZhY3RvcnkoJ3NtYWxsJyksXHJcbiAgc291cmNlOiBjcmVhdGVET01GYWN0b3J5KCdzb3VyY2UnKSxcclxuICBzcGFuOiBjcmVhdGVET01GYWN0b3J5KCdzcGFuJyksXHJcbiAgc3Ryb25nOiBjcmVhdGVET01GYWN0b3J5KCdzdHJvbmcnKSxcclxuICBzdHlsZTogY3JlYXRlRE9NRmFjdG9yeSgnc3R5bGUnKSxcclxuICBzdWI6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1YicpLFxyXG4gIHN1bW1hcnk6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1bW1hcnknKSxcclxuICBzdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1cCcpLFxyXG4gIHRhYmxlOiBjcmVhdGVET01GYWN0b3J5KCd0YWJsZScpLFxyXG4gIHRib2R5OiBjcmVhdGVET01GYWN0b3J5KCd0Ym9keScpLFxyXG4gIHRkOiBjcmVhdGVET01GYWN0b3J5KCd0ZCcpLFxyXG4gIHRleHRhcmVhOiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0YXJlYScpLFxyXG4gIHRmb290OiBjcmVhdGVET01GYWN0b3J5KCd0Zm9vdCcpLFxyXG4gIHRoOiBjcmVhdGVET01GYWN0b3J5KCd0aCcpLFxyXG4gIHRoZWFkOiBjcmVhdGVET01GYWN0b3J5KCd0aGVhZCcpLFxyXG4gIHRpbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpbWUnKSxcclxuICB0aXRsZTogY3JlYXRlRE9NRmFjdG9yeSgndGl0bGUnKSxcclxuICB0cjogY3JlYXRlRE9NRmFjdG9yeSgndHInKSxcclxuICB0cmFjazogY3JlYXRlRE9NRmFjdG9yeSgndHJhY2snKSxcclxuICB1OiBjcmVhdGVET01GYWN0b3J5KCd1JyksXHJcbiAgdWw6IGNyZWF0ZURPTUZhY3RvcnkoJ3VsJyksXHJcbiAgJ3Zhcic6IGNyZWF0ZURPTUZhY3RvcnkoJ3ZhcicpLFxyXG4gIHZpZGVvOiBjcmVhdGVET01GYWN0b3J5KCd2aWRlbycpLFxyXG4gIHdicjogY3JlYXRlRE9NRmFjdG9yeSgnd2JyJyksXHJcblxyXG4gIC8vIFNWR1xyXG4gIGNpcmNsZTogY3JlYXRlRE9NRmFjdG9yeSgnY2lyY2xlJyksXHJcbiAgY2xpcFBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ2NsaXBQYXRoJyksXHJcbiAgZGVmczogY3JlYXRlRE9NRmFjdG9yeSgnZGVmcycpLFxyXG4gIGVsbGlwc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2VsbGlwc2UnKSxcclxuICBnOiBjcmVhdGVET01GYWN0b3J5KCdnJyksXHJcbiAgaW1hZ2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltYWdlJyksXHJcbiAgbGluZTogY3JlYXRlRE9NRmFjdG9yeSgnbGluZScpLFxyXG4gIGxpbmVhckdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdsaW5lYXJHcmFkaWVudCcpLFxyXG4gIG1hc2s6IGNyZWF0ZURPTUZhY3RvcnkoJ21hc2snKSxcclxuICBwYXRoOiBjcmVhdGVET01GYWN0b3J5KCdwYXRoJyksXHJcbiAgcGF0dGVybjogY3JlYXRlRE9NRmFjdG9yeSgncGF0dGVybicpLFxyXG4gIHBvbHlnb246IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlnb24nKSxcclxuICBwb2x5bGluZTogY3JlYXRlRE9NRmFjdG9yeSgncG9seWxpbmUnKSxcclxuICByYWRpYWxHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgncmFkaWFsR3JhZGllbnQnKSxcclxuICByZWN0OiBjcmVhdGVET01GYWN0b3J5KCdyZWN0JyksXHJcbiAgc3RvcDogY3JlYXRlRE9NRmFjdG9yeSgnc3RvcCcpLFxyXG4gIHN2ZzogY3JlYXRlRE9NRmFjdG9yeSgnc3ZnJyksXHJcbiAgdGV4dDogY3JlYXRlRE9NRmFjdG9yeSgndGV4dCcpLFxyXG4gIHRzcGFuOiBjcmVhdGVET01GYWN0b3J5KCd0c3BhbicpXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmFjdG9yaWVzOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xyXG5cclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcclxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xyXG5cclxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xyXG4gIGtleTogdHJ1ZSxcclxuICByZWY6IHRydWUsXHJcbiAgX19zZWxmOiB0cnVlLFxyXG4gIF9fc291cmNlOiB0cnVlXHJcbn07XHJcblxyXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xyXG5cclxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XHJcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcclxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XHJcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XHJcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcclxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XHJcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcclxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcclxuICAgIH1cclxuICB9O1xyXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xyXG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXHJcbiAgICBjb25maWd1cmFibGU6IHRydWVcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XHJcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcclxuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcclxuICAgIH1cclxuICB9O1xyXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xyXG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWVcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXHJcbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXHJcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXHJcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdHlwZVxyXG4gKiBAcGFyYW0geyp9IGtleVxyXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcclxuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxyXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xyXG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXHJcbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cclxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXHJcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXHJcbiAqIEBwYXJhbSB7Kn0gb3duZXJcclxuICogQHBhcmFtIHsqfSBwcm9wc1xyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XHJcbiAgdmFyIGVsZW1lbnQgPSB7XHJcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxyXG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcclxuXHJcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XHJcbiAgICB0eXBlOiB0eXBlLFxyXG4gICAga2V5OiBrZXksXHJcbiAgICByZWY6IHJlZixcclxuICAgIHByb3BzOiBwcm9wcyxcclxuXHJcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxyXG4gICAgX293bmVyOiBvd25lclxyXG4gIH07XHJcblxyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXHJcbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxyXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxyXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXHJcbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xyXG5cclxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXHJcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXHJcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xyXG4gICAgLy8gaWdub3JlcyBpdC5cclxuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICB2YWx1ZTogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICB2YWx1ZTogc2VsZlxyXG4gICAgICB9KTtcclxuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcclxuICAgICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICB2YWx1ZTogc291cmNlXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XHJcbiAgICAgIGVsZW1lbnQuX3NlbGYgPSBzZWxmO1xyXG4gICAgICBlbGVtZW50Ll9zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xyXG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xyXG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxyXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZWxlbWVudFxyXG4gKi9cclxuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xyXG4gIHZhciBwcm9wTmFtZTtcclxuXHJcbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxyXG4gIHZhciBwcm9wcyA9IHt9O1xyXG5cclxuICB2YXIga2V5ID0gbnVsbDtcclxuICB2YXIgcmVmID0gbnVsbDtcclxuICB2YXIgc2VsZiA9IG51bGw7XHJcbiAgdmFyIHNvdXJjZSA9IG51bGw7XHJcblxyXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xyXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcclxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcclxuICAgIH1cclxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XHJcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XHJcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XHJcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XHJcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xyXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xyXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxyXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xyXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xyXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xyXG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcclxuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XHJcbiAgICB9XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xyXG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcclxuICB9XHJcblxyXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xyXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XHJcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XHJcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xyXG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBpZiAoa2V5IHx8IHJlZikge1xyXG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XHJcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xyXG4gICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWYpIHtcclxuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXHJcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVmYWN0b3J5XHJcbiAqL1xyXG5SZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgdmFyIGZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xyXG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxyXG4gIC8vIGVhc2lseSBhY2Nlc3NlZCBvbiBlbGVtZW50cy4gRS5nLiBgPEZvbyAvPi50eXBlID09PSBGb29gLlxyXG4gIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBuYW1lZCBgY29uc3RydWN0b3JgIHNpbmNlIHRoaXMgbWF5IG5vdCBiZSB0aGUgZnVuY3Rpb25cclxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cclxuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcclxuICBmYWN0b3J5LnR5cGUgPSB0eXBlO1xyXG4gIHJldHVybiBmYWN0b3J5O1xyXG59O1xyXG5cclxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcclxuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xyXG5cclxuICByZXR1cm4gbmV3RWxlbWVudDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cclxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNsb25lZWxlbWVudFxyXG4gKi9cclxuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XHJcbiAgdmFyIHByb3BOYW1lO1xyXG5cclxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXHJcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XHJcblxyXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcclxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XHJcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xyXG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXHJcbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xyXG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcclxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXHJcbiAgLy8gdHJ1ZSBvd25lci5cclxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xyXG5cclxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXHJcbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XHJcblxyXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xyXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcclxuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXHJcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XHJcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcclxuICAgIH1cclxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XHJcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xyXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcclxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xyXG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xyXG4gICAgfVxyXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcclxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xyXG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xyXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cclxuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cclxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcclxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcclxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcclxuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xyXG4gICAgfVxyXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cclxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmlzdmFsaWRlbGVtZW50XHJcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXHJcbiAqIEBmaW5hbFxyXG4gKi9cclxuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4vKipcclxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcclxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcclxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcclxuICogdGhhdCBzdXBwb3J0IGl0LlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcclxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcclxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XHJcblxyXG52YXIgY2hlY2tSZWFjdFR5cGVTcGVjID0gcmVxdWlyZSgnLi9jaGVja1JlYWN0VHlwZVNwZWMnKTtcclxuXHJcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcclxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XHJcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcclxuICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXHJcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxyXG4gKiB1cGRhdGVzLlxyXG4gKi9cclxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XHJcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcclxuXHJcbiAgaWYgKCFpbmZvKSB7XHJcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcclxuICAgIGlmIChwYXJlbnROYW1lKSB7XHJcbiAgICAgIGluZm8gPSAnIENoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGluZm87XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXHJcbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxyXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cclxuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXHJcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxyXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcclxuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XHJcblxyXG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgfHwgKG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgPSB7fSk7XHJcblxyXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcclxuICBpZiAobWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgbWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xyXG5cclxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxyXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXHJcbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcclxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xyXG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXHJcbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nO1xyXG4gIH1cclxuXHJcbiAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KSkgOiB2b2lkIDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXHJcbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxyXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxyXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XHJcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XHJcbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XHJcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xyXG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cclxuICAgIGlmIChub2RlLl9zdG9yZSkge1xyXG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAobm9kZSkge1xyXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xyXG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cclxuICAgIGlmIChpdGVyYXRvckZuKSB7XHJcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XHJcbiAgICAgICAgdmFyIHN0ZXA7XHJcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xyXG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXHJcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xyXG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcclxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcclxuICBpZiAoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzKSB7XHJcbiAgICBjaGVja1JlYWN0VHlwZVNwZWMoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQsIG51bGwpO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xyXG4gIH1cclxufVxyXG5cclxudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHtcclxuXHJcbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xyXG4gICAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXHJcbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxyXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcclxuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHZhciBpbmZvID0gJyc7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgJ2l0XFwncyBkZWZpbmVkIGluLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbykgOiB2b2lkIDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cclxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cclxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcclxuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cclxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cclxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXHJcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXHJcbiAgICBpZiAodmFsaWRUeXBlKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH0sXHJcblxyXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XHJcbiAgICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcclxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xyXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJykgOiB2b2lkIDA7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcclxuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcclxuICB9LFxyXG5cclxuICBjbG9uZUVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcclxuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XHJcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcclxuICB9XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3I7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XHJcblxyXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcclxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxyXG4gKi9cclxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xyXG5cclxuICAvKipcclxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAZmluYWxcclxuICAgKi9cclxuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcclxuICAgKiBoYXZlIHByb2Nlc3NlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cclxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcclxuXHJcbiAgLyoqXHJcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxyXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxyXG4gICAqXHJcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxyXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxyXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xyXG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cclxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXHJcbiAgICpcclxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xyXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xyXG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcclxuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcclxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcclxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xyXG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROb29wVXBkYXRlUXVldWU7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XHJcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcclxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xyXG5cclxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XHJcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XHJcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xyXG5cclxuLyoqXHJcbiAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXHJcbiAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XHJcbiAqXHJcbiAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcclxuICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gKiAgICAgcHJvcFR5cGVzOiB7XHJcbiAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cclxuICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcclxuICpcclxuICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxyXG4gKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXHJcbiAqXHJcbiAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxyXG4gKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXHJcbiAqICAgICB9LFxyXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cclxuICogICB9KTtcclxuICpcclxuICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxyXG4gKlxyXG4gKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcclxuICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XHJcbiAqXHJcbiAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcclxuICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxyXG4gKlxyXG4gKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICogICAgcHJvcFR5cGVzOiB7XHJcbiAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxyXG4gKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xyXG4gKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcclxuICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxyXG4gKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xyXG4gKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxyXG4gKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXHJcbiAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxyXG4gKiAgICAgICAgICApO1xyXG4gKiAgICAgICAgfVxyXG4gKiAgICAgIH1cclxuICogICAgfSxcclxuICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XHJcbiAqICB9KTtcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5cclxudmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcclxuXHJcbnZhciBSZWFjdFByb3BUeXBlcyA9IHtcclxuICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXHJcbiAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcclxuICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcclxuICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcclxuICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcclxuICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcclxuICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcclxuXHJcbiAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxyXG4gIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcclxuICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcclxuICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxyXG4gIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXHJcbiAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXHJcbiAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcclxuICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXHJcbiAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXJcclxufTtcclxuXHJcbi8qKlxyXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xyXG4gKi9cclxuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xyXG5mdW5jdGlvbiBpcyh4LCB5KSB7XHJcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxyXG4gIGlmICh4ID09PSB5KSB7XHJcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcclxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXHJcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXHJcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xyXG4gIH1cclxufVxyXG4vKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cclxuXHJcbi8qKlxyXG4gKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXHJcbiAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIgd2UgZG9uJ3QgdXNlIHJlYWxcclxuICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxyXG4gKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XHJcbiAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cclxuICovXHJcbmZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xyXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgdGhpcy5zdGFjayA9ICcnO1xyXG59XHJcbi8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cclxuUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xyXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcclxuICB9XHJcbiAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XHJcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XHJcbiAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XHJcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XHJcbiAgICAgICAgaWYgKCFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0pIHtcclxuICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArICdhbmQgd2lsbCBub3Qgd29yayBpbiBwcm9kdWN0aW9uIHdpdGggdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gJyArICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgKyAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJywgcHJvcEZ1bGxOYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcclxuICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcclxuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcclxuICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcclxuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xyXG4gIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xyXG5cclxuICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XHJcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcclxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XHJcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xyXG4gICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcclxuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcclxuICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXHJcbiAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxyXG4gICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXHJcbiAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xyXG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKG51bGwpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XHJcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XHJcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XHJcbiAgICB9XHJcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcclxuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcclxuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcclxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XHJcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XHJcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgaWYgKCFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xyXG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xyXG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xyXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcclxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcclxuICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XHJcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XHJcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XHJcbiAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcclxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XHJcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xyXG4gICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XHJcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XHJcbiAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcclxuICB9XHJcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xyXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xyXG4gICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcclxuICAgIH1cclxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XHJcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xyXG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xyXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcclxuICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcclxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xyXG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xyXG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XHJcbiAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XHJcbiAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XHJcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xyXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xyXG4gICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xyXG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xyXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xyXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xyXG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcclxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XHJcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XHJcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xyXG4gICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcclxuICAgICAgaWYgKCFjaGVja2VyKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XHJcbiAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XHJcbiAgICBjYXNlICdudW1iZXInOlxyXG4gICAgY2FzZSAnc3RyaW5nJzpcclxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xyXG4gICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xyXG4gICAgICBpZiAoaXRlcmF0b3JGbikge1xyXG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xyXG4gICAgICAgIHZhciBzdGVwO1xyXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xyXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cclxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XHJcbiAgLy8gTmF0aXZlIFN5bWJvbC5cclxuICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXHJcbiAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXHJcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxyXG5mdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcclxuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcclxuICAgIHJldHVybiAnYXJyYXknO1xyXG4gIH1cclxuICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXHJcbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cclxuICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxyXG4gICAgcmV0dXJuICdvYmplY3QnO1xyXG4gIH1cclxuICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcclxuICAgIHJldHVybiAnc3ltYm9sJztcclxuICB9XHJcbiAgcmV0dXJuIHByb3BUeXBlO1xyXG59XHJcblxyXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXHJcbi8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxyXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcclxuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xyXG4gIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgIHJldHVybiAnZGF0ZSc7XHJcbiAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBwcm9wVHlwZTtcclxufVxyXG5cclxuLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cclxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xyXG4gIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xyXG4gICAgcmV0dXJuIEFOT05ZTU9VUztcclxuICB9XHJcbiAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzOyIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xyXG5cclxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xyXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XHJcblxyXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gUmVhY3RQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XHJcbiAgLy8gRHVwbGljYXRlZCBmcm9tIFJlYWN0Q29tcG9uZW50LlxyXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcclxuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xyXG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXHJcbiAgLy8gcmVuZGVyZXIuXHJcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxyXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBSZWFjdENvbXBvbmVudC5wcm90b3R5cGU7XHJcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcclxuUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlYWN0UHVyZUNvbXBvbmVudDtcclxuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXHJcbl9hc3NpZ24oUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlKTtcclxuUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHVyZUNvbXBvbmVudDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gZmFsc2U7XHJcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgdHJ5IHtcclxuICAgIC8vICRGbG93Rml4TWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcclxuICAgIGNhbkRlZmluZVByb3BlcnR5ID0gdHJ1ZTtcclxuICB9IGNhdGNoICh4KSB7XHJcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY2FuRGVmaW5lUHJvcGVydHk7IiwiLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcclxuXHJcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcclxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xyXG5cclxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xyXG5cclxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBcInByb2R1Y3Rpb25cIiA9PT0gJ3Rlc3QnKSB7XHJcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXHJcbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXHJcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XHJcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xyXG59XHJcblxyXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XHJcblxyXG4vKipcclxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxyXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcclxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cclxuICogQHBhcmFtIHs/b2JqZWN0fSBlbGVtZW50IFRoZSBSZWFjdCBlbGVtZW50IHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXHJcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XHJcbiAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xyXG4gICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XHJcbiAgICAgIHZhciBlcnJvcjtcclxuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cclxuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxyXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXHJcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxyXG4gICAgICAgICEodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIFJlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc4NCcsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogdm9pZCAwO1xyXG4gICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XHJcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgZXJyb3IgPSBleDtcclxuICAgICAgfVxyXG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XHJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XHJcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXHJcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cclxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xyXG5cclxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XHJcblxyXG4gICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcclxuICAgICAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGRlYnVnSUQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBjb21wb25lbnRTdGFja0luZm8pIDogdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVhY3RUeXBlU3BlYzsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XHJcblxyXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcclxuXHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcclxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5vbmx5XHJcbiAqXHJcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcclxuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cclxuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXHJcbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcclxuICogc3RydWN0dXJlLlxyXG4gKi9cclxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XHJcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnMTQzJykgOiB2b2lkIDA7XHJcbiAgcmV0dXJuIGNoaWxkcmVuO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG9ubHlDaGlsZDsiLCIvKipcclxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xyXG5cclxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xyXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRTeW1ib2wnKTtcclxuXHJcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XHJcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcclxudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xyXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcclxuXHJcbnZhciBTRVBBUkFUT1IgPSAnLic7XHJcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XHJcblxyXG4vKipcclxuICogVGhpcyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50IHNpbmNlIHRoaXMgZmlsZSBpcyBzaGFyZWQgYmV0d2VlblxyXG4gKiBpc29tb3JwaGljIGFuZCByZW5kZXJlcnMuIFdlIGNvdWxkIGV4dHJhY3QgdGhpcyB0byBhXHJcbiAqXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxyXG4gKiBwYXR0ZXJuLlxyXG4gKi9cclxuXHJcbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcclxuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxyXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxyXG4gIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XHJcbiAgICAvLyBFeHBsaWNpdCBrZXlcclxuICAgIHJldHVybiBLZXlFc2NhcGVVdGlscy5lc2NhcGUoY29tcG9uZW50LmtleSk7XHJcbiAgfVxyXG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XHJcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxyXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXHJcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxyXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxyXG4gKiBwcm9jZXNzLlxyXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcclxuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcclxuXHJcbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xyXG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXHJcbiAgICBjaGlsZHJlbiA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHxcclxuICAvLyBUaGUgZm9sbG93aW5nIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQuIFRoaXMgbWVhbnMgd2UgY2FuIG9wdGltaXplXHJcbiAgLy8gc29tZSBjaGVja3MuIFJlYWN0IEZpYmVyIGFsc28gaW5saW5lcyB0aGlzIGxvZ2ljIGZvciBzaW1pbGFyIHB1cnBvc2VzLlxyXG4gIHR5cGUgPT09ICdvYmplY3QnICYmIGNoaWxkcmVuLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcclxuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXHJcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxyXG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cclxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNoaWxkO1xyXG4gIHZhciBuZXh0TmFtZTtcclxuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cclxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xyXG5cclxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XHJcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xyXG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcclxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcclxuICAgICAgdmFyIHN0ZXA7XHJcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XHJcbiAgICAgICAgdmFyIGlpID0gMDtcclxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XHJcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XHJcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcclxuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnJztcclxuICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xyXG4gICAgICAgICAgICBpZiAobWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUpIHtcclxuICAgICAgICAgICAgICBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lICsgJ2AuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0pIDogdm9pZCAwO1xyXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxyXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcclxuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XHJcbiAgICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcclxuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIEtleUVzY2FwZVV0aWxzLmVzY2FwZShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xyXG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XHJcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkIG9yIHdyYXAgdGhlIG9iamVjdCB1c2luZyBjcmVhdGVGcmFnbWVudChvYmplY3QpIGZyb20gdGhlICcgKyAnUmVhY3QgYWRkLW9ucy4nO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcclxuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xyXG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcclxuICAgICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcclxuICAgICAgIWZhbHNlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiBfcHJvZEludmFyaWFudCgnMzEnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IHZvaWQgMDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcclxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxyXG4gKlxyXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXHJcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcclxuICpcclxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXHJcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XHJcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cclxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cclxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cclxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XHJcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0Jyk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XHJcblx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcclxuXHRcdHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XHJcblx0fSk7XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXHJcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcclxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcclxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXHJcbiAqL1xyXG5cclxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xyXG5cclxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcclxuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcclxuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xyXG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xyXG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XHJcbiAgICB9XHJcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcclxuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXHJcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XHJcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xyXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xyXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgICAgfSBjYXRjaCh4KSB7fVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcclxuIiwiLyohXHJcbiAqIFhSZWdFeHAuYnVpbGQgMy4xLjFcclxuICogPHhyZWdleHAuY29tPlxyXG4gKiBTdGV2ZW4gTGV2aXRoYW4gKGMpIDIwMTItMjAxNiBNSVQgTGljZW5zZVxyXG4gKiBJbnNwaXJlZCBieSBMZWEgVmVyb3UncyBSZWdFeHAuY3JlYXRlIDxsZWEudmVyb3UubWU+XHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihYUmVnRXhwKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIFJFR0VYX0RBVEEgPSAneHJlZ2V4cCc7XHJcbiAgICB2YXIgc3ViUGFydHMgPSAvKFxcKCkoPyFcXD8pfFxcXFwoWzEtOV1cXGQqKXxcXFxcW1xcc1xcU118XFxbKD86W15cXFxcXFxdXXxcXFxcW1xcc1xcU10pKl0vZztcclxuICAgIHZhciBwYXJ0cyA9IFhSZWdFeHAudW5pb24oWy9cXCh7eyhbXFx3JF0rKX19XFwpfHt7KFtcXHckXSspfX0vLCBzdWJQYXJ0c10sICdnJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpcHMgYSBsZWFkaW5nIGBeYCBhbmQgdHJhaWxpbmcgdW5lc2NhcGVkIGAkYCwgaWYgYm90aCBhcmUgcHJlc2VudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiBQYXR0ZXJuIHRvIHByb2Nlc3MuXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBQYXR0ZXJuIHdpdGggZWRnZSBhbmNob3JzIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRlYW5jaG9yKHBhdHRlcm4pIHtcclxuICAgICAgICAvLyBBbGxvdyBhbnkgbnVtYmVyIG9mIGVtcHR5IG5vbmNhcHR1cmluZyBncm91cHMgYmVmb3JlL2FmdGVyIGFuY2hvcnMsIGJlY2F1c2UgcmVnZXhlc1xyXG4gICAgICAgIC8vIGJ1aWx0L2dlbmVyYXRlZCBieSBYUmVnRXhwIHNvbWV0aW1lcyBpbmNsdWRlIHRoZW1cclxuICAgICAgICB2YXIgbGVhZGluZ0FuY2hvciA9IC9eKD86XFwoXFw/OlxcKSkqXFxeLyxcclxuICAgICAgICAgICAgdHJhaWxpbmdBbmNob3IgPSAvXFwkKD86XFwoXFw/OlxcKSkqJC87XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgbGVhZGluZ0FuY2hvci50ZXN0KHBhdHRlcm4pICYmXHJcbiAgICAgICAgICAgIHRyYWlsaW5nQW5jaG9yLnRlc3QocGF0dGVybikgJiZcclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHRyYWlsaW5nIGAkYCBpc24ndCBlc2NhcGVkXHJcbiAgICAgICAgICAgIHRyYWlsaW5nQW5jaG9yLnRlc3QocGF0dGVybi5yZXBsYWNlKC9cXFxcW1xcc1xcU10vZywgJycpKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKGxlYWRpbmdBbmNob3IsICcnKS5yZXBsYWNlKHRyYWlsaW5nQW5jaG9yLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCB2YWx1ZSB0byBhbiBYUmVnRXhwLiBOYXRpdmUgUmVnRXhwIGZsYWdzIGFyZSBub3QgcHJlc2VydmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gdmFsdWUgVmFsdWUgdG8gY29udmVydC5cclxuICAgICAqIEByZXR1cm5zIHtSZWdFeHB9IFhSZWdFeHAgb2JqZWN0IHdpdGggWFJlZ0V4cCBzeW50YXggYXBwbGllZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXNYUmVnRXhwKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIFhSZWdFeHAuaXNSZWdFeHAodmFsdWUpID9cclxuICAgICAgICAgICAgKHZhbHVlW1JFR0VYX0RBVEFdICYmIHZhbHVlW1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lcyA/XHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCByZWNvbXBpbGUsIHRvIHByZXNlcnZlIGNhcHR1cmUgbmFtZXNcclxuICAgICAgICAgICAgICAgIHZhbHVlIDpcclxuICAgICAgICAgICAgICAgIC8vIFJlY29tcGlsZSBhcyBYUmVnRXhwXHJcbiAgICAgICAgICAgICAgICBYUmVnRXhwKHZhbHVlLnNvdXJjZSlcclxuICAgICAgICAgICAgKSA6XHJcbiAgICAgICAgICAgIC8vIENvbXBpbGUgc3RyaW5nIGFzIFhSZWdFeHBcclxuICAgICAgICAgICAgWFJlZ0V4cCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgcmVnZXhlcyB1c2luZyBuYW1lZCBzdWJwYXR0ZXJucywgZm9yIHJlYWRhYmlsaXR5IGFuZCBwYXR0ZXJuIHJldXNlLiBCYWNrcmVmZXJlbmNlcyBpblxyXG4gICAgICogdGhlIG91dGVyIHBhdHRlcm4gYW5kIHByb3ZpZGVkIHN1YnBhdHRlcm5zIGFyZSBhdXRvbWF0aWNhbGx5IHJlbnVtYmVyZWQgdG8gd29yayBjb3JyZWN0bHkuXHJcbiAgICAgKiBOYXRpdmUgZmxhZ3MgdXNlZCBieSBwcm92aWRlZCBzdWJwYXR0ZXJucyBhcmUgaWdub3JlZCBpbiBmYXZvciBvZiB0aGUgYGZsYWdzYCBhcmd1bWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiBYUmVnRXhwIHBhdHRlcm4gdXNpbmcgYHt7bmFtZX19YCBmb3IgZW1iZWRkZWQgc3VicGF0dGVybnMuIEFsbG93c1xyXG4gICAgICogICBgKHt7bmFtZX19KWAgYXMgc2hvcnRoYW5kIGZvciBgKD88bmFtZT57e25hbWV9fSlgLiBQYXR0ZXJucyBjYW5ub3QgYmUgZW1iZWRkZWQgd2l0aGluXHJcbiAgICAgKiAgIGNoYXJhY3RlciBjbGFzc2VzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN1YnMgTG9va3VwIG9iamVjdCBmb3IgbmFtZWQgc3VicGF0dGVybnMuIFZhbHVlcyBjYW4gYmUgc3RyaW5ncyBvciByZWdleGVzLiBBXHJcbiAgICAgKiAgIGxlYWRpbmcgYF5gIGFuZCB0cmFpbGluZyB1bmVzY2FwZWQgYCRgIGFyZSBzdHJpcHBlZCBmcm9tIHN1YnBhdHRlcm5zLCBpZiBib3RoIGFyZSBwcmVzZW50LlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtmbGFnc10gQW55IGNvbWJpbmF0aW9uIG9mIFhSZWdFeHAgZmxhZ3MuXHJcbiAgICAgKiBAcmV0dXJucyB7UmVnRXhwfSBSZWdleCB3aXRoIGludGVycG9sYXRlZCBzdWJwYXR0ZXJucy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogdmFyIHRpbWUgPSBYUmVnRXhwLmJ1aWxkKCcoP3gpXiB7e2hvdXJzfX0gKHt7bWludXRlc319KSAkJywge1xyXG4gICAgICogICBob3VyczogWFJlZ0V4cC5idWlsZCgne3toMTJ9fSA6IHwge3toMjR9fScsIHtcclxuICAgICAqICAgICBoMTI6IC8xWzAtMl18MD9bMS05XS8sXHJcbiAgICAgKiAgICAgaDI0OiAvMlswLTNdfFswMV1bMC05XS9cclxuICAgICAqICAgfSwgJ3gnKSxcclxuICAgICAqICAgbWludXRlczogL15bMC01XVswLTldJC9cclxuICAgICAqIH0pO1xyXG4gICAgICogdGltZS50ZXN0KCcxMDo1OScpOyAvLyAtPiB0cnVlXHJcbiAgICAgKiBYUmVnRXhwLmV4ZWMoJzEwOjU5JywgdGltZSkubWludXRlczsgLy8gLT4gJzU5J1xyXG4gICAgICovXHJcbiAgICBYUmVnRXhwLmJ1aWxkID0gZnVuY3Rpb24ocGF0dGVybiwgc3VicywgZmxhZ3MpIHtcclxuICAgICAgICB2YXIgaW5saW5lRmxhZ3MgPSAvXlxcKFxcPyhbXFx3JF0rKVxcKS8uZXhlYyhwYXR0ZXJuKSxcclxuICAgICAgICAgICAgZGF0YSA9IHt9LFxyXG4gICAgICAgICAgICBudW1DYXBzID0gMCwgLy8gJ0NhcHMnIGlzIHNob3J0IGZvciBjYXB0dXJlc1xyXG4gICAgICAgICAgICBudW1QcmlvckNhcHMsXHJcbiAgICAgICAgICAgIG51bU91dGVyQ2FwcyA9IDAsXHJcbiAgICAgICAgICAgIG91dGVyQ2Fwc01hcCA9IFswXSxcclxuICAgICAgICAgICAgb3V0ZXJDYXBOYW1lcyxcclxuICAgICAgICAgICAgc3ViLFxyXG4gICAgICAgICAgICBwO1xyXG5cclxuICAgICAgICAvLyBBZGQgZmxhZ3Mgd2l0aGluIGEgbGVhZGluZyBtb2RlIG1vZGlmaWVyIHRvIHRoZSBvdmVyYWxsIHBhdHRlcm4ncyBmbGFnc1xyXG4gICAgICAgIGlmIChpbmxpbmVGbGFncykge1xyXG4gICAgICAgICAgICBmbGFncyA9IGZsYWdzIHx8ICcnO1xyXG4gICAgICAgICAgICBpbmxpbmVGbGFnc1sxXS5yZXBsYWNlKC8uL2csIGZ1bmN0aW9uKGZsYWcpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGFkZCBkdXBsaWNhdGVzXHJcbiAgICAgICAgICAgICAgICBmbGFncyArPSAoZmxhZ3MuaW5kZXhPZihmbGFnKSA+IC0xID8gJycgOiBmbGFnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHAgaW4gc3Vicykge1xyXG4gICAgICAgICAgICBpZiAoc3Vicy5oYXNPd25Qcm9wZXJ0eShwKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFzc2luZyB0byBYUmVnRXhwIGVuYWJsZXMgZXh0ZW5kZWQgc3ludGF4IGFuZCBlbnN1cmVzIGluZGVwZW5kZW50IHZhbGlkaXR5LFxyXG4gICAgICAgICAgICAgICAgLy8gbGVzdCBhbiB1bmVzY2FwZWQgYChgLCBgKWAsIGBbYCwgb3IgdHJhaWxpbmcgYFxcYCBicmVha3MgdGhlIGAoPzopYCB3cmFwcGVyLiBGb3JcclxuICAgICAgICAgICAgICAgIC8vIHN1YnBhdHRlcm5zIHByb3ZpZGVkIGFzIG5hdGl2ZSByZWdleGVzLCBpdCBkaWVzIG9uIG9jdGFscyBhbmQgYWRkcyB0aGUgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgIC8vIHVzZWQgdG8gaG9sZCBleHRlbmRlZCByZWdleCBpbnN0YW5jZSBkYXRhLCBmb3Igc2ltcGxpY2l0eVxyXG4gICAgICAgICAgICAgICAgc3ViID0gYXNYUmVnRXhwKHN1YnNbcF0pO1xyXG4gICAgICAgICAgICAgICAgZGF0YVtwXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEZWFuY2hvcmluZyBhbGxvd3MgZW1iZWRkaW5nIGluZGVwZW5kZW50bHkgdXNlZnVsIGFuY2hvcmVkIHJlZ2V4ZXMuIElmIHlvdVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWxseSBuZWVkIHRvIGtlZXAgeW91ciBhbmNob3JzLCBkb3VibGUgdGhlbSAoaS5lLiwgYF5eLi4uJCRgKVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGRlYW5jaG9yKHN1Yi5zb3VyY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzOiBzdWJbUkVHRVhfREFUQV0uY2FwdHVyZU5hbWVzIHx8IFtdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQYXNzaW5nIHRvIFhSZWdFeHAgZGllcyBvbiBvY3RhbHMgYW5kIGVuc3VyZXMgdGhlIG91dGVyIHBhdHRlcm4gaXMgaW5kZXBlbmRlbnRseSB2YWxpZDtcclxuICAgICAgICAvLyBoZWxwcyBrZWVwIHRoaXMgc2ltcGxlLiBOYW1lZCBjYXB0dXJlcyB3aWxsIGJlIHB1dCBiYWNrXHJcbiAgICAgICAgcGF0dGVybiA9IGFzWFJlZ0V4cChwYXR0ZXJuKTtcclxuICAgICAgICBvdXRlckNhcE5hbWVzID0gcGF0dGVybltSRUdFWF9EQVRBXS5jYXB0dXJlTmFtZXMgfHwgW107XHJcbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc291cmNlLnJlcGxhY2UocGFydHMsIGZ1bmN0aW9uKCQwLCAkMSwgJDIsICQzLCAkNCkge1xyXG4gICAgICAgICAgICB2YXIgc3ViTmFtZSA9ICQxIHx8ICQyLFxyXG4gICAgICAgICAgICAgICAgY2FwTmFtZSxcclxuICAgICAgICAgICAgICAgIGludHJvLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxDYXBJbmRleDtcclxuICAgICAgICAgICAgLy8gTmFtZWQgc3VicGF0dGVyblxyXG4gICAgICAgICAgICBpZiAoc3ViTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KHN1Yk5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdVbmRlZmluZWQgcHJvcGVydHkgJyArICQwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIE5hbWVkIHN1YnBhdHRlcm4gd2FzIHdyYXBwZWQgaW4gYSBjYXB0dXJpbmcgZ3JvdXBcclxuICAgICAgICAgICAgICAgIGlmICgkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcE5hbWUgPSBvdXRlckNhcE5hbWVzW251bU91dGVyQ2Fwc107XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYXBzTWFwWysrbnVtT3V0ZXJDYXBzXSA9ICsrbnVtQ2FwcztcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgbmFtZWQgZ3JvdXAsIHByZXNlcnZlIHRoZSBuYW1lLiBPdGhlcndpc2UsIHVzZSB0aGUgc3VicGF0dGVybiBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNhcHR1cmUgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIGludHJvID0gJyg/PCcgKyAoY2FwTmFtZSB8fCBzdWJOYW1lKSArICc+JztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50cm8gPSAnKD86JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG51bVByaW9yQ2FwcyA9IG51bUNhcHM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50cm8gKyBkYXRhW3N1Yk5hbWVdLnBhdHRlcm4ucmVwbGFjZShzdWJQYXJ0cywgZnVuY3Rpb24obWF0Y2gsIHBhcmVuLCBiYWNrcmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FwdHVyaW5nIGdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcE5hbWUgPSBkYXRhW3N1Yk5hbWVdLm5hbWVzW251bUNhcHMgLSBudW1QcmlvckNhcHNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICArK251bUNhcHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNhcHR1cmUgaGFzIGEgbmFtZSwgcHJlc2VydmUgdGhlIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnKD88JyArIGNhcE5hbWUgKyAnPic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYWNrcmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQ2FwSW5kZXggPSArYmFja3JlZiAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJld3JpdGUgdGhlIGJhY2tyZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbc3ViTmFtZV0ubmFtZXNbbG9jYWxDYXBJbmRleF0gP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBwcmVzZXJ2ZSB0aGUgYmFja3JlZmVyZW5jZSBuYW1lIGluIGNhc2UgdXNpbmcgZmxhZyBgbmBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXFxcazwnICsgZGF0YVtzdWJOYW1lXS5uYW1lc1tsb2NhbENhcEluZGV4XSArICc+JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxcXCcgKyAoK2JhY2tyZWYgKyBudW1QcmlvckNhcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgICAgICAgICB9KSArICcpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDYXB0dXJpbmcgZ3JvdXBcclxuICAgICAgICAgICAgaWYgKCQzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXBOYW1lID0gb3V0ZXJDYXBOYW1lc1tudW1PdXRlckNhcHNdO1xyXG4gICAgICAgICAgICAgICAgb3V0ZXJDYXBzTWFwWysrbnVtT3V0ZXJDYXBzXSA9ICsrbnVtQ2FwcztcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNhcHR1cmUgaGFzIGEgbmFtZSwgcHJlc2VydmUgdGhlIG5hbWVcclxuICAgICAgICAgICAgICAgIGlmIChjYXBOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoPzwnICsgY2FwTmFtZSArICc+JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQmFja3JlZmVyZW5jZVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCQ0KSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbENhcEluZGV4ID0gKyQ0IC0gMTtcclxuICAgICAgICAgICAgICAgIC8vIFJld3JpdGUgdGhlIGJhY2tyZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRlckNhcE5hbWVzW2xvY2FsQ2FwSW5kZXhdID9cclxuICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHByZXNlcnZlIHRoZSBiYWNrcmVmZXJlbmNlIG5hbWUgaW4gY2FzZSB1c2luZyBmbGFnIGBuYFxyXG4gICAgICAgICAgICAgICAgICAgICdcXFxcazwnICsgb3V0ZXJDYXBOYW1lc1tsb2NhbENhcEluZGV4XSArICc+JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgJ1xcXFwnICsgb3V0ZXJDYXBzTWFwWyskNF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICQwO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gWFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XHJcbiAgICB9O1xyXG5cclxufTtcclxuIiwiLyohXHJcbiAqIFhSZWdFeHAubWF0Y2hSZWN1cnNpdmUgMy4xLjFcclxuICogPHhyZWdleHAuY29tPlxyXG4gKiBTdGV2ZW4gTGV2aXRoYW4gKGMpIDIwMDktMjAxNiBNSVQgTGljZW5zZVxyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oWFJlZ0V4cCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG1hdGNoIGRldGFpbCBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHByb3ZpZGVkIHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcm93KG5hbWUsIHZhbHVlLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogZW5kXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2ggc3RyaW5ncyBiZXR3ZWVuIG91dGVybW9zdCBsZWZ0IGFuZCByaWdodCBkZWxpbWl0ZXJzLCBvciBhbiBhcnJheSBvZlxyXG4gICAgICogb2JqZWN0cyB3aXRoIGRldGFpbGVkIG1hdGNoIHBhcnRzIGFuZCBwb3NpdGlvbiBkYXRhLiBBbiBlcnJvciBpcyB0aHJvd24gaWYgZGVsaW1pdGVycyBhcmVcclxuICAgICAqIHVuYmFsYW5jZWQgd2l0aGluIHRoZSBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsZWZ0IExlZnQgZGVsaW1pdGVyIGFzIGFuIFhSZWdFeHAgcGF0dGVybi5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByaWdodCBSaWdodCBkZWxpbWl0ZXIgYXMgYW4gWFJlZ0V4cCBwYXR0ZXJuLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtmbGFnc10gQW55IG5hdGl2ZSBvciBYUmVnRXhwIGZsYWdzLCB1c2VkIGZvciB0aGUgbGVmdCBhbmQgcmlnaHQgZGVsaW1pdGVycy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gTGV0cyB5b3Ugc3BlY2lmeSBgdmFsdWVOYW1lc2AgYW5kIGBlc2NhcGVDaGFyYCBvcHRpb25zLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBtYXRjaGVzLCBvciBhbiBlbXB0eSBhcnJheS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogLy8gQmFzaWMgdXNhZ2VcclxuICAgICAqIHZhciBzdHIgPSAnKHQoKGUpKXMpdCgpKGluZyknO1xyXG4gICAgICogWFJlZ0V4cC5tYXRjaFJlY3Vyc2l2ZShzdHIsICdcXFxcKCcsICdcXFxcKScsICdnJyk7XHJcbiAgICAgKiAvLyAtPiBbJ3QoKGUpKXMnLCAnJywgJ2luZyddXHJcbiAgICAgKlxyXG4gICAgICogLy8gRXh0ZW5kZWQgaW5mb3JtYXRpb24gbW9kZSB3aXRoIHZhbHVlTmFtZXNcclxuICAgICAqIHN0ciA9ICdIZXJlIGlzIDxkaXY+IDxkaXY+YW48L2Rpdj48L2Rpdj4gZXhhbXBsZSc7XHJcbiAgICAgKiBYUmVnRXhwLm1hdGNoUmVjdXJzaXZlKHN0ciwgJzxkaXZcXFxccyo+JywgJzwvZGl2PicsICdnaScsIHtcclxuICAgICAqICAgdmFsdWVOYW1lczogWydiZXR3ZWVuJywgJ2xlZnQnLCAnbWF0Y2gnLCAncmlnaHQnXVxyXG4gICAgICogfSk7XHJcbiAgICAgKiAvLyAtPiBbXHJcbiAgICAgKiAvLyB7bmFtZTogJ2JldHdlZW4nLCB2YWx1ZTogJ0hlcmUgaXMgJywgICAgICAgc3RhcnQ6IDAsICBlbmQ6IDh9LFxyXG4gICAgICogLy8ge25hbWU6ICdsZWZ0JywgICAgdmFsdWU6ICc8ZGl2PicsICAgICAgICAgIHN0YXJ0OiA4LCAgZW5kOiAxM30sXHJcbiAgICAgKiAvLyB7bmFtZTogJ21hdGNoJywgICB2YWx1ZTogJyA8ZGl2PmFuPC9kaXY+Jywgc3RhcnQ6IDEzLCBlbmQ6IDI3fSxcclxuICAgICAqIC8vIHtuYW1lOiAncmlnaHQnLCAgIHZhbHVlOiAnPC9kaXY+JywgICAgICAgICBzdGFydDogMjcsIGVuZDogMzN9LFxyXG4gICAgICogLy8ge25hbWU6ICdiZXR3ZWVuJywgdmFsdWU6ICcgZXhhbXBsZScsICAgICAgIHN0YXJ0OiAzMywgZW5kOiA0MX1cclxuICAgICAqIC8vIF1cclxuICAgICAqXHJcbiAgICAgKiAvLyBPbWl0dGluZyB1bm5lZWRlZCBwYXJ0cyB3aXRoIG51bGwgdmFsdWVOYW1lcywgYW5kIHVzaW5nIGVzY2FwZUNoYXJcclxuICAgICAqIHN0ciA9ICcuLi57MX0uXFxcXHt7ZnVuY3Rpb24oeCx5KXtyZXR1cm4ge3k6eH19fSc7XHJcbiAgICAgKiBYUmVnRXhwLm1hdGNoUmVjdXJzaXZlKHN0ciwgJ3snLCAnfScsICdnJywge1xyXG4gICAgICogICB2YWx1ZU5hbWVzOiBbJ2xpdGVyYWwnLCBudWxsLCAndmFsdWUnLCBudWxsXSxcclxuICAgICAqICAgZXNjYXBlQ2hhcjogJ1xcXFwnXHJcbiAgICAgKiB9KTtcclxuICAgICAqIC8vIC0+IFtcclxuICAgICAqIC8vIHtuYW1lOiAnbGl0ZXJhbCcsIHZhbHVlOiAnLi4uJywgIHN0YXJ0OiAwLCBlbmQ6IDN9LFxyXG4gICAgICogLy8ge25hbWU6ICd2YWx1ZScsICAgdmFsdWU6ICcxJywgICAgc3RhcnQ6IDQsIGVuZDogNX0sXHJcbiAgICAgKiAvLyB7bmFtZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy5cXFxceycsIHN0YXJ0OiA2LCBlbmQ6IDl9LFxyXG4gICAgICogLy8ge25hbWU6ICd2YWx1ZScsICAgdmFsdWU6ICdmdW5jdGlvbih4LHkpe3JldHVybiB7eTp4fX0nLCBzdGFydDogMTAsIGVuZDogMzd9XHJcbiAgICAgKiAvLyBdXHJcbiAgICAgKlxyXG4gICAgICogLy8gU3RpY2t5IG1vZGUgdmlhIGZsYWcgeVxyXG4gICAgICogc3RyID0gJzwxPjw8PDI+Pj48Mz40PDU+JztcclxuICAgICAqIFhSZWdFeHAubWF0Y2hSZWN1cnNpdmUoc3RyLCAnPCcsICc+JywgJ2d5Jyk7XHJcbiAgICAgKiAvLyAtPiBbJzEnLCAnPDwyPj4nLCAnMyddXHJcbiAgICAgKi9cclxuICAgIFhSZWdFeHAubWF0Y2hSZWN1cnNpdmUgPSBmdW5jdGlvbihzdHIsIGxlZnQsIHJpZ2h0LCBmbGFncywgb3B0aW9ucykge1xyXG4gICAgICAgIGZsYWdzID0gZmxhZ3MgfHwgJyc7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIGdsb2JhbCA9IGZsYWdzLmluZGV4T2YoJ2cnKSA+IC0xLFxyXG4gICAgICAgICAgICBzdGlja3kgPSBmbGFncy5pbmRleE9mKCd5JykgPiAtMSxcclxuICAgICAgICAgICAgLy8gRmxhZyBgeWAgaXMgY29udHJvbGxlZCBpbnRlcm5hbGx5XHJcbiAgICAgICAgICAgIGJhc2ljRmxhZ3MgPSBmbGFncy5yZXBsYWNlKC95L2csICcnKSxcclxuICAgICAgICAgICAgZXNjYXBlQ2hhciA9IG9wdGlvbnMuZXNjYXBlQ2hhcixcclxuICAgICAgICAgICAgdk4gPSBvcHRpb25zLnZhbHVlTmFtZXMsXHJcbiAgICAgICAgICAgIG91dHB1dCA9IFtdLFxyXG4gICAgICAgICAgICBvcGVuVG9rZW5zID0gMCxcclxuICAgICAgICAgICAgZGVsaW1TdGFydCA9IDAsXHJcbiAgICAgICAgICAgIGRlbGltRW5kID0gMCxcclxuICAgICAgICAgICAgbGFzdE91dGVyRW5kID0gMCxcclxuICAgICAgICAgICAgb3V0ZXJTdGFydCxcclxuICAgICAgICAgICAgaW5uZXJTdGFydCxcclxuICAgICAgICAgICAgbGVmdE1hdGNoLFxyXG4gICAgICAgICAgICByaWdodE1hdGNoLFxyXG4gICAgICAgICAgICBlc2M7XHJcbiAgICAgICAgbGVmdCA9IFhSZWdFeHAobGVmdCwgYmFzaWNGbGFncyk7XHJcbiAgICAgICAgcmlnaHQgPSBYUmVnRXhwKHJpZ2h0LCBiYXNpY0ZsYWdzKTtcclxuXHJcbiAgICAgICAgaWYgKGVzY2FwZUNoYXIpIHtcclxuICAgICAgICAgICAgaWYgKGVzY2FwZUNoYXIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgZXNjYXBlIGNoYXJhY3RlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVzY2FwZUNoYXIgPSBYUmVnRXhwLmVzY2FwZShlc2NhcGVDaGFyKTtcclxuICAgICAgICAgICAgLy8gVXNpbmcgYFhSZWdFeHAudW5pb25gIHNhZmVseSByZXdyaXRlcyBiYWNrcmVmZXJlbmNlcyBpbiBgbGVmdGAgYW5kIGByaWdodGBcclxuICAgICAgICAgICAgZXNjID0gbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgICAgICcoPzonICsgZXNjYXBlQ2hhciArICdbXFxcXFNcXFxcc118KD86KD8hJyArXHJcbiAgICAgICAgICAgICAgICAgICAgWFJlZ0V4cC51bmlvbihbbGVmdCwgcmlnaHRdKS5zb3VyY2UgK1xyXG4gICAgICAgICAgICAgICAgICAgICcpW14nICsgZXNjYXBlQ2hhciArICddKSspKycsXHJcbiAgICAgICAgICAgICAgICAvLyBGbGFncyBgZ3lgIG5vdCBuZWVkZWQgaGVyZVxyXG4gICAgICAgICAgICAgICAgZmxhZ3MucmVwbGFjZSgvW15pbXVdKy9nLCAnJylcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHVzaW5nIGFuIGVzY2FwZSBjaGFyYWN0ZXIsIGFkdmFuY2UgdG8gdGhlIGRlbGltaXRlcidzIG5leHQgc3RhcnRpbmcgcG9zaXRpb24sXHJcbiAgICAgICAgICAgIC8vIHNraXBwaW5nIGFueSBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gYmV0d2VlblxyXG4gICAgICAgICAgICBpZiAoZXNjYXBlQ2hhcikge1xyXG4gICAgICAgICAgICAgICAgZGVsaW1FbmQgKz0gKFhSZWdFeHAuZXhlYyhzdHIsIGVzYywgZGVsaW1FbmQsICdzdGlja3knKSB8fCBbJyddKVswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVmdE1hdGNoID0gWFJlZ0V4cC5leGVjKHN0ciwgbGVmdCwgZGVsaW1FbmQpO1xyXG4gICAgICAgICAgICByaWdodE1hdGNoID0gWFJlZ0V4cC5leGVjKHN0ciwgcmlnaHQsIGRlbGltRW5kKTtcclxuICAgICAgICAgICAgLy8gS2VlcCB0aGUgbGVmdG1vc3QgbWF0Y2ggb25seVxyXG4gICAgICAgICAgICBpZiAobGVmdE1hdGNoICYmIHJpZ2h0TWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0TWF0Y2guaW5kZXggPD0gcmlnaHRNYXRjaC5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0TWF0Y2ggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0TWF0Y2ggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBhdGhzIChMTTogbGVmdE1hdGNoLCBSTTogcmlnaHRNYXRjaCwgT1Q6IG9wZW5Ub2tlbnMpOlxyXG4gICAgICAgICAgICAvLyBMTSB8IFJNIHwgT1QgfCBSZXN1bHRcclxuICAgICAgICAgICAgLy8gMSAgfCAwICB8IDEgIHwgbG9vcFxyXG4gICAgICAgICAgICAvLyAxICB8IDAgIHwgMCAgfCBsb29wXHJcbiAgICAgICAgICAgIC8vIDAgIHwgMSAgfCAxICB8IGxvb3BcclxuICAgICAgICAgICAgLy8gMCAgfCAxICB8IDAgIHwgdGhyb3dcclxuICAgICAgICAgICAgLy8gMCAgfCAwICB8IDEgIHwgdGhyb3dcclxuICAgICAgICAgICAgLy8gMCAgfCAwICB8IDAgIHwgYnJlYWtcclxuICAgICAgICAgICAgLy8gVGhlIHBhdGhzIGFib3ZlIGRvbid0IGluY2x1ZGUgdGhlIHN0aWNreSBtb2RlIHNwZWNpYWwgY2FzZS4gVGhlIGxvb3AgZW5kcyBhZnRlciB0aGVcclxuICAgICAgICAgICAgLy8gZmlyc3QgY29tcGxldGVkIG1hdGNoIGlmIG5vdCBgZ2xvYmFsYC5cclxuICAgICAgICAgICAgaWYgKGxlZnRNYXRjaCB8fCByaWdodE1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxpbVN0YXJ0ID0gKGxlZnRNYXRjaCB8fCByaWdodE1hdGNoKS5pbmRleDtcclxuICAgICAgICAgICAgICAgIGRlbGltRW5kID0gZGVsaW1TdGFydCArIChsZWZ0TWF0Y2ggfHwgcmlnaHRNYXRjaClbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvcGVuVG9rZW5zKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RpY2t5ICYmICFvcGVuVG9rZW5zICYmIGRlbGltU3RhcnQgPiBsYXN0T3V0ZXJFbmQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZWZ0TWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgIGlmICghb3BlblRva2Vucykge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyU3RhcnQgPSBkZWxpbVN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyU3RhcnQgPSBkZWxpbUVuZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICsrb3BlblRva2VucztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChyaWdodE1hdGNoICYmIG9wZW5Ub2tlbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghLS1vcGVuVG9rZW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2TlswXSAmJiBvdXRlclN0YXJ0ID4gbGFzdE91dGVyRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyb3codk5bMF0sIHN0ci5zbGljZShsYXN0T3V0ZXJFbmQsIG91dGVyU3RhcnQpLCBsYXN0T3V0ZXJFbmQsIG91dGVyU3RhcnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodk5bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHJvdyh2TlsxXSwgc3RyLnNsaWNlKG91dGVyU3RhcnQsIGlubmVyU3RhcnQpLCBvdXRlclN0YXJ0LCBpbm5lclN0YXJ0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZOWzJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChyb3codk5bMl0sIHN0ci5zbGljZShpbm5lclN0YXJ0LCBkZWxpbVN0YXJ0KSwgaW5uZXJTdGFydCwgZGVsaW1TdGFydCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2TlszXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocm93KHZOWzNdLCBzdHIuc2xpY2UoZGVsaW1TdGFydCwgZGVsaW1FbmQpLCBkZWxpbVN0YXJ0LCBkZWxpbUVuZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGlubmVyU3RhcnQsIGRlbGltU3RhcnQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdE91dGVyRW5kID0gZGVsaW1FbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnbG9iYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmJhbGFuY2VkIGRlbGltaXRlciBmb3VuZCBpbiBzdHJpbmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsaW1pdGVyIG1hdGNoZWQgYW4gZW1wdHkgc3RyaW5nLCBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXHJcbiAgICAgICAgICAgIGlmIChkZWxpbVN0YXJ0ID09PSBkZWxpbUVuZCkge1xyXG4gICAgICAgICAgICAgICAgKytkZWxpbUVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGdsb2JhbCAmJiAhc3RpY2t5ICYmIHZOICYmIHZOWzBdICYmIHN0ci5sZW5ndGggPiBsYXN0T3V0ZXJFbmQpIHtcclxuICAgICAgICAgICAgb3V0cHV0LnB1c2gocm93KHZOWzBdLCBzdHIuc2xpY2UobGFzdE91dGVyRW5kKSwgbGFzdE91dGVyRW5kLCBzdHIubGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfTtcclxuXHJcbn07XHJcbiIsIi8qIVxyXG4gKiBYUmVnRXhwIFVuaWNvZGUgQmFzZSAzLjEuMVxyXG4gKiA8eHJlZ2V4cC5jb20+XHJcbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAwOC0yMDE2IE1JVCBMaWNlbnNlXHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihYUmVnRXhwKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGJhc2Ugc3VwcG9ydCBmb3IgVW5pY29kZSBtYXRjaGluZzpcclxuICAgICAqIC0gQWRkcyBzeW50YXggYFxccHsuLn1gIGZvciBtYXRjaGluZyBVbmljb2RlIHRva2Vucy4gVG9rZW5zIGNhbiBiZSBpbnZlcnRlZCB1c2luZyBgXFxQey4ufWAgb3JcclxuICAgICAqICAgYFxccHteLi59YC4gVG9rZW4gbmFtZXMgaWdub3JlIGNhc2UsIHNwYWNlcywgaHlwaGVucywgYW5kIHVuZGVyc2NvcmVzLiBZb3UgY2FuIG9taXQgdGhlXHJcbiAgICAgKiAgIGJyYWNlcyBmb3IgdG9rZW4gbmFtZXMgdGhhdCBhcmUgYSBzaW5nbGUgbGV0dGVyIChlLmcuIGBcXHBMYCBvciBgUExgKS5cclxuICAgICAqIC0gQWRkcyBmbGFnIEEgKGFzdHJhbCksIHdoaWNoIGVuYWJsZXMgMjEtYml0IFVuaWNvZGUgc3VwcG9ydC5cclxuICAgICAqIC0gQWRkcyB0aGUgYFhSZWdFeHAuYWRkVW5pY29kZURhdGFgIG1ldGhvZCB1c2VkIGJ5IG90aGVyIGFkZG9ucyB0byBwcm92aWRlIGNoYXJhY3RlciBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIFVuaWNvZGUgQmFzZSByZWxpZXMgb24gZXh0ZXJuYWxseSBwcm92aWRlZCBVbmljb2RlIGNoYXJhY3RlciBkYXRhLiBPZmZpY2lhbCBhZGRvbnMgYXJlXHJcbiAgICAgKiBhdmFpbGFibGUgdG8gcHJvdmlkZSBkYXRhIGZvciBVbmljb2RlIGNhdGVnb3JpZXMsIHNjcmlwdHMsIGJsb2NrcywgYW5kIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJlcXVpcmVzIFhSZWdFeHBcclxuICAgICAqL1xyXG5cclxuICAgIC8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG4gICAgLy8gUHJpdmF0ZSBzdHVmZlxyXG4gICAgLy8gPT0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT09XHJcblxyXG4gICAgLy8gU3RvcmFnZSBmb3IgVW5pY29kZSBkYXRhXHJcbiAgICB2YXIgdW5pY29kZSA9IHt9O1xyXG5cclxuICAgIC8vIFJldXNlIHV0aWxzXHJcbiAgICB2YXIgZGVjID0gWFJlZ0V4cC5fZGVjO1xyXG4gICAgdmFyIGhleCA9IFhSZWdFeHAuX2hleDtcclxuICAgIHZhciBwYWQ0ID0gWFJlZ0V4cC5fcGFkNDtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZXMgYSB0b2tlbiBsb29rdXAgbmFtZTogbG93ZXJjYXNlLCB3aXRoIGh5cGhlbnMsIHNwYWNlcywgYW5kIHVuZGVyc2NvcmVzIHJlbW92ZWRcclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvWy0gX10rL2csICcnKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldHMgdGhlIGRlY2ltYWwgY29kZSBvZiBhIGxpdGVyYWwgY29kZSB1bml0LCBcXHhISCwgXFx1SEhISCwgb3IgYSBiYWNrc2xhc2gtZXNjYXBlZCBsaXRlcmFsXHJcbiAgICBmdW5jdGlvbiBjaGFyQ29kZShjaHIpIHtcclxuICAgICAgICB2YXIgZXNjID0gL15cXFxcW3h1XSguKykvLmV4ZWMoY2hyKTtcclxuICAgICAgICByZXR1cm4gZXNjID9cclxuICAgICAgICAgICAgZGVjKGVzY1sxXSkgOlxyXG4gICAgICAgICAgICBjaHIuY2hhckNvZGVBdChjaHIuY2hhckF0KDApID09PSAnXFxcXCcgPyAxIDogMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW52ZXJ0cyBhIGxpc3Qgb2Ygb3JkZXJlZCBCTVAgY2hhcmFjdGVycyBhbmQgcmFuZ2VzXHJcbiAgICBmdW5jdGlvbiBpbnZlcnRCbXAocmFuZ2UpIHtcclxuICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XHJcbiAgICAgICAgdmFyIGxhc3RFbmQgPSAtMTtcclxuICAgICAgICBYUmVnRXhwLmZvckVhY2goXHJcbiAgICAgICAgICAgIHJhbmdlLFxyXG4gICAgICAgICAgICAvKFxcXFx4Li58XFxcXHUuLi4ufFxcXFw/W1xcc1xcU10pKD86LShcXFxceC4ufFxcXFx1Li4uLnxcXFxcP1tcXHNcXFNdKSk/LyxcclxuICAgICAgICAgICAgZnVuY3Rpb24obSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2hhckNvZGUobVsxXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPiAobGFzdEVuZCArIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9ICdcXFxcdScgKyBwYWQ0KGhleChsYXN0RW5kICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA+IChsYXN0RW5kICsgMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9ICctXFxcXHUnICsgcGFkNChoZXgoc3RhcnQgLSAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdEVuZCA9IGNoYXJDb2RlKG1bMl0gfHwgbVsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChsYXN0RW5kIDwgMHhGRkZGKSB7XHJcbiAgICAgICAgICAgIG91dHB1dCArPSAnXFxcXHUnICsgcGFkNChoZXgobGFzdEVuZCArIDEpKTtcclxuICAgICAgICAgICAgaWYgKGxhc3RFbmQgPCAweEZGRkUpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnLVxcXFx1RkZGRic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZW5lcmF0ZXMgYW4gaW52ZXJ0ZWQgQk1QIHJhbmdlIG9uIGZpcnN0IHVzZVxyXG4gICAgZnVuY3Rpb24gY2FjaGVJbnZlcnRlZEJtcChzbHVnKSB7XHJcbiAgICAgICAgdmFyIHByb3AgPSAnYiEnO1xyXG4gICAgICAgIHJldHVybiB1bmljb2RlW3NsdWddW3Byb3BdIHx8IChcclxuICAgICAgICAgICAgdW5pY29kZVtzbHVnXVtwcm9wXSA9IGludmVydEJtcCh1bmljb2RlW3NsdWddLmJtcClcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbWJpbmVzIGFuZCBvcHRpb25hbGx5IG5lZ2F0ZXMgQk1QIGFuZCBhc3RyYWwgZGF0YVxyXG4gICAgZnVuY3Rpb24gYnVpbGRBc3RyYWwoc2x1ZywgaXNOZWdhdGVkKSB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB1bmljb2RlW3NsdWddLFxyXG4gICAgICAgICAgICBjb21iaW5lZCA9ICcnO1xyXG4gICAgICAgIGlmIChpdGVtLmJtcCAmJiAhaXRlbS5pc0JtcExhc3QpIHtcclxuICAgICAgICAgICAgY29tYmluZWQgPSAnWycgKyBpdGVtLmJtcCArICddJyArIChpdGVtLmFzdHJhbCA/ICd8JyA6ICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uYXN0cmFsKSB7XHJcbiAgICAgICAgICAgIGNvbWJpbmVkICs9IGl0ZW0uYXN0cmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5pc0JtcExhc3QgJiYgaXRlbS5ibXApIHtcclxuICAgICAgICAgICAgY29tYmluZWQgKz0gKGl0ZW0uYXN0cmFsID8gJ3wnIDogJycpICsgJ1snICsgaXRlbS5ibXAgKyAnXSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFzdHJhbCBVbmljb2RlIHRva2VucyBhbHdheXMgbWF0Y2ggYSBjb2RlIHBvaW50LCBuZXZlciBhIGNvZGUgdW5pdFxyXG4gICAgICAgIHJldHVybiBpc05lZ2F0ZWQgP1xyXG4gICAgICAgICAgICAnKD86KD8hJyArIGNvbWJpbmVkICsgJykoPzpbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXDAtXFx1RkZGRl0pKScgOlxyXG4gICAgICAgICAgICAnKD86JyArIGNvbWJpbmVkICsgJyknO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJ1aWxkcyBhIGNvbXBsZXRlIGFzdHJhbCBwYXR0ZXJuIG9uIGZpcnN0IHVzZVxyXG4gICAgZnVuY3Rpb24gY2FjaGVBc3RyYWwoc2x1ZywgaXNOZWdhdGVkKSB7XHJcbiAgICAgICAgdmFyIHByb3AgPSBpc05lZ2F0ZWQgPyAnYSEnIDogJ2E9JztcclxuICAgICAgICByZXR1cm4gdW5pY29kZVtzbHVnXVtwcm9wXSB8fCAoXHJcbiAgICAgICAgICAgIHVuaWNvZGVbc2x1Z11bcHJvcF0gPSBidWlsZEFzdHJhbChzbHVnLCBpc05lZ2F0ZWQpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA9PS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPT1cclxuICAgIC8vIENvcmUgZnVuY3Rpb25hbGl0eVxyXG4gICAgLy8gPT0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT09XHJcblxyXG4gICAgLypcclxuICAgICAqIEFkZCBVbmljb2RlIHRva2VuIHN5bnRheDogXFxwey4ufSwgXFxQey4ufSwgXFxwe14uLn0uIEFsc28gYWRkIGFzdHJhbCBtb2RlIChmbGFnIEEpLlxyXG4gICAgICovXHJcbiAgICBYUmVnRXhwLmFkZFRva2VuKFxyXG4gICAgICAgIC8vIFVzZSBgKmAgaW5zdGVhZCBvZiBgK2AgdG8gYXZvaWQgY2FwdHVyaW5nIGBeYCBhcyB0aGUgdG9rZW4gbmFtZSBpbiBgXFxwe159YFxyXG4gICAgICAgIC9cXFxcKFtwUF0pKD86eyhcXF4/KShbXn1dKil9fChbQS1aYS16XSkpLyxcclxuICAgICAgICBmdW5jdGlvbihtYXRjaCwgc2NvcGUsIGZsYWdzKSB7XHJcbiAgICAgICAgICAgIHZhciBFUlJfRE9VQkxFX05FRyA9ICdJbnZhbGlkIGRvdWJsZSBuZWdhdGlvbiAnLFxyXG4gICAgICAgICAgICAgICAgRVJSX1VOS05PV05fTkFNRSA9ICdVbmtub3duIFVuaWNvZGUgdG9rZW4gJyxcclxuICAgICAgICAgICAgICAgIEVSUl9VTktOT1dOX1JFRiA9ICdVbmljb2RlIHRva2VuIG1pc3NpbmcgZGF0YSAnLFxyXG4gICAgICAgICAgICAgICAgRVJSX0FTVFJBTF9PTkxZID0gJ0FzdHJhbCBtb2RlIHJlcXVpcmVkIGZvciBVbmljb2RlIHRva2VuICcsXHJcbiAgICAgICAgICAgICAgICBFUlJfQVNUUkFMX0lOX0NMQVNTID0gJ0FzdHJhbCBtb2RlIGRvZXMgbm90IHN1cHBvcnQgVW5pY29kZSB0b2tlbnMgd2l0aGluIGNoYXJhY3RlciBjbGFzc2VzJyxcclxuICAgICAgICAgICAgICAgIC8vIE5lZ2F0ZWQgdmlhIFxcUHsuLn0gb3IgXFxwe14uLn1cclxuICAgICAgICAgICAgICAgIGlzTmVnYXRlZCA9IG1hdGNoWzFdID09PSAnUCcgfHwgISFtYXRjaFsyXSxcclxuICAgICAgICAgICAgICAgIC8vIFN3aXRjaCBmcm9tIEJNUCAoMC1GRkZGKSB0byBhc3RyYWwgKDAtMTBGRkZGKSBtb2RlIHZpYSBmbGFnIEFcclxuICAgICAgICAgICAgICAgIGlzQXN0cmFsTW9kZSA9IGZsYWdzLmluZGV4T2YoJ0EnKSA+IC0xLFxyXG4gICAgICAgICAgICAgICAgLy8gVG9rZW4gbG9va3VwIG5hbWUuIENoZWNrIGBbNF1gIGZpcnN0IHRvIGF2b2lkIHBhc3NpbmcgYHVuZGVmaW5lZGAgdmlhIGBcXHB7fWBcclxuICAgICAgICAgICAgICAgIHNsdWcgPSBub3JtYWxpemUobWF0Y2hbNF0gfHwgbWF0Y2hbM10pLFxyXG4gICAgICAgICAgICAgICAgLy8gVG9rZW4gZGF0YSBvYmplY3RcclxuICAgICAgICAgICAgICAgIGl0ZW0gPSB1bmljb2RlW3NsdWddO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09PSAnUCcgJiYgbWF0Y2hbMl0pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihFUlJfRE9VQkxFX05FRyArIG1hdGNoWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXVuaWNvZGUuaGFzT3duUHJvcGVydHkoc2x1ZykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihFUlJfVU5LTk9XTl9OQU1FICsgbWF0Y2hbMF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTd2l0Y2ggdG8gdGhlIG5lZ2F0ZWQgZm9ybSBvZiB0aGUgcmVmZXJlbmNlZCBVbmljb2RlIHRva2VuXHJcbiAgICAgICAgICAgIGlmIChpdGVtLmludmVyc2VPZikge1xyXG4gICAgICAgICAgICAgICAgc2x1ZyA9IG5vcm1hbGl6ZShpdGVtLmludmVyc2VPZik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXVuaWNvZGUuaGFzT3duUHJvcGVydHkoc2x1ZykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoRVJSX1VOS05PV05fUkVGICsgbWF0Y2hbMF0gKyAnIC0+ICcgKyBpdGVtLmludmVyc2VPZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpdGVtID0gdW5pY29kZVtzbHVnXTtcclxuICAgICAgICAgICAgICAgIGlzTmVnYXRlZCA9ICFpc05lZ2F0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghKGl0ZW0uYm1wIHx8IGlzQXN0cmFsTW9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihFUlJfQVNUUkFMX09OTFkgKyBtYXRjaFswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzQXN0cmFsTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlID09PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKEVSUl9BU1RSQUxfSU5fQ0xBU1MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUFzdHJhbChzbHVnLCBpc05lZ2F0ZWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2NvcGUgPT09ICdjbGFzcycgP1xyXG4gICAgICAgICAgICAgICAgKGlzTmVnYXRlZCA/IGNhY2hlSW52ZXJ0ZWRCbXAoc2x1ZykgOiBpdGVtLmJtcCkgOlxyXG4gICAgICAgICAgICAgICAgKGlzTmVnYXRlZCA/ICdbXicgOiAnWycpICsgaXRlbS5ibXAgKyAnXSc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNjb3BlOiAnYWxsJyxcclxuICAgICAgICAgICAgb3B0aW9uYWxGbGFnczogJ0EnLFxyXG4gICAgICAgICAgICBsZWFkQ2hhcjogJ1xcXFwnXHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdG8gdGhlIGxpc3Qgb2YgVW5pY29kZSB0b2tlbnMgdGhhdCBYUmVnRXhwIHJlZ2V4ZXMgY2FuIG1hdGNoIHZpYSBgXFxwYCBvciBgXFxQYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIE9iamVjdHMgd2l0aCBuYW1lZCBjaGFyYWN0ZXIgcmFuZ2VzLiBFYWNoIG9iamVjdCBtYXkgaGF2ZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiAgIGBuYW1lYCwgYGFsaWFzYCwgYGlzQm1wTGFzdGAsIGBpbnZlcnNlT2ZgLCBgYm1wYCwgYW5kIGBhc3RyYWxgLiBBbGwgYnV0IGBuYW1lYCBhcmVcclxuICAgICAqICAgb3B0aW9uYWwsIGFsdGhvdWdoIG9uZSBvZiBgYm1wYCBvciBgYXN0cmFsYCBpcyByZXF1aXJlZCAodW5sZXNzIGBpbnZlcnNlT2ZgIGlzIHNldCkuIElmXHJcbiAgICAgKiAgIGBhc3RyYWxgIGlzIGFic2VudCwgdGhlIGBibXBgIGRhdGEgaXMgdXNlZCBmb3IgQk1QIGFuZCBhc3RyYWwgbW9kZXMuIElmIGBibXBgIGlzIGFic2VudCxcclxuICAgICAqICAgdGhlIG5hbWUgZXJyb3JzIGluIEJNUCBtb2RlIGJ1dCB3b3JrcyBpbiBhc3RyYWwgbW9kZS4gSWYgYm90aCBgYm1wYCBhbmQgYGFzdHJhbGAgYXJlXHJcbiAgICAgKiAgIHByb3ZpZGVkLCB0aGUgYGJtcGAgZGF0YSBvbmx5IGlzIHVzZWQgaW4gQk1QIG1vZGUsIGFuZCB0aGUgY29tYmluYXRpb24gb2YgYGJtcGAgYW5kXHJcbiAgICAgKiAgIGBhc3RyYWxgIGRhdGEgaXMgdXNlZCBpbiBhc3RyYWwgbW9kZS4gYGlzQm1wTGFzdGAgaXMgbmVlZGVkIHdoZW4gYSB0b2tlbiBtYXRjaGVzIG9ycGhhblxyXG4gICAgICogICBoaWdoIHN1cnJvZ2F0ZXMgKmFuZCogdXNlcyBzdXJyb2dhdGUgcGFpcnMgdG8gbWF0Y2ggYXN0cmFsIGNvZGUgcG9pbnRzLiBUaGUgYGJtcGAgYW5kXHJcbiAgICAgKiAgIGBhc3RyYWxgIGRhdGEgc2hvdWxkIGJlIGEgY29tYmluYXRpb24gb2YgbGl0ZXJhbCBjaGFyYWN0ZXJzIGFuZCBgXFx4SEhgIG9yIGBcXHVISEhIYCBlc2NhcGVcclxuICAgICAqICAgc2VxdWVuY2VzLCB3aXRoIGh5cGhlbnMgdG8gY3JlYXRlIHJhbmdlcy4gQW55IHJlZ2V4IG1ldGFjaGFyYWN0ZXJzIGluIHRoZSBkYXRhIHNob3VsZCBiZVxyXG4gICAgICogICBlc2NhcGVkLCBhcGFydCBmcm9tIHJhbmdlLWNyZWF0aW5nIGh5cGhlbnMuIFRoZSBgYXN0cmFsYCBkYXRhIGNhbiBhZGRpdGlvbmFsbHkgdXNlXHJcbiAgICAgKiAgIGNoYXJhY3RlciBjbGFzc2VzIGFuZCBhbHRlcm5hdGlvbiwgYW5kIHNob3VsZCB1c2Ugc3Vycm9nYXRlIHBhaXJzIHRvIHJlcHJlc2VudCBhc3RyYWwgY29kZVxyXG4gICAgICogICBwb2ludHMuIGBpbnZlcnNlT2ZgIGNhbiBiZSB1c2VkIHRvIGF2b2lkIGR1cGxpY2F0aW5nIGNoYXJhY3RlciBkYXRhIGlmIGEgVW5pY29kZSB0b2tlbiBpc1xyXG4gICAgICogICBkZWZpbmVkIGFzIHRoZSBleGFjdCBpbnZlcnNlIG9mIGFub3RoZXIgdG9rZW4uXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIC8vIEJhc2ljIHVzZVxyXG4gICAgICogWFJlZ0V4cC5hZGRVbmljb2RlRGF0YShbe1xyXG4gICAgICogICBuYW1lOiAnWERpZ2l0JyxcclxuICAgICAqICAgYWxpYXM6ICdIZXhhZGVjaW1hbCcsXHJcbiAgICAgKiAgIGJtcDogJzAtOUEtRmEtZidcclxuICAgICAqIH1dKTtcclxuICAgICAqIFhSZWdFeHAoJ1xcXFxwe1hEaWdpdH06XFxcXHB7SGV4YWRlY2ltYWx9KycpLnRlc3QoJzA6M0QnKTsgLy8gLT4gdHJ1ZVxyXG4gICAgICovXHJcbiAgICBYUmVnRXhwLmFkZFVuaWNvZGVEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIHZhciBFUlJfTk9fTkFNRSA9ICdVbmljb2RlIHRva2VuIHJlcXVpcmVzIG5hbWUnLFxyXG4gICAgICAgICAgICBFUlJfTk9fREFUQSA9ICdVbmljb2RlIHRva2VuIGhhcyBubyBjaGFyYWN0ZXIgZGF0YSAnLFxyXG4gICAgICAgICAgICBpdGVtLFxyXG4gICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpdGVtID0gZGF0YVtpXTtcclxuICAgICAgICAgICAgaWYgKCFpdGVtLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfTk9fTkFNRSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCEoaXRlbS5pbnZlcnNlT2YgfHwgaXRlbS5ibXAgfHwgaXRlbS5hc3RyYWwpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX05PX0RBVEEgKyBpdGVtLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVuaWNvZGVbbm9ybWFsaXplKGl0ZW0ubmFtZSldID0gaXRlbTtcclxuICAgICAgICAgICAgaWYgKGl0ZW0uYWxpYXMpIHtcclxuICAgICAgICAgICAgICAgIHVuaWNvZGVbbm9ybWFsaXplKGl0ZW0uYWxpYXMpXSA9IGl0ZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IHRoZSBwYXR0ZXJuIGNhY2hlIHVzZWQgYnkgdGhlIGBYUmVnRXhwYCBjb25zdHJ1Y3Rvciwgc2luY2UgdGhlIHNhbWUgcGF0dGVybiBhbmRcclxuICAgICAgICAvLyBmbGFncyBtaWdodCBub3cgcHJvZHVjZSBkaWZmZXJlbnQgcmVzdWx0c1xyXG4gICAgICAgIFhSZWdFeHAuY2FjaGUuZmx1c2goJ3BhdHRlcm5zJyk7XHJcbiAgICB9O1xyXG5cclxufTtcclxuIiwiLyohXHJcbiAqIFhSZWdFeHAgVW5pY29kZSBCbG9ja3MgMy4xLjFcclxuICogPHhyZWdleHAuY29tPlxyXG4gKiBTdGV2ZW4gTGV2aXRoYW4gKGMpIDIwMTAtMjAxNiBNSVQgTGljZW5zZVxyXG4gKiBVbmljb2RlIGRhdGEgYnkgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNieW5lbnMuYmU+XHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihYUmVnRXhwKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHN1cHBvcnQgZm9yIGFsbCBVbmljb2RlIGJsb2Nrcy4gQmxvY2sgbmFtZXMgdXNlIHRoZSBwcmVmaXggJ0luJy4gRS5nLixcclxuICAgICAqIGBcXHB7SW5CYXNpY0xhdGlufWAuIFRva2VuIG5hbWVzIGFyZSBjYXNlIGluc2Vuc2l0aXZlLCBhbmQgYW55IHNwYWNlcywgaHlwaGVucywgYW5kXHJcbiAgICAgKiB1bmRlcnNjb3JlcyBhcmUgaWdub3JlZC5cclxuICAgICAqXHJcbiAgICAgKiBVc2VzIFVuaWNvZGUgOC4wLjAuXHJcbiAgICAgKlxyXG4gICAgICogQHJlcXVpcmVzIFhSZWdFeHAsIFVuaWNvZGUgQmFzZVxyXG4gICAgICovXHJcblxyXG4gICAgaWYgKCFYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdVbmljb2RlIEJhc2UgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIFVuaWNvZGUgQmxvY2tzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgWFJlZ0V4cC5hZGRVbmljb2RlRGF0YShbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BZWdlYW5fTnVtYmVycycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REQwMC1cXHVERDNGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQWhvbScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REYwMC1cXHVERjNGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQWxjaGVtaWNhbF9TeW1ib2xzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRFtcXHVERjAwLVxcdURGN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BbHBoYWJldGljX1ByZXNlbnRhdGlvbl9Gb3JtcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUZCMDAtXFx1RkI0RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQW5hdG9saWFuX0hpZXJvZ2x5cGhzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxMVtcXHVEQzAwLVxcdURFN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BbmNpZW50X0dyZWVrX011c2ljYWxfTm90YXRpb24nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdURFMDAtXFx1REU0Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkFuY2llbnRfR3JlZWtfTnVtYmVycycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REQ0MC1cXHVERDhGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQW5jaWVudF9TeW1ib2xzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERDkwLVxcdUREQ0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BcmFiaWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwNjAwLVxcdTA2RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkFyYWJpY19FeHRlbmRlZF9BJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDhBMC1cXHUwOEZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BcmFiaWNfTWF0aGVtYXRpY2FsX0FscGhhYmV0aWNfU3ltYm9scycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0JbXFx1REUwMC1cXHVERUZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQXJhYmljX1ByZXNlbnRhdGlvbl9Gb3Jtc19BJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1RkI1MC1cXHVGREZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BcmFiaWNfUHJlc2VudGF0aW9uX0Zvcm1zX0InLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVGRTcwLVxcdUZFRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkFyYWJpY19TdXBwbGVtZW50JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDc1MC1cXHUwNzdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Bcm1lbmlhbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA1MzAtXFx1MDU4RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQXJyb3dzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjE5MC1cXHUyMUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5BdmVzdGFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjAwLVxcdURGM0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5CYWxpbmVzZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFCMDAtXFx1MUI3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQmFtdW0nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBNkEwLVxcdUE2RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJhbXVtX1N1cHBsZW1lbnQnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFBW1xcdURDMDAtXFx1REUzRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJhc2ljX0xhdGluJyxcclxuICAgICAgICAgICAgYm1wOiAnXFwwLVxceDdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5CYXNzYV9WYWgnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFBW1xcdURFRDAtXFx1REVGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJhdGFrJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUJDMC1cXHUxQkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5CZW5nYWxpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDk4MC1cXHUwOUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5CbG9ja19FbGVtZW50cycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTI1ODAtXFx1MjU5RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQm9wb21vZm8nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUzMTAwLVxcdTMxMkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJvcG9tb2ZvX0V4dGVuZGVkJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MzFBMC1cXHUzMUJGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Cb3hfRHJhd2luZycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTI1MDAtXFx1MjU3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQnJhaG1pJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQzAwLVxcdURDN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5CcmFpbGxlX1BhdHRlcm5zJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjgwMC1cXHUyOEZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5CdWdpbmVzZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFBMDAtXFx1MUExRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQnVoaWQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNzQwLVxcdTE3NUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkJ5emFudGluZV9NdXNpY2FsX1N5bWJvbHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdURDMDAtXFx1RENGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19Db21wYXRpYmlsaXR5JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MzMwMC1cXHUzM0ZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfQ29tcGF0aWJpbGl0eV9Gb3JtcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUZFMzAtXFx1RkU0RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX0NvbXBhdGliaWxpdHlfSWRlb2dyYXBocycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUY5MDAtXFx1RkFGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX0NvbXBhdGliaWxpdHlfSWRlb2dyYXBoc19TdXBwbGVtZW50JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDg3RVtcXHVEQzAwLVxcdURFMUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfUmFkaWNhbHNfU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTJFODAtXFx1MkVGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1N0cm9rZXMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUzMUMwLVxcdTMxRUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNKS19TeW1ib2xzX2FuZF9QdW5jdHVhdGlvbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTMwMDAtXFx1MzAzRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1VuaWZpZWRfSWRlb2dyYXBocycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTRFMDAtXFx1OUZGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1VuaWZpZWRfSWRlb2dyYXBoc19FeHRlbnNpb25fQScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTM0MDAtXFx1NERCRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1VuaWZpZWRfSWRlb2dyYXBoc19FeHRlbnNpb25fQicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1tcXHVEODQwLVxcdUQ4NjhdW1xcdURDMDAtXFx1REZGRl18XFx1RDg2OVtcXHVEQzAwLVxcdURFREZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfVW5pZmllZF9JZGVvZ3JhcGhzX0V4dGVuc2lvbl9DJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDg2RFtcXHVEQzAwLVxcdURGM0ZdfFtcXHVEODZBLVxcdUQ4NkNdW1xcdURDMDAtXFx1REZGRl18XFx1RDg2OVtcXHVERjAwLVxcdURGRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DSktfVW5pZmllZF9JZGVvZ3JhcGhzX0V4dGVuc2lvbl9EJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDg2RFtcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ0pLX1VuaWZpZWRfSWRlb2dyYXBoc19FeHRlbnNpb25fRScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1tcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQUZdfFxcdUQ4NkVbXFx1REMyMC1cXHVERkZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ2FyaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERUEwLVxcdURFREZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DYXVjYXNpYW5fQWxiYW5pYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdUREMzAtXFx1REQ2Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNoYWttYScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REQwMC1cXHVERDRGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ2hhbScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUFBMDAtXFx1QUE1RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ2hlcm9rZWUnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxM0EwLVxcdTEzRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNoZXJva2VlX1N1cHBsZW1lbnQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBQjcwLVxcdUFCQkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkNvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzMDAtXFx1MDM2RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX0V4dGVuZGVkJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUFCMC1cXHUxQUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFEQzAtXFx1MURGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjBEMC1cXHUyMEZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Db21iaW5pbmdfSGFsZl9NYXJrcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUZFMjAtXFx1RkUyRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ29tbW9uX0luZGljX051bWJlcl9Gb3JtcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4MzAtXFx1QTgzRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ29udHJvbF9QaWN0dXJlcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTI0MDAtXFx1MjQzRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ29wdGljJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkM4MC1cXHUyQ0ZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Db3B0aWNfRXBhY3RfTnVtYmVycycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REVFMC1cXHVERUZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ291bnRpbmdfUm9kX051bWVyYWxzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVERjYwLVxcdURGN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DdW5laWZvcm0nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA4W1xcdURDMDAtXFx1REZGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkN1bmVpZm9ybV9OdW1iZXJzX2FuZF9QdW5jdHVhdGlvbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDlbXFx1REMwMC1cXHVEQzdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ3VycmVuY3lfU3ltYm9scycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTIwQTAtXFx1MjBDRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luQ3lwcmlvdF9TeWxsYWJhcnknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDMDAtXFx1REMzRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkN5cmlsbGljJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDQwMC1cXHUwNEZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DeXJpbGxpY19FeHRlbmRlZF9BJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkRFMC1cXHUyREZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DeXJpbGxpY19FeHRlbmRlZF9CJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTY0MC1cXHVBNjlGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5DeXJpbGxpY19TdXBwbGVtZW50JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDUwMC1cXHUwNTJGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5EZXNlcmV0JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQzAwLVxcdURDNEZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5EZXZhbmFnYXJpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDkwMC1cXHUwOTdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5EZXZhbmFnYXJpX0V4dGVuZGVkJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QThFMC1cXHVBOEZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5EaW5nYmF0cycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTI3MDAtXFx1MjdCRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luRG9taW5vX1RpbGVzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQ1tcXHVEQzMwLVxcdURDOUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5EdXBsb3lhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MkZbXFx1REMwMC1cXHVEQzlGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luRWFybHlfRHluYXN0aWNfQ3VuZWlmb3JtJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwOVtcXHVEQzgwLVxcdURENEZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5FZ3lwdGlhbl9IaWVyb2dseXBocycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MENbXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkVsYmFzYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdUREMDAtXFx1REQyRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkVtb3RpY29ucycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0RbXFx1REUwMC1cXHVERTRGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luRW5jbG9zZWRfQWxwaGFudW1lcmljX1N1cHBsZW1lbnQnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNDW1xcdUREMDAtXFx1RERGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkVuY2xvc2VkX0FscGhhbnVtZXJpY3MnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyNDYwLVxcdTI0RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkVuY2xvc2VkX0NKS19MZXR0ZXJzX2FuZF9Nb250aHMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUzMjAwLVxcdTMyRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkVuY2xvc2VkX0lkZW9ncmFwaGljX1N1cHBsZW1lbnQnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNDW1xcdURFMDAtXFx1REVGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkV0aGlvcGljJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTIwMC1cXHUxMzdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5FdGhpb3BpY19FeHRlbmRlZCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTJEODAtXFx1MkRERidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luRXRoaW9waWNfRXh0ZW5kZWRfQScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUFCMDAtXFx1QUIyRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luRXRoaW9waWNfU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTEzODAtXFx1MTM5RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luR2VuZXJhbF9QdW5jdHVhdGlvbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTIwMDAtXFx1MjA2RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luR2VvbWV0cmljX1NoYXBlcycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTI1QTAtXFx1MjVGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luR2VvbWV0cmljX1NoYXBlc19FeHRlbmRlZCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0RbXFx1REY4MC1cXHVERkZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luR2VvcmdpYW4nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxMEEwLVxcdTEwRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkdlb3JnaWFuX1N1cHBsZW1lbnQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyRDAwLVxcdTJEMkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkdsYWdvbGl0aWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyQzAwLVxcdTJDNUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkdvdGhpYycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REYzMC1cXHVERjRGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luR3JhbnRoYScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REYwMC1cXHVERjdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luR3JlZWtfRXh0ZW5kZWQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxRjAwLVxcdTFGRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkdyZWVrX2FuZF9Db3B0aWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwMzcwLVxcdTAzRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkd1amFyYXRpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEE4MC1cXHUwQUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5HdXJtdWtoaScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBBMDAtXFx1MEE3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luSGFsZndpZHRoX2FuZF9GdWxsd2lkdGhfRm9ybXMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVGRjAwLVxcdUZGRUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbmd1bF9Db21wYXRpYmlsaXR5X0phbW8nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUzMTMwLVxcdTMxOEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkhhbmd1bF9KYW1vJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTEwMC1cXHUxMUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5IYW5ndWxfSmFtb19FeHRlbmRlZF9BJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTk2MC1cXHVBOTdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5IYW5ndWxfSmFtb19FeHRlbmRlZF9CJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1RDdCMC1cXHVEN0ZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5IYW5ndWxfU3lsbGFibGVzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QUMwMC1cXHVEN0FGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5IYW51bm9vJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTcyMC1cXHUxNzNGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5IYXRyYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDRTAtXFx1RENGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkhlYnJldycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA1OTAtXFx1MDVGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luSGlnaF9Qcml2YXRlX1VzZV9TdXJyb2dhdGVzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1REI4MC1cXHVEQkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5IaWdoX1N1cnJvZ2F0ZXMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVEODAwLVxcdURCN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkhpcmFnYW5hJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MzA0MC1cXHUzMDlGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5JUEFfRXh0ZW5zaW9ucycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTAyNTAtXFx1MDJBRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luSWRlb2dyYXBoaWNfRGVzY3JpcHRpb25fQ2hhcmFjdGVycycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTJGRjAtXFx1MkZGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luSW1wZXJpYWxfQXJhbWFpYycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REM0MC1cXHVEQzVGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luSW5zY3JpcHRpb25hbF9QYWhsYXZpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjYwLVxcdURGN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5JbnNjcmlwdGlvbmFsX1BhcnRoaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjQwLVxcdURGNUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5KYXZhbmVzZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE5ODAtXFx1QTlERidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luS2FpdGhpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQzgwLVxcdURDQ0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5LYW5hX1N1cHBsZW1lbnQnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODJDW1xcdURDMDAtXFx1RENGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkthbmJ1bicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTMxOTAtXFx1MzE5RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luS2FuZ3hpX1JhZGljYWxzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkYwMC1cXHUyRkRGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5LYW5uYWRhJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEM4MC1cXHUwQ0ZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5LYXRha2FuYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTMwQTAtXFx1MzBGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luS2F0YWthbmFfUGhvbmV0aWNfRXh0ZW5zaW9ucycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTMxRjAtXFx1MzFGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luS2F5YWhfTGknLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBOTAwLVxcdUE5MkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbktoYXJvc2h0aGknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURFMDAtXFx1REU1Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbktobWVyJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTc4MC1cXHUxN0ZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5LaG1lcl9TeW1ib2xzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTlFMC1cXHUxOUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5LaG9qa2knLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURFMDAtXFx1REU0Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbktodWRhd2FkaScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REVCMC1cXHVERUZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTGFvJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEU4MC1cXHUwRUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl9FeHRlbmRlZF9BZGRpdGlvbmFsJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUUwMC1cXHUxRUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl9FeHRlbmRlZF9BJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDEwMC1cXHUwMTdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl9FeHRlbmRlZF9CJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDE4MC1cXHUwMjRGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl9FeHRlbmRlZF9DJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkM2MC1cXHUyQzdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl9FeHRlbmRlZF9EJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTcyMC1cXHVBN0ZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl9FeHRlbmRlZF9FJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QUIzMC1cXHVBQjZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MYXRpbl8xX1N1cHBsZW1lbnQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHg4MC1cXHhGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTGVwY2hhJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUMwMC1cXHUxQzRGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MZXR0ZXJsaWtlX1N5bWJvbHMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyMTAwLVxcdTIxNEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxpbWJ1JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTkwMC1cXHUxOTRGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MaW5lYXJfQScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REUwMC1cXHVERjdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTGluZWFyX0JfSWRlb2dyYW1zJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVEQzgwLVxcdURDRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MaW5lYXJfQl9TeWxsYWJhcnknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURDMDAtXFx1REM3Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxpc3UnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBNEQwLVxcdUE0RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkxvd19TdXJyb2dhdGVzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1REMwMC1cXHVERkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5MeWNpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURFODAtXFx1REU5Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbkx5ZGlhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REQyMC1cXHVERDNGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWFoYWphbmknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURENTAtXFx1REQ3Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1haGpvbmdfVGlsZXMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNDW1xcdURDMDAtXFx1REMyRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1hbGF5YWxhbScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBEMDAtXFx1MEQ3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWFuZGFpYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA4NDAtXFx1MDg1RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWFuaWNoYWVhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REVDMC1cXHVERUZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWF0aGVtYXRpY2FsX0FscGhhbnVtZXJpY19TeW1ib2xzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNVtcXHVEQzAwLVxcdURGRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NYXRoZW1hdGljYWxfT3BlcmF0b3JzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjIwMC1cXHUyMkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NZWV0ZWlfTWF5ZWsnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBQkMwLVxcdUFCRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1lZXRlaV9NYXlla19FeHRlbnNpb25zJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QUFFMC1cXHVBQUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NZW5kZV9LaWtha3VpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQVtcXHVEQzAwLVxcdURDREZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NZXJvaXRpY19DdXJzaXZlJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEREEwLVxcdURERkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NZXJvaXRpY19IaWVyb2dseXBocycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REQ4MC1cXHVERDlGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWlhbycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUJbXFx1REYwMC1cXHVERjlGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWlzY2VsbGFuZW91c19NYXRoZW1hdGljYWxfU3ltYm9sc19BJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjdDMC1cXHUyN0VGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NaXNjZWxsYW5lb3VzX01hdGhlbWF0aWNhbF9TeW1ib2xzX0InLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyOTgwLVxcdTI5RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1pc2NlbGxhbmVvdXNfU3ltYm9scycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTI2MDAtXFx1MjZGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTWlzY2VsbGFuZW91c19TeW1ib2xzX2FuZF9BcnJvd3MnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyQjAwLVxcdTJCRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1pc2NlbGxhbmVvdXNfU3ltYm9sc19hbmRfUGljdG9ncmFwaHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNEW1xcdURDMDAtXFx1RERGRl18XFx1RDgzQ1tcXHVERjAwLVxcdURGRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NaXNjZWxsYW5lb3VzX1RlY2huaWNhbCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTIzMDAtXFx1MjNGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTW9kaScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REUwMC1cXHVERTVGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTW9kaWZpZXJfVG9uZV9MZXR0ZXJzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTcwMC1cXHVBNzFGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Nb25nb2xpYW4nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxODAwLVxcdTE4QUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk1ybycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REU0MC1cXHVERTZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTXVsdGFuaScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REU4MC1cXHVERUFGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTXVzaWNhbF9TeW1ib2xzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVERDAwLVxcdURERkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NeWFubWFyJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTAwMC1cXHUxMDlGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5NeWFubWFyX0V4dGVuZGVkX0EnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBQTYwLVxcdUFBN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk15YW5tYXJfRXh0ZW5kZWRfQicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE5RTAtXFx1QTlGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luTktvJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDdDMC1cXHUwN0ZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5OYWJhdGFlYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDODAtXFx1RENBRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk5ld19UYWlfTHVlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTk4MC1cXHUxOURGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5OdW1iZXJfRm9ybXMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyMTUwLVxcdTIxOEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk9naGFtJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTY4MC1cXHUxNjlGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5PbF9DaGlraScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFDNTAtXFx1MUM3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luT2xkX0h1bmdhcmlhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDNbXFx1REM4MC1cXHVEQ0ZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luT2xkX0l0YWxpYycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REYwMC1cXHVERjJGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luT2xkX05vcnRoX0FyYWJpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURFODAtXFx1REU5Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk9sZF9QZXJtaWMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAwW1xcdURGNTAtXFx1REY3Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk9sZF9QZXJzaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERkEwLVxcdURGREZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5PbGRfU291dGhfQXJhYmlhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REU2MC1cXHVERTdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luT2xkX1R1cmtpYycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDNbXFx1REMwMC1cXHVEQzRGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luT3B0aWNhbF9DaGFyYWN0ZXJfUmVjb2duaXRpb24nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyNDQwLVxcdTI0NUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbk9yaXlhJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEIwMC1cXHUwQjdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Pcm5hbWVudGFsX0RpbmdiYXRzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRFtcXHVERTUwLVxcdURFN0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5Pc21hbnlhJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQzgwLVxcdURDQUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5QYWhhd2hfSG1vbmcnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODFBW1xcdURGMDAtXFx1REY4Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblBhbG15cmVuZScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REM2MC1cXHVEQzdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luUGF1X0Npbl9IYXUnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA2W1xcdURFQzAtXFx1REVGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblBoYWdzX3BhJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTg0MC1cXHVBODdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5QaGFpc3Rvc19EaXNjJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVEREQwLVxcdURERkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5QaG9lbmljaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERDAwLVxcdUREMUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5QaG9uZXRpY19FeHRlbnNpb25zJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUQwMC1cXHUxRDdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5QaG9uZXRpY19FeHRlbnNpb25zX1N1cHBsZW1lbnQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxRDgwLVxcdTFEQkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblBsYXlpbmdfQ2FyZHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNDW1xcdURDQTAtXFx1RENGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblByaXZhdGVfVXNlX0FyZWEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVFMDAwLVxcdUY4RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblBzYWx0ZXJfUGFobGF2aScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REY4MC1cXHVERkFGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luUmVqYW5nJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTkzMC1cXHVBOTVGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5SdW1pX051bWVyYWxfU3ltYm9scycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDNbXFx1REU2MC1cXHVERTdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luUnVuaWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNkEwLVxcdTE2RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblNhbWFyaXRhbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA4MDAtXFx1MDgzRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU2F1cmFzaHRyYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4ODAtXFx1QThERidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU2hhcmFkYScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REQ4MC1cXHVERERGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU2hhdmlhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REM1MC1cXHVEQzdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU2hvcnRoYW5kX0Zvcm1hdF9Db250cm9scycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MkZbXFx1RENBMC1cXHVEQ0FGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU2lkZGhhbScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REQ4MC1cXHVEREZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU2luaGFsYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBEODAtXFx1MERGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU2luaGFsYV9BcmNoYWljX051bWJlcnMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURERTAtXFx1RERGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblNtYWxsX0Zvcm1fVmFyaWFudHMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVGRTUwLVxcdUZFNkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblNvcmFfU29tcGVuZycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1RENEMC1cXHVEQ0ZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU3BhY2luZ19Nb2RpZmllcl9MZXR0ZXJzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDJCMC1cXHUwMkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TcGVjaWFscycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUZGRjAtXFx1RkZGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU3VuZGFuZXNlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUI4MC1cXHUxQkJGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TdW5kYW5lc2VfU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFDQzAtXFx1MUNDRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU3VwZXJzY3JpcHRzX2FuZF9TdWJzY3JpcHRzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjA3MC1cXHUyMDlGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TdXBwbGVtZW50YWxfQXJyb3dzX0EnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyN0YwLVxcdTI3RkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblN1cHBsZW1lbnRhbF9BcnJvd3NfQicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTI5MDAtXFx1Mjk3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFsX0Fycm93c19DJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRVtcXHVEQzAwLVxcdURDRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TdXBwbGVtZW50YWxfTWF0aGVtYXRpY2FsX09wZXJhdG9ycycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTJBMDAtXFx1MkFGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFsX1B1bmN0dWF0aW9uJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkUwMC1cXHUyRTdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TdXBwbGVtZW50YWxfU3ltYm9sc19hbmRfUGljdG9ncmFwaHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNFW1xcdUREMDAtXFx1RERGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblN1cHBsZW1lbnRhcnlfUHJpdmF0ZV9Vc2VfQXJlYV9BJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnW1xcdURCODAtXFx1REJCRl1bXFx1REMwMC1cXHVERkZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU3VwcGxlbWVudGFyeV9Qcml2YXRlX1VzZV9BcmVhX0InLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdbXFx1REJDMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5TdXR0b25fU2lnbldyaXRpbmcnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM2W1xcdURDMDAtXFx1REVBRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblN5bG90aV9OYWdyaScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4MDAtXFx1QTgyRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luU3lyaWFjJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDcwMC1cXHUwNzRGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5UYWdhbG9nJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTcwMC1cXHUxNzFGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5UYWdiYW53YScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3NjAtXFx1MTc3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVGFncycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdURCNDBbXFx1REMwMC1cXHVEQzdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVGFpX0xlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTk1MC1cXHUxOTdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5UYWlfVGhhbScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFBMjAtXFx1MUFBRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVGFpX1ZpZXQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBQTgwLVxcdUFBREYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblRhaV9YdWFuX0ppbmdfU3ltYm9scycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzRbXFx1REYwMC1cXHVERjVGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVGFrcmknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURFODAtXFx1REVDRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblRhbWlsJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEI4MC1cXHUwQkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5UZWx1Z3UnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwQzAwLVxcdTBDN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblRoYWFuYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA3ODAtXFx1MDdCRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVGhhaScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBFMDAtXFx1MEU3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVGliZXRhbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBGMDAtXFx1MEZGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVGlmaW5hZ2gnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUyRDMwLVxcdTJEN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblRpcmh1dGEnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURDODAtXFx1RENERl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblRyYW5zcG9ydF9hbmRfTWFwX1N5bWJvbHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNEW1xcdURFODAtXFx1REVGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblVnYXJpdGljJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjgwLVxcdURGOUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5VbmlmaWVkX0NhbmFkaWFuX0Fib3JpZ2luYWxfU3lsbGFiaWNzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTQwMC1cXHUxNjdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5VbmlmaWVkX0NhbmFkaWFuX0Fib3JpZ2luYWxfU3lsbGFiaWNzX0V4dGVuZGVkJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MThCMC1cXHUxOEZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5WYWknLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBNTAwLVxcdUE2M0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblZhcmlhdGlvbl9TZWxlY3RvcnMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVGRTAwLVxcdUZFMEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJblZhcmlhdGlvbl9TZWxlY3RvcnNfU3VwcGxlbWVudCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdURCNDBbXFx1REQwMC1cXHVEREVGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVmVkaWNfRXh0ZW5zaW9ucycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFDRDAtXFx1MUNGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luVmVydGljYWxfRm9ybXMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVGRTEwLVxcdUZFMUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbldhcmFuZ19DaXRpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNltcXHVEQ0EwLVxcdURDRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5ZaV9SYWRpY2FscycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE0OTAtXFx1QTRDRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luWWlfU3lsbGFibGVzJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTAwMC1cXHVBNDhGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSW5ZaWppbmdfSGV4YWdyYW1fU3ltYm9scycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTREQzAtXFx1NERGRidcclxuICAgICAgICB9XHJcbiAgICBdKTtcclxuXHJcbn07XHJcbiIsIi8qIVxyXG4gKiBYUmVnRXhwIFVuaWNvZGUgQ2F0ZWdvcmllcyAzLjEuMVxyXG4gKiA8eHJlZ2V4cC5jb20+XHJcbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAxMC0yMDE2IE1JVCBMaWNlbnNlXHJcbiAqIFVuaWNvZGUgZGF0YSBieSBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc2J5bmVucy5iZT5cclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFhSZWdFeHApIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgc3VwcG9ydCBmb3IgVW5pY29kZSdzIGdlbmVyYWwgY2F0ZWdvcmllcy4gRS5nLiwgYFxccHtMdX1gIG9yIGBcXHB7VXBwZXJjYXNlIExldHRlcn1gLiBTZWVcclxuICAgICAqIGNhdGVnb3J5IGRlc2NyaXB0aW9ucyBpbiBVQVggIzQ0IDxodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ0LyNHQ19WYWx1ZXNfVGFibGU+LiBUb2tlblxyXG4gICAgICogbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUsIGFuZCBhbnkgc3BhY2VzLCBoeXBoZW5zLCBhbmQgdW5kZXJzY29yZXMgYXJlIGlnbm9yZWQuXHJcbiAgICAgKlxyXG4gICAgICogVXNlcyBVbmljb2RlIDguMC4wLlxyXG4gICAgICpcclxuICAgICAqIEByZXF1aXJlcyBYUmVnRXhwLCBVbmljb2RlIEJhc2VcclxuICAgICAqL1xyXG5cclxuICAgIGlmICghWFJlZ0V4cC5hZGRVbmljb2RlRGF0YSkge1xyXG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignVW5pY29kZSBCYXNlIG11c3QgYmUgbG9hZGVkIGJlZm9yZSBVbmljb2RlIENhdGVnb3JpZXMnKTtcclxuICAgIH1cclxuXHJcbiAgICBYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdPdGhlcicsXHJcbiAgICAgICAgICAgIGlzQm1wTGFzdDogdHJ1ZSxcclxuICAgICAgICAgICAgYm1wOiAnXFwwLVxceDFGXFx4N0YtXFx4OUZcXHhBRFxcdTAzNzhcXHUwMzc5XFx1MDM4MC1cXHUwMzgzXFx1MDM4QlxcdTAzOERcXHUwM0EyXFx1MDUzMFxcdTA1NTdcXHUwNTU4XFx1MDU2MFxcdTA1ODhcXHUwNThCXFx1MDU4Q1xcdTA1OTBcXHUwNUM4LVxcdTA1Q0ZcXHUwNUVCLVxcdTA1RUZcXHUwNUY1LVxcdTA2MDVcXHUwNjFDXFx1MDYxRFxcdTA2RERcXHUwNzBFXFx1MDcwRlxcdTA3NEJcXHUwNzRDXFx1MDdCMi1cXHUwN0JGXFx1MDdGQi1cXHUwN0ZGXFx1MDgyRVxcdTA4MkZcXHUwODNGXFx1MDg1Q1xcdTA4NURcXHUwODVGLVxcdTA4OUZcXHUwOEI1LVxcdTA4RTJcXHUwOTg0XFx1MDk4RFxcdTA5OEVcXHUwOTkxXFx1MDk5MlxcdTA5QTlcXHUwOUIxXFx1MDlCMy1cXHUwOUI1XFx1MDlCQVxcdTA5QkJcXHUwOUM1XFx1MDlDNlxcdTA5QzlcXHUwOUNBXFx1MDlDRi1cXHUwOUQ2XFx1MDlEOC1cXHUwOURCXFx1MDlERVxcdTA5RTRcXHUwOUU1XFx1MDlGQy1cXHUwQTAwXFx1MEEwNFxcdTBBMEItXFx1MEEwRVxcdTBBMTFcXHUwQTEyXFx1MEEyOVxcdTBBMzFcXHUwQTM0XFx1MEEzN1xcdTBBM0FcXHUwQTNCXFx1MEEzRFxcdTBBNDMtXFx1MEE0NlxcdTBBNDlcXHUwQTRBXFx1MEE0RS1cXHUwQTUwXFx1MEE1Mi1cXHUwQTU4XFx1MEE1RFxcdTBBNUYtXFx1MEE2NVxcdTBBNzYtXFx1MEE4MFxcdTBBODRcXHUwQThFXFx1MEE5MlxcdTBBQTlcXHUwQUIxXFx1MEFCNFxcdTBBQkFcXHUwQUJCXFx1MEFDNlxcdTBBQ0FcXHUwQUNFXFx1MEFDRlxcdTBBRDEtXFx1MEFERlxcdTBBRTRcXHUwQUU1XFx1MEFGMi1cXHUwQUY4XFx1MEFGQS1cXHUwQjAwXFx1MEIwNFxcdTBCMERcXHUwQjBFXFx1MEIxMVxcdTBCMTJcXHUwQjI5XFx1MEIzMVxcdTBCMzRcXHUwQjNBXFx1MEIzQlxcdTBCNDVcXHUwQjQ2XFx1MEI0OVxcdTBCNEFcXHUwQjRFLVxcdTBCNTVcXHUwQjU4LVxcdTBCNUJcXHUwQjVFXFx1MEI2NFxcdTBCNjVcXHUwQjc4LVxcdTBCODFcXHUwQjg0XFx1MEI4Qi1cXHUwQjhEXFx1MEI5MVxcdTBCOTYtXFx1MEI5OFxcdTBCOUJcXHUwQjlEXFx1MEJBMC1cXHUwQkEyXFx1MEJBNS1cXHUwQkE3XFx1MEJBQi1cXHUwQkFEXFx1MEJCQS1cXHUwQkJEXFx1MEJDMy1cXHUwQkM1XFx1MEJDOVxcdTBCQ0VcXHUwQkNGXFx1MEJEMS1cXHUwQkQ2XFx1MEJEOC1cXHUwQkU1XFx1MEJGQi1cXHUwQkZGXFx1MEMwNFxcdTBDMERcXHUwQzExXFx1MEMyOVxcdTBDM0EtXFx1MEMzQ1xcdTBDNDVcXHUwQzQ5XFx1MEM0RS1cXHUwQzU0XFx1MEM1N1xcdTBDNUItXFx1MEM1RlxcdTBDNjRcXHUwQzY1XFx1MEM3MC1cXHUwQzc3XFx1MEM4MFxcdTBDODRcXHUwQzhEXFx1MEM5MVxcdTBDQTlcXHUwQ0I0XFx1MENCQVxcdTBDQkJcXHUwQ0M1XFx1MENDOVxcdTBDQ0UtXFx1MENENFxcdTBDRDctXFx1MENERFxcdTBDREZcXHUwQ0U0XFx1MENFNVxcdTBDRjBcXHUwQ0YzLVxcdTBEMDBcXHUwRDA0XFx1MEQwRFxcdTBEMTFcXHUwRDNCXFx1MEQzQ1xcdTBENDVcXHUwRDQ5XFx1MEQ0Ri1cXHUwRDU2XFx1MEQ1OC1cXHUwRDVFXFx1MEQ2NFxcdTBENjVcXHUwRDc2LVxcdTBENzhcXHUwRDgwXFx1MEQ4MVxcdTBEODRcXHUwRDk3LVxcdTBEOTlcXHUwREIyXFx1MERCQ1xcdTBEQkVcXHUwREJGXFx1MERDNy1cXHUwREM5XFx1MERDQi1cXHUwRENFXFx1MERENVxcdTBERDdcXHUwREUwLVxcdTBERTVcXHUwREYwXFx1MERGMVxcdTBERjUtXFx1MEUwMFxcdTBFM0ItXFx1MEUzRVxcdTBFNUMtXFx1MEU4MFxcdTBFODNcXHUwRTg1XFx1MEU4NlxcdTBFODlcXHUwRThCXFx1MEU4Q1xcdTBFOEUtXFx1MEU5M1xcdTBFOThcXHUwRUEwXFx1MEVBNFxcdTBFQTZcXHUwRUE4XFx1MEVBOVxcdTBFQUNcXHUwRUJBXFx1MEVCRVxcdTBFQkZcXHUwRUM1XFx1MEVDN1xcdTBFQ0VcXHUwRUNGXFx1MEVEQVxcdTBFREJcXHUwRUUwLVxcdTBFRkZcXHUwRjQ4XFx1MEY2RC1cXHUwRjcwXFx1MEY5OFxcdTBGQkRcXHUwRkNEXFx1MEZEQi1cXHUwRkZGXFx1MTBDNlxcdTEwQzgtXFx1MTBDQ1xcdTEwQ0VcXHUxMENGXFx1MTI0OVxcdTEyNEVcXHUxMjRGXFx1MTI1N1xcdTEyNTlcXHUxMjVFXFx1MTI1RlxcdTEyODlcXHUxMjhFXFx1MTI4RlxcdTEyQjFcXHUxMkI2XFx1MTJCN1xcdTEyQkZcXHUxMkMxXFx1MTJDNlxcdTEyQzdcXHUxMkQ3XFx1MTMxMVxcdTEzMTZcXHUxMzE3XFx1MTM1QlxcdTEzNUNcXHUxMzdELVxcdTEzN0ZcXHUxMzlBLVxcdTEzOUZcXHUxM0Y2XFx1MTNGN1xcdTEzRkVcXHUxM0ZGXFx1MTY5RC1cXHUxNjlGXFx1MTZGOS1cXHUxNkZGXFx1MTcwRFxcdTE3MTUtXFx1MTcxRlxcdTE3MzctXFx1MTczRlxcdTE3NTQtXFx1MTc1RlxcdTE3NkRcXHUxNzcxXFx1MTc3NC1cXHUxNzdGXFx1MTdERVxcdTE3REZcXHUxN0VBLVxcdTE3RUZcXHUxN0ZBLVxcdTE3RkZcXHUxODBFXFx1MTgwRlxcdTE4MUEtXFx1MTgxRlxcdTE4NzgtXFx1MTg3RlxcdTE4QUItXFx1MThBRlxcdTE4RjYtXFx1MThGRlxcdTE5MUZcXHUxOTJDLVxcdTE5MkZcXHUxOTNDLVxcdTE5M0ZcXHUxOTQxLVxcdTE5NDNcXHUxOTZFXFx1MTk2RlxcdTE5NzUtXFx1MTk3RlxcdTE5QUMtXFx1MTlBRlxcdTE5Q0EtXFx1MTlDRlxcdTE5REItXFx1MTlERFxcdTFBMUNcXHUxQTFEXFx1MUE1RlxcdTFBN0RcXHUxQTdFXFx1MUE4QS1cXHUxQThGXFx1MUE5QS1cXHUxQTlGXFx1MUFBRVxcdTFBQUZcXHUxQUJGLVxcdTFBRkZcXHUxQjRDLVxcdTFCNEZcXHUxQjdELVxcdTFCN0ZcXHUxQkY0LVxcdTFCRkJcXHUxQzM4LVxcdTFDM0FcXHUxQzRBLVxcdTFDNENcXHUxQzgwLVxcdTFDQkZcXHUxQ0M4LVxcdTFDQ0ZcXHUxQ0Y3XFx1MUNGQS1cXHUxQ0ZGXFx1MURGNi1cXHUxREZCXFx1MUYxNlxcdTFGMTdcXHUxRjFFXFx1MUYxRlxcdTFGNDZcXHUxRjQ3XFx1MUY0RVxcdTFGNEZcXHUxRjU4XFx1MUY1QVxcdTFGNUNcXHUxRjVFXFx1MUY3RVxcdTFGN0ZcXHUxRkI1XFx1MUZDNVxcdTFGRDRcXHUxRkQ1XFx1MUZEQ1xcdTFGRjBcXHUxRkYxXFx1MUZGNVxcdTFGRkZcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNkZcXHUyMDcyXFx1MjA3M1xcdTIwOEZcXHUyMDlELVxcdTIwOUZcXHUyMEJGLVxcdTIwQ0ZcXHUyMEYxLVxcdTIwRkZcXHUyMThDLVxcdTIxOEZcXHUyM0ZCLVxcdTIzRkZcXHUyNDI3LVxcdTI0M0ZcXHUyNDRCLVxcdTI0NUZcXHUyQjc0XFx1MkI3NVxcdTJCOTZcXHUyQjk3XFx1MkJCQS1cXHUyQkJDXFx1MkJDOVxcdTJCRDItXFx1MkJFQlxcdTJCRjAtXFx1MkJGRlxcdTJDMkZcXHUyQzVGXFx1MkNGNC1cXHUyQ0Y4XFx1MkQyNlxcdTJEMjgtXFx1MkQyQ1xcdTJEMkVcXHUyRDJGXFx1MkQ2OC1cXHUyRDZFXFx1MkQ3MS1cXHUyRDdFXFx1MkQ5Ny1cXHUyRDlGXFx1MkRBN1xcdTJEQUZcXHUyREI3XFx1MkRCRlxcdTJEQzdcXHUyRENGXFx1MkREN1xcdTJEREZcXHUyRTQzLVxcdTJFN0ZcXHUyRTlBXFx1MkVGNC1cXHUyRUZGXFx1MkZENi1cXHUyRkVGXFx1MkZGQy1cXHUyRkZGXFx1MzA0MFxcdTMwOTdcXHUzMDk4XFx1MzEwMC1cXHUzMTA0XFx1MzEyRS1cXHUzMTMwXFx1MzE4RlxcdTMxQkItXFx1MzFCRlxcdTMxRTQtXFx1MzFFRlxcdTMyMUZcXHUzMkZGXFx1NERCNi1cXHU0REJGXFx1OUZENi1cXHU5RkZGXFx1QTQ4RC1cXHVBNDhGXFx1QTRDNy1cXHVBNENGXFx1QTYyQy1cXHVBNjNGXFx1QTZGOC1cXHVBNkZGXFx1QTdBRVxcdUE3QUZcXHVBN0I4LVxcdUE3RjZcXHVBODJDLVxcdUE4MkZcXHVBODNBLVxcdUE4M0ZcXHVBODc4LVxcdUE4N0ZcXHVBOEM1LVxcdUE4Q0RcXHVBOERBLVxcdUE4REZcXHVBOEZFXFx1QThGRlxcdUE5NTQtXFx1QTk1RVxcdUE5N0QtXFx1QTk3RlxcdUE5Q0VcXHVBOURBLVxcdUE5RERcXHVBOUZGXFx1QUEzNy1cXHVBQTNGXFx1QUE0RVxcdUFBNEZcXHVBQTVBXFx1QUE1QlxcdUFBQzMtXFx1QUFEQVxcdUFBRjctXFx1QUIwMFxcdUFCMDdcXHVBQjA4XFx1QUIwRlxcdUFCMTBcXHVBQjE3LVxcdUFCMUZcXHVBQjI3XFx1QUIyRlxcdUFCNjYtXFx1QUI2RlxcdUFCRUVcXHVBQkVGXFx1QUJGQS1cXHVBQkZGXFx1RDdBNC1cXHVEN0FGXFx1RDdDNy1cXHVEN0NBXFx1RDdGQy1cXHVGOEZGXFx1RkE2RVxcdUZBNkZcXHVGQURBLVxcdUZBRkZcXHVGQjA3LVxcdUZCMTJcXHVGQjE4LVxcdUZCMUNcXHVGQjM3XFx1RkIzRFxcdUZCM0ZcXHVGQjQyXFx1RkI0NVxcdUZCQzItXFx1RkJEMlxcdUZENDAtXFx1RkQ0RlxcdUZEOTBcXHVGRDkxXFx1RkRDOC1cXHVGREVGXFx1RkRGRVxcdUZERkZcXHVGRTFBLVxcdUZFMUZcXHVGRTUzXFx1RkU2N1xcdUZFNkMtXFx1RkU2RlxcdUZFNzVcXHVGRUZELVxcdUZGMDBcXHVGRkJGLVxcdUZGQzFcXHVGRkM4XFx1RkZDOVxcdUZGRDBcXHVGRkQxXFx1RkZEOFxcdUZGRDlcXHVGRkRELVxcdUZGREZcXHVGRkU3XFx1RkZFRi1cXHVGRkZCXFx1RkZGRVxcdUZGRkYnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODM0W1xcdURDRjYtXFx1RENGRlxcdUREMjdcXHVERDI4XFx1REQ3My1cXHVERDdBXFx1RERFOS1cXHVEREZGXFx1REU0Ni1cXHVERUZGXFx1REY1Ny1cXHVERjVGXFx1REY3Mi1cXHVERkZGXXxcXHVEODM2W1xcdURFOEMtXFx1REU5QVxcdURFQTBcXHVERUIwLVxcdURGRkZdfFxcdUQ4M0NbXFx1REMyQy1cXHVEQzJGXFx1REM5NC1cXHVEQzlGXFx1RENBRlxcdURDQjBcXHVEQ0MwXFx1RENEMFxcdURDRjYtXFx1RENGRlxcdUREMEQtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENkZcXHVERDlCLVxcdURERTVcXHVERTAzLVxcdURFMEZcXHVERTNCLVxcdURFM0ZcXHVERTQ5LVxcdURFNEZcXHVERTUyLVxcdURFRkZdfFxcdUQ4MUFbXFx1REUzOS1cXHVERTNGXFx1REU1RlxcdURFNkEtXFx1REU2RFxcdURFNzAtXFx1REVDRlxcdURFRUVcXHVERUVGXFx1REVGNi1cXHVERUZGXFx1REY0Ni1cXHVERjRGXFx1REY1QVxcdURGNjJcXHVERjc4LVxcdURGN0NcXHVERjkwLVxcdURGRkZdfFxcdUQ4MDlbXFx1REM2RlxcdURDNzUtXFx1REM3RlxcdURENDQtXFx1REZGRl18XFx1RDgxQltcXHVEQzAwLVxcdURFRkZcXHVERjQ1LVxcdURGNEZcXHVERjdGLVxcdURGOEVcXHVERkEwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMxRVxcdURDMUZdfFxcdUQ4M0RbXFx1REQ3QVxcdUREQTRcXHVERUQxLVxcdURFREZcXHVERUVELVxcdURFRUZcXHVERUY0LVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4MDFbXFx1REM5RVxcdURDOUZcXHVEQ0FBLVxcdURDRkZcXHVERDI4LVxcdUREMkZcXHVERDY0LVxcdURENkVcXHVERDcwLVxcdURERkZcXHVERjM3LVxcdURGM0ZcXHVERjU2LVxcdURGNUZcXHVERjY4LVxcdURGRkZdfFxcdUQ4MDBbXFx1REMwQ1xcdURDMjdcXHVEQzNCXFx1REMzRVxcdURDNEVcXHVEQzRGXFx1REM1RS1cXHVEQzdGXFx1RENGQi1cXHVEQ0ZGXFx1REQwMy1cXHVERDA2XFx1REQzNC1cXHVERDM2XFx1REQ4RC1cXHVERDhGXFx1REQ5Qy1cXHVERDlGXFx1RERBMS1cXHVERENGXFx1RERGRS1cXHVERTdGXFx1REU5RC1cXHVERTlGXFx1REVEMS1cXHVERURGXFx1REVGQy1cXHVERUZGXFx1REYyNC1cXHVERjJGXFx1REY0Qi1cXHVERjRGXFx1REY3Qi1cXHVERjdGXFx1REY5RVxcdURGQzQtXFx1REZDN1xcdURGRDYtXFx1REZGRl18XFx1RDg2OVtcXHVERUQ3LVxcdURFRkZdfFxcdUQ4M0JbXFx1REMwMC1cXHVEREZGXFx1REUwNFxcdURFMjBcXHVERTIzXFx1REUyNVxcdURFMjZcXHVERTI4XFx1REUzM1xcdURFMzhcXHVERTNBXFx1REUzQy1cXHVERTQxXFx1REU0My1cXHVERTQ2XFx1REU0OFxcdURFNEFcXHVERTRDXFx1REU1MFxcdURFNTNcXHVERTU1XFx1REU1NlxcdURFNThcXHVERTVBXFx1REU1Q1xcdURFNUVcXHVERTYwXFx1REU2M1xcdURFNjVcXHVERTY2XFx1REU2QlxcdURFNzNcXHVERTc4XFx1REU3RFxcdURFN0ZcXHVERThBXFx1REU5Qy1cXHVERUEwXFx1REVBNFxcdURFQUFcXHVERUJDLVxcdURFRUZcXHVERUYyLVxcdURGRkZdfFxcdUQ4N0VbXFx1REUxRS1cXHVERkZGXXxcXHVEQjQwW1xcdURDMDAtXFx1RENGRlxcdURERjAtXFx1REZGRl18XFx1RDgwNFtcXHVEQzRFLVxcdURDNTFcXHVEQzcwLVxcdURDN0VcXHVEQ0JEXFx1RENDMi1cXHVEQ0NGXFx1RENFOS1cXHVEQ0VGXFx1RENGQS1cXHVEQ0ZGXFx1REQzNVxcdURENDQtXFx1REQ0RlxcdURENzctXFx1REQ3RlxcdUREQ0VcXHVERENGXFx1RERFMFxcdURERjUtXFx1RERGRlxcdURFMTJcXHVERTNFLVxcdURFN0ZcXHVERTg3XFx1REU4OVxcdURFOEVcXHVERTlFXFx1REVBQS1cXHVERUFGXFx1REVFQi1cXHVERUVGXFx1REVGQS1cXHVERUZGXFx1REYwNFxcdURGMERcXHVERjBFXFx1REYxMVxcdURGMTJcXHVERjI5XFx1REYzMVxcdURGMzRcXHVERjNBXFx1REYzQlxcdURGNDVcXHVERjQ2XFx1REY0OVxcdURGNEFcXHVERjRFXFx1REY0RlxcdURGNTEtXFx1REY1NlxcdURGNTgtXFx1REY1Q1xcdURGNjRcXHVERjY1XFx1REY2RC1cXHVERjZGXFx1REY3NS1cXHVERkZGXXxcXHVEODNBW1xcdURDQzVcXHVEQ0M2XFx1RENENy1cXHVERkZGXXxcXHVEODBEW1xcdURDMkYtXFx1REZGRl18XFx1RDg2RFtcXHVERjM1LVxcdURGM0ZdfFtcXHVEODA3XFx1RDgwQVxcdUQ4MEJcXHVEODBFLVxcdUQ4MTBcXHVEODEyLVxcdUQ4MTlcXHVEODFDLVxcdUQ4MkJcXHVEODJEXFx1RDgyRVxcdUQ4MzAtXFx1RDgzM1xcdUQ4MzctXFx1RDgzOVxcdUQ4M0ZcXHVEODc0LVxcdUQ4N0RcXHVEODdGLVxcdURCM0ZcXHVEQjQxLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwNltcXHVEQzAwLVxcdURDOUZcXHVEQ0YzLVxcdURDRkVcXHVERDAwLVxcdURFQkZcXHVERUY5LVxcdURGRkZdfFxcdUQ4MDNbXFx1REM0OS1cXHVEQzdGXFx1RENCMy1cXHVEQ0JGXFx1RENGMy1cXHVEQ0Y5XFx1REQwMC1cXHVERTVGXFx1REU3Ri1cXHVERkZGXXxcXHVEODM1W1xcdURDNTVcXHVEQzlEXFx1RENBMFxcdURDQTFcXHVEQ0EzXFx1RENBNFxcdURDQTdcXHVEQ0E4XFx1RENBRFxcdURDQkFcXHVEQ0JDXFx1RENDNFxcdUREMDZcXHVERDBCXFx1REQwQ1xcdUREMTVcXHVERDFEXFx1REQzQVxcdUREM0ZcXHVERDQ1XFx1REQ0Ny1cXHVERDQ5XFx1REQ1MVxcdURFQTZcXHVERUE3XFx1REZDQ1xcdURGQ0RdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzdGXFx1RENDOC1cXHVEQ0NGXFx1RENEQS1cXHVERDdGXFx1RERCNlxcdUREQjdcXHVERERFLVxcdURERkZcXHVERTQ1LVxcdURFNEZcXHVERTVBLVxcdURFN0ZcXHVERUI4LVxcdURFQkZcXHVERUNBLVxcdURFRkZcXHVERjFBLVxcdURGMUNcXHVERjJDLVxcdURGMkZcXHVERjQwLVxcdURGRkZdfFxcdUQ4MDJbXFx1REMwNlxcdURDMDdcXHVEQzA5XFx1REMzNlxcdURDMzktXFx1REMzQlxcdURDM0RcXHVEQzNFXFx1REM1NlxcdURDOUYtXFx1RENBNlxcdURDQjAtXFx1RENERlxcdURDRjNcXHVEQ0Y2LVxcdURDRkFcXHVERDFDLVxcdUREMUVcXHVERDNBLVxcdUREM0VcXHVERDQwLVxcdUREN0ZcXHVEREI4LVxcdUREQkJcXHVEREQwXFx1REREMVxcdURFMDRcXHVERTA3LVxcdURFMEJcXHVERTE0XFx1REUxOFxcdURFMzQtXFx1REUzN1xcdURFM0ItXFx1REUzRVxcdURFNDgtXFx1REU0RlxcdURFNTktXFx1REU1RlxcdURFQTAtXFx1REVCRlxcdURFRTctXFx1REVFQVxcdURFRjctXFx1REVGRlxcdURGMzYtXFx1REYzOFxcdURGNTZcXHVERjU3XFx1REY3My1cXHVERjc3XFx1REY5Mi1cXHVERjk4XFx1REY5RC1cXHVERkE4XFx1REZCMC1cXHVERkZGXXxcXHVEODA4W1xcdURGOUEtXFx1REZGRl18XFx1RDgyRltcXHVEQzZCLVxcdURDNkZcXHVEQzdELVxcdURDN0ZcXHVEQzg5LVxcdURDOEZcXHVEQzlBXFx1REM5QlxcdURDQTAtXFx1REZGRl18XFx1RDgyQ1tcXHVEQzAyLVxcdURGRkZdfFxcdUQ4MTFbXFx1REU0Ny1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1REQwRlxcdUREMTktXFx1REQ3RlxcdUREODUtXFx1RERCRlxcdUREQzEtXFx1REZGRl18XFx1RDg3M1tcXHVERUEyLVxcdURGRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ2MnLFxyXG4gICAgICAgICAgICBhbGlhczogJ0NvbnRyb2wnLFxyXG4gICAgICAgICAgICBibXA6ICdcXDAtXFx4MUZcXHg3Ri1cXHg5RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NmJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdGb3JtYXQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHhBRFxcdTA2MDAtXFx1MDYwNVxcdTA2MUNcXHUwNkREXFx1MDcwRlxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNjRcXHUyMDY2LVxcdTIwNkZcXHVGRUZGXFx1RkZGOS1cXHVGRkZCJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXXxcXHVEODJGW1xcdURDQTAtXFx1RENBM118XFx1RDgzNFtcXHVERDczLVxcdUREN0FdfFxcdUQ4MDRcXHVEQ0JEJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ24nLFxyXG4gICAgICAgICAgICBhbGlhczogJ1VuYXNzaWduZWQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwMzc4XFx1MDM3OVxcdTAzODAtXFx1MDM4M1xcdTAzOEJcXHUwMzhEXFx1MDNBMlxcdTA1MzBcXHUwNTU3XFx1MDU1OFxcdTA1NjBcXHUwNTg4XFx1MDU4QlxcdTA1OENcXHUwNTkwXFx1MDVDOC1cXHUwNUNGXFx1MDVFQi1cXHUwNUVGXFx1MDVGNS1cXHUwNUZGXFx1MDYxRFxcdTA3MEVcXHUwNzRCXFx1MDc0Q1xcdTA3QjItXFx1MDdCRlxcdTA3RkItXFx1MDdGRlxcdTA4MkVcXHUwODJGXFx1MDgzRlxcdTA4NUNcXHUwODVEXFx1MDg1Ri1cXHUwODlGXFx1MDhCNS1cXHUwOEUyXFx1MDk4NFxcdTA5OERcXHUwOThFXFx1MDk5MVxcdTA5OTJcXHUwOUE5XFx1MDlCMVxcdTA5QjMtXFx1MDlCNVxcdTA5QkFcXHUwOUJCXFx1MDlDNVxcdTA5QzZcXHUwOUM5XFx1MDlDQVxcdTA5Q0YtXFx1MDlENlxcdTA5RDgtXFx1MDlEQlxcdTA5REVcXHUwOUU0XFx1MDlFNVxcdTA5RkMtXFx1MEEwMFxcdTBBMDRcXHUwQTBCLVxcdTBBMEVcXHUwQTExXFx1MEExMlxcdTBBMjlcXHUwQTMxXFx1MEEzNFxcdTBBMzdcXHUwQTNBXFx1MEEzQlxcdTBBM0RcXHUwQTQzLVxcdTBBNDZcXHUwQTQ5XFx1MEE0QVxcdTBBNEUtXFx1MEE1MFxcdTBBNTItXFx1MEE1OFxcdTBBNURcXHUwQTVGLVxcdTBBNjVcXHUwQTc2LVxcdTBBODBcXHUwQTg0XFx1MEE4RVxcdTBBOTJcXHUwQUE5XFx1MEFCMVxcdTBBQjRcXHUwQUJBXFx1MEFCQlxcdTBBQzZcXHUwQUNBXFx1MEFDRVxcdTBBQ0ZcXHUwQUQxLVxcdTBBREZcXHUwQUU0XFx1MEFFNVxcdTBBRjItXFx1MEFGOFxcdTBBRkEtXFx1MEIwMFxcdTBCMDRcXHUwQjBEXFx1MEIwRVxcdTBCMTFcXHUwQjEyXFx1MEIyOVxcdTBCMzFcXHUwQjM0XFx1MEIzQVxcdTBCM0JcXHUwQjQ1XFx1MEI0NlxcdTBCNDlcXHUwQjRBXFx1MEI0RS1cXHUwQjU1XFx1MEI1OC1cXHUwQjVCXFx1MEI1RVxcdTBCNjRcXHUwQjY1XFx1MEI3OC1cXHUwQjgxXFx1MEI4NFxcdTBCOEItXFx1MEI4RFxcdTBCOTFcXHUwQjk2LVxcdTBCOThcXHUwQjlCXFx1MEI5RFxcdTBCQTAtXFx1MEJBMlxcdTBCQTUtXFx1MEJBN1xcdTBCQUItXFx1MEJBRFxcdTBCQkEtXFx1MEJCRFxcdTBCQzMtXFx1MEJDNVxcdTBCQzlcXHUwQkNFXFx1MEJDRlxcdTBCRDEtXFx1MEJENlxcdTBCRDgtXFx1MEJFNVxcdTBCRkItXFx1MEJGRlxcdTBDMDRcXHUwQzBEXFx1MEMxMVxcdTBDMjlcXHUwQzNBLVxcdTBDM0NcXHUwQzQ1XFx1MEM0OVxcdTBDNEUtXFx1MEM1NFxcdTBDNTdcXHUwQzVCLVxcdTBDNUZcXHUwQzY0XFx1MEM2NVxcdTBDNzAtXFx1MEM3N1xcdTBDODBcXHUwQzg0XFx1MEM4RFxcdTBDOTFcXHUwQ0E5XFx1MENCNFxcdTBDQkFcXHUwQ0JCXFx1MENDNVxcdTBDQzlcXHUwQ0NFLVxcdTBDRDRcXHUwQ0Q3LVxcdTBDRERcXHUwQ0RGXFx1MENFNFxcdTBDRTVcXHUwQ0YwXFx1MENGMy1cXHUwRDAwXFx1MEQwNFxcdTBEMERcXHUwRDExXFx1MEQzQlxcdTBEM0NcXHUwRDQ1XFx1MEQ0OVxcdTBENEYtXFx1MEQ1NlxcdTBENTgtXFx1MEQ1RVxcdTBENjRcXHUwRDY1XFx1MEQ3Ni1cXHUwRDc4XFx1MEQ4MFxcdTBEODFcXHUwRDg0XFx1MEQ5Ny1cXHUwRDk5XFx1MERCMlxcdTBEQkNcXHUwREJFXFx1MERCRlxcdTBEQzctXFx1MERDOVxcdTBEQ0ItXFx1MERDRVxcdTBERDVcXHUwREQ3XFx1MERFMC1cXHUwREU1XFx1MERGMFxcdTBERjFcXHUwREY1LVxcdTBFMDBcXHUwRTNCLVxcdTBFM0VcXHUwRTVDLVxcdTBFODBcXHUwRTgzXFx1MEU4NVxcdTBFODZcXHUwRTg5XFx1MEU4QlxcdTBFOENcXHUwRThFLVxcdTBFOTNcXHUwRTk4XFx1MEVBMFxcdTBFQTRcXHUwRUE2XFx1MEVBOFxcdTBFQTlcXHUwRUFDXFx1MEVCQVxcdTBFQkVcXHUwRUJGXFx1MEVDNVxcdTBFQzdcXHUwRUNFXFx1MEVDRlxcdTBFREFcXHUwRURCXFx1MEVFMC1cXHUwRUZGXFx1MEY0OFxcdTBGNkQtXFx1MEY3MFxcdTBGOThcXHUwRkJEXFx1MEZDRFxcdTBGREItXFx1MEZGRlxcdTEwQzZcXHUxMEM4LVxcdTEwQ0NcXHUxMENFXFx1MTBDRlxcdTEyNDlcXHUxMjRFXFx1MTI0RlxcdTEyNTdcXHUxMjU5XFx1MTI1RVxcdTEyNUZcXHUxMjg5XFx1MTI4RVxcdTEyOEZcXHUxMkIxXFx1MTJCNlxcdTEyQjdcXHUxMkJGXFx1MTJDMVxcdTEyQzZcXHUxMkM3XFx1MTJEN1xcdTEzMTFcXHUxMzE2XFx1MTMxN1xcdTEzNUJcXHUxMzVDXFx1MTM3RC1cXHUxMzdGXFx1MTM5QS1cXHUxMzlGXFx1MTNGNlxcdTEzRjdcXHUxM0ZFXFx1MTNGRlxcdTE2OUQtXFx1MTY5RlxcdTE2RjktXFx1MTZGRlxcdTE3MERcXHUxNzE1LVxcdTE3MUZcXHUxNzM3LVxcdTE3M0ZcXHUxNzU0LVxcdTE3NUZcXHUxNzZEXFx1MTc3MVxcdTE3NzQtXFx1MTc3RlxcdTE3REVcXHUxN0RGXFx1MTdFQS1cXHUxN0VGXFx1MTdGQS1cXHUxN0ZGXFx1MTgwRlxcdTE4MUEtXFx1MTgxRlxcdTE4NzgtXFx1MTg3RlxcdTE4QUItXFx1MThBRlxcdTE4RjYtXFx1MThGRlxcdTE5MUZcXHUxOTJDLVxcdTE5MkZcXHUxOTNDLVxcdTE5M0ZcXHUxOTQxLVxcdTE5NDNcXHUxOTZFXFx1MTk2RlxcdTE5NzUtXFx1MTk3RlxcdTE5QUMtXFx1MTlBRlxcdTE5Q0EtXFx1MTlDRlxcdTE5REItXFx1MTlERFxcdTFBMUNcXHUxQTFEXFx1MUE1RlxcdTFBN0RcXHUxQTdFXFx1MUE4QS1cXHUxQThGXFx1MUE5QS1cXHUxQTlGXFx1MUFBRVxcdTFBQUZcXHUxQUJGLVxcdTFBRkZcXHUxQjRDLVxcdTFCNEZcXHUxQjdELVxcdTFCN0ZcXHUxQkY0LVxcdTFCRkJcXHUxQzM4LVxcdTFDM0FcXHUxQzRBLVxcdTFDNENcXHUxQzgwLVxcdTFDQkZcXHUxQ0M4LVxcdTFDQ0ZcXHUxQ0Y3XFx1MUNGQS1cXHUxQ0ZGXFx1MURGNi1cXHUxREZCXFx1MUYxNlxcdTFGMTdcXHUxRjFFXFx1MUYxRlxcdTFGNDZcXHUxRjQ3XFx1MUY0RVxcdTFGNEZcXHUxRjU4XFx1MUY1QVxcdTFGNUNcXHUxRjVFXFx1MUY3RVxcdTFGN0ZcXHUxRkI1XFx1MUZDNVxcdTFGRDRcXHUxRkQ1XFx1MUZEQ1xcdTFGRjBcXHUxRkYxXFx1MUZGNVxcdTFGRkZcXHUyMDY1XFx1MjA3MlxcdTIwNzNcXHUyMDhGXFx1MjA5RC1cXHUyMDlGXFx1MjBCRi1cXHUyMENGXFx1MjBGMS1cXHUyMEZGXFx1MjE4Qy1cXHUyMThGXFx1MjNGQi1cXHUyM0ZGXFx1MjQyNy1cXHUyNDNGXFx1MjQ0Qi1cXHUyNDVGXFx1MkI3NFxcdTJCNzVcXHUyQjk2XFx1MkI5N1xcdTJCQkEtXFx1MkJCQ1xcdTJCQzlcXHUyQkQyLVxcdTJCRUJcXHUyQkYwLVxcdTJCRkZcXHUyQzJGXFx1MkM1RlxcdTJDRjQtXFx1MkNGOFxcdTJEMjZcXHUyRDI4LVxcdTJEMkNcXHUyRDJFXFx1MkQyRlxcdTJENjgtXFx1MkQ2RVxcdTJENzEtXFx1MkQ3RVxcdTJEOTctXFx1MkQ5RlxcdTJEQTdcXHUyREFGXFx1MkRCN1xcdTJEQkZcXHUyREM3XFx1MkRDRlxcdTJERDdcXHUyRERGXFx1MkU0My1cXHUyRTdGXFx1MkU5QVxcdTJFRjQtXFx1MkVGRlxcdTJGRDYtXFx1MkZFRlxcdTJGRkMtXFx1MkZGRlxcdTMwNDBcXHUzMDk3XFx1MzA5OFxcdTMxMDAtXFx1MzEwNFxcdTMxMkUtXFx1MzEzMFxcdTMxOEZcXHUzMUJCLVxcdTMxQkZcXHUzMUU0LVxcdTMxRUZcXHUzMjFGXFx1MzJGRlxcdTREQjYtXFx1NERCRlxcdTlGRDYtXFx1OUZGRlxcdUE0OEQtXFx1QTQ4RlxcdUE0QzctXFx1QTRDRlxcdUE2MkMtXFx1QTYzRlxcdUE2RjgtXFx1QTZGRlxcdUE3QUVcXHVBN0FGXFx1QTdCOC1cXHVBN0Y2XFx1QTgyQy1cXHVBODJGXFx1QTgzQS1cXHVBODNGXFx1QTg3OC1cXHVBODdGXFx1QThDNS1cXHVBOENEXFx1QThEQS1cXHVBOERGXFx1QThGRVxcdUE4RkZcXHVBOTU0LVxcdUE5NUVcXHVBOTdELVxcdUE5N0ZcXHVBOUNFXFx1QTlEQS1cXHVBOUREXFx1QTlGRlxcdUFBMzctXFx1QUEzRlxcdUFBNEVcXHVBQTRGXFx1QUE1QVxcdUFBNUJcXHVBQUMzLVxcdUFBREFcXHVBQUY3LVxcdUFCMDBcXHVBQjA3XFx1QUIwOFxcdUFCMEZcXHVBQjEwXFx1QUIxNy1cXHVBQjFGXFx1QUIyN1xcdUFCMkZcXHVBQjY2LVxcdUFCNkZcXHVBQkVFXFx1QUJFRlxcdUFCRkEtXFx1QUJGRlxcdUQ3QTQtXFx1RDdBRlxcdUQ3QzctXFx1RDdDQVxcdUQ3RkMtXFx1RDdGRlxcdUZBNkVcXHVGQTZGXFx1RkFEQS1cXHVGQUZGXFx1RkIwNy1cXHVGQjEyXFx1RkIxOC1cXHVGQjFDXFx1RkIzN1xcdUZCM0RcXHVGQjNGXFx1RkI0MlxcdUZCNDVcXHVGQkMyLVxcdUZCRDJcXHVGRDQwLVxcdUZENEZcXHVGRDkwXFx1RkQ5MVxcdUZEQzgtXFx1RkRFRlxcdUZERkVcXHVGREZGXFx1RkUxQS1cXHVGRTFGXFx1RkU1M1xcdUZFNjdcXHVGRTZDLVxcdUZFNkZcXHVGRTc1XFx1RkVGRFxcdUZFRkVcXHVGRjAwXFx1RkZCRi1cXHVGRkMxXFx1RkZDOFxcdUZGQzlcXHVGRkQwXFx1RkZEMVxcdUZGRDhcXHVGRkQ5XFx1RkZERC1cXHVGRkRGXFx1RkZFN1xcdUZGRUYtXFx1RkZGOFxcdUZGRkVcXHVGRkZGJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1REI0MFtcXHVEQzAwXFx1REMwMi1cXHVEQzFGXFx1REM4MC1cXHVEQ0ZGXFx1RERGMC1cXHVERkZGXXxcXHVEODM0W1xcdURDRjYtXFx1RENGRlxcdUREMjdcXHVERDI4XFx1RERFOS1cXHVEREZGXFx1REU0Ni1cXHVERUZGXFx1REY1Ny1cXHVERjVGXFx1REY3Mi1cXHVERkZGXXxcXHVEODNDW1xcdURDMkMtXFx1REMyRlxcdURDOTQtXFx1REM5RlxcdURDQUZcXHVEQ0IwXFx1RENDMFxcdURDRDBcXHVEQ0Y2LVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDZGXFx1REQ5Qi1cXHVEREU1XFx1REUwMy1cXHVERTBGXFx1REUzQi1cXHVERTNGXFx1REU0OS1cXHVERTRGXFx1REU1Mi1cXHVERUZGXXxcXHVEODFBW1xcdURFMzktXFx1REUzRlxcdURFNUZcXHVERTZBLVxcdURFNkRcXHVERTcwLVxcdURFQ0ZcXHVERUVFXFx1REVFRlxcdURFRjYtXFx1REVGRlxcdURGNDYtXFx1REY0RlxcdURGNUFcXHVERjYyXFx1REY3OC1cXHVERjdDXFx1REY5MC1cXHVERkZGXXxcXHVEODA5W1xcdURDNkZcXHVEQzc1LVxcdURDN0ZcXHVERDQ0LVxcdURGRkZdfFxcdUQ4MUJbXFx1REMwMC1cXHVERUZGXFx1REY0NS1cXHVERjRGXFx1REY3Ri1cXHVERjhFXFx1REZBMC1cXHVERkZGXXxcXHVEODZFW1xcdURDMUVcXHVEQzFGXXxcXHVEODNEW1xcdUREN0FcXHVEREE0XFx1REVEMS1cXHVERURGXFx1REVFRC1cXHVERUVGXFx1REVGNC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODAxW1xcdURDOUVcXHVEQzlGXFx1RENBQS1cXHVEQ0ZGXFx1REQyOC1cXHVERDJGXFx1REQ2NC1cXHVERDZFXFx1REQ3MC1cXHVEREZGXFx1REYzNy1cXHVERjNGXFx1REY1Ni1cXHVERjVGXFx1REY2OC1cXHVERkZGXXxcXHVEODAwW1xcdURDMENcXHVEQzI3XFx1REMzQlxcdURDM0VcXHVEQzRFXFx1REM0RlxcdURDNUUtXFx1REM3RlxcdURDRkItXFx1RENGRlxcdUREMDMtXFx1REQwNlxcdUREMzQtXFx1REQzNlxcdUREOEQtXFx1REQ4RlxcdUREOUMtXFx1REQ5RlxcdUREQTEtXFx1RERDRlxcdURERkUtXFx1REU3RlxcdURFOUQtXFx1REU5RlxcdURFRDEtXFx1REVERlxcdURFRkMtXFx1REVGRlxcdURGMjQtXFx1REYyRlxcdURGNEItXFx1REY0RlxcdURGN0ItXFx1REY3RlxcdURGOUVcXHVERkM0LVxcdURGQzdcXHVERkQ2LVxcdURGRkZdfFxcdUQ4NjlbXFx1REVENy1cXHVERUZGXXxcXHVEODNCW1xcdURDMDAtXFx1RERGRlxcdURFMDRcXHVERTIwXFx1REUyM1xcdURFMjVcXHVERTI2XFx1REUyOFxcdURFMzNcXHVERTM4XFx1REUzQVxcdURFM0MtXFx1REU0MVxcdURFNDMtXFx1REU0NlxcdURFNDhcXHVERTRBXFx1REU0Q1xcdURFNTBcXHVERTUzXFx1REU1NVxcdURFNTZcXHVERTU4XFx1REU1QVxcdURFNUNcXHVERTVFXFx1REU2MFxcdURFNjNcXHVERTY1XFx1REU2NlxcdURFNkJcXHVERTczXFx1REU3OFxcdURFN0RcXHVERTdGXFx1REU4QVxcdURFOUMtXFx1REVBMFxcdURFQTRcXHVERUFBXFx1REVCQy1cXHVERUVGXFx1REVGMi1cXHVERkZGXXxbXFx1REJCRlxcdURCRkZdW1xcdURGRkVcXHVERkZGXXxcXHVEODdFW1xcdURFMUUtXFx1REZGRl18XFx1RDgyRltcXHVEQzZCLVxcdURDNkZcXHVEQzdELVxcdURDN0ZcXHVEQzg5LVxcdURDOEZcXHVEQzlBXFx1REM5QlxcdURDQTQtXFx1REZGRl18XFx1RDgzQVtcXHVEQ0M1XFx1RENDNlxcdURDRDctXFx1REZGRl18XFx1RDgwRFtcXHVEQzJGLVxcdURGRkZdfFxcdUQ4NkRbXFx1REYzNS1cXHVERjNGXXxbXFx1RDgwN1xcdUQ4MEFcXHVEODBCXFx1RDgwRS1cXHVEODEwXFx1RDgxMi1cXHVEODE5XFx1RDgxQy1cXHVEODJCXFx1RDgyRFxcdUQ4MkVcXHVEODMwLVxcdUQ4MzNcXHVEODM3LVxcdUQ4MzlcXHVEODNGXFx1RDg3NC1cXHVEODdEXFx1RDg3Ri1cXHVEQjNGXFx1REI0MS1cXHVEQjdGXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MDZbXFx1REMwMC1cXHVEQzlGXFx1RENGMy1cXHVEQ0ZFXFx1REQwMC1cXHVERUJGXFx1REVGOS1cXHVERkZGXXxcXHVEODAzW1xcdURDNDktXFx1REM3RlxcdURDQjMtXFx1RENCRlxcdURDRjMtXFx1RENGOVxcdUREMDAtXFx1REU1RlxcdURFN0YtXFx1REZGRl18XFx1RDgzNVtcXHVEQzU1XFx1REM5RFxcdURDQTBcXHVEQ0ExXFx1RENBM1xcdURDQTRcXHVEQ0E3XFx1RENBOFxcdURDQURcXHVEQ0JBXFx1RENCQ1xcdURDQzRcXHVERDA2XFx1REQwQlxcdUREMENcXHVERDE1XFx1REQxRFxcdUREM0FcXHVERDNGXFx1REQ0NVxcdURENDctXFx1REQ0OVxcdURENTFcXHVERUE2XFx1REVBN1xcdURGQ0NcXHVERkNEXXxcXHVEODM2W1xcdURFOEMtXFx1REU5QVxcdURFQTBcXHVERUIwLVxcdURGRkZdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzdGXFx1RENDOC1cXHVEQ0NGXFx1RENEQS1cXHVERDdGXFx1RERCNlxcdUREQjdcXHVERERFLVxcdURERkZcXHVERTQ1LVxcdURFNEZcXHVERTVBLVxcdURFN0ZcXHVERUI4LVxcdURFQkZcXHVERUNBLVxcdURFRkZcXHVERjFBLVxcdURGMUNcXHVERjJDLVxcdURGMkZcXHVERjQwLVxcdURGRkZdfFxcdUQ4MDJbXFx1REMwNlxcdURDMDdcXHVEQzA5XFx1REMzNlxcdURDMzktXFx1REMzQlxcdURDM0RcXHVEQzNFXFx1REM1NlxcdURDOUYtXFx1RENBNlxcdURDQjAtXFx1RENERlxcdURDRjNcXHVEQ0Y2LVxcdURDRkFcXHVERDFDLVxcdUREMUVcXHVERDNBLVxcdUREM0VcXHVERDQwLVxcdUREN0ZcXHVEREI4LVxcdUREQkJcXHVEREQwXFx1REREMVxcdURFMDRcXHVERTA3LVxcdURFMEJcXHVERTE0XFx1REUxOFxcdURFMzQtXFx1REUzN1xcdURFM0ItXFx1REUzRVxcdURFNDgtXFx1REU0RlxcdURFNTktXFx1REU1RlxcdURFQTAtXFx1REVCRlxcdURFRTctXFx1REVFQVxcdURFRjctXFx1REVGRlxcdURGMzYtXFx1REYzOFxcdURGNTZcXHVERjU3XFx1REY3My1cXHVERjc3XFx1REY5Mi1cXHVERjk4XFx1REY5RC1cXHVERkE4XFx1REZCMC1cXHVERkZGXXxcXHVEODA4W1xcdURGOUEtXFx1REZGRl18XFx1RDgwNFtcXHVEQzRFLVxcdURDNTFcXHVEQzcwLVxcdURDN0VcXHVEQ0MyLVxcdURDQ0ZcXHVEQ0U5LVxcdURDRUZcXHVEQ0ZBLVxcdURDRkZcXHVERDM1XFx1REQ0NC1cXHVERDRGXFx1REQ3Ny1cXHVERDdGXFx1RERDRVxcdUREQ0ZcXHVEREUwXFx1RERGNS1cXHVEREZGXFx1REUxMlxcdURFM0UtXFx1REU3RlxcdURFODdcXHVERTg5XFx1REU4RVxcdURFOUVcXHVERUFBLVxcdURFQUZcXHVERUVCLVxcdURFRUZcXHVERUZBLVxcdURFRkZcXHVERjA0XFx1REYwRFxcdURGMEVcXHVERjExXFx1REYxMlxcdURGMjlcXHVERjMxXFx1REYzNFxcdURGM0FcXHVERjNCXFx1REY0NVxcdURGNDZcXHVERjQ5XFx1REY0QVxcdURGNEVcXHVERjRGXFx1REY1MS1cXHVERjU2XFx1REY1OC1cXHVERjVDXFx1REY2NFxcdURGNjVcXHVERjZELVxcdURGNkZcXHVERjc1LVxcdURGRkZdfFxcdUQ4MkNbXFx1REMwMi1cXHVERkZGXXxcXHVEODExW1xcdURFNDctXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdUREMEZcXHVERDE5LVxcdUREN0ZcXHVERDg1LVxcdUREQkZcXHVEREMxLVxcdURGRkZdfFxcdUQ4NzNbXFx1REVBMi1cXHVERkZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NvJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdQcml2YXRlX1VzZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUUwMDAtXFx1RjhGRicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1tcXHVEQjgwLVxcdURCQkVcXHVEQkMwLVxcdURCRkVdW1xcdURDMDAtXFx1REZGRl18W1xcdURCQkZcXHVEQkZGXVtcXHVEQzAwLVxcdURGRkRdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ3MnLFxyXG4gICAgICAgICAgICBhbGlhczogJ1N1cnJvZ2F0ZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUQ4MDAtXFx1REZGRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0wnLFxyXG4gICAgICAgICAgICBhbGlhczogJ0xldHRlcicsXHJcbiAgICAgICAgICAgIGJtcDogJ0EtWmEtelxceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTgzXFx1MjE4NFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDVcXHUzMDA2XFx1MzAzMS1cXHUzMDM1XFx1MzAzQlxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFNVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNDBcXHVERjQyLVxcdURGNDlcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODA1W1xcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODA5W1xcdURDODAtXFx1REQ0M118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTGwnLFxyXG4gICAgICAgICAgICBhbGlhczogJ0xvd2VyY2FzZV9MZXR0ZXInLFxyXG4gICAgICAgICAgICBibXA6ICdhLXpcXHhCNVxceERGLVxceEY2XFx4RjgtXFx4RkZcXHUwMTAxXFx1MDEwM1xcdTAxMDVcXHUwMTA3XFx1MDEwOVxcdTAxMEJcXHUwMTBEXFx1MDEwRlxcdTAxMTFcXHUwMTEzXFx1MDExNVxcdTAxMTdcXHUwMTE5XFx1MDExQlxcdTAxMURcXHUwMTFGXFx1MDEyMVxcdTAxMjNcXHUwMTI1XFx1MDEyN1xcdTAxMjlcXHUwMTJCXFx1MDEyRFxcdTAxMkZcXHUwMTMxXFx1MDEzM1xcdTAxMzVcXHUwMTM3XFx1MDEzOFxcdTAxM0FcXHUwMTNDXFx1MDEzRVxcdTAxNDBcXHUwMTQyXFx1MDE0NFxcdTAxNDZcXHUwMTQ4XFx1MDE0OVxcdTAxNEJcXHUwMTREXFx1MDE0RlxcdTAxNTFcXHUwMTUzXFx1MDE1NVxcdTAxNTdcXHUwMTU5XFx1MDE1QlxcdTAxNURcXHUwMTVGXFx1MDE2MVxcdTAxNjNcXHUwMTY1XFx1MDE2N1xcdTAxNjlcXHUwMTZCXFx1MDE2RFxcdTAxNkZcXHUwMTcxXFx1MDE3M1xcdTAxNzVcXHUwMTc3XFx1MDE3QVxcdTAxN0NcXHUwMTdFLVxcdTAxODBcXHUwMTgzXFx1MDE4NVxcdTAxODhcXHUwMThDXFx1MDE4RFxcdTAxOTJcXHUwMTk1XFx1MDE5OS1cXHUwMTlCXFx1MDE5RVxcdTAxQTFcXHUwMUEzXFx1MDFBNVxcdTAxQThcXHUwMUFBXFx1MDFBQlxcdTAxQURcXHUwMUIwXFx1MDFCNFxcdTAxQjZcXHUwMUI5XFx1MDFCQVxcdTAxQkQtXFx1MDFCRlxcdTAxQzZcXHUwMUM5XFx1MDFDQ1xcdTAxQ0VcXHUwMUQwXFx1MDFEMlxcdTAxRDRcXHUwMUQ2XFx1MDFEOFxcdTAxREFcXHUwMURDXFx1MDFERFxcdTAxREZcXHUwMUUxXFx1MDFFM1xcdTAxRTVcXHUwMUU3XFx1MDFFOVxcdTAxRUJcXHUwMUVEXFx1MDFFRlxcdTAxRjBcXHUwMUYzXFx1MDFGNVxcdTAxRjlcXHUwMUZCXFx1MDFGRFxcdTAxRkZcXHUwMjAxXFx1MDIwM1xcdTAyMDVcXHUwMjA3XFx1MDIwOVxcdTAyMEJcXHUwMjBEXFx1MDIwRlxcdTAyMTFcXHUwMjEzXFx1MDIxNVxcdTAyMTdcXHUwMjE5XFx1MDIxQlxcdTAyMURcXHUwMjFGXFx1MDIyMVxcdTAyMjNcXHUwMjI1XFx1MDIyN1xcdTAyMjlcXHUwMjJCXFx1MDIyRFxcdTAyMkZcXHUwMjMxXFx1MDIzMy1cXHUwMjM5XFx1MDIzQ1xcdTAyM0ZcXHUwMjQwXFx1MDI0MlxcdTAyNDdcXHUwMjQ5XFx1MDI0QlxcdTAyNERcXHUwMjRGLVxcdTAyOTNcXHUwMjk1LVxcdTAyQUZcXHUwMzcxXFx1MDM3M1xcdTAzNzdcXHUwMzdCLVxcdTAzN0RcXHUwMzkwXFx1MDNBQy1cXHUwM0NFXFx1MDNEMFxcdTAzRDFcXHUwM0Q1LVxcdTAzRDdcXHUwM0Q5XFx1MDNEQlxcdTAzRERcXHUwM0RGXFx1MDNFMVxcdTAzRTNcXHUwM0U1XFx1MDNFN1xcdTAzRTlcXHUwM0VCXFx1MDNFRFxcdTAzRUYtXFx1MDNGM1xcdTAzRjVcXHUwM0Y4XFx1MDNGQlxcdTAzRkNcXHUwNDMwLVxcdTA0NUZcXHUwNDYxXFx1MDQ2M1xcdTA0NjVcXHUwNDY3XFx1MDQ2OVxcdTA0NkJcXHUwNDZEXFx1MDQ2RlxcdTA0NzFcXHUwNDczXFx1MDQ3NVxcdTA0NzdcXHUwNDc5XFx1MDQ3QlxcdTA0N0RcXHUwNDdGXFx1MDQ4MVxcdTA0OEJcXHUwNDhEXFx1MDQ4RlxcdTA0OTFcXHUwNDkzXFx1MDQ5NVxcdTA0OTdcXHUwNDk5XFx1MDQ5QlxcdTA0OURcXHUwNDlGXFx1MDRBMVxcdTA0QTNcXHUwNEE1XFx1MDRBN1xcdTA0QTlcXHUwNEFCXFx1MDRBRFxcdTA0QUZcXHUwNEIxXFx1MDRCM1xcdTA0QjVcXHUwNEI3XFx1MDRCOVxcdTA0QkJcXHUwNEJEXFx1MDRCRlxcdTA0QzJcXHUwNEM0XFx1MDRDNlxcdTA0QzhcXHUwNENBXFx1MDRDQ1xcdTA0Q0VcXHUwNENGXFx1MDREMVxcdTA0RDNcXHUwNEQ1XFx1MDREN1xcdTA0RDlcXHUwNERCXFx1MDRERFxcdTA0REZcXHUwNEUxXFx1MDRFM1xcdTA0RTVcXHUwNEU3XFx1MDRFOVxcdTA0RUJcXHUwNEVEXFx1MDRFRlxcdTA0RjFcXHUwNEYzXFx1MDRGNVxcdTA0RjdcXHUwNEY5XFx1MDRGQlxcdTA0RkRcXHUwNEZGXFx1MDUwMVxcdTA1MDNcXHUwNTA1XFx1MDUwN1xcdTA1MDlcXHUwNTBCXFx1MDUwRFxcdTA1MEZcXHUwNTExXFx1MDUxM1xcdTA1MTVcXHUwNTE3XFx1MDUxOVxcdTA1MUJcXHUwNTFEXFx1MDUxRlxcdTA1MjFcXHUwNTIzXFx1MDUyNVxcdTA1MjdcXHUwNTI5XFx1MDUyQlxcdTA1MkRcXHUwNTJGXFx1MDU2MS1cXHUwNTg3XFx1MTNGOC1cXHUxM0ZEXFx1MUQwMC1cXHUxRDJCXFx1MUQ2Qi1cXHUxRDc3XFx1MUQ3OS1cXHUxRDlBXFx1MUUwMVxcdTFFMDNcXHUxRTA1XFx1MUUwN1xcdTFFMDlcXHUxRTBCXFx1MUUwRFxcdTFFMEZcXHUxRTExXFx1MUUxM1xcdTFFMTVcXHUxRTE3XFx1MUUxOVxcdTFFMUJcXHUxRTFEXFx1MUUxRlxcdTFFMjFcXHUxRTIzXFx1MUUyNVxcdTFFMjdcXHUxRTI5XFx1MUUyQlxcdTFFMkRcXHUxRTJGXFx1MUUzMVxcdTFFMzNcXHUxRTM1XFx1MUUzN1xcdTFFMzlcXHUxRTNCXFx1MUUzRFxcdTFFM0ZcXHUxRTQxXFx1MUU0M1xcdTFFNDVcXHUxRTQ3XFx1MUU0OVxcdTFFNEJcXHUxRTREXFx1MUU0RlxcdTFFNTFcXHUxRTUzXFx1MUU1NVxcdTFFNTdcXHUxRTU5XFx1MUU1QlxcdTFFNURcXHUxRTVGXFx1MUU2MVxcdTFFNjNcXHUxRTY1XFx1MUU2N1xcdTFFNjlcXHUxRTZCXFx1MUU2RFxcdTFFNkZcXHUxRTcxXFx1MUU3M1xcdTFFNzVcXHUxRTc3XFx1MUU3OVxcdTFFN0JcXHUxRTdEXFx1MUU3RlxcdTFFODFcXHUxRTgzXFx1MUU4NVxcdTFFODdcXHUxRTg5XFx1MUU4QlxcdTFFOERcXHUxRThGXFx1MUU5MVxcdTFFOTNcXHUxRTk1LVxcdTFFOURcXHUxRTlGXFx1MUVBMVxcdTFFQTNcXHUxRUE1XFx1MUVBN1xcdTFFQTlcXHUxRUFCXFx1MUVBRFxcdTFFQUZcXHUxRUIxXFx1MUVCM1xcdTFFQjVcXHUxRUI3XFx1MUVCOVxcdTFFQkJcXHUxRUJEXFx1MUVCRlxcdTFFQzFcXHUxRUMzXFx1MUVDNVxcdTFFQzdcXHUxRUM5XFx1MUVDQlxcdTFFQ0RcXHUxRUNGXFx1MUVEMVxcdTFFRDNcXHUxRUQ1XFx1MUVEN1xcdTFFRDlcXHUxRURCXFx1MUVERFxcdTFFREZcXHUxRUUxXFx1MUVFM1xcdTFFRTVcXHUxRUU3XFx1MUVFOVxcdTFFRUJcXHUxRUVEXFx1MUVFRlxcdTFFRjFcXHUxRUYzXFx1MUVGNVxcdTFFRjdcXHUxRUY5XFx1MUVGQlxcdTFFRkRcXHUxRUZGLVxcdTFGMDdcXHUxRjEwLVxcdTFGMTVcXHUxRjIwLVxcdTFGMjdcXHUxRjMwLVxcdTFGMzdcXHUxRjQwLVxcdTFGNDVcXHUxRjUwLVxcdTFGNTdcXHUxRjYwLVxcdTFGNjdcXHUxRjcwLVxcdTFGN0RcXHUxRjgwLVxcdTFGODdcXHUxRjkwLVxcdTFGOTdcXHUxRkEwLVxcdTFGQTdcXHUxRkIwLVxcdTFGQjRcXHUxRkI2XFx1MUZCN1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2XFx1MUZDN1xcdTFGRDAtXFx1MUZEM1xcdTFGRDZcXHUxRkQ3XFx1MUZFMC1cXHUxRkU3XFx1MUZGMi1cXHUxRkY0XFx1MUZGNlxcdTFGRjdcXHUyMTBBXFx1MjEwRVxcdTIxMEZcXHUyMTEzXFx1MjEyRlxcdTIxMzRcXHUyMTM5XFx1MjEzQ1xcdTIxM0RcXHUyMTQ2LVxcdTIxNDlcXHUyMTRFXFx1MjE4NFxcdTJDMzAtXFx1MkM1RVxcdTJDNjFcXHUyQzY1XFx1MkM2NlxcdTJDNjhcXHUyQzZBXFx1MkM2Q1xcdTJDNzFcXHUyQzczXFx1MkM3NFxcdTJDNzYtXFx1MkM3QlxcdTJDODFcXHUyQzgzXFx1MkM4NVxcdTJDODdcXHUyQzg5XFx1MkM4QlxcdTJDOERcXHUyQzhGXFx1MkM5MVxcdTJDOTNcXHUyQzk1XFx1MkM5N1xcdTJDOTlcXHUyQzlCXFx1MkM5RFxcdTJDOUZcXHUyQ0ExXFx1MkNBM1xcdTJDQTVcXHUyQ0E3XFx1MkNBOVxcdTJDQUJcXHUyQ0FEXFx1MkNBRlxcdTJDQjFcXHUyQ0IzXFx1MkNCNVxcdTJDQjdcXHUyQ0I5XFx1MkNCQlxcdTJDQkRcXHUyQ0JGXFx1MkNDMVxcdTJDQzNcXHUyQ0M1XFx1MkNDN1xcdTJDQzlcXHUyQ0NCXFx1MkNDRFxcdTJDQ0ZcXHUyQ0QxXFx1MkNEM1xcdTJDRDVcXHUyQ0Q3XFx1MkNEOVxcdTJDREJcXHUyQ0REXFx1MkNERlxcdTJDRTFcXHUyQ0UzXFx1MkNFNFxcdTJDRUNcXHUyQ0VFXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1QTY0MVxcdUE2NDNcXHVBNjQ1XFx1QTY0N1xcdUE2NDlcXHVBNjRCXFx1QTY0RFxcdUE2NEZcXHVBNjUxXFx1QTY1M1xcdUE2NTVcXHVBNjU3XFx1QTY1OVxcdUE2NUJcXHVBNjVEXFx1QTY1RlxcdUE2NjFcXHVBNjYzXFx1QTY2NVxcdUE2NjdcXHVBNjY5XFx1QTY2QlxcdUE2NkRcXHVBNjgxXFx1QTY4M1xcdUE2ODVcXHVBNjg3XFx1QTY4OVxcdUE2OEJcXHVBNjhEXFx1QTY4RlxcdUE2OTFcXHVBNjkzXFx1QTY5NVxcdUE2OTdcXHVBNjk5XFx1QTY5QlxcdUE3MjNcXHVBNzI1XFx1QTcyN1xcdUE3MjlcXHVBNzJCXFx1QTcyRFxcdUE3MkYtXFx1QTczMVxcdUE3MzNcXHVBNzM1XFx1QTczN1xcdUE3MzlcXHVBNzNCXFx1QTczRFxcdUE3M0ZcXHVBNzQxXFx1QTc0M1xcdUE3NDVcXHVBNzQ3XFx1QTc0OVxcdUE3NEJcXHVBNzREXFx1QTc0RlxcdUE3NTFcXHVBNzUzXFx1QTc1NVxcdUE3NTdcXHVBNzU5XFx1QTc1QlxcdUE3NURcXHVBNzVGXFx1QTc2MVxcdUE3NjNcXHVBNzY1XFx1QTc2N1xcdUE3NjlcXHVBNzZCXFx1QTc2RFxcdUE3NkZcXHVBNzcxLVxcdUE3NzhcXHVBNzdBXFx1QTc3Q1xcdUE3N0ZcXHVBNzgxXFx1QTc4M1xcdUE3ODVcXHVBNzg3XFx1QTc4Q1xcdUE3OEVcXHVBNzkxXFx1QTc5My1cXHVBNzk1XFx1QTc5N1xcdUE3OTlcXHVBNzlCXFx1QTc5RFxcdUE3OUZcXHVBN0ExXFx1QTdBM1xcdUE3QTVcXHVBN0E3XFx1QTdBOVxcdUE3QjVcXHVBN0I3XFx1QTdGQVxcdUFCMzAtXFx1QUI1QVxcdUFCNjAtXFx1QUI2NVxcdUFCNzAtXFx1QUJCRlxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZGNDEtXFx1RkY1QScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDNbXFx1RENDMC1cXHVEQ0YyXXxcXHVEODM1W1xcdURDMUEtXFx1REMzM1xcdURDNEUtXFx1REM1NFxcdURDNTYtXFx1REM2N1xcdURDODItXFx1REM5QlxcdURDQjYtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdURDQ0ZcXHVEQ0VBLVxcdUREMDNcXHVERDFFLVxcdUREMzdcXHVERDUyLVxcdURENkJcXHVERDg2LVxcdUREOUZcXHVEREJBLVxcdURERDNcXHVEREVFLVxcdURFMDdcXHVERTIyLVxcdURFM0JcXHVERTU2LVxcdURFNkZcXHVERThBLVxcdURFQTVcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRTFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMUJcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNTVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGOEZcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQzlcXHVERkNCXXxcXHVEODAxW1xcdURDMjgtXFx1REM0Rl18XFx1RDgwNltcXHVEQ0MwLVxcdURDREZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTG0nLFxyXG4gICAgICAgICAgICBhbGlhczogJ01vZGlmaWVyX0xldHRlcicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTAyQjAtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3NFxcdTAzN0FcXHUwNTU5XFx1MDY0MFxcdTA2RTVcXHUwNkU2XFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDk3MVxcdTBFNDZcXHUwRUM2XFx1MTBGQ1xcdTE3RDdcXHUxODQzXFx1MUFBN1xcdTFDNzgtXFx1MUM3RFxcdTFEMkMtXFx1MUQ2QVxcdTFENzhcXHUxRDlCLVxcdTFEQkZcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTJDN0NcXHUyQzdEXFx1MkQ2RlxcdTJFMkZcXHUzMDA1XFx1MzAzMS1cXHUzMDM1XFx1MzAzQlxcdTMwOURcXHUzMDlFXFx1MzBGQy1cXHUzMEZFXFx1QTAxNVxcdUE0RjgtXFx1QTRGRFxcdUE2MENcXHVBNjdGXFx1QTY5Q1xcdUE2OURcXHVBNzE3LVxcdUE3MUZcXHVBNzcwXFx1QTc4OFxcdUE3RjhcXHVBN0Y5XFx1QTlDRlxcdUE5RTZcXHVBQTcwXFx1QUFERFxcdUFBRjNcXHVBQUY0XFx1QUI1Qy1cXHVBQjVGXFx1RkY3MFxcdUZGOUVcXHVGRjlGJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQVtcXHVERjQwLVxcdURGNDNdfFxcdUQ4MUJbXFx1REY5My1cXHVERjlGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0xvJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdPdGhlcl9MZXR0ZXInLFxyXG4gICAgICAgICAgICBibXA6ICdcXHhBQVxceEJBXFx1MDFCQlxcdTAxQzAtXFx1MDFDM1xcdTAyOTRcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2M0ZcXHUwNjQxLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA4MDAtXFx1MDgxNVxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3Mi1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDVcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwRDAtXFx1MTBGQVxcdTEwRkQtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZGMS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEQ1xcdTE4MjAtXFx1MTg0MlxcdTE4NDQtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3N1xcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MjEzNS1cXHUyMTM4XFx1MkQzMC1cXHUyRDY3XFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNlxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTAxNFxcdUEwMTYtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGN1xcdUE1MDAtXFx1QTYwQlxcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY2RVxcdUE2QTAtXFx1QTZFNVxcdUE3OEZcXHVBN0Y3XFx1QTdGQi1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUUwLVxcdUE5RTRcXHVBOUU3LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNkZcXHVBQTcxLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCXFx1QUFEQ1xcdUFBRTAtXFx1QUFFQVxcdUFBRjJcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjY2LVxcdUZGNkZcXHVGRjcxLVxcdUZGOURcXHVGRkEwLVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGREMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNDBcXHVERjQyLVxcdURGNDlcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODA1W1xcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOVtcXHVEQzgwLVxcdURENDNdfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODAxW1xcdURDNTAtXFx1REM5RFxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMdCcsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnVGl0bGVjYXNlX0xldHRlcicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTAxQzVcXHUwMUM4XFx1MDFDQlxcdTAxRjJcXHUxRjg4LVxcdTFGOEZcXHUxRjk4LVxcdTFGOUZcXHUxRkE4LVxcdTFGQUZcXHUxRkJDXFx1MUZDQ1xcdTFGRkMnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMdScsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnVXBwZXJjYXNlX0xldHRlcicsXHJcbiAgICAgICAgICAgIGJtcDogJ0EtWlxceEMwLVxceEQ2XFx4RDgtXFx4REVcXHUwMTAwXFx1MDEwMlxcdTAxMDRcXHUwMTA2XFx1MDEwOFxcdTAxMEFcXHUwMTBDXFx1MDEwRVxcdTAxMTBcXHUwMTEyXFx1MDExNFxcdTAxMTZcXHUwMTE4XFx1MDExQVxcdTAxMUNcXHUwMTFFXFx1MDEyMFxcdTAxMjJcXHUwMTI0XFx1MDEyNlxcdTAxMjhcXHUwMTJBXFx1MDEyQ1xcdTAxMkVcXHUwMTMwXFx1MDEzMlxcdTAxMzRcXHUwMTM2XFx1MDEzOVxcdTAxM0JcXHUwMTNEXFx1MDEzRlxcdTAxNDFcXHUwMTQzXFx1MDE0NVxcdTAxNDdcXHUwMTRBXFx1MDE0Q1xcdTAxNEVcXHUwMTUwXFx1MDE1MlxcdTAxNTRcXHUwMTU2XFx1MDE1OFxcdTAxNUFcXHUwMTVDXFx1MDE1RVxcdTAxNjBcXHUwMTYyXFx1MDE2NFxcdTAxNjZcXHUwMTY4XFx1MDE2QVxcdTAxNkNcXHUwMTZFXFx1MDE3MFxcdTAxNzJcXHUwMTc0XFx1MDE3NlxcdTAxNzhcXHUwMTc5XFx1MDE3QlxcdTAxN0RcXHUwMTgxXFx1MDE4MlxcdTAxODRcXHUwMTg2XFx1MDE4N1xcdTAxODktXFx1MDE4QlxcdTAxOEUtXFx1MDE5MVxcdTAxOTNcXHUwMTk0XFx1MDE5Ni1cXHUwMTk4XFx1MDE5Q1xcdTAxOURcXHUwMTlGXFx1MDFBMFxcdTAxQTJcXHUwMUE0XFx1MDFBNlxcdTAxQTdcXHUwMUE5XFx1MDFBQ1xcdTAxQUVcXHUwMUFGXFx1MDFCMS1cXHUwMUIzXFx1MDFCNVxcdTAxQjdcXHUwMUI4XFx1MDFCQ1xcdTAxQzRcXHUwMUM3XFx1MDFDQVxcdTAxQ0RcXHUwMUNGXFx1MDFEMVxcdTAxRDNcXHUwMUQ1XFx1MDFEN1xcdTAxRDlcXHUwMURCXFx1MDFERVxcdTAxRTBcXHUwMUUyXFx1MDFFNFxcdTAxRTZcXHUwMUU4XFx1MDFFQVxcdTAxRUNcXHUwMUVFXFx1MDFGMVxcdTAxRjRcXHUwMUY2LVxcdTAxRjhcXHUwMUZBXFx1MDFGQ1xcdTAxRkVcXHUwMjAwXFx1MDIwMlxcdTAyMDRcXHUwMjA2XFx1MDIwOFxcdTAyMEFcXHUwMjBDXFx1MDIwRVxcdTAyMTBcXHUwMjEyXFx1MDIxNFxcdTAyMTZcXHUwMjE4XFx1MDIxQVxcdTAyMUNcXHUwMjFFXFx1MDIyMFxcdTAyMjJcXHUwMjI0XFx1MDIyNlxcdTAyMjhcXHUwMjJBXFx1MDIyQ1xcdTAyMkVcXHUwMjMwXFx1MDIzMlxcdTAyM0FcXHUwMjNCXFx1MDIzRFxcdTAyM0VcXHUwMjQxXFx1MDI0My1cXHUwMjQ2XFx1MDI0OFxcdTAyNEFcXHUwMjRDXFx1MDI0RVxcdTAzNzBcXHUwMzcyXFx1MDM3NlxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEVcXHUwMzhGXFx1MDM5MS1cXHUwM0ExXFx1MDNBMy1cXHUwM0FCXFx1MDNDRlxcdTAzRDItXFx1MDNENFxcdTAzRDhcXHUwM0RBXFx1MDNEQ1xcdTAzREVcXHUwM0UwXFx1MDNFMlxcdTAzRTRcXHUwM0U2XFx1MDNFOFxcdTAzRUFcXHUwM0VDXFx1MDNFRVxcdTAzRjRcXHUwM0Y3XFx1MDNGOVxcdTAzRkFcXHUwM0ZELVxcdTA0MkZcXHUwNDYwXFx1MDQ2MlxcdTA0NjRcXHUwNDY2XFx1MDQ2OFxcdTA0NkFcXHUwNDZDXFx1MDQ2RVxcdTA0NzBcXHUwNDcyXFx1MDQ3NFxcdTA0NzZcXHUwNDc4XFx1MDQ3QVxcdTA0N0NcXHUwNDdFXFx1MDQ4MFxcdTA0OEFcXHUwNDhDXFx1MDQ4RVxcdTA0OTBcXHUwNDkyXFx1MDQ5NFxcdTA0OTZcXHUwNDk4XFx1MDQ5QVxcdTA0OUNcXHUwNDlFXFx1MDRBMFxcdTA0QTJcXHUwNEE0XFx1MDRBNlxcdTA0QThcXHUwNEFBXFx1MDRBQ1xcdTA0QUVcXHUwNEIwXFx1MDRCMlxcdTA0QjRcXHUwNEI2XFx1MDRCOFxcdTA0QkFcXHUwNEJDXFx1MDRCRVxcdTA0QzBcXHUwNEMxXFx1MDRDM1xcdTA0QzVcXHUwNEM3XFx1MDRDOVxcdTA0Q0JcXHUwNENEXFx1MDREMFxcdTA0RDJcXHUwNEQ0XFx1MDRENlxcdTA0RDhcXHUwNERBXFx1MDREQ1xcdTA0REVcXHUwNEUwXFx1MDRFMlxcdTA0RTRcXHUwNEU2XFx1MDRFOFxcdTA0RUFcXHUwNEVDXFx1MDRFRVxcdTA0RjBcXHUwNEYyXFx1MDRGNFxcdTA0RjZcXHUwNEY4XFx1MDRGQVxcdTA0RkNcXHUwNEZFXFx1MDUwMFxcdTA1MDJcXHUwNTA0XFx1MDUwNlxcdTA1MDhcXHUwNTBBXFx1MDUwQ1xcdTA1MEVcXHUwNTEwXFx1MDUxMlxcdTA1MTRcXHUwNTE2XFx1MDUxOFxcdTA1MUFcXHUwNTFDXFx1MDUxRVxcdTA1MjBcXHUwNTIyXFx1MDUyNFxcdTA1MjZcXHUwNTI4XFx1MDUyQVxcdTA1MkNcXHUwNTJFXFx1MDUzMS1cXHUwNTU2XFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxM0EwLVxcdTEzRjVcXHUxRTAwXFx1MUUwMlxcdTFFMDRcXHUxRTA2XFx1MUUwOFxcdTFFMEFcXHUxRTBDXFx1MUUwRVxcdTFFMTBcXHUxRTEyXFx1MUUxNFxcdTFFMTZcXHUxRTE4XFx1MUUxQVxcdTFFMUNcXHUxRTFFXFx1MUUyMFxcdTFFMjJcXHUxRTI0XFx1MUUyNlxcdTFFMjhcXHUxRTJBXFx1MUUyQ1xcdTFFMkVcXHUxRTMwXFx1MUUzMlxcdTFFMzRcXHUxRTM2XFx1MUUzOFxcdTFFM0FcXHUxRTNDXFx1MUUzRVxcdTFFNDBcXHUxRTQyXFx1MUU0NFxcdTFFNDZcXHUxRTQ4XFx1MUU0QVxcdTFFNENcXHUxRTRFXFx1MUU1MFxcdTFFNTJcXHUxRTU0XFx1MUU1NlxcdTFFNThcXHUxRTVBXFx1MUU1Q1xcdTFFNUVcXHUxRTYwXFx1MUU2MlxcdTFFNjRcXHUxRTY2XFx1MUU2OFxcdTFFNkFcXHUxRTZDXFx1MUU2RVxcdTFFNzBcXHUxRTcyXFx1MUU3NFxcdTFFNzZcXHUxRTc4XFx1MUU3QVxcdTFFN0NcXHUxRTdFXFx1MUU4MFxcdTFFODJcXHUxRTg0XFx1MUU4NlxcdTFFODhcXHUxRThBXFx1MUU4Q1xcdTFFOEVcXHUxRTkwXFx1MUU5MlxcdTFFOTRcXHUxRTlFXFx1MUVBMFxcdTFFQTJcXHUxRUE0XFx1MUVBNlxcdTFFQThcXHUxRUFBXFx1MUVBQ1xcdTFFQUVcXHUxRUIwXFx1MUVCMlxcdTFFQjRcXHUxRUI2XFx1MUVCOFxcdTFFQkFcXHUxRUJDXFx1MUVCRVxcdTFFQzBcXHUxRUMyXFx1MUVDNFxcdTFFQzZcXHUxRUM4XFx1MUVDQVxcdTFFQ0NcXHUxRUNFXFx1MUVEMFxcdTFFRDJcXHUxRUQ0XFx1MUVENlxcdTFFRDhcXHUxRURBXFx1MUVEQ1xcdTFFREVcXHUxRUUwXFx1MUVFMlxcdTFFRTRcXHUxRUU2XFx1MUVFOFxcdTFFRUFcXHUxRUVDXFx1MUVFRVxcdTFFRjBcXHUxRUYyXFx1MUVGNFxcdTFFRjZcXHUxRUY4XFx1MUVGQVxcdTFFRkNcXHUxRUZFXFx1MUYwOC1cXHUxRjBGXFx1MUYxOC1cXHUxRjFEXFx1MUYyOC1cXHUxRjJGXFx1MUYzOC1cXHUxRjNGXFx1MUY0OC1cXHUxRjREXFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1RlxcdTFGNjgtXFx1MUY2RlxcdTFGQjgtXFx1MUZCQlxcdTFGQzgtXFx1MUZDQlxcdTFGRDgtXFx1MUZEQlxcdTFGRTgtXFx1MUZFQ1xcdTFGRjgtXFx1MUZGQlxcdTIxMDJcXHUyMTA3XFx1MjEwQi1cXHUyMTBEXFx1MjExMC1cXHUyMTEyXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMzAtXFx1MjEzM1xcdTIxM0VcXHUyMTNGXFx1MjE0NVxcdTIxODNcXHUyQzAwLVxcdTJDMkVcXHUyQzYwXFx1MkM2Mi1cXHUyQzY0XFx1MkM2N1xcdTJDNjlcXHUyQzZCXFx1MkM2RC1cXHUyQzcwXFx1MkM3MlxcdTJDNzVcXHUyQzdFLVxcdTJDODBcXHUyQzgyXFx1MkM4NFxcdTJDODZcXHUyQzg4XFx1MkM4QVxcdTJDOENcXHUyQzhFXFx1MkM5MFxcdTJDOTJcXHUyQzk0XFx1MkM5NlxcdTJDOThcXHUyQzlBXFx1MkM5Q1xcdTJDOUVcXHUyQ0EwXFx1MkNBMlxcdTJDQTRcXHUyQ0E2XFx1MkNBOFxcdTJDQUFcXHUyQ0FDXFx1MkNBRVxcdTJDQjBcXHUyQ0IyXFx1MkNCNFxcdTJDQjZcXHUyQ0I4XFx1MkNCQVxcdTJDQkNcXHUyQ0JFXFx1MkNDMFxcdTJDQzJcXHUyQ0M0XFx1MkNDNlxcdTJDQzhcXHUyQ0NBXFx1MkNDQ1xcdTJDQ0VcXHUyQ0QwXFx1MkNEMlxcdTJDRDRcXHUyQ0Q2XFx1MkNEOFxcdTJDREFcXHUyQ0RDXFx1MkNERVxcdTJDRTBcXHUyQ0UyXFx1MkNFQlxcdTJDRURcXHUyQ0YyXFx1QTY0MFxcdUE2NDJcXHVBNjQ0XFx1QTY0NlxcdUE2NDhcXHVBNjRBXFx1QTY0Q1xcdUE2NEVcXHVBNjUwXFx1QTY1MlxcdUE2NTRcXHVBNjU2XFx1QTY1OFxcdUE2NUFcXHVBNjVDXFx1QTY1RVxcdUE2NjBcXHVBNjYyXFx1QTY2NFxcdUE2NjZcXHVBNjY4XFx1QTY2QVxcdUE2NkNcXHVBNjgwXFx1QTY4MlxcdUE2ODRcXHVBNjg2XFx1QTY4OFxcdUE2OEFcXHVBNjhDXFx1QTY4RVxcdUE2OTBcXHVBNjkyXFx1QTY5NFxcdUE2OTZcXHVBNjk4XFx1QTY5QVxcdUE3MjJcXHVBNzI0XFx1QTcyNlxcdUE3MjhcXHVBNzJBXFx1QTcyQ1xcdUE3MkVcXHVBNzMyXFx1QTczNFxcdUE3MzZcXHVBNzM4XFx1QTczQVxcdUE3M0NcXHVBNzNFXFx1QTc0MFxcdUE3NDJcXHVBNzQ0XFx1QTc0NlxcdUE3NDhcXHVBNzRBXFx1QTc0Q1xcdUE3NEVcXHVBNzUwXFx1QTc1MlxcdUE3NTRcXHVBNzU2XFx1QTc1OFxcdUE3NUFcXHVBNzVDXFx1QTc1RVxcdUE3NjBcXHVBNzYyXFx1QTc2NFxcdUE3NjZcXHVBNzY4XFx1QTc2QVxcdUE3NkNcXHVBNzZFXFx1QTc3OVxcdUE3N0JcXHVBNzdEXFx1QTc3RVxcdUE3ODBcXHVBNzgyXFx1QTc4NFxcdUE3ODZcXHVBNzhCXFx1QTc4RFxcdUE3OTBcXHVBNzkyXFx1QTc5NlxcdUE3OThcXHVBNzlBXFx1QTc5Q1xcdUE3OUVcXHVBN0EwXFx1QTdBMlxcdUE3QTRcXHVBN0E2XFx1QTdBOFxcdUE3QUEtXFx1QTdBRFxcdUE3QjAtXFx1QTdCNFxcdUE3QjZcXHVGRjIxLVxcdUZGM0EnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA2W1xcdURDQTAtXFx1RENCRl18XFx1RDgwM1tcXHVEQzgwLVxcdURDQjJdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzI3XXxcXHVEODM1W1xcdURDMDAtXFx1REMxOVxcdURDMzQtXFx1REM0RFxcdURDNjgtXFx1REM4MVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCNVxcdURDRDAtXFx1RENFOVxcdUREMDRcXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQzOFxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ2Qy1cXHVERDg1XFx1RERBMC1cXHVEREI5XFx1RERENC1cXHVEREVEXFx1REUwOC1cXHVERTIxXFx1REUzQy1cXHVERTU1XFx1REU3MC1cXHVERTg5XFx1REVBOC1cXHVERUMwXFx1REVFMi1cXHVERUZBXFx1REYxQy1cXHVERjM0XFx1REY1Ni1cXHVERjZFXFx1REY5MC1cXHVERkE4XFx1REZDQV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdNYXJrJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RTMtXFx1MDkwM1xcdTA5M0EtXFx1MDkzQ1xcdTA5M0UtXFx1MDk0RlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MS1cXHUwOTgzXFx1MDlCQ1xcdTA5QkUtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MEEwMS1cXHUwQTAzXFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBQkNcXHUwQUJFLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBCMDEtXFx1MEIwM1xcdTBCM0NcXHUwQjNFLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEN1xcdTBDMDAtXFx1MEMwM1xcdTBDM0UtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxLVxcdTBDODNcXHUwQ0JDXFx1MENCRS1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDEtXFx1MEQwM1xcdTBEM0UtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODJcXHUwRDgzXFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREYyXFx1MERGM1xcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUI5XFx1MEVCQlxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0VcXHUwRjNGXFx1MEY3MS1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyQi1cXHUxMDNFXFx1MTA1Ni1cXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZEXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhEXFx1MTA4RlxcdTEwOUEtXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MThBOVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTFBMTctXFx1MUExQlxcdTFBNTUtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQkVcXHUxQjAwLVxcdTFCMDRcXHUxQjM0LVxcdTFCNDRcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCODJcXHUxQkExLVxcdTFCQURcXHUxQkU2LVxcdTFCRjNcXHUxQzI0LVxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRThcXHUxQ0VEXFx1MUNGMi1cXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjVcXHUxREZDLVxcdTFERkZcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyMy1cXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzRcXHVBOEUwLVxcdUE4RjFcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTNcXHVBOTgwLVxcdUE5ODNcXHVBOUIzLVxcdUE5QzBcXHVBOUU1XFx1QUEyOS1cXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTREXFx1QUE3Qi1cXHVBQTdEXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQi1cXHVBQUVGXFx1QUFGNVxcdUFBRjZcXHVBQkUzLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkYnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdURDQjAtXFx1RENDM1xcdUREQUYtXFx1RERCNVxcdUREQjgtXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMC1cXHVERTQwXFx1REVBQi1cXHVERUI3XFx1REYxRC1cXHVERjJCXXxcXHVEODM0W1xcdURENjUtXFx1REQ2OVxcdURENkQtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgwNFtcXHVEQzAwLVxcdURDMDJcXHVEQzM4LVxcdURDNDZcXHVEQzdGLVxcdURDODJcXHVEQ0IwLVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMzRcXHVERDczXFx1REQ4MC1cXHVERDgyXFx1RERCMy1cXHVEREMwXFx1RERDQS1cXHVERENDXFx1REUyQy1cXHVERTM3XFx1REVERi1cXHVERUVBXFx1REYwMC1cXHVERjAzXFx1REYzQ1xcdURGM0UtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0Qi1cXHVERjREXFx1REY1N1xcdURGNjJcXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODFCW1xcdURGNTEtXFx1REY3RVxcdURGOEYtXFx1REY5Ml18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XXxcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNYycsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnU3BhY2luZ19NYXJrJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDkwM1xcdTA5M0JcXHUwOTNFLVxcdTA5NDBcXHUwOTQ5LVxcdTA5NENcXHUwOTRFXFx1MDk0RlxcdTA5ODJcXHUwOTgzXFx1MDlCRS1cXHUwOUMwXFx1MDlDN1xcdTA5QzhcXHUwOUNCXFx1MDlDQ1xcdTA5RDdcXHUwQTAzXFx1MEEzRS1cXHUwQTQwXFx1MEE4M1xcdTBBQkUtXFx1MEFDMFxcdTBBQzlcXHUwQUNCXFx1MEFDQ1xcdTBCMDJcXHUwQjAzXFx1MEIzRVxcdTBCNDBcXHUwQjQ3XFx1MEI0OFxcdTBCNEJcXHUwQjRDXFx1MEI1N1xcdTBCQkVcXHUwQkJGXFx1MEJDMVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0NcXHUwQkQ3XFx1MEMwMS1cXHUwQzAzXFx1MEM0MS1cXHUwQzQ0XFx1MEM4MlxcdTBDODNcXHUwQ0JFXFx1MENDMC1cXHUwQ0M0XFx1MENDN1xcdTBDQzhcXHUwQ0NBXFx1MENDQlxcdTBDRDVcXHUwQ0Q2XFx1MEQwMlxcdTBEMDNcXHUwRDNFLVxcdTBENDBcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENENcXHUwRDU3XFx1MEQ4MlxcdTBEODNcXHUwRENGLVxcdTBERDFcXHUwREQ4LVxcdTBEREZcXHUwREYyXFx1MERGM1xcdTBGM0VcXHUwRjNGXFx1MEY3RlxcdTEwMkJcXHUxMDJDXFx1MTAzMVxcdTEwMzhcXHUxMDNCXFx1MTAzQ1xcdTEwNTZcXHUxMDU3XFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZEXFx1MTA4M1xcdTEwODRcXHUxMDg3LVxcdTEwOENcXHUxMDhGXFx1MTA5QS1cXHUxMDlDXFx1MTdCNlxcdTE3QkUtXFx1MTdDNVxcdTE3QzdcXHUxN0M4XFx1MTkyMy1cXHUxOTI2XFx1MTkyOS1cXHUxOTJCXFx1MTkzMFxcdTE5MzFcXHUxOTMzLVxcdTE5MzhcXHUxQTE5XFx1MUExQVxcdTFBNTVcXHUxQTU3XFx1MUE2MVxcdTFBNjNcXHUxQTY0XFx1MUE2RC1cXHUxQTcyXFx1MUIwNFxcdTFCMzVcXHUxQjNCXFx1MUIzRC1cXHUxQjQxXFx1MUI0M1xcdTFCNDRcXHUxQjgyXFx1MUJBMVxcdTFCQTZcXHUxQkE3XFx1MUJBQVxcdTFCRTdcXHUxQkVBLVxcdTFCRUNcXHUxQkVFXFx1MUJGMlxcdTFCRjNcXHUxQzI0LVxcdTFDMkJcXHUxQzM0XFx1MUMzNVxcdTFDRTFcXHUxQ0YyXFx1MUNGM1xcdTMwMkVcXHUzMDJGXFx1QTgyM1xcdUE4MjRcXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzNcXHVBOTUyXFx1QTk1M1xcdUE5ODNcXHVBOUI0XFx1QTlCNVxcdUE5QkFcXHVBOUJCXFx1QTlCRC1cXHVBOUMwXFx1QUEyRlxcdUFBMzBcXHVBQTMzXFx1QUEzNFxcdUFBNERcXHVBQTdCXFx1QUE3RFxcdUFBRUJcXHVBQUVFXFx1QUFFRlxcdUFBRjVcXHVBQkUzXFx1QUJFNFxcdUFCRTZcXHVBQkU3XFx1QUJFOVxcdUFCRUFcXHVBQkVDJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVERDY1XFx1REQ2NlxcdURENkQtXFx1REQ3Ml18XFx1RDgwNFtcXHVEQzAwXFx1REMwMlxcdURDODJcXHVEQ0IwLVxcdURDQjJcXHVEQ0I3XFx1RENCOFxcdUREMkNcXHVERDgyXFx1RERCMy1cXHVEREI1XFx1RERCRlxcdUREQzBcXHVERTJDLVxcdURFMkVcXHVERTMyXFx1REUzM1xcdURFMzVcXHVERUUwLVxcdURFRTJcXHVERjAyXFx1REYwM1xcdURGM0VcXHVERjNGXFx1REY0MS1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjU3XFx1REY2MlxcdURGNjNdfFxcdUQ4MDVbXFx1RENCMC1cXHVEQ0IyXFx1RENCOVxcdURDQkItXFx1RENCRVxcdURDQzFcXHVEREFGLVxcdUREQjFcXHVEREI4LVxcdUREQkJcXHVEREJFXFx1REUzMC1cXHVERTMyXFx1REUzQlxcdURFM0NcXHVERTNFXFx1REVBQ1xcdURFQUVcXHVERUFGXFx1REVCNlxcdURGMjBcXHVERjIxXFx1REYyNl18XFx1RDgxQltcXHVERjUxLVxcdURGN0VdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTWUnLFxyXG4gICAgICAgICAgICBhbGlhczogJ0VuY2xvc2luZ19NYXJrJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDQ4OFxcdTA0ODlcXHUxQUJFXFx1MjBERC1cXHUyMEUwXFx1MjBFMi1cXHUyMEU0XFx1QTY3MC1cXHVBNjcyJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTW4nLFxyXG4gICAgICAgICAgICBhbGlhczogJ05vbnNwYWNpbmdfTWFyaycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RTJcXHUwOUUzXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBCMDFcXHUwQjNDXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU2XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJDMFxcdTBCQ0RcXHUwQzAwXFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRTJcXHUwQ0UzXFx1MEQwMVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDYyXFx1MEQ2M1xcdTBEQ0FcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQjlcXHUwRUJCXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjAzXFx1MUIzNFxcdTFCMzYtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjVcXHUxREZDLVxcdTFERkZcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRFxcdTMwOTlcXHUzMDlBXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4QzRcXHVBOEUwLVxcdUE4RjFcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MzRbXFx1REQ2Ny1cXHVERDY5XFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjhGLVxcdURGOTJdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDQS1cXHVERENDXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQ1xcdURGNDBcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XXxcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdOJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdOdW1iZXInLFxyXG4gICAgICAgICAgICBibXA6ICcwLTlcXHhCMlxceEIzXFx4QjlcXHhCQy1cXHhCRVxcdTA2NjAtXFx1MDY2OVxcdTA2RjAtXFx1MDZGOVxcdTA3QzAtXFx1MDdDOVxcdTA5NjYtXFx1MDk2RlxcdTA5RTYtXFx1MDlFRlxcdTA5RjQtXFx1MDlGOVxcdTBBNjYtXFx1MEE2RlxcdTBBRTYtXFx1MEFFRlxcdTBCNjYtXFx1MEI2RlxcdTBCNzItXFx1MEI3N1xcdTBCRTYtXFx1MEJGMlxcdTBDNjYtXFx1MEM2RlxcdTBDNzgtXFx1MEM3RVxcdTBDRTYtXFx1MENFRlxcdTBENjYtXFx1MEQ3NVxcdTBERTYtXFx1MERFRlxcdTBFNTAtXFx1MEU1OVxcdTBFRDAtXFx1MEVEOVxcdTBGMjAtXFx1MEYzM1xcdTEwNDAtXFx1MTA0OVxcdTEwOTAtXFx1MTA5OVxcdTEzNjktXFx1MTM3Q1xcdTE2RUUtXFx1MTZGMFxcdTE3RTAtXFx1MTdFOVxcdTE3RjAtXFx1MTdGOVxcdTE4MTAtXFx1MTgxOVxcdTE5NDYtXFx1MTk0RlxcdTE5RDAtXFx1MTlEQVxcdTFBODAtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFCNTAtXFx1MUI1OVxcdTFCQjAtXFx1MUJCOVxcdTFDNDAtXFx1MUM0OVxcdTFDNTAtXFx1MUM1OVxcdTIwNzBcXHUyMDc0LVxcdTIwNzlcXHUyMDgwLVxcdTIwODlcXHUyMTUwLVxcdTIxODJcXHUyMTg1LVxcdTIxODlcXHUyNDYwLVxcdTI0OUJcXHUyNEVBLVxcdTI0RkZcXHUyNzc2LVxcdTI3OTNcXHUyQ0ZEXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzgtXFx1MzAzQVxcdTMxOTItXFx1MzE5NVxcdTMyMjAtXFx1MzIyOVxcdTMyNDgtXFx1MzI0RlxcdTMyNTEtXFx1MzI1RlxcdTMyODAtXFx1MzI4OVxcdTMyQjEtXFx1MzJCRlxcdUE2MjAtXFx1QTYyOVxcdUE2RTYtXFx1QTZFRlxcdUE4MzAtXFx1QTgzNVxcdUE4RDAtXFx1QThEOVxcdUE5MDAtXFx1QTkwOVxcdUE5RDAtXFx1QTlEOVxcdUE5RjAtXFx1QTlGOVxcdUFBNTAtXFx1QUE1OVxcdUFCRjAtXFx1QUJGOVxcdUZGMTAtXFx1RkYxOScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REQwNy1cXHVERDMzXFx1REQ0MC1cXHVERDc4XFx1REQ4QVxcdUREOEJcXHVERUUxLVxcdURFRkJcXHVERjIwLVxcdURGMjNcXHVERjQxXFx1REY0QVxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQ0EwLVxcdURDQTldfFxcdUQ4MDNbXFx1RENGQS1cXHVEQ0ZGXFx1REU2MC1cXHVERTdFXXxcXHVEODM1W1xcdURGQ0UtXFx1REZGRl18XFx1RDgzQVtcXHVEQ0M3LVxcdURDQ0ZdfFxcdUQ4MUFbXFx1REU2MC1cXHVERTY5XFx1REY1MC1cXHVERjU5XFx1REY1Qi1cXHVERjYxXXxcXHVEODA2W1xcdURDRTAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzUyLVxcdURDNkZcXHVEQ0YwLVxcdURDRjlcXHVERDM2LVxcdUREM0ZcXHVEREQwLVxcdURERDlcXHVEREUxLVxcdURERjRcXHVERUYwLVxcdURFRjldfFxcdUQ4MzRbXFx1REY2MC1cXHVERjcxXXxcXHVEODNDW1xcdUREMDAtXFx1REQwQ118XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVdfFxcdUQ4MDJbXFx1REM1OC1cXHVEQzVGXFx1REM3OS1cXHVEQzdGXFx1RENBNy1cXHVEQ0FGXFx1RENGQi1cXHVEQ0ZGXFx1REQxNi1cXHVERDFCXFx1RERCQ1xcdUREQkRcXHVEREMwLVxcdUREQ0ZcXHVEREQyLVxcdURERkZcXHVERTQwLVxcdURFNDdcXHVERTdEXFx1REU3RVxcdURFOUQtXFx1REU5RlxcdURFRUItXFx1REVFRlxcdURGNTgtXFx1REY1RlxcdURGNzgtXFx1REY3RlxcdURGQTktXFx1REZBRl18XFx1RDgwNVtcXHVEQ0QwLVxcdURDRDlcXHVERTUwLVxcdURFNTlcXHVERUMwLVxcdURFQzlcXHVERjMwLVxcdURGM0JdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTmQnLFxyXG4gICAgICAgICAgICBhbGlhczogJ0RlY2ltYWxfTnVtYmVyJyxcclxuICAgICAgICAgICAgYm1wOiAnMC05XFx1MDY2MC1cXHUwNjY5XFx1MDZGMC1cXHUwNkY5XFx1MDdDMC1cXHUwN0M5XFx1MDk2Ni1cXHUwOTZGXFx1MDlFNi1cXHUwOUVGXFx1MEE2Ni1cXHUwQTZGXFx1MEFFNi1cXHUwQUVGXFx1MEI2Ni1cXHUwQjZGXFx1MEJFNi1cXHUwQkVGXFx1MEM2Ni1cXHUwQzZGXFx1MENFNi1cXHUwQ0VGXFx1MEQ2Ni1cXHUwRDZGXFx1MERFNi1cXHUwREVGXFx1MEU1MC1cXHUwRTU5XFx1MEVEMC1cXHUwRUQ5XFx1MEYyMC1cXHUwRjI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA5MC1cXHUxMDk5XFx1MTdFMC1cXHUxN0U5XFx1MTgxMC1cXHUxODE5XFx1MTk0Ni1cXHUxOTRGXFx1MTlEMC1cXHUxOUQ5XFx1MUE4MC1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUI1MC1cXHUxQjU5XFx1MUJCMC1cXHUxQkI5XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1QTYyMC1cXHVBNjI5XFx1QThEMC1cXHVBOEQ5XFx1QTkwMC1cXHVBOTA5XFx1QTlEMC1cXHVBOUQ5XFx1QTlGMC1cXHVBOUY5XFx1QUE1MC1cXHVBQTU5XFx1QUJGMC1cXHVBQkY5XFx1RkYxMC1cXHVGRjE5JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMVtcXHVEQ0EwLVxcdURDQTldfFxcdUQ4MzVbXFx1REZDRS1cXHVERkZGXXxcXHVEODA1W1xcdURDRDAtXFx1RENEOVxcdURFNTAtXFx1REU1OVxcdURFQzAtXFx1REVDOVxcdURGMzAtXFx1REYzOV18XFx1RDgwNltcXHVEQ0UwLVxcdURDRTldfFxcdUQ4MDRbXFx1REM2Ni1cXHVEQzZGXFx1RENGMC1cXHVEQ0Y5XFx1REQzNi1cXHVERDNGXFx1REREMC1cXHVEREQ5XFx1REVGMC1cXHVERUY5XXxcXHVEODFBW1xcdURFNjAtXFx1REU2OVxcdURGNTAtXFx1REY1OV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdObCcsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnTGV0dGVyX051bWJlcicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE2RUUtXFx1MTZGMFxcdTIxNjAtXFx1MjE4MlxcdTIxODUtXFx1MjE4OFxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDM4LVxcdTMwM0FcXHVBNkU2LVxcdUE2RUYnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA5W1xcdURDMDAtXFx1REM2RV18XFx1RDgwMFtcXHVERDQwLVxcdURENzRcXHVERjQxXFx1REY0QVxcdURGRDEtXFx1REZENV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdObycsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnT3RoZXJfTnVtYmVyJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx4QjJcXHhCM1xceEI5XFx4QkMtXFx4QkVcXHUwOUY0LVxcdTA5RjlcXHUwQjcyLVxcdTBCNzdcXHUwQkYwLVxcdTBCRjJcXHUwQzc4LVxcdTBDN0VcXHUwRDcwLVxcdTBENzVcXHUwRjJBLVxcdTBGMzNcXHUxMzY5LVxcdTEzN0NcXHUxN0YwLVxcdTE3RjlcXHUxOURBXFx1MjA3MFxcdTIwNzQtXFx1MjA3OVxcdTIwODAtXFx1MjA4OVxcdTIxNTAtXFx1MjE1RlxcdTIxODlcXHUyNDYwLVxcdTI0OUJcXHUyNEVBLVxcdTI0RkZcXHUyNzc2LVxcdTI3OTNcXHUyQ0ZEXFx1MzE5Mi1cXHUzMTk1XFx1MzIyMC1cXHUzMjI5XFx1MzI0OC1cXHUzMjRGXFx1MzI1MS1cXHUzMjVGXFx1MzI4MC1cXHUzMjg5XFx1MzJCMS1cXHUzMkJGXFx1QTgzMC1cXHVBODM1JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQzUyLVxcdURDNjVcXHVEREUxLVxcdURERjRdfFxcdUQ4MDNbXFx1RENGQS1cXHVEQ0ZGXFx1REU2MC1cXHVERTdFXXxcXHVEODNDW1xcdUREMDAtXFx1REQwQ118XFx1RDgwNltcXHVEQ0VBLVxcdURDRjJdfFxcdUQ4M0FbXFx1RENDNy1cXHVEQ0NGXXxcXHVEODAyW1xcdURDNTgtXFx1REM1RlxcdURDNzktXFx1REM3RlxcdURDQTctXFx1RENBRlxcdURDRkItXFx1RENGRlxcdUREMTYtXFx1REQxQlxcdUREQkNcXHVEREJEXFx1RERDMC1cXHVERENGXFx1REREMi1cXHVEREZGXFx1REU0MC1cXHVERTQ3XFx1REU3RFxcdURFN0VcXHVERTlELVxcdURFOUZcXHVERUVCLVxcdURFRUZcXHVERjU4LVxcdURGNUZcXHVERjc4LVxcdURGN0ZcXHVERkE5LVxcdURGQUZdfFxcdUQ4MDVbXFx1REYzQVxcdURGM0JdfFxcdUQ4MUFbXFx1REY1Qi1cXHVERjYxXXxcXHVEODM0W1xcdURGNjAtXFx1REY3MV18XFx1RDgwMFtcXHVERDA3LVxcdUREMzNcXHVERDc1LVxcdURENzhcXHVERDhBXFx1REQ4QlxcdURFRTEtXFx1REVGQlxcdURGMjAtXFx1REYyM10nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdQJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdQdW5jdHVhdGlvbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xceDIxLVxceDIzXFx4MjUtXFxcXHgyQVxceDJDLVxceDJGXFx4M0FcXHgzQlxcXFx4M0ZcXHg0MFxcXFx4NUItXFxcXHg1RFxceDVGXFxcXHg3QlxceDdEXFx4QTFcXHhBN1xceEFCXFx4QjZcXHhCN1xceEJCXFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkU0MlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjUnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDlbXFx1REM3MC1cXHVEQzc0XXxcXHVEODA1W1xcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXXxcXHVEODAxXFx1REQ2RnxcXHVEODJGXFx1REM5RnxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzlcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdQYycsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnQ29ubmVjdG9yX1B1bmN0dWF0aW9uJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx4NUZcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZGM0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdQZCcsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnRGFzaF9QdW5jdHVhdGlvbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcXFx4MkRcXHUwNThBXFx1MDVCRVxcdTE0MDBcXHUxODA2XFx1MjAxMC1cXHUyMDE1XFx1MkUxN1xcdTJFMUFcXHUyRTNBXFx1MkUzQlxcdTJFNDBcXHUzMDFDXFx1MzAzMFxcdTMwQTBcXHVGRTMxXFx1RkUzMlxcdUZFNThcXHVGRTYzXFx1RkYwRCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1BlJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdDbG9zZV9QdW5jdHVhdGlvbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcXFx4MjlcXFxceDVEXFx4N0RcXHUwRjNCXFx1MEYzRFxcdTE2OUNcXHUyMDQ2XFx1MjA3RVxcdTIwOEVcXHUyMzA5XFx1MjMwQlxcdTIzMkFcXHUyNzY5XFx1Mjc2QlxcdTI3NkRcXHUyNzZGXFx1Mjc3MVxcdTI3NzNcXHUyNzc1XFx1MjdDNlxcdTI3RTdcXHUyN0U5XFx1MjdFQlxcdTI3RURcXHUyN0VGXFx1Mjk4NFxcdTI5ODZcXHUyOTg4XFx1Mjk4QVxcdTI5OENcXHUyOThFXFx1Mjk5MFxcdTI5OTJcXHUyOTk0XFx1Mjk5NlxcdTI5OThcXHUyOUQ5XFx1MjlEQlxcdTI5RkRcXHUyRTIzXFx1MkUyNVxcdTJFMjdcXHUyRTI5XFx1MzAwOVxcdTMwMEJcXHUzMDBEXFx1MzAwRlxcdTMwMTFcXHUzMDE1XFx1MzAxN1xcdTMwMTlcXHUzMDFCXFx1MzAxRVxcdTMwMUZcXHVGRDNFXFx1RkUxOFxcdUZFMzZcXHVGRTM4XFx1RkUzQVxcdUZFM0NcXHVGRTNFXFx1RkU0MFxcdUZFNDJcXHVGRTQ0XFx1RkU0OFxcdUZFNUFcXHVGRTVDXFx1RkU1RVxcdUZGMDlcXHVGRjNEXFx1RkY1RFxcdUZGNjBcXHVGRjYzJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnUGYnLFxyXG4gICAgICAgICAgICBhbGlhczogJ0ZpbmFsX1B1bmN0dWF0aW9uJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx4QkJcXHUyMDE5XFx1MjAxRFxcdTIwM0FcXHUyRTAzXFx1MkUwNVxcdTJFMEFcXHUyRTBEXFx1MkUxRFxcdTJFMjEnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdQaScsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnSW5pdGlhbF9QdW5jdHVhdGlvbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xceEFCXFx1MjAxOFxcdTIwMUJcXHUyMDFDXFx1MjAxRlxcdTIwMzlcXHUyRTAyXFx1MkUwNFxcdTJFMDlcXHUyRTBDXFx1MkUxQ1xcdTJFMjAnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdQbycsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnT3RoZXJfUHVuY3R1YXRpb24nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHgyMS1cXHgyM1xceDI1LVxceDI3XFxcXHgyQVxceDJDXFxcXHgyRVxceDJGXFx4M0FcXHgzQlxcXFx4M0ZcXHg0MFxcXFx4NUNcXHhBMVxceEE3XFx4QjZcXHhCN1xceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTY2RFxcdTE2NkVcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwNVxcdTE4MDctXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDE2XFx1MjAxN1xcdTIwMjAtXFx1MjAyN1xcdTIwMzAtXFx1MjAzOFxcdTIwM0ItXFx1MjAzRVxcdTIwNDEtXFx1MjA0M1xcdTIwNDctXFx1MjA1MVxcdTIwNTNcXHUyMDU1LVxcdTIwNUVcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwXFx1MkUwMVxcdTJFMDYtXFx1MkUwOFxcdTJFMEJcXHUyRTBFLVxcdTJFMTZcXHUyRTE4XFx1MkUxOVxcdTJFMUJcXHUyRTFFXFx1MkUxRlxcdTJFMkEtXFx1MkUyRVxcdTJFMzAtXFx1MkUzOVxcdTJFM0MtXFx1MkUzRlxcdTJFNDFcXHUzMDAxLVxcdTMwMDNcXHUzMDNEXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkUxMC1cXHVGRTE2XFx1RkUxOVxcdUZFMzBcXHVGRTQ1XFx1RkU0NlxcdUZFNDktXFx1RkU0Q1xcdUZFNTAtXFx1RkU1MlxcdUZFNTQtXFx1RkU1N1xcdUZFNUYtXFx1RkU2MVxcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwN1xcdUZGMEFcXHVGRjBDXFx1RkYwRVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQ1xcdUZGNjFcXHVGRjY0XFx1RkY2NScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REM1N1xcdUREMUZcXHVERDNGXFx1REU1MC1cXHVERTU4XFx1REU3RlxcdURFRjAtXFx1REVGNlxcdURGMzktXFx1REYzRlxcdURGOTktXFx1REY5Q118XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MDVbXFx1RENDNlxcdUREQzEtXFx1REREN1xcdURFNDEtXFx1REU0M1xcdURGM0MtXFx1REYzRV18XFx1RDgzNltcXHVERTg3LVxcdURFOEJdfFxcdUQ4MDFcXHVERDZGfFxcdUQ4MkZcXHVEQzlGfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOVxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERjlGXFx1REZEMF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1BzJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdPcGVuX1B1bmN0dWF0aW9uJyxcclxuICAgICAgICAgICAgYm1wOiAnXFxcXHgyOFxcXFx4NUJcXFxceDdCXFx1MEYzQVxcdTBGM0NcXHUxNjlCXFx1MjAxQVxcdTIwMUVcXHUyMDQ1XFx1MjA3RFxcdTIwOERcXHUyMzA4XFx1MjMwQVxcdTIzMjlcXHUyNzY4XFx1Mjc2QVxcdTI3NkNcXHUyNzZFXFx1Mjc3MFxcdTI3NzJcXHUyNzc0XFx1MjdDNVxcdTI3RTZcXHUyN0U4XFx1MjdFQVxcdTI3RUNcXHUyN0VFXFx1Mjk4M1xcdTI5ODVcXHUyOTg3XFx1Mjk4OVxcdTI5OEJcXHUyOThEXFx1Mjk4RlxcdTI5OTFcXHUyOTkzXFx1Mjk5NVxcdTI5OTdcXHUyOUQ4XFx1MjlEQVxcdTI5RkNcXHUyRTIyXFx1MkUyNFxcdTJFMjZcXHUyRTI4XFx1MkU0MlxcdTMwMDhcXHUzMDBBXFx1MzAwQ1xcdTMwMEVcXHUzMDEwXFx1MzAxNFxcdTMwMTZcXHUzMDE4XFx1MzAxQVxcdTMwMURcXHVGRDNGXFx1RkUxN1xcdUZFMzVcXHVGRTM3XFx1RkUzOVxcdUZFM0JcXHVGRTNEXFx1RkUzRlxcdUZFNDFcXHVGRTQzXFx1RkU0N1xcdUZFNTlcXHVGRTVCXFx1RkU1RFxcdUZGMDhcXHVGRjNCXFx1RkY1QlxcdUZGNUZcXHVGRjYyJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnUycsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnU3ltYm9sJyxcclxuICAgICAgICAgICAgYm1wOiAnXFxcXHgyNFxcXFx4MkJcXHgzQy1cXHgzRVxcXFx4NUVcXHg2MFxcXFx4N0NcXHg3RVxceEEyLVxceEE2XFx4QThcXHhBOVxceEFDXFx4QUUtXFx4QjFcXHhCNFxceEI4XFx4RDdcXHhGN1xcdTAyQzItXFx1MDJDNVxcdTAyRDItXFx1MDJERlxcdTAyRTUtXFx1MDJFQlxcdTAyRURcXHUwMkVGLVxcdTAyRkZcXHUwMzc1XFx1MDM4NFxcdTAzODVcXHUwM0Y2XFx1MDQ4MlxcdTA1OEQtXFx1MDU4RlxcdTA2MDYtXFx1MDYwOFxcdTA2MEJcXHUwNjBFXFx1MDYwRlxcdTA2REVcXHUwNkU5XFx1MDZGRFxcdTA2RkVcXHUwN0Y2XFx1MDlGMlxcdTA5RjNcXHUwOUZBXFx1MDlGQlxcdTBBRjFcXHUwQjcwXFx1MEJGMy1cXHUwQkZBXFx1MEM3RlxcdTBENzlcXHUwRTNGXFx1MEYwMS1cXHUwRjAzXFx1MEYxM1xcdTBGMTUtXFx1MEYxN1xcdTBGMUEtXFx1MEYxRlxcdTBGMzRcXHUwRjM2XFx1MEYzOFxcdTBGQkUtXFx1MEZDNVxcdTBGQzctXFx1MEZDQ1xcdTBGQ0VcXHUwRkNGXFx1MEZENS1cXHUwRkQ4XFx1MTA5RVxcdTEwOUZcXHUxMzkwLVxcdTEzOTlcXHUxN0RCXFx1MTk0MFxcdTE5REUtXFx1MTlGRlxcdTFCNjEtXFx1MUI2QVxcdTFCNzQtXFx1MUI3Q1xcdTFGQkRcXHUxRkJGLVxcdTFGQzFcXHUxRkNELVxcdTFGQ0ZcXHUxRkRELVxcdTFGREZcXHUxRkVELVxcdTFGRUZcXHUxRkZEXFx1MUZGRVxcdTIwNDRcXHUyMDUyXFx1MjA3QS1cXHUyMDdDXFx1MjA4QS1cXHUyMDhDXFx1MjBBMC1cXHUyMEJFXFx1MjEwMFxcdTIxMDFcXHUyMTAzLVxcdTIxMDZcXHUyMTA4XFx1MjEwOVxcdTIxMTRcXHUyMTE2LVxcdTIxMThcXHUyMTFFLVxcdTIxMjNcXHUyMTI1XFx1MjEyN1xcdTIxMjlcXHUyMTJFXFx1MjEzQVxcdTIxM0JcXHUyMTQwLVxcdTIxNDRcXHUyMTRBLVxcdTIxNERcXHUyMTRGXFx1MjE4QVxcdTIxOEJcXHUyMTkwLVxcdTIzMDdcXHUyMzBDLVxcdTIzMjhcXHUyMzJCLVxcdTIzRkFcXHUyNDAwLVxcdTI0MjZcXHUyNDQwLVxcdTI0NEFcXHUyNDlDLVxcdTI0RTlcXHUyNTAwLVxcdTI3NjdcXHUyNzk0LVxcdTI3QzRcXHUyN0M3LVxcdTI3RTVcXHUyN0YwLVxcdTI5ODJcXHUyOTk5LVxcdTI5RDdcXHUyOURDLVxcdTI5RkJcXHUyOUZFLVxcdTJCNzNcXHUyQjc2LVxcdTJCOTVcXHUyQjk4LVxcdTJCQjlcXHUyQkJELVxcdTJCQzhcXHUyQkNBLVxcdTJCRDFcXHUyQkVDLVxcdTJCRUZcXHUyQ0U1LVxcdTJDRUFcXHUyRTgwLVxcdTJFOTlcXHUyRTlCLVxcdTJFRjNcXHUyRjAwLVxcdTJGRDVcXHUyRkYwLVxcdTJGRkJcXHUzMDA0XFx1MzAxMlxcdTMwMTNcXHUzMDIwXFx1MzAzNlxcdTMwMzdcXHUzMDNFXFx1MzAzRlxcdTMwOUJcXHUzMDlDXFx1MzE5MFxcdTMxOTFcXHUzMTk2LVxcdTMxOUZcXHUzMUMwLVxcdTMxRTNcXHUzMjAwLVxcdTMyMUVcXHUzMjJBLVxcdTMyNDdcXHUzMjUwXFx1MzI2MC1cXHUzMjdGXFx1MzI4QS1cXHUzMkIwXFx1MzJDMC1cXHUzMkZFXFx1MzMwMC1cXHUzM0ZGXFx1NERDMC1cXHU0REZGXFx1QTQ5MC1cXHVBNEM2XFx1QTcwMC1cXHVBNzE2XFx1QTcyMFxcdUE3MjFcXHVBNzg5XFx1QTc4QVxcdUE4MjgtXFx1QTgyQlxcdUE4MzYtXFx1QTgzOVxcdUFBNzctXFx1QUE3OVxcdUFCNUJcXHVGQjI5XFx1RkJCMi1cXHVGQkMxXFx1RkRGQ1xcdUZERkRcXHVGRTYyXFx1RkU2NC1cXHVGRTY2XFx1RkU2OVxcdUZGMDRcXHVGRjBCXFx1RkYxQy1cXHVGRjFFXFx1RkYzRVxcdUZGNDBcXHVGRjVDXFx1RkY1RVxcdUZGRTAtXFx1RkZFNlxcdUZGRTgtXFx1RkZFRVxcdUZGRkNcXHVGRkZEJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzRVtcXHVEQzAwLVxcdURDMEJcXHVEQzEwLVxcdURDNDdcXHVEQzUwLVxcdURDNTlcXHVEQzYwLVxcdURDODdcXHVEQzkwLVxcdURDQURcXHVERDEwLVxcdUREMThcXHVERDgwLVxcdUREODRcXHVEREMwXXxcXHVEODNDW1xcdURDMDAtXFx1REMyQlxcdURDMzAtXFx1REM5M1xcdURDQTAtXFx1RENBRVxcdURDQjEtXFx1RENCRlxcdURDQzEtXFx1RENDRlxcdURDRDEtXFx1RENGNVxcdUREMTAtXFx1REQyRVxcdUREMzAtXFx1REQ2QlxcdURENzAtXFx1REQ5QVxcdURERTYtXFx1REUwMlxcdURFMTAtXFx1REUzQVxcdURFNDAtXFx1REU0OFxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REQ3OVxcdUREN0ItXFx1RERBM1xcdUREQTUtXFx1REVEMFxcdURFRTAtXFx1REVFQ1xcdURFRjAtXFx1REVGM1xcdURGMDAtXFx1REY3M1xcdURGODAtXFx1REZENF18XFx1RDgzNVtcXHVERUMxXFx1REVEQlxcdURFRkJcXHVERjE1XFx1REYzNVxcdURGNEZcXHVERjZGXFx1REY4OVxcdURGQTlcXHVERkMzXXxcXHVEODAwW1xcdUREMzctXFx1REQzRlxcdURENzktXFx1REQ4OVxcdUREOENcXHVERDkwLVxcdUREOUJcXHVEREEwXFx1REREMC1cXHVEREZDXXxcXHVEODJGXFx1REM5Q3xcXHVEODA1XFx1REYzRnxcXHVEODAyW1xcdURDNzdcXHVEQzc4XFx1REVDOF18XFx1RDgxQVtcXHVERjNDLVxcdURGM0ZcXHVERjQ1XXxcXHVEODM2W1xcdURDMDAtXFx1RERGRlxcdURFMzctXFx1REUzQVxcdURFNkQtXFx1REU3NFxcdURFNzYtXFx1REU4M1xcdURFODVcXHVERTg2XXxcXHVEODM0W1xcdURDMDAtXFx1RENGNVxcdUREMDAtXFx1REQyNlxcdUREMjktXFx1REQ2NFxcdURENkEtXFx1REQ2Q1xcdUREODNcXHVERDg0XFx1REQ4Qy1cXHVEREE5XFx1RERBRS1cXHVEREU4XFx1REUwMC1cXHVERTQxXFx1REU0NVxcdURGMDAtXFx1REY1Nl18XFx1RDgzQltcXHVERUYwXFx1REVGMV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdTYycsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnQ3VycmVuY3lfU3ltYm9sJyxcclxuICAgICAgICAgICAgYm1wOiAnXFxcXHgyNFxceEEyLVxceEE1XFx1MDU4RlxcdTA2MEJcXHUwOUYyXFx1MDlGM1xcdTA5RkJcXHUwQUYxXFx1MEJGOVxcdTBFM0ZcXHUxN0RCXFx1MjBBMC1cXHUyMEJFXFx1QTgzOFxcdUZERkNcXHVGRTY5XFx1RkYwNFxcdUZGRTBcXHVGRkUxXFx1RkZFNVxcdUZGRTYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdTaycsXHJcbiAgICAgICAgICAgIGFsaWFzOiAnTW9kaWZpZXJfU3ltYm9sJyxcclxuICAgICAgICAgICAgYm1wOiAnXFxcXHg1RVxceDYwXFx4QThcXHhBRlxceEI0XFx4QjhcXHUwMkMyLVxcdTAyQzVcXHUwMkQyLVxcdTAyREZcXHUwMkU1LVxcdTAyRUJcXHUwMkVEXFx1MDJFRi1cXHUwMkZGXFx1MDM3NVxcdTAzODRcXHUwMzg1XFx1MUZCRFxcdTFGQkYtXFx1MUZDMVxcdTFGQ0QtXFx1MUZDRlxcdTFGREQtXFx1MUZERlxcdTFGRUQtXFx1MUZFRlxcdTFGRkRcXHUxRkZFXFx1MzA5QlxcdTMwOUNcXHVBNzAwLVxcdUE3MTZcXHVBNzIwXFx1QTcyMVxcdUE3ODlcXHVBNzhBXFx1QUI1QlxcdUZCQjItXFx1RkJDMVxcdUZGM0VcXHVGRjQwXFx1RkZFMycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NtJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdNYXRoX1N5bWJvbCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcXFx4MkJcXHgzQy1cXHgzRVxcXFx4N0NcXHg3RVxceEFDXFx4QjFcXHhEN1xceEY3XFx1MDNGNlxcdTA2MDYtXFx1MDYwOFxcdTIwNDRcXHUyMDUyXFx1MjA3QS1cXHUyMDdDXFx1MjA4QS1cXHUyMDhDXFx1MjExOFxcdTIxNDAtXFx1MjE0NFxcdTIxNEJcXHUyMTkwLVxcdTIxOTRcXHUyMTlBXFx1MjE5QlxcdTIxQTBcXHUyMUEzXFx1MjFBNlxcdTIxQUVcXHUyMUNFXFx1MjFDRlxcdTIxRDJcXHUyMUQ0XFx1MjFGNC1cXHUyMkZGXFx1MjMyMFxcdTIzMjFcXHUyMzdDXFx1MjM5Qi1cXHUyM0IzXFx1MjNEQy1cXHUyM0UxXFx1MjVCN1xcdTI1QzFcXHUyNUY4LVxcdTI1RkZcXHUyNjZGXFx1MjdDMC1cXHUyN0M0XFx1MjdDNy1cXHUyN0U1XFx1MjdGMC1cXHUyN0ZGXFx1MjkwMC1cXHUyOTgyXFx1Mjk5OS1cXHUyOUQ3XFx1MjlEQy1cXHUyOUZCXFx1MjlGRS1cXHUyQUZGXFx1MkIzMC1cXHUyQjQ0XFx1MkI0Ny1cXHUyQjRDXFx1RkIyOVxcdUZFNjJcXHVGRTY0LVxcdUZFNjZcXHVGRjBCXFx1RkYxQy1cXHVGRjFFXFx1RkY1Q1xcdUZGNUVcXHVGRkUyXFx1RkZFOS1cXHVGRkVDJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzQltcXHVERUYwXFx1REVGMV18XFx1RDgzNVtcXHVERUMxXFx1REVEQlxcdURFRkJcXHVERjE1XFx1REYzNVxcdURGNEZcXHVERjZGXFx1REY4OVxcdURGQTlcXHVERkMzXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NvJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdPdGhlcl9TeW1ib2wnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHhBNlxceEE5XFx4QUVcXHhCMFxcdTA0ODJcXHUwNThEXFx1MDU4RVxcdTA2MEVcXHUwNjBGXFx1MDZERVxcdTA2RTlcXHUwNkZEXFx1MDZGRVxcdTA3RjZcXHUwOUZBXFx1MEI3MFxcdTBCRjMtXFx1MEJGOFxcdTBCRkFcXHUwQzdGXFx1MEQ3OVxcdTBGMDEtXFx1MEYwM1xcdTBGMTNcXHUwRjE1LVxcdTBGMTdcXHUwRjFBLVxcdTBGMUZcXHUwRjM0XFx1MEYzNlxcdTBGMzhcXHUwRkJFLVxcdTBGQzVcXHUwRkM3LVxcdTBGQ0NcXHUwRkNFXFx1MEZDRlxcdTBGRDUtXFx1MEZEOFxcdTEwOUVcXHUxMDlGXFx1MTM5MC1cXHUxMzk5XFx1MTk0MFxcdTE5REUtXFx1MTlGRlxcdTFCNjEtXFx1MUI2QVxcdTFCNzQtXFx1MUI3Q1xcdTIxMDBcXHUyMTAxXFx1MjEwMy1cXHUyMTA2XFx1MjEwOFxcdTIxMDlcXHUyMTE0XFx1MjExNlxcdTIxMTdcXHUyMTFFLVxcdTIxMjNcXHUyMTI1XFx1MjEyN1xcdTIxMjlcXHUyMTJFXFx1MjEzQVxcdTIxM0JcXHUyMTRBXFx1MjE0Q1xcdTIxNERcXHUyMTRGXFx1MjE4QVxcdTIxOEJcXHUyMTk1LVxcdTIxOTlcXHUyMTlDLVxcdTIxOUZcXHUyMUExXFx1MjFBMlxcdTIxQTRcXHUyMUE1XFx1MjFBNy1cXHUyMUFEXFx1MjFBRi1cXHUyMUNEXFx1MjFEMFxcdTIxRDFcXHUyMUQzXFx1MjFENS1cXHUyMUYzXFx1MjMwMC1cXHUyMzA3XFx1MjMwQy1cXHUyMzFGXFx1MjMyMi1cXHUyMzI4XFx1MjMyQi1cXHUyMzdCXFx1MjM3RC1cXHUyMzlBXFx1MjNCNC1cXHUyM0RCXFx1MjNFMi1cXHUyM0ZBXFx1MjQwMC1cXHUyNDI2XFx1MjQ0MC1cXHUyNDRBXFx1MjQ5Qy1cXHUyNEU5XFx1MjUwMC1cXHUyNUI2XFx1MjVCOC1cXHUyNUMwXFx1MjVDMi1cXHUyNUY3XFx1MjYwMC1cXHUyNjZFXFx1MjY3MC1cXHUyNzY3XFx1Mjc5NC1cXHUyN0JGXFx1MjgwMC1cXHUyOEZGXFx1MkIwMC1cXHUyQjJGXFx1MkI0NVxcdTJCNDZcXHUyQjRELVxcdTJCNzNcXHUyQjc2LVxcdTJCOTVcXHUyQjk4LVxcdTJCQjlcXHUyQkJELVxcdTJCQzhcXHUyQkNBLVxcdTJCRDFcXHUyQkVDLVxcdTJCRUZcXHUyQ0U1LVxcdTJDRUFcXHUyRTgwLVxcdTJFOTlcXHUyRTlCLVxcdTJFRjNcXHUyRjAwLVxcdTJGRDVcXHUyRkYwLVxcdTJGRkJcXHUzMDA0XFx1MzAxMlxcdTMwMTNcXHUzMDIwXFx1MzAzNlxcdTMwMzdcXHUzMDNFXFx1MzAzRlxcdTMxOTBcXHUzMTkxXFx1MzE5Ni1cXHUzMTlGXFx1MzFDMC1cXHUzMUUzXFx1MzIwMC1cXHUzMjFFXFx1MzIyQS1cXHUzMjQ3XFx1MzI1MFxcdTMyNjAtXFx1MzI3RlxcdTMyOEEtXFx1MzJCMFxcdTMyQzAtXFx1MzJGRVxcdTMzMDAtXFx1MzNGRlxcdTREQzAtXFx1NERGRlxcdUE0OTAtXFx1QTRDNlxcdUE4MjgtXFx1QTgyQlxcdUE4MzZcXHVBODM3XFx1QTgzOVxcdUFBNzctXFx1QUE3OVxcdUZERkRcXHVGRkU0XFx1RkZFOFxcdUZGRURcXHVGRkVFXFx1RkZGQ1xcdUZGRkQnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNFW1xcdURDMDAtXFx1REMwQlxcdURDMTAtXFx1REM0N1xcdURDNTAtXFx1REM1OVxcdURDNjAtXFx1REM4N1xcdURDOTAtXFx1RENBRFxcdUREMTAtXFx1REQxOFxcdUREODAtXFx1REQ4NFxcdUREQzBdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDc5XFx1REQ3Qi1cXHVEREEzXFx1RERBNS1cXHVERUQwXFx1REVFMC1cXHVERUVDXFx1REVGMC1cXHVERUYzXFx1REYwMC1cXHVERjczXFx1REY4MC1cXHVERkQ0XXxcXHVEODNDW1xcdURDMDAtXFx1REMyQlxcdURDMzAtXFx1REM5M1xcdURDQTAtXFx1RENBRVxcdURDQjEtXFx1RENCRlxcdURDQzEtXFx1RENDRlxcdURDRDEtXFx1RENGNVxcdUREMTAtXFx1REQyRVxcdUREMzAtXFx1REQ2QlxcdURENzAtXFx1REQ5QVxcdURERTYtXFx1REUwMlxcdURFMTAtXFx1REUzQVxcdURFNDAtXFx1REU0OFxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERkZBXXxcXHVEODAwW1xcdUREMzctXFx1REQzRlxcdURENzktXFx1REQ4OVxcdUREOENcXHVERDkwLVxcdUREOUJcXHVEREEwXFx1REREMC1cXHVEREZDXXxcXHVEODJGXFx1REM5Q3xcXHVEODA1XFx1REYzRnxcXHVEODAyW1xcdURDNzdcXHVEQzc4XFx1REVDOF18XFx1RDgxQVtcXHVERjNDLVxcdURGM0ZcXHVERjQ1XXxcXHVEODM2W1xcdURDMDAtXFx1RERGRlxcdURFMzctXFx1REUzQVxcdURFNkQtXFx1REU3NFxcdURFNzYtXFx1REU4M1xcdURFODVcXHVERTg2XXxcXHVEODM0W1xcdURDMDAtXFx1RENGNVxcdUREMDAtXFx1REQyNlxcdUREMjktXFx1REQ2NFxcdURENkEtXFx1REQ2Q1xcdUREODNcXHVERDg0XFx1REQ4Qy1cXHVEREE5XFx1RERBRS1cXHVEREU4XFx1REUwMC1cXHVERTQxXFx1REU0NVxcdURGMDAtXFx1REY1Nl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdaJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdTZXBhcmF0b3InLFxyXG4gICAgICAgICAgICBibXA6ICdcXHgyMFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMjhcXHUyMDI5XFx1MjAyRlxcdTIwNUZcXHUzMDAwJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnWmwnLFxyXG4gICAgICAgICAgICBhbGlhczogJ0xpbmVfU2VwYXJhdG9yJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjAyOCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1pwJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdQYXJhZ3JhcGhfU2VwYXJhdG9yJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjAyOSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1pzJyxcclxuICAgICAgICAgICAgYWxpYXM6ICdTcGFjZV9TZXBhcmF0b3InLFxyXG4gICAgICAgICAgICBibXA6ICdcXHgyMFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMCdcclxuICAgICAgICB9XHJcbiAgICBdKTtcclxuXHJcbn07XHJcbiIsIi8qIVxyXG4gKiBYUmVnRXhwIFVuaWNvZGUgUHJvcGVydGllcyAzLjEuMVxyXG4gKiA8eHJlZ2V4cC5jb20+XHJcbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAxMi0yMDE2IE1JVCBMaWNlbnNlXHJcbiAqIFVuaWNvZGUgZGF0YSBieSBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc2J5bmVucy5iZT5cclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFhSZWdFeHApIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgcHJvcGVydGllcyB0byBtZWV0IHRoZSBVVFMgIzE4IExldmVsIDEgUkwxLjIgcmVxdWlyZW1lbnRzIGZvciBVbmljb2RlIHJlZ2V4IHN1cHBvcnQuIFNlZVxyXG4gICAgICogPGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMTgvI1JMMS4yPi4gRm9sbG93aW5nIGFyZSBkZWZpbml0aW9ucyBvZiB0aGVzZSBwcm9wZXJ0aWVzIGZyb21cclxuICAgICAqIFVBWCAjNDQgPGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDQvPjpcclxuICAgICAqXHJcbiAgICAgKiAtIEFscGhhYmV0aWNcclxuICAgICAqICAgQ2hhcmFjdGVycyB3aXRoIHRoZSBBbHBoYWJldGljIHByb3BlcnR5LiBHZW5lcmF0ZWQgZnJvbTogTG93ZXJjYXNlICsgVXBwZXJjYXNlICsgTHQgKyBMbSArXHJcbiAgICAgKiAgIExvICsgTmwgKyBPdGhlcl9BbHBoYWJldGljLlxyXG4gICAgICpcclxuICAgICAqIC0gRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludFxyXG4gICAgICogICBGb3IgcHJvZ3JhbW1hdGljIGRldGVybWluYXRpb24gb2YgZGVmYXVsdCBpZ25vcmFibGUgY29kZSBwb2ludHMuIE5ldyBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkXHJcbiAgICAgKiAgIGJlIGlnbm9yZWQgaW4gcmVuZGVyaW5nICh1bmxlc3MgZXhwbGljaXRseSBzdXBwb3J0ZWQpIHdpbGwgYmUgYXNzaWduZWQgaW4gdGhlc2UgcmFuZ2VzLFxyXG4gICAgICogICBwZXJtaXR0aW5nIHByb2dyYW1zIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIG9mIHN1Y2ggY2hhcmFjdGVycyB3aGVuIG5vdFxyXG4gICAgICogICBvdGhlcndpc2Ugc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIC0gTG93ZXJjYXNlXHJcbiAgICAgKiAgIENoYXJhY3RlcnMgd2l0aCB0aGUgTG93ZXJjYXNlIHByb3BlcnR5LiBHZW5lcmF0ZWQgZnJvbTogTGwgKyBPdGhlcl9Mb3dlcmNhc2UuXHJcbiAgICAgKlxyXG4gICAgICogLSBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludFxyXG4gICAgICogICBDb2RlIHBvaW50cyBwZXJtYW5lbnRseSByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNlLlxyXG4gICAgICpcclxuICAgICAqIC0gVXBwZXJjYXNlXHJcbiAgICAgKiAgIENoYXJhY3RlcnMgd2l0aCB0aGUgVXBwZXJjYXNlIHByb3BlcnR5LiBHZW5lcmF0ZWQgZnJvbTogTHUgKyBPdGhlcl9VcHBlcmNhc2UuXHJcbiAgICAgKlxyXG4gICAgICogLSBXaGl0ZV9TcGFjZVxyXG4gICAgICogICBTcGFjZXMsIHNlcGFyYXRvciBjaGFyYWN0ZXJzIGFuZCBvdGhlciBjb250cm9sIGNoYXJhY3RlcnMgd2hpY2ggc2hvdWxkIGJlIHRyZWF0ZWQgYnlcclxuICAgICAqICAgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzIGFzIFwid2hpdGUgc3BhY2VcIiBmb3IgdGhlIHB1cnBvc2Ugb2YgcGFyc2luZyBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcHJvcGVydGllcyBBU0NJSSwgQW55LCBhbmQgQXNzaWduZWQgYXJlIGFsc28gaW5jbHVkZWQgYnV0IGFyZSBub3QgZGVmaW5lZCBpbiBVQVggIzQ0LiBVVFNcclxuICAgICAqICMxOCBSTDEuMiBhZGRpdGlvbmFsbHkgcmVxdWlyZXMgc3VwcG9ydCBmb3IgVW5pY29kZSBzY3JpcHRzIGFuZCBnZW5lcmFsIGNhdGVnb3JpZXMuIFRoZXNlIGFyZVxyXG4gICAgICogaW5jbHVkZWQgaW4gWFJlZ0V4cCdzIFVuaWNvZGUgQ2F0ZWdvcmllcyBhbmQgVW5pY29kZSBTY3JpcHRzIGFkZG9ucy5cclxuICAgICAqXHJcbiAgICAgKiBUb2tlbiBuYW1lcyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgYW5kIGFueSBzcGFjZXMsIGh5cGhlbnMsIGFuZCB1bmRlcnNjb3JlcyBhcmUgaWdub3JlZC5cclxuICAgICAqXHJcbiAgICAgKiBVc2VzIFVuaWNvZGUgOC4wLjAuXHJcbiAgICAgKlxyXG4gICAgICogQHJlcXVpcmVzIFhSZWdFeHAsIFVuaWNvZGUgQmFzZVxyXG4gICAgICovXHJcblxyXG4gICAgaWYgKCFYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdVbmljb2RlIEJhc2UgbXVzdCBiZSBsb2FkZWQgYmVmb3JlIFVuaWNvZGUgUHJvcGVydGllcycpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB1bmljb2RlRGF0YSA9IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBU0NJSScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcMC1cXHg3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0FscGhhYmV0aWMnLFxyXG4gICAgICAgICAgICBibXA6ICdBLVphLXpcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM0NVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1QjAtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY1N1xcdTA2NTktXFx1MDY1RlxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2RTEtXFx1MDZFOFxcdTA2RUQtXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3M0ZcXHUwNzRELVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTdcXHUwODFBLVxcdTA4MkNcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOEUzLVxcdTA4RTlcXHUwOEYwLVxcdTA5M0JcXHUwOTNELVxcdTA5NENcXHUwOTRFLVxcdTA5NTBcXHUwOTU1LVxcdTA5NjNcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJELVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0JcXHUwOUNDXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RjBcXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEJcXHUwQTRDXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcwLVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkQtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0JcXHUwQUNDXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRjlcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRC1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCXFx1MEI0Q1xcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNDXFx1MEJEMFxcdTBCRDdcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNENcXHUwQzU1XFx1MEM1NlxcdTBDNTgtXFx1MEM1QVxcdTBDNjAtXFx1MEM2M1xcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkQtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDQ1xcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRDXFx1MEQ0RVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNDZcXHUwRTREXFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDRFxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODFcXHUwRjg4LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUxMDAwLVxcdTEwMzZcXHUxMDM4XFx1MTAzQi1cXHUxMDNGXFx1MTA1MC1cXHUxMDYyXFx1MTA2NS1cXHUxMDY4XFx1MTA2RS1cXHUxMDg2XFx1MTA4RVxcdTEwOUNcXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTNcXHUxNzIwLVxcdTE3MzNcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdCM1xcdTE3QjYtXFx1MTdDOFxcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTM4XFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MS1cXHUxQTc0XFx1MUFBN1xcdTFCMDAtXFx1MUIzM1xcdTFCMzUtXFx1MUI0M1xcdTFCNDUtXFx1MUI0QlxcdTFCODAtXFx1MUJBOVxcdTFCQUMtXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFCRTctXFx1MUJGMVxcdTFDMDAtXFx1MUMzNVxcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGM1xcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MURFNy1cXHUxREY0XFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTI0QjYtXFx1MjRFOVxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3NC1cXHVBNjdCXFx1QTY3Ri1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEMzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MkFcXHVBOTMwLVxcdUE5NTJcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QjJcXHVBOUI0LVxcdUE5QkZcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFCRVxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY1XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGREMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDgwNFtcXHVEQzAwLVxcdURDNDVcXHVEQzgyLVxcdURDQjhcXHVEQ0QwLVxcdURDRThcXHVERDAwLVxcdUREMzJcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4MC1cXHVEREJGXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzRcXHVERTM3XFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFOFxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNELVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEJcXHVERjRDXFx1REY1MFxcdURGNTdcXHVERjVELVxcdURGNjNdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYzNlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4M0NbXFx1REQzMC1cXHVERDQ5XFx1REQ1MC1cXHVERDY5XFx1REQ3MC1cXHVERDg5XXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlFXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODA1W1xcdURDODAtXFx1RENDMVxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERCNVxcdUREQjgtXFx1RERCRVxcdURERDgtXFx1RERERFxcdURFMDAtXFx1REUzRVxcdURFNDBcXHVERTQ0XFx1REU4MC1cXHVERUI1XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJBXXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMC1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTAtXFx1REY3RVxcdURGOTMtXFx1REY5Rl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQW55JyxcclxuICAgICAgICAgICAgaXNCbXBMYXN0OiB0cnVlLFxyXG4gICAgICAgICAgICBibXA6ICdcXDAtXFx1RkZGRicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx4QURcXHUwMzRGXFx1MDYxQ1xcdTExNUZcXHUxMTYwXFx1MTdCNFxcdTE3QjVcXHUxODBCLVxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNkZcXHUzMTY0XFx1RkUwMC1cXHVGRTBGXFx1RkVGRlxcdUZGQTBcXHVGRkYwLVxcdUZGRjgnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdbXFx1REI0MC1cXHVEQjQzXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MzRbXFx1REQ3My1cXHVERDdBXXxcXHVEODJGW1xcdURDQTAtXFx1RENBM10nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMb3dlcmNhc2UnLFxyXG4gICAgICAgICAgICBibXA6ICdhLXpcXHhBQVxceEI1XFx4QkFcXHhERi1cXHhGNlxceEY4LVxceEZGXFx1MDEwMVxcdTAxMDNcXHUwMTA1XFx1MDEwN1xcdTAxMDlcXHUwMTBCXFx1MDEwRFxcdTAxMEZcXHUwMTExXFx1MDExM1xcdTAxMTVcXHUwMTE3XFx1MDExOVxcdTAxMUJcXHUwMTFEXFx1MDExRlxcdTAxMjFcXHUwMTIzXFx1MDEyNVxcdTAxMjdcXHUwMTI5XFx1MDEyQlxcdTAxMkRcXHUwMTJGXFx1MDEzMVxcdTAxMzNcXHUwMTM1XFx1MDEzN1xcdTAxMzhcXHUwMTNBXFx1MDEzQ1xcdTAxM0VcXHUwMTQwXFx1MDE0MlxcdTAxNDRcXHUwMTQ2XFx1MDE0OFxcdTAxNDlcXHUwMTRCXFx1MDE0RFxcdTAxNEZcXHUwMTUxXFx1MDE1M1xcdTAxNTVcXHUwMTU3XFx1MDE1OVxcdTAxNUJcXHUwMTVEXFx1MDE1RlxcdTAxNjFcXHUwMTYzXFx1MDE2NVxcdTAxNjdcXHUwMTY5XFx1MDE2QlxcdTAxNkRcXHUwMTZGXFx1MDE3MVxcdTAxNzNcXHUwMTc1XFx1MDE3N1xcdTAxN0FcXHUwMTdDXFx1MDE3RS1cXHUwMTgwXFx1MDE4M1xcdTAxODVcXHUwMTg4XFx1MDE4Q1xcdTAxOERcXHUwMTkyXFx1MDE5NVxcdTAxOTktXFx1MDE5QlxcdTAxOUVcXHUwMUExXFx1MDFBM1xcdTAxQTVcXHUwMUE4XFx1MDFBQVxcdTAxQUJcXHUwMUFEXFx1MDFCMFxcdTAxQjRcXHUwMUI2XFx1MDFCOVxcdTAxQkFcXHUwMUJELVxcdTAxQkZcXHUwMUM2XFx1MDFDOVxcdTAxQ0NcXHUwMUNFXFx1MDFEMFxcdTAxRDJcXHUwMUQ0XFx1MDFENlxcdTAxRDhcXHUwMURBXFx1MDFEQ1xcdTAxRERcXHUwMURGXFx1MDFFMVxcdTAxRTNcXHUwMUU1XFx1MDFFN1xcdTAxRTlcXHUwMUVCXFx1MDFFRFxcdTAxRUZcXHUwMUYwXFx1MDFGM1xcdTAxRjVcXHUwMUY5XFx1MDFGQlxcdTAxRkRcXHUwMUZGXFx1MDIwMVxcdTAyMDNcXHUwMjA1XFx1MDIwN1xcdTAyMDlcXHUwMjBCXFx1MDIwRFxcdTAyMEZcXHUwMjExXFx1MDIxM1xcdTAyMTVcXHUwMjE3XFx1MDIxOVxcdTAyMUJcXHUwMjFEXFx1MDIxRlxcdTAyMjFcXHUwMjIzXFx1MDIyNVxcdTAyMjdcXHUwMjI5XFx1MDIyQlxcdTAyMkRcXHUwMjJGXFx1MDIzMVxcdTAyMzMtXFx1MDIzOVxcdTAyM0NcXHUwMjNGXFx1MDI0MFxcdTAyNDJcXHUwMjQ3XFx1MDI0OVxcdTAyNEJcXHUwMjREXFx1MDI0Ri1cXHUwMjkzXFx1MDI5NS1cXHUwMkI4XFx1MDJDMFxcdTAyQzFcXHUwMkUwLVxcdTAyRTRcXHUwMzQ1XFx1MDM3MVxcdTAzNzNcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM5MFxcdTAzQUMtXFx1MDNDRVxcdTAzRDBcXHUwM0QxXFx1MDNENS1cXHUwM0Q3XFx1MDNEOVxcdTAzREJcXHUwM0REXFx1MDNERlxcdTAzRTFcXHUwM0UzXFx1MDNFNVxcdTAzRTdcXHUwM0U5XFx1MDNFQlxcdTAzRURcXHUwM0VGLVxcdTAzRjNcXHUwM0Y1XFx1MDNGOFxcdTAzRkJcXHUwM0ZDXFx1MDQzMC1cXHUwNDVGXFx1MDQ2MVxcdTA0NjNcXHUwNDY1XFx1MDQ2N1xcdTA0NjlcXHUwNDZCXFx1MDQ2RFxcdTA0NkZcXHUwNDcxXFx1MDQ3M1xcdTA0NzVcXHUwNDc3XFx1MDQ3OVxcdTA0N0JcXHUwNDdEXFx1MDQ3RlxcdTA0ODFcXHUwNDhCXFx1MDQ4RFxcdTA0OEZcXHUwNDkxXFx1MDQ5M1xcdTA0OTVcXHUwNDk3XFx1MDQ5OVxcdTA0OUJcXHUwNDlEXFx1MDQ5RlxcdTA0QTFcXHUwNEEzXFx1MDRBNVxcdTA0QTdcXHUwNEE5XFx1MDRBQlxcdTA0QURcXHUwNEFGXFx1MDRCMVxcdTA0QjNcXHUwNEI1XFx1MDRCN1xcdTA0QjlcXHUwNEJCXFx1MDRCRFxcdTA0QkZcXHUwNEMyXFx1MDRDNFxcdTA0QzZcXHUwNEM4XFx1MDRDQVxcdTA0Q0NcXHUwNENFXFx1MDRDRlxcdTA0RDFcXHUwNEQzXFx1MDRENVxcdTA0RDdcXHUwNEQ5XFx1MDREQlxcdTA0RERcXHUwNERGXFx1MDRFMVxcdTA0RTNcXHUwNEU1XFx1MDRFN1xcdTA0RTlcXHUwNEVCXFx1MDRFRFxcdTA0RUZcXHUwNEYxXFx1MDRGM1xcdTA0RjVcXHUwNEY3XFx1MDRGOVxcdTA0RkJcXHUwNEZEXFx1MDRGRlxcdTA1MDFcXHUwNTAzXFx1MDUwNVxcdTA1MDdcXHUwNTA5XFx1MDUwQlxcdTA1MERcXHUwNTBGXFx1MDUxMVxcdTA1MTNcXHUwNTE1XFx1MDUxN1xcdTA1MTlcXHUwNTFCXFx1MDUxRFxcdTA1MUZcXHUwNTIxXFx1MDUyM1xcdTA1MjVcXHUwNTI3XFx1MDUyOVxcdTA1MkJcXHUwNTJEXFx1MDUyRlxcdTA1NjEtXFx1MDU4N1xcdTEzRjgtXFx1MTNGRFxcdTFEMDAtXFx1MURCRlxcdTFFMDFcXHUxRTAzXFx1MUUwNVxcdTFFMDdcXHUxRTA5XFx1MUUwQlxcdTFFMERcXHUxRTBGXFx1MUUxMVxcdTFFMTNcXHUxRTE1XFx1MUUxN1xcdTFFMTlcXHUxRTFCXFx1MUUxRFxcdTFFMUZcXHUxRTIxXFx1MUUyM1xcdTFFMjVcXHUxRTI3XFx1MUUyOVxcdTFFMkJcXHUxRTJEXFx1MUUyRlxcdTFFMzFcXHUxRTMzXFx1MUUzNVxcdTFFMzdcXHUxRTM5XFx1MUUzQlxcdTFFM0RcXHUxRTNGXFx1MUU0MVxcdTFFNDNcXHUxRTQ1XFx1MUU0N1xcdTFFNDlcXHUxRTRCXFx1MUU0RFxcdTFFNEZcXHUxRTUxXFx1MUU1M1xcdTFFNTVcXHUxRTU3XFx1MUU1OVxcdTFFNUJcXHUxRTVEXFx1MUU1RlxcdTFFNjFcXHUxRTYzXFx1MUU2NVxcdTFFNjdcXHUxRTY5XFx1MUU2QlxcdTFFNkRcXHUxRTZGXFx1MUU3MVxcdTFFNzNcXHUxRTc1XFx1MUU3N1xcdTFFNzlcXHUxRTdCXFx1MUU3RFxcdTFFN0ZcXHUxRTgxXFx1MUU4M1xcdTFFODVcXHUxRTg3XFx1MUU4OVxcdTFFOEJcXHUxRThEXFx1MUU4RlxcdTFFOTFcXHUxRTkzXFx1MUU5NS1cXHUxRTlEXFx1MUU5RlxcdTFFQTFcXHUxRUEzXFx1MUVBNVxcdTFFQTdcXHUxRUE5XFx1MUVBQlxcdTFFQURcXHUxRUFGXFx1MUVCMVxcdTFFQjNcXHUxRUI1XFx1MUVCN1xcdTFFQjlcXHUxRUJCXFx1MUVCRFxcdTFFQkZcXHUxRUMxXFx1MUVDM1xcdTFFQzVcXHUxRUM3XFx1MUVDOVxcdTFFQ0JcXHUxRUNEXFx1MUVDRlxcdTFFRDFcXHUxRUQzXFx1MUVENVxcdTFFRDdcXHUxRUQ5XFx1MUVEQlxcdTFFRERcXHUxRURGXFx1MUVFMVxcdTFFRTNcXHUxRUU1XFx1MUVFN1xcdTFFRTlcXHUxRUVCXFx1MUVFRFxcdTFFRUZcXHUxRUYxXFx1MUVGM1xcdTFFRjVcXHUxRUY3XFx1MUVGOVxcdTFFRkJcXHUxRUZEXFx1MUVGRi1cXHUxRjA3XFx1MUYxMC1cXHUxRjE1XFx1MUYyMC1cXHUxRjI3XFx1MUYzMC1cXHUxRjM3XFx1MUY0MC1cXHUxRjQ1XFx1MUY1MC1cXHUxRjU3XFx1MUY2MC1cXHUxRjY3XFx1MUY3MC1cXHUxRjdEXFx1MUY4MC1cXHUxRjg3XFx1MUY5MC1cXHUxRjk3XFx1MUZBMC1cXHUxRkE3XFx1MUZCMC1cXHUxRkI0XFx1MUZCNlxcdTFGQjdcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNlxcdTFGQzdcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2XFx1MUZEN1xcdTFGRTAtXFx1MUZFN1xcdTFGRjItXFx1MUZGNFxcdTFGRjZcXHUxRkY3XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTBBXFx1MjEwRVxcdTIxMEZcXHUyMTEzXFx1MjEyRlxcdTIxMzRcXHUyMTM5XFx1MjEzQ1xcdTIxM0RcXHUyMTQ2LVxcdTIxNDlcXHUyMTRFXFx1MjE3MC1cXHUyMTdGXFx1MjE4NFxcdTI0RDAtXFx1MjRFOVxcdTJDMzAtXFx1MkM1RVxcdTJDNjFcXHUyQzY1XFx1MkM2NlxcdTJDNjhcXHUyQzZBXFx1MkM2Q1xcdTJDNzFcXHUyQzczXFx1MkM3NFxcdTJDNzYtXFx1MkM3RFxcdTJDODFcXHUyQzgzXFx1MkM4NVxcdTJDODdcXHUyQzg5XFx1MkM4QlxcdTJDOERcXHUyQzhGXFx1MkM5MVxcdTJDOTNcXHUyQzk1XFx1MkM5N1xcdTJDOTlcXHUyQzlCXFx1MkM5RFxcdTJDOUZcXHUyQ0ExXFx1MkNBM1xcdTJDQTVcXHUyQ0E3XFx1MkNBOVxcdTJDQUJcXHUyQ0FEXFx1MkNBRlxcdTJDQjFcXHUyQ0IzXFx1MkNCNVxcdTJDQjdcXHUyQ0I5XFx1MkNCQlxcdTJDQkRcXHUyQ0JGXFx1MkNDMVxcdTJDQzNcXHUyQ0M1XFx1MkNDN1xcdTJDQzlcXHUyQ0NCXFx1MkNDRFxcdTJDQ0ZcXHUyQ0QxXFx1MkNEM1xcdTJDRDVcXHUyQ0Q3XFx1MkNEOVxcdTJDREJcXHUyQ0REXFx1MkNERlxcdTJDRTFcXHUyQ0UzXFx1MkNFNFxcdTJDRUNcXHUyQ0VFXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1QTY0MVxcdUE2NDNcXHVBNjQ1XFx1QTY0N1xcdUE2NDlcXHVBNjRCXFx1QTY0RFxcdUE2NEZcXHVBNjUxXFx1QTY1M1xcdUE2NTVcXHVBNjU3XFx1QTY1OVxcdUE2NUJcXHVBNjVEXFx1QTY1RlxcdUE2NjFcXHVBNjYzXFx1QTY2NVxcdUE2NjdcXHVBNjY5XFx1QTY2QlxcdUE2NkRcXHVBNjgxXFx1QTY4M1xcdUE2ODVcXHVBNjg3XFx1QTY4OVxcdUE2OEJcXHVBNjhEXFx1QTY4RlxcdUE2OTFcXHVBNjkzXFx1QTY5NVxcdUE2OTdcXHVBNjk5XFx1QTY5Qi1cXHVBNjlEXFx1QTcyM1xcdUE3MjVcXHVBNzI3XFx1QTcyOVxcdUE3MkJcXHVBNzJEXFx1QTcyRi1cXHVBNzMxXFx1QTczM1xcdUE3MzVcXHVBNzM3XFx1QTczOVxcdUE3M0JcXHVBNzNEXFx1QTczRlxcdUE3NDFcXHVBNzQzXFx1QTc0NVxcdUE3NDdcXHVBNzQ5XFx1QTc0QlxcdUE3NERcXHVBNzRGXFx1QTc1MVxcdUE3NTNcXHVBNzU1XFx1QTc1N1xcdUE3NTlcXHVBNzVCXFx1QTc1RFxcdUE3NUZcXHVBNzYxXFx1QTc2M1xcdUE3NjVcXHVBNzY3XFx1QTc2OVxcdUE3NkJcXHVBNzZEXFx1QTc2Ri1cXHVBNzc4XFx1QTc3QVxcdUE3N0NcXHVBNzdGXFx1QTc4MVxcdUE3ODNcXHVBNzg1XFx1QTc4N1xcdUE3OENcXHVBNzhFXFx1QTc5MVxcdUE3OTMtXFx1QTc5NVxcdUE3OTdcXHVBNzk5XFx1QTc5QlxcdUE3OURcXHVBNzlGXFx1QTdBMVxcdUE3QTNcXHVBN0E1XFx1QTdBN1xcdUE3QTlcXHVBN0I1XFx1QTdCN1xcdUE3RjgtXFx1QTdGQVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJCRlxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZGNDEtXFx1RkY1QScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDNbXFx1RENDMC1cXHVEQ0YyXXxcXHVEODM1W1xcdURDMUEtXFx1REMzM1xcdURDNEUtXFx1REM1NFxcdURDNTYtXFx1REM2N1xcdURDODItXFx1REM5QlxcdURDQjYtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdURDQ0ZcXHVEQ0VBLVxcdUREMDNcXHVERDFFLVxcdUREMzdcXHVERDUyLVxcdURENkJcXHVERDg2LVxcdUREOUZcXHVEREJBLVxcdURERDNcXHVEREVFLVxcdURFMDdcXHVERTIyLVxcdURFM0JcXHVERTU2LVxcdURFNkZcXHVERThBLVxcdURFQTVcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRTFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMUJcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNTVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGOEZcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQzlcXHVERkNCXXxcXHVEODAxW1xcdURDMjgtXFx1REM0Rl18XFx1RDgwNltcXHVEQ0MwLVxcdURDREZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTm9uY2hhcmFjdGVyX0NvZGVfUG9pbnQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVGREQwLVxcdUZERUZcXHVGRkZFXFx1RkZGRicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1tcXHVEQjNGXFx1REI3RlxcdURCQkZcXHVEQkZGXFx1RDgzRlxcdUQ4N0ZcXHVEOEJGXFx1REFGRlxcdUQ5N0ZcXHVEOUJGXFx1RDlGRlxcdURBM0ZcXHVEOEZGXFx1REFCRlxcdURBN0ZcXHVEOTNGXVtcXHVERkZFXFx1REZGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdVcHBlcmNhc2UnLFxyXG4gICAgICAgICAgICBibXA6ICdBLVpcXHhDMC1cXHhENlxceEQ4LVxceERFXFx1MDEwMFxcdTAxMDJcXHUwMTA0XFx1MDEwNlxcdTAxMDhcXHUwMTBBXFx1MDEwQ1xcdTAxMEVcXHUwMTEwXFx1MDExMlxcdTAxMTRcXHUwMTE2XFx1MDExOFxcdTAxMUFcXHUwMTFDXFx1MDExRVxcdTAxMjBcXHUwMTIyXFx1MDEyNFxcdTAxMjZcXHUwMTI4XFx1MDEyQVxcdTAxMkNcXHUwMTJFXFx1MDEzMFxcdTAxMzJcXHUwMTM0XFx1MDEzNlxcdTAxMzlcXHUwMTNCXFx1MDEzRFxcdTAxM0ZcXHUwMTQxXFx1MDE0M1xcdTAxNDVcXHUwMTQ3XFx1MDE0QVxcdTAxNENcXHUwMTRFXFx1MDE1MFxcdTAxNTJcXHUwMTU0XFx1MDE1NlxcdTAxNThcXHUwMTVBXFx1MDE1Q1xcdTAxNUVcXHUwMTYwXFx1MDE2MlxcdTAxNjRcXHUwMTY2XFx1MDE2OFxcdTAxNkFcXHUwMTZDXFx1MDE2RVxcdTAxNzBcXHUwMTcyXFx1MDE3NFxcdTAxNzZcXHUwMTc4XFx1MDE3OVxcdTAxN0JcXHUwMTdEXFx1MDE4MVxcdTAxODJcXHUwMTg0XFx1MDE4NlxcdTAxODdcXHUwMTg5LVxcdTAxOEJcXHUwMThFLVxcdTAxOTFcXHUwMTkzXFx1MDE5NFxcdTAxOTYtXFx1MDE5OFxcdTAxOUNcXHUwMTlEXFx1MDE5RlxcdTAxQTBcXHUwMUEyXFx1MDFBNFxcdTAxQTZcXHUwMUE3XFx1MDFBOVxcdTAxQUNcXHUwMUFFXFx1MDFBRlxcdTAxQjEtXFx1MDFCM1xcdTAxQjVcXHUwMUI3XFx1MDFCOFxcdTAxQkNcXHUwMUM0XFx1MDFDN1xcdTAxQ0FcXHUwMUNEXFx1MDFDRlxcdTAxRDFcXHUwMUQzXFx1MDFENVxcdTAxRDdcXHUwMUQ5XFx1MDFEQlxcdTAxREVcXHUwMUUwXFx1MDFFMlxcdTAxRTRcXHUwMUU2XFx1MDFFOFxcdTAxRUFcXHUwMUVDXFx1MDFFRVxcdTAxRjFcXHUwMUY0XFx1MDFGNi1cXHUwMUY4XFx1MDFGQVxcdTAxRkNcXHUwMUZFXFx1MDIwMFxcdTAyMDJcXHUwMjA0XFx1MDIwNlxcdTAyMDhcXHUwMjBBXFx1MDIwQ1xcdTAyMEVcXHUwMjEwXFx1MDIxMlxcdTAyMTRcXHUwMjE2XFx1MDIxOFxcdTAyMUFcXHUwMjFDXFx1MDIxRVxcdTAyMjBcXHUwMjIyXFx1MDIyNFxcdTAyMjZcXHUwMjI4XFx1MDIyQVxcdTAyMkNcXHUwMjJFXFx1MDIzMFxcdTAyMzJcXHUwMjNBXFx1MDIzQlxcdTAyM0RcXHUwMjNFXFx1MDI0MVxcdTAyNDMtXFx1MDI0NlxcdTAyNDhcXHUwMjRBXFx1MDI0Q1xcdTAyNEVcXHUwMzcwXFx1MDM3MlxcdTAzNzZcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFXFx1MDM4RlxcdTAzOTEtXFx1MDNBMVxcdTAzQTMtXFx1MDNBQlxcdTAzQ0ZcXHUwM0QyLVxcdTAzRDRcXHUwM0Q4XFx1MDNEQVxcdTAzRENcXHUwM0RFXFx1MDNFMFxcdTAzRTJcXHUwM0U0XFx1MDNFNlxcdTAzRThcXHUwM0VBXFx1MDNFQ1xcdTAzRUVcXHUwM0Y0XFx1MDNGN1xcdTAzRjlcXHUwM0ZBXFx1MDNGRC1cXHUwNDJGXFx1MDQ2MFxcdTA0NjJcXHUwNDY0XFx1MDQ2NlxcdTA0NjhcXHUwNDZBXFx1MDQ2Q1xcdTA0NkVcXHUwNDcwXFx1MDQ3MlxcdTA0NzRcXHUwNDc2XFx1MDQ3OFxcdTA0N0FcXHUwNDdDXFx1MDQ3RVxcdTA0ODBcXHUwNDhBXFx1MDQ4Q1xcdTA0OEVcXHUwNDkwXFx1MDQ5MlxcdTA0OTRcXHUwNDk2XFx1MDQ5OFxcdTA0OUFcXHUwNDlDXFx1MDQ5RVxcdTA0QTBcXHUwNEEyXFx1MDRBNFxcdTA0QTZcXHUwNEE4XFx1MDRBQVxcdTA0QUNcXHUwNEFFXFx1MDRCMFxcdTA0QjJcXHUwNEI0XFx1MDRCNlxcdTA0QjhcXHUwNEJBXFx1MDRCQ1xcdTA0QkVcXHUwNEMwXFx1MDRDMVxcdTA0QzNcXHUwNEM1XFx1MDRDN1xcdTA0QzlcXHUwNENCXFx1MDRDRFxcdTA0RDBcXHUwNEQyXFx1MDRENFxcdTA0RDZcXHUwNEQ4XFx1MDREQVxcdTA0RENcXHUwNERFXFx1MDRFMFxcdTA0RTJcXHUwNEU0XFx1MDRFNlxcdTA0RThcXHUwNEVBXFx1MDRFQ1xcdTA0RUVcXHUwNEYwXFx1MDRGMlxcdTA0RjRcXHUwNEY2XFx1MDRGOFxcdTA0RkFcXHUwNEZDXFx1MDRGRVxcdTA1MDBcXHUwNTAyXFx1MDUwNFxcdTA1MDZcXHUwNTA4XFx1MDUwQVxcdTA1MENcXHUwNTBFXFx1MDUxMFxcdTA1MTJcXHUwNTE0XFx1MDUxNlxcdTA1MThcXHUwNTFBXFx1MDUxQ1xcdTA1MUVcXHUwNTIwXFx1MDUyMlxcdTA1MjRcXHUwNTI2XFx1MDUyOFxcdTA1MkFcXHUwNTJDXFx1MDUyRVxcdTA1MzEtXFx1MDU1NlxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTNBMC1cXHUxM0Y1XFx1MUUwMFxcdTFFMDJcXHUxRTA0XFx1MUUwNlxcdTFFMDhcXHUxRTBBXFx1MUUwQ1xcdTFFMEVcXHUxRTEwXFx1MUUxMlxcdTFFMTRcXHUxRTE2XFx1MUUxOFxcdTFFMUFcXHUxRTFDXFx1MUUxRVxcdTFFMjBcXHUxRTIyXFx1MUUyNFxcdTFFMjZcXHUxRTI4XFx1MUUyQVxcdTFFMkNcXHUxRTJFXFx1MUUzMFxcdTFFMzJcXHUxRTM0XFx1MUUzNlxcdTFFMzhcXHUxRTNBXFx1MUUzQ1xcdTFFM0VcXHUxRTQwXFx1MUU0MlxcdTFFNDRcXHUxRTQ2XFx1MUU0OFxcdTFFNEFcXHUxRTRDXFx1MUU0RVxcdTFFNTBcXHUxRTUyXFx1MUU1NFxcdTFFNTZcXHUxRTU4XFx1MUU1QVxcdTFFNUNcXHUxRTVFXFx1MUU2MFxcdTFFNjJcXHUxRTY0XFx1MUU2NlxcdTFFNjhcXHUxRTZBXFx1MUU2Q1xcdTFFNkVcXHUxRTcwXFx1MUU3MlxcdTFFNzRcXHUxRTc2XFx1MUU3OFxcdTFFN0FcXHUxRTdDXFx1MUU3RVxcdTFFODBcXHUxRTgyXFx1MUU4NFxcdTFFODZcXHUxRTg4XFx1MUU4QVxcdTFFOENcXHUxRThFXFx1MUU5MFxcdTFFOTJcXHUxRTk0XFx1MUU5RVxcdTFFQTBcXHUxRUEyXFx1MUVBNFxcdTFFQTZcXHUxRUE4XFx1MUVBQVxcdTFFQUNcXHUxRUFFXFx1MUVCMFxcdTFFQjJcXHUxRUI0XFx1MUVCNlxcdTFFQjhcXHUxRUJBXFx1MUVCQ1xcdTFFQkVcXHUxRUMwXFx1MUVDMlxcdTFFQzRcXHUxRUM2XFx1MUVDOFxcdTFFQ0FcXHUxRUNDXFx1MUVDRVxcdTFFRDBcXHUxRUQyXFx1MUVENFxcdTFFRDZcXHUxRUQ4XFx1MUVEQVxcdTFFRENcXHUxRURFXFx1MUVFMFxcdTFFRTJcXHUxRUU0XFx1MUVFNlxcdTFFRThcXHUxRUVBXFx1MUVFQ1xcdTFFRUVcXHUxRUYwXFx1MUVGMlxcdTFFRjRcXHUxRUY2XFx1MUVGOFxcdTFFRkFcXHUxRUZDXFx1MUVGRVxcdTFGMDgtXFx1MUYwRlxcdTFGMTgtXFx1MUYxRFxcdTFGMjgtXFx1MUYyRlxcdTFGMzgtXFx1MUYzRlxcdTFGNDgtXFx1MUY0RFxcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUZcXHUxRjY4LVxcdTFGNkZcXHUxRkI4LVxcdTFGQkJcXHUxRkM4LVxcdTFGQ0JcXHUxRkQ4LVxcdTFGREJcXHUxRkU4LVxcdTFGRUNcXHUxRkY4LVxcdTFGRkJcXHUyMTAyXFx1MjEwN1xcdTIxMEItXFx1MjEwRFxcdTIxMTAtXFx1MjExMlxcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTMwLVxcdTIxMzNcXHUyMTNFXFx1MjEzRlxcdTIxNDVcXHUyMTYwLVxcdTIxNkZcXHUyMTgzXFx1MjRCNi1cXHUyNENGXFx1MkMwMC1cXHUyQzJFXFx1MkM2MFxcdTJDNjItXFx1MkM2NFxcdTJDNjdcXHUyQzY5XFx1MkM2QlxcdTJDNkQtXFx1MkM3MFxcdTJDNzJcXHUyQzc1XFx1MkM3RS1cXHUyQzgwXFx1MkM4MlxcdTJDODRcXHUyQzg2XFx1MkM4OFxcdTJDOEFcXHUyQzhDXFx1MkM4RVxcdTJDOTBcXHUyQzkyXFx1MkM5NFxcdTJDOTZcXHUyQzk4XFx1MkM5QVxcdTJDOUNcXHUyQzlFXFx1MkNBMFxcdTJDQTJcXHUyQ0E0XFx1MkNBNlxcdTJDQThcXHUyQ0FBXFx1MkNBQ1xcdTJDQUVcXHUyQ0IwXFx1MkNCMlxcdTJDQjRcXHUyQ0I2XFx1MkNCOFxcdTJDQkFcXHUyQ0JDXFx1MkNCRVxcdTJDQzBcXHUyQ0MyXFx1MkNDNFxcdTJDQzZcXHUyQ0M4XFx1MkNDQVxcdTJDQ0NcXHUyQ0NFXFx1MkNEMFxcdTJDRDJcXHUyQ0Q0XFx1MkNENlxcdTJDRDhcXHUyQ0RBXFx1MkNEQ1xcdTJDREVcXHUyQ0UwXFx1MkNFMlxcdTJDRUJcXHUyQ0VEXFx1MkNGMlxcdUE2NDBcXHVBNjQyXFx1QTY0NFxcdUE2NDZcXHVBNjQ4XFx1QTY0QVxcdUE2NENcXHVBNjRFXFx1QTY1MFxcdUE2NTJcXHVBNjU0XFx1QTY1NlxcdUE2NThcXHVBNjVBXFx1QTY1Q1xcdUE2NUVcXHVBNjYwXFx1QTY2MlxcdUE2NjRcXHVBNjY2XFx1QTY2OFxcdUE2NkFcXHVBNjZDXFx1QTY4MFxcdUE2ODJcXHVBNjg0XFx1QTY4NlxcdUE2ODhcXHVBNjhBXFx1QTY4Q1xcdUE2OEVcXHVBNjkwXFx1QTY5MlxcdUE2OTRcXHVBNjk2XFx1QTY5OFxcdUE2OUFcXHVBNzIyXFx1QTcyNFxcdUE3MjZcXHVBNzI4XFx1QTcyQVxcdUE3MkNcXHVBNzJFXFx1QTczMlxcdUE3MzRcXHVBNzM2XFx1QTczOFxcdUE3M0FcXHVBNzNDXFx1QTczRVxcdUE3NDBcXHVBNzQyXFx1QTc0NFxcdUE3NDZcXHVBNzQ4XFx1QTc0QVxcdUE3NENcXHVBNzRFXFx1QTc1MFxcdUE3NTJcXHVBNzU0XFx1QTc1NlxcdUE3NThcXHVBNzVBXFx1QTc1Q1xcdUE3NUVcXHVBNzYwXFx1QTc2MlxcdUE3NjRcXHVBNzY2XFx1QTc2OFxcdUE3NkFcXHVBNzZDXFx1QTc2RVxcdUE3NzlcXHVBNzdCXFx1QTc3RFxcdUE3N0VcXHVBNzgwXFx1QTc4MlxcdUE3ODRcXHVBNzg2XFx1QTc4QlxcdUE3OERcXHVBNzkwXFx1QTc5MlxcdUE3OTZcXHVBNzk4XFx1QTc5QVxcdUE3OUNcXHVBNzlFXFx1QTdBMFxcdUE3QTJcXHVBN0E0XFx1QTdBNlxcdUE3QThcXHVBN0FBLVxcdUE3QURcXHVBN0IwLVxcdUE3QjRcXHVBN0I2XFx1RkYyMS1cXHVGRjNBJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNltcXHVEQ0EwLVxcdURDQkZdfFxcdUQ4MDNbXFx1REM4MC1cXHVEQ0IyXXxcXHVEODM1W1xcdURDMDAtXFx1REMxOVxcdURDMzQtXFx1REM0RFxcdURDNjgtXFx1REM4MVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCNVxcdURDRDAtXFx1RENFOVxcdUREMDRcXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQzOFxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ2Qy1cXHVERDg1XFx1RERBMC1cXHVEREI5XFx1RERENC1cXHVEREVEXFx1REUwOC1cXHVERTIxXFx1REUzQy1cXHVERTU1XFx1REU3MC1cXHVERTg5XFx1REVBOC1cXHVERUMwXFx1REVFMi1cXHVERUZBXFx1REYxQy1cXHVERjM0XFx1REY1Ni1cXHVERjZFXFx1REY5MC1cXHVERkE4XFx1REZDQV18XFx1RDgwMVtcXHVEQzAwLVxcdURDMjddfFxcdUQ4M0NbXFx1REQzMC1cXHVERDQ5XFx1REQ1MC1cXHVERDY5XFx1REQ3MC1cXHVERDg5XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1doaXRlX1NwYWNlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx4MDktXFx4MERcXHgyMFxceDg1XFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDAnXHJcbiAgICAgICAgfVxyXG4gICAgXTtcclxuXHJcbiAgICAvLyBBZGQgbm9uLWdlbmVyYXRlZCBkYXRhXHJcbiAgICB1bmljb2RlRGF0YS5wdXNoKHtcclxuICAgICAgICBuYW1lOiAnQXNzaWduZWQnLFxyXG4gICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgZGVmaW5lZCBhcyB0aGUgaW52ZXJzZSBvZiBVbmljb2RlIGNhdGVnb3J5IENuIChVbmFzc2lnbmVkKSwgdGhlIFVuaWNvZGVcclxuICAgICAgICAvLyBDYXRlZ29yaWVzIGFkZG9uIGlzIHJlcXVpcmVkIHRvIHVzZSB0aGlzIHByb3BlcnR5XHJcbiAgICAgICAgaW52ZXJzZU9mOiAnQ24nXHJcbiAgICB9KTtcclxuXHJcbiAgICBYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKHVuaWNvZGVEYXRhKTtcclxuXHJcbn07XHJcbiIsIi8qIVxyXG4gKiBYUmVnRXhwIFVuaWNvZGUgU2NyaXB0cyAzLjEuMVxyXG4gKiA8eHJlZ2V4cC5jb20+XHJcbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAxMC0yMDE2IE1JVCBMaWNlbnNlXHJcbiAqIFVuaWNvZGUgZGF0YSBieSBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc2J5bmVucy5iZT5cclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFhSZWdFeHApIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgc3VwcG9ydCBmb3IgYWxsIFVuaWNvZGUgc2NyaXB0cy4gRS5nLiwgYFxccHtMYXRpbn1gLiBUb2tlbiBuYW1lcyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSxcclxuICAgICAqIGFuZCBhbnkgc3BhY2VzLCBoeXBoZW5zLCBhbmQgdW5kZXJzY29yZXMgYXJlIGlnbm9yZWQuXHJcbiAgICAgKlxyXG4gICAgICogVXNlcyBVbmljb2RlIDguMC4wLlxyXG4gICAgICpcclxuICAgICAqIEByZXF1aXJlcyBYUmVnRXhwLCBVbmljb2RlIEJhc2VcclxuICAgICAqL1xyXG5cclxuICAgIGlmICghWFJlZ0V4cC5hZGRVbmljb2RlRGF0YSkge1xyXG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignVW5pY29kZSBCYXNlIG11c3QgYmUgbG9hZGVkIGJlZm9yZSBVbmljb2RlIFNjcmlwdHMnKTtcclxuICAgIH1cclxuXHJcbiAgICBYUmVnRXhwLmFkZFVuaWNvZGVEYXRhKFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBaG9tJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVERjAwLVxcdURGMTlcXHVERjFELVxcdURGMkJcXHVERjMwLVxcdURGM0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQW5hdG9saWFuX0hpZXJvZ2x5cGhzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQXJhYmljJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDYwMC1cXHUwNjA0XFx1MDYwNi1cXHUwNjBCXFx1MDYwRC1cXHUwNjFBXFx1MDYxRVxcdTA2MjAtXFx1MDYzRlxcdTA2NDEtXFx1MDY0QVxcdTA2NTYtXFx1MDY2RlxcdTA2NzEtXFx1MDZEQ1xcdTA2REUtXFx1MDZGRlxcdTA3NTAtXFx1MDc3RlxcdTA4QTAtXFx1MDhCNFxcdTA4RTMtXFx1MDhGRlxcdUZCNTAtXFx1RkJDMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGRFxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDNbXFx1REU2MC1cXHVERTdFXXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJcXHVERUYwXFx1REVGMV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBcm1lbmlhbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA1MzEtXFx1MDU1NlxcdTA1NTktXFx1MDU1RlxcdTA1NjEtXFx1MDU4N1xcdTA1OEFcXHUwNThELVxcdTA1OEZcXHVGQjEzLVxcdUZCMTcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdBdmVzdGFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERjAwLVxcdURGMzVcXHVERjM5LVxcdURGM0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQmFsaW5lc2UnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCN0MnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdCYW11bScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE2QTAtXFx1QTZGNycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REMwMC1cXHVERTM4XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0Jhc3NhX1ZhaCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REVEMC1cXHVERUVEXFx1REVGMC1cXHVERUY1XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0JhdGFrJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MUJDMC1cXHUxQkYzXFx1MUJGQy1cXHUxQkZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQmVuZ2FsaScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA5ODAtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUZCJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQm9wb21vZm8nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwMkVBXFx1MDJFQlxcdTMxMDUtXFx1MzEyRFxcdTMxQTAtXFx1MzFCQSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0JyYWhtaScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REMwMC1cXHVEQzREXFx1REM1Mi1cXHVEQzZGXFx1REM3Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdCcmFpbGxlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MjgwMC1cXHUyOEZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQnVnaW5lc2UnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxQTAwLVxcdTFBMUJcXHUxQTFFXFx1MUExRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0J1aGlkJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTc0MC1cXHUxNzUzJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ2FuYWRpYW5fQWJvcmlnaW5hbCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE0MDAtXFx1MTY3RlxcdTE4QjAtXFx1MThGNSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NhcmlhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REVBMC1cXHVERUQwXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0NhdWNhc2lhbl9BbGJhbmlhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REQzMC1cXHVERDYzXFx1REQ2Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDaGFrbWEnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQ0M10nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDaGFtJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE1Qy1cXHVBQTVGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ2hlcm9rZWUnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHVBQjcwLVxcdUFCQkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb21tb24nLFxyXG4gICAgICAgICAgICBibXA6ICdcXDAtXFx4NDBcXFxceDVCLVxceDYwXFxcXHg3Qi1cXHhBOVxceEFCLVxceEI5XFx4QkItXFx4QkZcXHhEN1xceEY3XFx1MDJCOS1cXHUwMkRGXFx1MDJFNS1cXHUwMkU5XFx1MDJFQy1cXHUwMkZGXFx1MDM3NFxcdTAzN0VcXHUwMzg1XFx1MDM4N1xcdTA1ODlcXHUwNjA1XFx1MDYwQ1xcdTA2MUJcXHUwNjFDXFx1MDYxRlxcdTA2NDBcXHUwNkREXFx1MDk2NFxcdTA5NjVcXHUwRTNGXFx1MEZENS1cXHUwRkQ4XFx1MTBGQlxcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTgwMlxcdTE4MDNcXHUxODA1XFx1MUNEM1xcdTFDRTFcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjNcXHUxQ0Y1XFx1MUNGNlxcdTIwMDAtXFx1MjAwQlxcdTIwMEUtXFx1MjA2NFxcdTIwNjYtXFx1MjA3MFxcdTIwNzQtXFx1MjA3RVxcdTIwODAtXFx1MjA4RVxcdTIwQTAtXFx1MjBCRVxcdTIxMDAtXFx1MjEyNVxcdTIxMjctXFx1MjEyOVxcdTIxMkMtXFx1MjEzMVxcdTIxMzMtXFx1MjE0RFxcdTIxNEYtXFx1MjE1RlxcdTIxODktXFx1MjE4QlxcdTIxOTAtXFx1MjNGQVxcdTI0MDAtXFx1MjQyNlxcdTI0NDAtXFx1MjQ0QVxcdTI0NjAtXFx1MjdGRlxcdTI5MDAtXFx1MkI3M1xcdTJCNzYtXFx1MkI5NVxcdTJCOTgtXFx1MkJCOVxcdTJCQkQtXFx1MkJDOFxcdTJCQ0EtXFx1MkJEMVxcdTJCRUMtXFx1MkJFRlxcdTJFMDAtXFx1MkU0MlxcdTJGRjAtXFx1MkZGQlxcdTMwMDAtXFx1MzAwNFxcdTMwMDZcXHUzMDA4LVxcdTMwMjBcXHUzMDMwLVxcdTMwMzdcXHUzMDNDLVxcdTMwM0ZcXHUzMDlCXFx1MzA5Q1xcdTMwQTBcXHUzMEZCXFx1MzBGQ1xcdTMxOTAtXFx1MzE5RlxcdTMxQzAtXFx1MzFFM1xcdTMyMjAtXFx1MzI1RlxcdTMyN0YtXFx1MzJDRlxcdTMzNTgtXFx1MzNGRlxcdTREQzAtXFx1NERGRlxcdUE3MDAtXFx1QTcyMVxcdUE3ODgtXFx1QTc4QVxcdUE4MzAtXFx1QTgzOVxcdUE5MkVcXHVBOUNGXFx1QUI1QlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTY2XFx1RkU2OC1cXHVGRTZCXFx1RkVGRlxcdUZGMDEtXFx1RkYyMFxcdUZGM0ItXFx1RkY0MFxcdUZGNUItXFx1RkY2NVxcdUZGNzBcXHVGRjlFXFx1RkY5RlxcdUZGRTAtXFx1RkZFNlxcdUZGRTgtXFx1RkZFRVxcdUZGRjktXFx1RkZGRCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4M0VbXFx1REMwMC1cXHVEQzBCXFx1REMxMC1cXHVEQzQ3XFx1REM1MC1cXHVEQzU5XFx1REM2MC1cXHVEQzg3XFx1REM5MC1cXHVEQ0FEXFx1REQxMC1cXHVERDE4XFx1REQ4MC1cXHVERDg0XFx1RERDMF18XFx1RDgyRltcXHVEQ0EwLVxcdURDQTNdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXXxcXHVEODNEW1xcdURDMDAtXFx1REQ3OVxcdUREN0ItXFx1RERBM1xcdUREQTUtXFx1REVEMFxcdURFRTAtXFx1REVFQ1xcdURFRjAtXFx1REVGM1xcdURGMDAtXFx1REY3M1xcdURGODAtXFx1REZENF18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERDA3LVxcdUREMzNcXHVERDM3LVxcdUREM0ZcXHVERDkwLVxcdUREOUJcXHVEREQwLVxcdURERkNcXHVERUUxLVxcdURFRkJdfFxcdUQ4MzRbXFx1REMwMC1cXHVEQ0Y1XFx1REQwMC1cXHVERDI2XFx1REQyOS1cXHVERDY2XFx1REQ2QS1cXHVERDdBXFx1REQ4M1xcdUREODRcXHVERDhDLVxcdUREQTlcXHVEREFFLVxcdURERThcXHVERjAwLVxcdURGNTZcXHVERjYwLVxcdURGNzFdfFxcdUQ4M0NbXFx1REMwMC1cXHVEQzJCXFx1REMzMC1cXHVEQzkzXFx1RENBMC1cXHVEQ0FFXFx1RENCMS1cXHVEQ0JGXFx1RENDMS1cXHVEQ0NGXFx1RENEMS1cXHVEQ0Y1XFx1REQwMC1cXHVERDBDXFx1REQxMC1cXHVERDJFXFx1REQzMC1cXHVERDZCXFx1REQ3MC1cXHVERDlBXFx1RERFNi1cXHVEREZGXFx1REUwMVxcdURFMDJcXHVERTEwLVxcdURFM0FcXHVERTQwLVxcdURFNDhcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REZGRl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDb3B0aWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwM0UyLVxcdTAzRUZcXHUyQzgwLVxcdTJDRjNcXHUyQ0Y5LVxcdTJDRkYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdDdW5laWZvcm0nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDNzAtXFx1REM3NFxcdURDODAtXFx1REQ0M118XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ3lwcmlvdCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0ZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQ3lyaWxsaWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwNDAwLVxcdTA0ODRcXHUwNDg3LVxcdTA1MkZcXHUxRDJCXFx1MUQ3OFxcdTJERTAtXFx1MkRGRlxcdUE2NDAtXFx1QTY5RlxcdUZFMkVcXHVGRTJGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnRGVzZXJldCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REMwMC1cXHVEQzRGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0RldmFuYWdhcmknLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwOTAwLVxcdTA5NTBcXHUwOTUzLVxcdTA5NjNcXHUwOTY2LVxcdTA5N0ZcXHVBOEUwLVxcdUE4RkQnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdEdXBsb3lhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5Qy1cXHVEQzlGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0VneXB0aWFuX0hpZXJvZ2x5cGhzJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwQ1tcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0VsYmFzYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAxW1xcdUREMDAtXFx1REQyN10nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdFdGhpb3BpYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTEyMDAtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzdDXFx1MTM4MC1cXHUxMzk5XFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnR2VvcmdpYW4nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTBGRlxcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnR2xhZ29saXRpYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0dvdGhpYycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REYzMC1cXHVERjRBXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0dyYW50aGEnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA0W1xcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0dyZWVrJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDM3MC1cXHUwMzczXFx1MDM3NS1cXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODRcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNFMVxcdTAzRjAtXFx1MDNGRlxcdTFEMjYtXFx1MUQyQVxcdTFENUQtXFx1MUQ2MVxcdTFENjYtXFx1MUQ2QVxcdTFEQkZcXHUxRjAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQzRcXHUxRkM2LVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkRELVxcdTFGRUZcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkVcXHUyMTI2XFx1QUI2NScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REQ0MC1cXHVERDhDXFx1RERBMF18XFx1RDgzNFtcXHVERTAwLVxcdURFNDVdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnR3VqYXJhdGknLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRjFcXHUwQUY5J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnR3VybXVraGknLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSGFuJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkU4MC1cXHUyRTk5XFx1MkU5Qi1cXHUyRUYzXFx1MkYwMC1cXHUyRkQ1XFx1MzAwNVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDM4LVxcdTMwM0JcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18W1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdIYW5ndWwnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxMTAwLVxcdTExRkZcXHUzMDJFXFx1MzAyRlxcdTMxMzEtXFx1MzE4RVxcdTMyMDAtXFx1MzIxRVxcdTMyNjAtXFx1MzI3RVxcdUE5NjAtXFx1QTk3Q1xcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUZGQTAtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0hhbnVub28nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNzIwLVxcdTE3MzQnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdIYXRyYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1RENGQi1cXHVEQ0ZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0hlYnJldycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA1OTEtXFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGNFxcdUZCMUQtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQjRGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnSGlyYWdhbmEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUYnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODJDXFx1REMwMXxcXHVEODNDXFx1REUwMCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0ltcGVyaWFsX0FyYW1haWMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURDNDAtXFx1REM1NVxcdURDNTctXFx1REM1Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdJbmhlcml0ZWQnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwMzAwLVxcdTAzNkZcXHUwNDg1XFx1MDQ4NlxcdTA2NEItXFx1MDY1NVxcdTA2NzBcXHUwOTUxXFx1MDk1MlxcdTFBQjAtXFx1MUFCRVxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjVcXHUxREZDLVxcdTFERkZcXHUyMDBDXFx1MjAwRFxcdTIwRDAtXFx1MjBGMFxcdTMwMkEtXFx1MzAyRFxcdTMwOTlcXHUzMDlBXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJEJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgzNFtcXHVERDY3LVxcdURENjlcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luc2NyaXB0aW9uYWxfUGFobGF2aScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REY2MC1cXHVERjcyXFx1REY3OC1cXHVERjdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0luc2NyaXB0aW9uYWxfUGFydGhpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURGNDAtXFx1REY1NVxcdURGNTgtXFx1REY1Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdKYXZhbmVzZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE5ODAtXFx1QTlDRFxcdUE5RDAtXFx1QTlEOVxcdUE5REVcXHVBOURGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnS2FpdGhpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVEQzgwLVxcdURDQzFdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnS2FubmFkYScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnS2F0YWthbmEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUzMEExLVxcdTMwRkFcXHUzMEZELVxcdTMwRkZcXHUzMUYwLVxcdTMxRkZcXHUzMkQwLVxcdTMyRkVcXHUzMzAwLVxcdTMzNTdcXHVGRjY2LVxcdUZGNkZcXHVGRjcxLVxcdUZGOUQnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODJDXFx1REMwMCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0theWFoX0xpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTkwMC1cXHVBOTJEXFx1QTkyRidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0toYXJvc2h0aGknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRi1cXHVERTQ3XFx1REU1MC1cXHVERTU4XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0tobWVyJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTc4MC1cXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTdGMC1cXHUxN0Y5XFx1MTlFMC1cXHUxOUZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnS2hvamtpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFM0RdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnS2h1ZGF3YWRpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjldJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTGFvJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTGF0aW4nLFxyXG4gICAgICAgICAgICBibXA6ICdBLVphLXpcXHhBQVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQjhcXHUwMkUwLVxcdTAyRTRcXHUxRDAwLVxcdTFEMjVcXHUxRDJDLVxcdTFENUNcXHUxRDYyLVxcdTFENjVcXHUxRDZCLVxcdTFENzdcXHUxRDc5LVxcdTFEQkVcXHUxRTAwLVxcdTFFRkZcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMkFcXHUyMTJCXFx1MjEzMlxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzYwLVxcdTJDN0ZcXHVBNzIyLVxcdUE3ODdcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE3RkZcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjRcXHVGQjAwLVxcdUZCMDZcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUEnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMZXBjaGEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxQzAwLVxcdTFDMzdcXHUxQzNCLVxcdTFDNDlcXHUxQzRELVxcdTFDNEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMaW1idScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDBcXHUxOTQ0LVxcdTE5NEYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMaW5lYXJfQScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0xpbmVhcl9CJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdMaXN1JyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTREMC1cXHVBNEZGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTHljaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERTgwLVxcdURFOUNdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTHlkaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERDIwLVxcdUREMzlcXHVERDNGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ01haGFqYW5pJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERDUwLVxcdURENzZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTWFsYXlhbGFtJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENUYtXFx1MEQ2M1xcdTBENjYtXFx1MEQ3NVxcdTBENzktXFx1MEQ3RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ01hbmRhaWMnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwODQwLVxcdTA4NUJcXHUwODVFJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTWFuaWNoYWVhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REVDMC1cXHVERUU2XFx1REVFQi1cXHVERUY2XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ01lZXRlaV9NYXllaycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUFBRTAtXFx1QUFGNlxcdUFCQzAtXFx1QUJFRFxcdUFCRjAtXFx1QUJGOSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ01lbmRlX0tpa2FrdWknLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDQzctXFx1RENENl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNZXJvaXRpY19DdXJzaXZlJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEREEwLVxcdUREQjdcXHVEREJDLVxcdUREQ0ZcXHVEREQyLVxcdURERkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTWVyb2l0aWNfSGllcm9nbHlwaHMnLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdUREODAtXFx1REQ5Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNaWFvJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwLVxcdURGN0VcXHVERjhGLVxcdURGOUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTW9kaScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REUwMC1cXHVERTQ0XFx1REU1MC1cXHVERTU5XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ01vbmdvbGlhbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE4MDBcXHUxODAxXFx1MTgwNFxcdTE4MDYtXFx1MTgwRVxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ01ybycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REU2RVxcdURFNkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTXVsdGFuaScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOV0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNeWFubWFyJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTAwMC1cXHUxMDlGXFx1QTlFMC1cXHVBOUZFXFx1QUE2MC1cXHVBQTdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTmFiYXRhZWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVEQzgwLVxcdURDOUVcXHVEQ0E3LVxcdURDQUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnTmV3X1RhaV9MdWUnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5REFcXHUxOURFXFx1MTlERidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ05rbycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA3QzAtXFx1MDdGQSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ09naGFtJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTY4MC1cXHUxNjlDJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnT2xfQ2hpa2knLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxQzUwLVxcdTFDN0YnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdPbGRfSHVuZ2FyaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJcXHVEQ0ZBLVxcdURDRkZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnT2xkX0l0YWxpYycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REYwMC1cXHVERjIzXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ09sZF9Ob3J0aF9BcmFiaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERTgwLVxcdURFOUZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnT2xkX1Blcm1pYycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDBbXFx1REY1MC1cXHVERjdBXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ09sZF9QZXJzaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGRDVdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnT2xkX1NvdXRoX0FyYWJpYW4nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODAyW1xcdURFNjAtXFx1REU3Rl0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdPbGRfVHVya2ljJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwM1tcXHVEQzAwLVxcdURDNDhdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnT3JpeWEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjc3J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnT3NtYW55YScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REM4MC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1BhaGF3aF9IbW9uZycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MUFbXFx1REYwMC1cXHVERjQ1XFx1REY1MC1cXHVERjU5XFx1REY1Qi1cXHVERjYxXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1BhbG15cmVuZScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REM2MC1cXHVEQzdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1BhdV9DaW5fSGF1JyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNltcXHVERUMwLVxcdURFRjhdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnUGhhZ3NfUGEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBODQwLVxcdUE4NzcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdQaG9lbmljaWFuJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMltcXHVERDAwLVxcdUREMUJcXHVERDFGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1BzYWx0ZXJfUGFobGF2aScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDJbXFx1REY4MC1cXHVERjkxXFx1REY5OS1cXHVERjlDXFx1REZBOS1cXHVERkFGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1JlamFuZycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE5MzAtXFx1QTk1M1xcdUE5NUYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdSdW5pYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NhbWFyaXRhbicsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA4MDAtXFx1MDgyRFxcdTA4MzAtXFx1MDgzRSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NhdXJhc2h0cmEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHVBODgwLVxcdUE4QzRcXHVBOENFLVxcdUE4RDknXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdTaGFyYWRhJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNFtcXHVERDgwLVxcdUREQ0RcXHVEREQwLVxcdUREREZdJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnU2hhdmlhbicsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDFbXFx1REM1MC1cXHVEQzdGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NpZGRoYW0nLFxyXG4gICAgICAgICAgICBhc3RyYWw6ICdcXHVEODA1W1xcdUREODAtXFx1RERCNVxcdUREQjgtXFx1RERERF0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdTaWduV3JpdGluZycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MzZbXFx1REMwMC1cXHVERThCXFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NpbmhhbGEnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjItXFx1MERGNCcsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1RERFMS1cXHVEREY0XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1NvcmFfU29tcGVuZycsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDRbXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1N1bmRhbmVzZScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTFCODAtXFx1MUJCRlxcdTFDQzAtXFx1MUNDNydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1N5bG90aV9OYWdyaScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE4MDAtXFx1QTgyQidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1N5cmlhYycsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTA3MDAtXFx1MDcwRFxcdTA3MEYtXFx1MDc0QVxcdTA3NEQtXFx1MDc0RidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1RhZ2Fsb2cnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTQnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdUYWdiYW53YScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGFpX0xlJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGFpX1RoYW0nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUEwLVxcdTFBQUQnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdUYWlfVmlldCcsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUFBODAtXFx1QUFDMlxcdUFBREItXFx1QUFERidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1Rha3JpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNVtcXHVERTgwLVxcdURFQjdcXHVERUMwLVxcdURFQzldJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGFtaWwnLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJGQSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1RlbHVndScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM3OC1cXHUwQzdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGhhYW5hJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MDc4MC1cXHUwN0IxJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGhhaScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU1QidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1RpYmV0YW4nLFxyXG4gICAgICAgICAgICBibXA6ICdcXHUwRjAwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkJFLVxcdTBGQ0NcXHUwRkNFLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1RpZmluYWdoJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJENzBcXHUyRDdGJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnVGlyaHV0YScsXHJcbiAgICAgICAgICAgIGFzdHJhbDogJ1xcdUQ4MDVbXFx1REM4MC1cXHVEQ0M3XFx1RENEMC1cXHVEQ0Q5XSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1VnYXJpdGljJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwMFtcXHVERjgwLVxcdURGOURcXHVERjlGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1ZhaScsXHJcbiAgICAgICAgICAgIGJtcDogJ1xcdUE1MDAtXFx1QTYyQidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1dhcmFuZ19DaXRpJyxcclxuICAgICAgICAgICAgYXN0cmFsOiAnXFx1RDgwNltcXHVEQ0EwLVxcdURDRjJcXHVEQ0ZGXSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1lpJyxcclxuICAgICAgICAgICAgYm1wOiAnXFx1QTAwMC1cXHVBNDhDXFx1QTQ5MC1cXHVBNEM2J1xyXG4gICAgICAgIH1cclxuICAgIF0pO1xyXG5cclxufTtcclxuIiwidmFyIFhSZWdFeHAgPSByZXF1aXJlKCcuL3hyZWdleHAnKTtcclxuXHJcbnJlcXVpcmUoJy4vYWRkb25zL2J1aWxkJykoWFJlZ0V4cCk7XHJcbnJlcXVpcmUoJy4vYWRkb25zL21hdGNocmVjdXJzaXZlJykoWFJlZ0V4cCk7XHJcbnJlcXVpcmUoJy4vYWRkb25zL3VuaWNvZGUtYmFzZScpKFhSZWdFeHApO1xyXG5yZXF1aXJlKCcuL2FkZG9ucy91bmljb2RlLWJsb2NrcycpKFhSZWdFeHApO1xyXG5yZXF1aXJlKCcuL2FkZG9ucy91bmljb2RlLWNhdGVnb3JpZXMnKShYUmVnRXhwKTtcclxucmVxdWlyZSgnLi9hZGRvbnMvdW5pY29kZS1wcm9wZXJ0aWVzJykoWFJlZ0V4cCk7XHJcbnJlcXVpcmUoJy4vYWRkb25zL3VuaWNvZGUtc2NyaXB0cycpKFhSZWdFeHApO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYUmVnRXhwO1xyXG4iLCIvKiFcclxuICogWFJlZ0V4cCAzLjEuMVxyXG4gKiA8eHJlZ2V4cC5jb20+XHJcbiAqIFN0ZXZlbiBMZXZpdGhhbiAoYykgMjAwNy0yMDE2IE1JVCBMaWNlbnNlXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIFhSZWdFeHAgcHJvdmlkZXMgYXVnbWVudGVkLCBleHRlbnNpYmxlIHJlZ3VsYXIgZXhwcmVzc2lvbnMuIFlvdSBnZXQgYWRkaXRpb25hbCByZWdleCBzeW50YXggYW5kXHJcbiAqIGZsYWdzLCBiZXlvbmQgd2hhdCBicm93c2VycyBzdXBwb3J0IG5hdGl2ZWx5LiBYUmVnRXhwIGlzIGFsc28gYSByZWdleCB1dGlsaXR5IGJlbHQgd2l0aCB0b29scyB0b1xyXG4gKiBtYWtlIHlvdXIgY2xpZW50LXNpZGUgZ3JlcHBpbmcgc2ltcGxlciBhbmQgbW9yZSBwb3dlcmZ1bCwgd2hpbGUgZnJlZWluZyB5b3UgZnJvbSByZWxhdGVkXHJcbiAqIGNyb3NzLWJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzLlxyXG4gKi9cclxuXHJcbi8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG4vLyBQcml2YXRlIHN0dWZmXHJcbi8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG5cclxuLy8gUHJvcGVydHkgbmFtZSB1c2VkIGZvciBleHRlbmRlZCByZWdleCBpbnN0YW5jZSBkYXRhXHJcbnZhciBSRUdFWF9EQVRBID0gJ3hyZWdleHAnO1xyXG4vLyBPcHRpb25hbCBmZWF0dXJlcyB0aGF0IGNhbiBiZSBpbnN0YWxsZWQgYW5kIHVuaW5zdGFsbGVkXHJcbnZhciBmZWF0dXJlcyA9IHtcclxuICAgIGFzdHJhbDogZmFsc2UsXHJcbiAgICBuYXRpdmVzOiBmYWxzZVxyXG59O1xyXG4vLyBOYXRpdmUgbWV0aG9kcyB0byB1c2UgYW5kIHJlc3RvcmUgKCduYXRpdmUnIGlzIGFuIEVTMyByZXNlcnZlZCBrZXl3b3JkKVxyXG52YXIgbmF0aXYgPSB7XHJcbiAgICBleGVjOiBSZWdFeHAucHJvdG90eXBlLmV4ZWMsXHJcbiAgICB0ZXN0OiBSZWdFeHAucHJvdG90eXBlLnRlc3QsXHJcbiAgICBtYXRjaDogU3RyaW5nLnByb3RvdHlwZS5tYXRjaCxcclxuICAgIHJlcGxhY2U6IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSxcclxuICAgIHNwbGl0OiBTdHJpbmcucHJvdG90eXBlLnNwbGl0XHJcbn07XHJcbi8vIFN0b3JhZ2UgZm9yIGZpeGVkL2V4dGVuZGVkIG5hdGl2ZSBtZXRob2RzXHJcbnZhciBmaXhlZCA9IHt9O1xyXG4vLyBTdG9yYWdlIGZvciByZWdleGVzIGNhY2hlZCBieSBgWFJlZ0V4cC5jYWNoZWBcclxudmFyIHJlZ2V4Q2FjaGUgPSB7fTtcclxuLy8gU3RvcmFnZSBmb3IgcGF0dGVybiBkZXRhaWxzIGNhY2hlZCBieSB0aGUgYFhSZWdFeHBgIGNvbnN0cnVjdG9yXHJcbnZhciBwYXR0ZXJuQ2FjaGUgPSB7fTtcclxuLy8gU3RvcmFnZSBmb3IgcmVnZXggc3ludGF4IHRva2VucyBhZGRlZCBpbnRlcm5hbGx5IG9yIGJ5IGBYUmVnRXhwLmFkZFRva2VuYFxyXG52YXIgdG9rZW5zID0gW107XHJcbi8vIFRva2VuIHNjb3Blc1xyXG52YXIgZGVmYXVsdFNjb3BlID0gJ2RlZmF1bHQnO1xyXG52YXIgY2xhc3NTY29wZSA9ICdjbGFzcyc7XHJcbi8vIFJlZ2V4ZXMgdGhhdCBtYXRjaCBuYXRpdmUgcmVnZXggc3ludGF4LCBpbmNsdWRpbmcgb2N0YWxzXHJcbnZhciBuYXRpdmVUb2tlbnMgPSB7XHJcbiAgICAvLyBBbnkgbmF0aXZlIG11bHRpY2hhcmFjdGVyIHRva2VuIGluIGRlZmF1bHQgc2NvcGUsIG9yIGFueSBzaW5nbGUgY2hhcmFjdGVyXHJcbiAgICAnZGVmYXVsdCc6IC9cXFxcKD86MCg/OlswLTNdWzAtN117MCwyfXxbNC03XVswLTddPyk/fFsxLTldXFxkKnx4W1xcZEEtRmEtZl17Mn18dSg/OltcXGRBLUZhLWZdezR9fHtbXFxkQS1GYS1mXSt9KXxjW0EtWmEtel18W1xcc1xcU10pfFxcKFxcPyg/Ols6PSFdfDxbPSFdKXxbPyorXVxcP3x7XFxkKyg/OixcXGQqKT99XFw/P3xbXFxzXFxTXS8sXHJcbiAgICAvLyBBbnkgbmF0aXZlIG11bHRpY2hhcmFjdGVyIHRva2VuIGluIGNoYXJhY3RlciBjbGFzcyBzY29wZSwgb3IgYW55IHNpbmdsZSBjaGFyYWN0ZXJcclxuICAgICdjbGFzcyc6IC9cXFxcKD86WzAtM11bMC03XXswLDJ9fFs0LTddWzAtN10/fHhbXFxkQS1GYS1mXXsyfXx1KD86W1xcZEEtRmEtZl17NH18e1tcXGRBLUZhLWZdK30pfGNbQS1aYS16XXxbXFxzXFxTXSl8W1xcc1xcU10vXHJcbn07XHJcbi8vIEFueSBiYWNrcmVmZXJlbmNlIG9yIGRvbGxhci1wcmVmaXhlZCBjaGFyYWN0ZXIgaW4gcmVwbGFjZW1lbnQgc3RyaW5nc1xyXG52YXIgcmVwbGFjZW1lbnRUb2tlbiA9IC9cXCQoPzp7KFtcXHckXSspfXwoXFxkXFxkP3xbXFxzXFxTXSkpL2c7XHJcbi8vIENoZWNrIGZvciBjb3JyZWN0IGBleGVjYCBoYW5kbGluZyBvZiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcclxudmFyIGNvcnJlY3RFeGVjTnBjZyA9IG5hdGl2LmV4ZWMuY2FsbCgvKCk/Py8sICcnKVsxXSA9PT0gdW5kZWZpbmVkO1xyXG4vLyBDaGVjayBmb3IgRVM2IGBmbGFnc2AgcHJvcCBzdXBwb3J0XHJcbnZhciBoYXNGbGFnc1Byb3AgPSAveC8uZmxhZ3MgIT09IHVuZGVmaW5lZDtcclxuLy8gU2hvcnRjdXQgdG8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXHJcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xyXG5cclxuZnVuY3Rpb24gaGFzTmF0aXZlRmxhZyhmbGFnKSB7XHJcbiAgICAvLyBDYW4ndCBjaGVjayBiYXNlZCBvbiB0aGUgcHJlc2Vuc2Ugb2YgcHJvcGVydGllcy9nZXR0ZXJzIHNpbmNlIGJyb3dzZXJzIG1pZ2h0IHN1cHBvcnQgc3VjaFxyXG4gICAgLy8gcHJvcGVydGllcyBldmVuIHdoZW4gdGhleSBkb24ndCBzdXBwb3J0IHRoZSBjb3JyZXNwb25kaW5nIGZsYWcgaW4gcmVnZXggY29uc3RydWN0aW9uICh0ZXN0ZWRcclxuICAgIC8vIGluIENocm9tZSA0OCwgd2hlcmUgYCd1bmljb2RlJyBpbiAveC9gIGlzIHRydWUgYnV0IHRyeWluZyB0byBjb25zdHJ1Y3QgYSByZWdleCB3aXRoIGZsYWcgYHVgXHJcbiAgICAvLyB0aHJvd3MgYW4gZXJyb3IpXHJcbiAgICB2YXIgaXNTdXBwb3J0ZWQgPSB0cnVlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBDYW4ndCB1c2UgcmVnZXggbGl0ZXJhbHMgZm9yIHRlc3RpbmcgZXZlbiBpbiBhIGB0cnlgIGJlY2F1c2UgcmVnZXggbGl0ZXJhbHMgd2l0aFxyXG4gICAgICAgIC8vIHVuc3VwcG9ydGVkIGZsYWdzIGNhdXNlIGEgY29tcGlsYXRpb24gZXJyb3IgaW4gSUVcclxuICAgICAgICBuZXcgUmVnRXhwKCcnLCBmbGFnKTtcclxuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xyXG4gICAgICAgIGlzU3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdXBwb3J0ZWQgJiYgZmxhZyA9PT0gJ3knKSB7XHJcbiAgICAgICAgLy8gV29yayBhcm91bmQgU2FmYXJpIDkuMS4xIGJ1Z1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdhYXwuJywgJ3knKS50ZXN0KCdiJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XHJcbn1cclxuLy8gQ2hlY2sgZm9yIEVTNiBgdWAgZmxhZyBzdXBwb3J0XHJcbnZhciBoYXNOYXRpdmVVID0gaGFzTmF0aXZlRmxhZygndScpO1xyXG4vLyBDaGVjayBmb3IgRVM2IGB5YCBmbGFnIHN1cHBvcnRcclxudmFyIGhhc05hdGl2ZVkgPSBoYXNOYXRpdmVGbGFnKCd5Jyk7XHJcbi8vIFRyYWNrZXIgZm9yIGtub3duIGZsYWdzLCBpbmNsdWRpbmcgYWRkb24gZmxhZ3NcclxudmFyIHJlZ2lzdGVyZWRGbGFncyA9IHtcclxuICAgIGc6IHRydWUsXHJcbiAgICBpOiB0cnVlLFxyXG4gICAgbTogdHJ1ZSxcclxuICAgIHU6IGhhc05hdGl2ZVUsXHJcbiAgICB5OiBoYXNOYXRpdmVZXHJcbn07XHJcblxyXG4vKipcclxuICogQXR0YWNoZXMgZXh0ZW5kZWQgZGF0YSBhbmQgYFhSZWdFeHAucHJvdG90eXBlYCBwcm9wZXJ0aWVzIHRvIGEgcmVnZXggb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggdG8gYXVnbWVudC5cclxuICogQHBhcmFtIHtBcnJheX0gY2FwdHVyZU5hbWVzIEFycmF5IHdpdGggY2FwdHVyZSBuYW1lcywgb3IgYG51bGxgLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30geFNvdXJjZSBYUmVnRXhwIHBhdHRlcm4gdXNlZCB0byBnZW5lcmF0ZSBgcmVnZXhgLCBvciBgbnVsbGAgaWYgTi9BLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30geEZsYWdzIFhSZWdFeHAgZmxhZ3MgdXNlZCB0byBnZW5lcmF0ZSBgcmVnZXhgLCBvciBgbnVsbGAgaWYgTi9BLlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0ludGVybmFsT25seT1mYWxzZV0gV2hldGhlciB0aGUgcmVnZXggd2lsbCBiZSB1c2VkIG9ubHkgZm9yIGludGVybmFsXHJcbiAqICAgb3BlcmF0aW9ucywgYW5kIG5ldmVyIGV4cG9zZWQgdG8gdXNlcnMuIEZvciBpbnRlcm5hbC1vbmx5IHJlZ2V4ZXMsIHdlIGNhbiBpbXByb3ZlIHBlcmYgYnlcclxuICogICBza2lwcGluZyBzb21lIG9wZXJhdGlvbnMgbGlrZSBhdHRhY2hpbmcgYFhSZWdFeHAucHJvdG90eXBlYCBwcm9wZXJ0aWVzLlxyXG4gKiBAcmV0dXJucyB7UmVnRXhwfSBBdWdtZW50ZWQgcmVnZXguXHJcbiAqL1xyXG5mdW5jdGlvbiBhdWdtZW50KHJlZ2V4LCBjYXB0dXJlTmFtZXMsIHhTb3VyY2UsIHhGbGFncywgaXNJbnRlcm5hbE9ubHkpIHtcclxuICAgIHZhciBwO1xyXG5cclxuICAgIHJlZ2V4W1JFR0VYX0RBVEFdID0ge1xyXG4gICAgICAgIGNhcHR1cmVOYW1lczogY2FwdHVyZU5hbWVzXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc0ludGVybmFsT25seSkge1xyXG4gICAgICAgIHJldHVybiByZWdleDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYW4ndCBhdXRvLWluaGVyaXQgdGhlc2Ugc2luY2UgdGhlIFhSZWdFeHAgY29uc3RydWN0b3IgcmV0dXJucyBhIG5vbnByaW1pdGl2ZSB2YWx1ZVxyXG4gICAgaWYgKHJlZ2V4Ll9fcHJvdG9fXykge1xyXG4gICAgICAgIHJlZ2V4Ll9fcHJvdG9fXyA9IFhSZWdFeHAucHJvdG90eXBlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKHAgaW4gWFJlZ0V4cC5wcm90b3R5cGUpIHtcclxuICAgICAgICAgICAgLy8gQW4gYFhSZWdFeHAucHJvdG90eXBlLmhhc093blByb3BlcnR5KHApYCBjaGVjayB3b3VsZG4ndCBiZSB3b3J0aCBpdCBoZXJlLCBzaW5jZSB0aGlzXHJcbiAgICAgICAgICAgIC8vIGlzIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSwgYW5kIGVudW1lcmFibGUgYE9iamVjdC5wcm90b3R5cGVgIG9yIGBSZWdFeHAucHJvdG90eXBlYFxyXG4gICAgICAgICAgICAvLyBleHRlbnNpb25zIGV4aXN0IG9uIGByZWdleC5wcm90b3R5cGVgIGFueXdheVxyXG4gICAgICAgICAgICByZWdleFtwXSA9IFhSZWdFeHAucHJvdG90eXBlW3BdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWdleFtSRUdFWF9EQVRBXS5zb3VyY2UgPSB4U291cmNlO1xyXG4gICAgLy8gRW11bGF0ZSB0aGUgRVM2IGBmbGFnc2AgcHJvcCBieSBlbnN1cmluZyBmbGFncyBhcmUgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXHJcbiAgICByZWdleFtSRUdFWF9EQVRBXS5mbGFncyA9IHhGbGFncyA/IHhGbGFncy5zcGxpdCgnJykuc29ydCgpLmpvaW4oJycpIDogeEZsYWdzO1xyXG5cclxuICAgIHJldHVybiByZWdleDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYW55IGR1cGxpY2F0ZSBjaGFyYWN0ZXJzIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gcmVtb3ZlIGR1cGxpY2F0ZSBjaGFyYWN0ZXJzIGZyb20uXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZyB3aXRoIGFueSBkdXBsaWNhdGUgY2hhcmFjdGVycyByZW1vdmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gY2xpcER1cGxpY2F0ZXMoc3RyKSB7XHJcbiAgICByZXR1cm4gbmF0aXYucmVwbGFjZS5jYWxsKHN0ciwgLyhbXFxzXFxTXSkoPz1bXFxzXFxTXSpcXDEpL2csICcnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvcGllcyBhIHJlZ2V4IG9iamVjdCB3aGlsZSBwcmVzZXJ2aW5nIGV4dGVuZGVkIGRhdGEgYW5kIGF1Z21lbnRpbmcgd2l0aCBgWFJlZ0V4cC5wcm90b3R5cGVgXHJcbiAqIHByb3BlcnRpZXMuIFRoZSBjb3B5IGhhcyBhIGZyZXNoIGBsYXN0SW5kZXhgIHByb3BlcnR5IChzZXQgdG8gemVybykuIEFsbG93cyBhZGRpbmcgYW5kIHJlbW92aW5nXHJcbiAqIGZsYWdzIGcgYW5kIHkgd2hpbGUgY29weWluZyB0aGUgcmVnZXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBjb3B5LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IHdpdGggb3B0aW9uYWwgcHJvcGVydGllczpcclxuICogICA8bGk+YGFkZEdgIHtCb29sZWFufSBBZGQgZmxhZyBnIHdoaWxlIGNvcHlpbmcgdGhlIHJlZ2V4LlxyXG4gKiAgIDxsaT5gYWRkWWAge0Jvb2xlYW59IEFkZCBmbGFnIHkgd2hpbGUgY29weWluZyB0aGUgcmVnZXguXHJcbiAqICAgPGxpPmByZW1vdmVHYCB7Qm9vbGVhbn0gUmVtb3ZlIGZsYWcgZyB3aGlsZSBjb3B5aW5nIHRoZSByZWdleC5cclxuICogICA8bGk+YHJlbW92ZVlgIHtCb29sZWFufSBSZW1vdmUgZmxhZyB5IHdoaWxlIGNvcHlpbmcgdGhlIHJlZ2V4LlxyXG4gKiAgIDxsaT5gaXNJbnRlcm5hbE9ubHlgIHtCb29sZWFufSBXaGV0aGVyIHRoZSBjb3BpZWQgcmVnZXggd2lsbCBiZSB1c2VkIG9ubHkgZm9yIGludGVybmFsXHJcbiAqICAgICBvcGVyYXRpb25zLCBhbmQgbmV2ZXIgZXhwb3NlZCB0byB1c2Vycy4gRm9yIGludGVybmFsLW9ubHkgcmVnZXhlcywgd2UgY2FuIGltcHJvdmUgcGVyZiBieVxyXG4gKiAgICAgc2tpcHBpbmcgc29tZSBvcGVyYXRpb25zIGxpa2UgYXR0YWNoaW5nIGBYUmVnRXhwLnByb3RvdHlwZWAgcHJvcGVydGllcy5cclxuICogQHJldHVybnMge1JlZ0V4cH0gQ29weSBvZiB0aGUgcHJvdmlkZWQgcmVnZXgsIHBvc3NpYmx5IHdpdGggbW9kaWZpZWQgZmxhZ3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3B5UmVnZXgocmVnZXgsIG9wdGlvbnMpIHtcclxuICAgIGlmICghWFJlZ0V4cC5pc1JlZ0V4cChyZWdleCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUeXBlIFJlZ0V4cCBleHBlY3RlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB4RGF0YSA9IHJlZ2V4W1JFR0VYX0RBVEFdIHx8IHt9LFxyXG4gICAgICAgIGZsYWdzID0gZ2V0TmF0aXZlRmxhZ3MocmVnZXgpLFxyXG4gICAgICAgIGZsYWdzVG9BZGQgPSAnJyxcclxuICAgICAgICBmbGFnc1RvUmVtb3ZlID0gJycsXHJcbiAgICAgICAgeHJlZ2V4cFNvdXJjZSA9IG51bGwsXHJcbiAgICAgICAgeHJlZ2V4cEZsYWdzID0gbnVsbDtcclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5yZW1vdmVHKSB7ZmxhZ3NUb1JlbW92ZSArPSAnZyc7fVxyXG4gICAgaWYgKG9wdGlvbnMucmVtb3ZlWSkge2ZsYWdzVG9SZW1vdmUgKz0gJ3knO31cclxuICAgIGlmIChmbGFnc1RvUmVtb3ZlKSB7XHJcbiAgICAgICAgZmxhZ3MgPSBuYXRpdi5yZXBsYWNlLmNhbGwoZmxhZ3MsIG5ldyBSZWdFeHAoJ1snICsgZmxhZ3NUb1JlbW92ZSArICddKycsICdnJyksICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5hZGRHKSB7ZmxhZ3NUb0FkZCArPSAnZyc7fVxyXG4gICAgaWYgKG9wdGlvbnMuYWRkWSkge2ZsYWdzVG9BZGQgKz0gJ3knO31cclxuICAgIGlmIChmbGFnc1RvQWRkKSB7XHJcbiAgICAgICAgZmxhZ3MgPSBjbGlwRHVwbGljYXRlcyhmbGFncyArIGZsYWdzVG9BZGQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghb3B0aW9ucy5pc0ludGVybmFsT25seSkge1xyXG4gICAgICAgIGlmICh4RGF0YS5zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB4cmVnZXhwU291cmNlID0geERhdGEuc291cmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBudWxsIG9yIHVuZGVmaW5lZDsgZG9uJ3Qgd2FudCB0byBhZGQgdG8gYGZsYWdzYCBpZiB0aGUgcHJldmlvdXMgdmFsdWUgd2FzIG51bGwsIHNpbmNlXHJcbiAgICAgICAgLy8gdGhhdCBpbmRpY2F0ZXMgd2UncmUgbm90IHRyYWNraW5nIG9yaWdpbmFsIHByZWNvbXBpbGF0aW9uIGZsYWdzXHJcbiAgICAgICAgaWYgKHhEYXRhLmZsYWdzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gRmxhZ3MgYXJlIG9ubHkgYWRkZWQgZm9yIG5vbi1pbnRlcm5hbCByZWdleGVzIGJ5IGBYUmVnRXhwLmdsb2JhbGl6ZWAuIEZsYWdzIGFyZSBuZXZlclxyXG4gICAgICAgICAgICAvLyByZW1vdmVkIGZvciBub24taW50ZXJuYWwgcmVnZXhlcywgc28gZG9uJ3QgbmVlZCB0byBoYW5kbGUgaXRcclxuICAgICAgICAgICAgeHJlZ2V4cEZsYWdzID0gZmxhZ3NUb0FkZCA/IGNsaXBEdXBsaWNhdGVzKHhEYXRhLmZsYWdzICsgZmxhZ3NUb0FkZCkgOiB4RGF0YS5mbGFncztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXVnbWVudCB3aXRoIGBYUmVnRXhwLnByb3RvdHlwZWAgcHJvcGVydGllcywgYnV0IHVzZSB0aGUgbmF0aXZlIGBSZWdFeHBgIGNvbnN0cnVjdG9yIHRvIGF2b2lkXHJcbiAgICAvLyBzZWFyY2hpbmcgZm9yIHNwZWNpYWwgdG9rZW5zLiBUaGF0IHdvdWxkIGJlIHdyb25nIGZvciByZWdleGVzIGNvbnN0cnVjdGVkIGJ5IGBSZWdFeHBgLCBhbmRcclxuICAgIC8vIHVubmVjZXNzYXJ5IGZvciByZWdleGVzIGNvbnN0cnVjdGVkIGJ5IGBYUmVnRXhwYCBiZWNhdXNlIHRoZSByZWdleCBoYXMgYWxyZWFkeSB1bmRlcmdvbmUgdGhlXHJcbiAgICAvLyB0cmFuc2xhdGlvbiB0byBuYXRpdmUgcmVnZXggc3ludGF4XHJcbiAgICByZWdleCA9IGF1Z21lbnQoXHJcbiAgICAgICAgbmV3IFJlZ0V4cChyZWdleC5zb3VyY2UsIGZsYWdzKSxcclxuICAgICAgICBoYXNOYW1lZENhcHR1cmUocmVnZXgpID8geERhdGEuY2FwdHVyZU5hbWVzLnNsaWNlKDApIDogbnVsbCxcclxuICAgICAgICB4cmVnZXhwU291cmNlLFxyXG4gICAgICAgIHhyZWdleHBGbGFncyxcclxuICAgICAgICBvcHRpb25zLmlzSW50ZXJuYWxPbmx5XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiByZWdleDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGhleGFkZWNpbWFsIHRvIGRlY2ltYWwuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXhcclxuICogQHJldHVybnMge051bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGRlYyhoZXgpIHtcclxuICAgIHJldHVybiBwYXJzZUludChoZXgsIDE2KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgbmF0aXZlIGBSZWdFeHBgIGZsYWdzIHVzZWQgYnkgYSByZWdleCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBjaGVjay5cclxuICogQHJldHVybnMge1N0cmluZ30gTmF0aXZlIGZsYWdzIGluIHVzZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldE5hdGl2ZUZsYWdzKHJlZ2V4KSB7XHJcbiAgICByZXR1cm4gaGFzRmxhZ3NQcm9wID9cclxuICAgICAgICByZWdleC5mbGFncyA6XHJcbiAgICAgICAgLy8gRXhwbGljaXRseSB1c2luZyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgKHJhdGhlciB0aGFuIGUuZy4gYFN0cmluZ2Agb3IgY29uY2F0ZW5hdGlvblxyXG4gICAgICAgIC8vIHdpdGggYW4gZW1wdHkgc3RyaW5nKSBhbGxvd3MgdGhpcyB0byBjb250aW51ZSB3b3JraW5nIHByZWRpY3RhYmx5IHdoZW5cclxuICAgICAgICAvLyBgWFJlZ0V4cC5wcm9wdG90eXBlLnRvU3RyaW5nYCBpcyBvdmVycmlkZW5cclxuICAgICAgICBuYXRpdi5leGVjLmNhbGwoL1xcLyhbYS16XSopJC9pLCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVnZXgpKVsxXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciBhIHJlZ2V4IGhhcyBleHRlbmRlZCBpbnN0YW5jZSBkYXRhIHVzZWQgdG8gdHJhY2sgY2FwdHVyZSBuYW1lcy5cclxuICpcclxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcmVnZXggdXNlcyBuYW1lZCBjYXB0dXJlLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzTmFtZWRDYXB0dXJlKHJlZ2V4KSB7XHJcbiAgICByZXR1cm4gISEocmVnZXhbUkVHRVhfREFUQV0gJiYgcmVnZXhbUkVHRVhfREFUQV0uY2FwdHVyZU5hbWVzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGRlY2ltYWwgdG8gaGV4YWRlY2ltYWwuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gZGVjXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBoZXgoZGVjKSB7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQoZGVjLCAxMCkudG9TdHJpbmcoMTYpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiB2YWx1ZSBjYW4gYmUgZm91bmQgaW4gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIHNlYXJjaC5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBsb2NhdGUgaW4gdGhlIGFycmF5LlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBaZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRoZSBpdGVtIGlzIGZvdW5kLCBvciAtMS5cclxuICovXHJcbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XHJcbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoLCBpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAtMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgYnkgcmVzb2x2aW5nIGl0cyBpbnRlcm5hbCBbW0NsYXNzXV0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgT2JqZWN0IHRvIGNoZWNrLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIHRvIGNoZWNrIGZvciwgaW4gVGl0bGVDYXNlLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgb2JqZWN0IG1hdGNoZXMgdGhlIHR5cGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1R5cGUodmFsdWUsIHR5cGUpIHtcclxuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgJyArIHR5cGUgKyAnXSc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgbmV4dCBub25pZ25vcmFibGUgdG9rZW4gYWZ0ZXIgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBpcyBhIHF1YW50aWZpZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIFBhdHRlcm4gdG8gc2VhcmNoIHdpdGhpbi5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcyBJbmRleCBpbiBgcGF0dGVybmAgdG8gc2VhcmNoIGF0LlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmxhZ3MgRmxhZ3MgdXNlZCBieSB0aGUgcGF0dGVybi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgYSBxdWFudGlmaWVyLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNRdWFudGlmaWVyTmV4dChwYXR0ZXJuLCBwb3MsIGZsYWdzKSB7XHJcbiAgICByZXR1cm4gbmF0aXYudGVzdC5jYWxsKFxyXG4gICAgICAgIGZsYWdzLmluZGV4T2YoJ3gnKSA+IC0xID9cclxuICAgICAgICAgICAgLy8gSWdub3JlIGFueSBsZWFkaW5nIHdoaXRlc3BhY2UsIGxpbmUgY29tbWVudHMsIGFuZCBpbmxpbmUgY29tbWVudHNcclxuICAgICAgICAgICAgL14oPzpcXHN8I1teI1xcbl0qfFxcKFxcPyNbXildKlxcKSkqKD86Wz8qK118e1xcZCsoPzosXFxkKik/fSkvIDpcclxuICAgICAgICAgICAgLy8gSWdub3JlIGFueSBsZWFkaW5nIGlubGluZSBjb21tZW50c1xyXG4gICAgICAgICAgICAvXig/OlxcKFxcPyNbXildKlxcKSkqKD86Wz8qK118e1xcZCsoPzosXFxkKik/fSkvLFxyXG4gICAgICAgIHBhdHRlcm4uc2xpY2UocG9zKVxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZHMgbGVhZGluZyB6ZXJvcyBpZiBzaG9ydGVyIHRoYW4gZm91ciBjaGFyYWN0ZXJzLiBVc2VkIGZvciBmaXhlZC1sZW5ndGggaGV4YWRlY2ltYWwgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBwYWQ0KHN0cikge1xyXG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCA0KSB7XHJcbiAgICAgICAgc3RyID0gJzAnICsgc3RyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBmb3IgZmxhZy1yZWxhdGVkIGVycm9ycywgYW5kIHN0cmlwcy9hcHBsaWVzIGZsYWdzIGluIGEgbGVhZGluZyBtb2RlIG1vZGlmaWVyLiBPZmZsb2Fkc1xyXG4gKiB0aGUgZmxhZyBwcmVwYXJhdGlvbiBsb2dpYyBmcm9tIHRoZSBgWFJlZ0V4cGAgY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIFJlZ2V4IHBhdHRlcm4sIHBvc3NpYmx5IHdpdGggYSBsZWFkaW5nIG1vZGUgbW9kaWZpZXIuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFncyBBbnkgY29tYmluYXRpb24gb2YgZmxhZ3MuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB3aXRoIHByb3BlcnRpZXMgYHBhdHRlcm5gIGFuZCBgZmxhZ3NgLlxyXG4gKi9cclxuZnVuY3Rpb24gcHJlcGFyZUZsYWdzKHBhdHRlcm4sIGZsYWdzKSB7XHJcbiAgICB2YXIgaTtcclxuXHJcbiAgICAvLyBSZWNlbnQgYnJvd3NlcnMgdGhyb3cgb24gZHVwbGljYXRlIGZsYWdzLCBzbyBjb3B5IHRoaXMgYmVoYXZpb3IgZm9yIG5vbm5hdGl2ZSBmbGFnc1xyXG4gICAgaWYgKGNsaXBEdXBsaWNhdGVzKGZsYWdzKSAhPT0gZmxhZ3MpIHtcclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgZHVwbGljYXRlIHJlZ2V4IGZsYWcgJyArIGZsYWdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdHJpcCBhbmQgYXBwbHkgYSBsZWFkaW5nIG1vZGUgbW9kaWZpZXIgd2l0aCBhbnkgY29tYmluYXRpb24gb2YgZmxhZ3MgZXhjZXB0IGcgb3IgeVxyXG4gICAgcGF0dGVybiA9IG5hdGl2LnJlcGxhY2UuY2FsbChwYXR0ZXJuLCAvXlxcKFxcPyhbXFx3JF0rKVxcKS8sIGZ1bmN0aW9uKCQwLCAkMSkge1xyXG4gICAgICAgIGlmIChuYXRpdi50ZXN0LmNhbGwoL1tneV0vLCAkMSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDYW5ub3QgdXNlIGZsYWcgZyBvciB5IGluIG1vZGUgbW9kaWZpZXIgJyArICQwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWxsb3cgZHVwbGljYXRlIGZsYWdzIHdpdGhpbiB0aGUgbW9kZSBtb2RpZmllclxyXG4gICAgICAgIGZsYWdzID0gY2xpcER1cGxpY2F0ZXMoZmxhZ3MgKyAkMSk7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVGhyb3cgb24gdW5rbm93biBuYXRpdmUgb3Igbm9ubmF0aXZlIGZsYWdzXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmxhZ3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAoIXJlZ2lzdGVyZWRGbGFnc1tmbGFncy5jaGFyQXQoaSldKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5rbm93biByZWdleCBmbGFnICcgKyBmbGFncy5jaGFyQXQoaSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXHJcbiAgICAgICAgZmxhZ3M6IGZsYWdzXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogUHJlcGFyZXMgYW4gb3B0aW9ucyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWUgVmFsdWUgdG8gY29udmVydCB0byBhbiBvcHRpb25zIG9iamVjdC5cclxuICogQHJldHVybnMge09iamVjdH0gT3B0aW9ucyBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBwcmVwYXJlT3B0aW9ucyh2YWx1ZSkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICBpZiAoaXNUeXBlKHZhbHVlLCAnU3RyaW5nJykpIHtcclxuICAgICAgICBYUmVnRXhwLmZvckVhY2godmFsdWUsIC9bXlxccyxdKy8sIGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbbWF0Y2hdID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIGEgZmxhZyBzbyBpdCBkb2Vzbid0IHRocm93IGFuICd1bmtub3duIGZsYWcnIGVycm9yLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmxhZyBTaW5nbGUtY2hhcmFjdGVyIGZsYWcgdG8gcmVnaXN0ZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckZsYWcoZmxhZykge1xyXG4gICAgaWYgKCEvXltcXHckXSQvLnRlc3QoZmxhZykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYWcgbXVzdCBiZSBhIHNpbmdsZSBjaGFyYWN0ZXIgQS1aYS16MC05XyQnKTtcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3RlcmVkRmxhZ3NbZmxhZ10gPSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogUnVucyBidWlsdC1pbiBhbmQgY3VzdG9tIHJlZ2V4IHN5bnRheCB0b2tlbnMgaW4gcmV2ZXJzZSBpbnNlcnRpb24gb3JkZXIgYXQgdGhlIHNwZWNpZmllZFxyXG4gKiBwb3NpdGlvbiwgdW50aWwgYSBtYXRjaCBpcyBmb3VuZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gT3JpZ2luYWwgcGF0dGVybiBmcm9tIHdoaWNoIGFuIFhSZWdFeHAgb2JqZWN0IGlzIGJlaW5nIGJ1aWx0LlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmxhZ3MgRmxhZ3MgYmVpbmcgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHJlZ2V4LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gcG9zIFBvc2l0aW9uIHRvIHNlYXJjaCBmb3IgdG9rZW5zIHdpdGhpbiBgcGF0dGVybmAuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY29wZSBSZWdleCBzY29wZSB0byBhcHBseTogJ2RlZmF1bHQnIG9yICdjbGFzcycuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IENvbnRleHQgb2JqZWN0IHRvIHVzZSBmb3IgdG9rZW4gaGFuZGxlciBmdW5jdGlvbnMuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB3aXRoIHByb3BlcnRpZXMgYG1hdGNoTGVuZ3RoYCwgYG91dHB1dGAsIGFuZCBgcmVwYXJzZWA7IG9yIGBudWxsYC5cclxuICovXHJcbmZ1bmN0aW9uIHJ1blRva2VucyhwYXR0ZXJuLCBmbGFncywgcG9zLCBzY29wZSwgY29udGV4dCkge1xyXG4gICAgdmFyIGkgPSB0b2tlbnMubGVuZ3RoLFxyXG4gICAgICAgIGxlYWRDaGFyID0gcGF0dGVybi5jaGFyQXQocG9zKSxcclxuICAgICAgICByZXN1bHQgPSBudWxsLFxyXG4gICAgICAgIG1hdGNoLFxyXG4gICAgICAgIHQ7XHJcblxyXG4gICAgLy8gUnVuIGluIHJldmVyc2UgaW5zZXJ0aW9uIG9yZGVyXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgdCA9IHRva2Vuc1tpXTtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICh0LmxlYWRDaGFyICYmIHQubGVhZENoYXIgIT09IGxlYWRDaGFyKSB8fFxyXG4gICAgICAgICAgICAodC5zY29wZSAhPT0gc2NvcGUgJiYgdC5zY29wZSAhPT0gJ2FsbCcpIHx8XHJcbiAgICAgICAgICAgICh0LmZsYWcgJiYgZmxhZ3MuaW5kZXhPZih0LmZsYWcpID09PSAtMSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtYXRjaCA9IFhSZWdFeHAuZXhlYyhwYXR0ZXJuLCB0LnJlZ2V4LCBwb3MsICdzdGlja3knKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hMZW5ndGg6IG1hdGNoWzBdLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG91dHB1dDogdC5oYW5kbGVyLmNhbGwoY29udGV4dCwgbWF0Y2gsIHNjb3BlLCBmbGFncyksXHJcbiAgICAgICAgICAgICAgICByZXBhcnNlOiB0LnJlcGFyc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gRmluaXNoZWQgd2l0aCB0b2tlbiB0ZXN0c1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgaW1wbGljaXQgYXN0cmFsIG1vZGUgb3B0LWluLiBXaGVuIGVuYWJsZWQsIGZsYWcgQSBpcyBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvXHJcbiAqIGFsbCBuZXcgcmVnZXhlcyBjcmVhdGVkIGJ5IFhSZWdFeHAuIFRoaXMgY2F1c2VzIGFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIGNyZWF0aW5nIHJlZ2V4ZXMgaWZcclxuICogdGhlIFVuaWNvZGUgQmFzZSBhZGRvbiBpcyBub3QgYXZhaWxhYmxlLCBzaW5jZSBmbGFnIEEgaXMgcmVnaXN0ZXJlZCBieSB0aGF0IGFkZG9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uIGB0cnVlYCB0byBlbmFibGU7IGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldEFzdHJhbChvbikge1xyXG4gICAgZmVhdHVyZXMuYXN0cmFsID0gb247XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmFibGVzIG9yIGRpc2FibGVzIG5hdGl2ZSBtZXRob2Qgb3ZlcnJpZGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uIGB0cnVlYCB0byBlbmFibGU7IGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldE5hdGl2ZXMob24pIHtcclxuICAgIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyA9IChvbiA/IGZpeGVkIDogbmF0aXYpLmV4ZWM7XHJcbiAgICBSZWdFeHAucHJvdG90eXBlLnRlc3QgPSAob24gPyBmaXhlZCA6IG5hdGl2KS50ZXN0O1xyXG4gICAgU3RyaW5nLnByb3RvdHlwZS5tYXRjaCA9IChvbiA/IGZpeGVkIDogbmF0aXYpLm1hdGNoO1xyXG4gICAgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlID0gKG9uID8gZml4ZWQgOiBuYXRpdikucmVwbGFjZTtcclxuICAgIFN0cmluZy5wcm90b3R5cGUuc3BsaXQgPSAob24gPyBmaXhlZCA6IG5hdGl2KS5zcGxpdDtcclxuXHJcbiAgICBmZWF0dXJlcy5uYXRpdmVzID0gb247XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBvYmplY3QsIG9yIHRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuIFRoaXMgaXMgdXNlZCB0byBmb2xsb3dcclxuICogdGhlIEVTNSBhYnN0cmFjdCBvcGVyYXRpb24gYFRvT2JqZWN0YC5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBPYmplY3QgdG8gY2hlY2sgYW5kIHJldHVybi5cclxuICogQHJldHVybnMgeyp9IFRoZSBwcm92aWRlZCBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b09iamVjdCh2YWx1ZSkge1xyXG4gICAgLy8gbnVsbCBvciB1bmRlZmluZWRcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgbnVsbCBvciB1bmRlZmluZWQgdG8gb2JqZWN0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG4vLyA9PS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPT1cclxuLy8gQ29uc3RydWN0b3JcclxuLy8gPT0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT09XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBleHRlbmRlZCByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciBtYXRjaGluZyB0ZXh0IHdpdGggYSBwYXR0ZXJuLiBEaWZmZXJzIGZyb20gYVxyXG4gKiBuYXRpdmUgcmVndWxhciBleHByZXNzaW9uIGluIHRoYXQgYWRkaXRpb25hbCBzeW50YXggYW5kIGZsYWdzIGFyZSBzdXBwb3J0ZWQuIFRoZSByZXR1cm5lZCBvYmplY3RcclxuICogaXMgaW4gZmFjdCBhIG5hdGl2ZSBgUmVnRXhwYCBhbmQgd29ya3Mgd2l0aCBhbGwgbmF0aXZlIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBjbGFzcyBYUmVnRXhwXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHBhdHRlcm4gUmVnZXggcGF0dGVybiBzdHJpbmcsIG9yIGFuIGV4aXN0aW5nIHJlZ2V4IG9iamVjdCB0byBjb3B5LlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZsYWdzXSBBbnkgY29tYmluYXRpb24gb2YgZmxhZ3MuXHJcbiAqICAgTmF0aXZlIGZsYWdzOlxyXG4gKiAgICAgPGxpPmBnYCAtIGdsb2JhbFxyXG4gKiAgICAgPGxpPmBpYCAtIGlnbm9yZSBjYXNlXHJcbiAqICAgICA8bGk+YG1gIC0gbXVsdGlsaW5lIGFuY2hvcnNcclxuICogICAgIDxsaT5gdWAgLSB1bmljb2RlIChFUzYpXHJcbiAqICAgICA8bGk+YHlgIC0gc3RpY2t5IChGaXJlZm94IDMrLCBFUzYpXHJcbiAqICAgQWRkaXRpb25hbCBYUmVnRXhwIGZsYWdzOlxyXG4gKiAgICAgPGxpPmBuYCAtIGV4cGxpY2l0IGNhcHR1cmVcclxuICogICAgIDxsaT5gc2AgLSBkb3QgbWF0Y2hlcyBhbGwgKGFrYSBzaW5nbGVsaW5lKVxyXG4gKiAgICAgPGxpPmB4YCAtIGZyZWUtc3BhY2luZyBhbmQgbGluZSBjb21tZW50cyAoYWthIGV4dGVuZGVkKVxyXG4gKiAgICAgPGxpPmBBYCAtIGFzdHJhbCAocmVxdWlyZXMgdGhlIFVuaWNvZGUgQmFzZSBhZGRvbilcclxuICogICBGbGFncyBjYW5ub3QgYmUgcHJvdmlkZWQgd2hlbiBjb25zdHJ1Y3Rpbmcgb25lIGBSZWdFeHBgIGZyb20gYW5vdGhlci5cclxuICogQHJldHVybnMge1JlZ0V4cH0gRXh0ZW5kZWQgcmVndWxhciBleHByZXNzaW9uIG9iamVjdC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gV2l0aCBuYW1lZCBjYXB0dXJlIGFuZCBmbGFnIHhcclxuICogWFJlZ0V4cCgnKD88eWVhcj4gIFswLTldezR9ICkgLT8gICMgeWVhciAgXFxuXFxcclxuICogICAgICAgICAgKD88bW9udGg+IFswLTldezJ9ICkgLT8gICMgbW9udGggXFxuXFxcclxuICogICAgICAgICAgKD88ZGF5PiAgIFswLTldezJ9ICkgICAgICMgZGF5ICAgJywgJ3gnKTtcclxuICpcclxuICogLy8gUHJvdmlkaW5nIGEgcmVnZXggb2JqZWN0IGNvcGllcyBpdC4gTmF0aXZlIHJlZ2V4ZXMgYXJlIHJlY29tcGlsZWQgdXNpbmcgbmF0aXZlIChub3QgWFJlZ0V4cClcclxuICogLy8gc3ludGF4LiBDb3BpZXMgbWFpbnRhaW4gZXh0ZW5kZWQgZGF0YSwgYXJlIGF1Z21lbnRlZCB3aXRoIGBYUmVnRXhwLnByb3RvdHlwZWAgcHJvcGVydGllcywgYW5kXHJcbiAqIC8vIGhhdmUgZnJlc2ggYGxhc3RJbmRleGAgcHJvcGVydGllcyAoc2V0IHRvIHplcm8pLlxyXG4gKiBYUmVnRXhwKC9yZWdleC8pO1xyXG4gKi9cclxuZnVuY3Rpb24gWFJlZ0V4cChwYXR0ZXJuLCBmbGFncykge1xyXG4gICAgaWYgKFhSZWdFeHAuaXNSZWdFeHAocGF0dGVybikpIHtcclxuICAgICAgICBpZiAoZmxhZ3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3Qgc3VwcGx5IGZsYWdzIHdoZW4gY29weWluZyBhIFJlZ0V4cCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29weVJlZ2V4KHBhdHRlcm4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvcHkgdGhlIGFyZ3VtZW50IGJlaGF2aW9yIG9mIGBSZWdFeHBgXHJcbiAgICBwYXR0ZXJuID0gcGF0dGVybiA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcocGF0dGVybik7XHJcbiAgICBmbGFncyA9IGZsYWdzID09PSB1bmRlZmluZWQgPyAnJyA6IFN0cmluZyhmbGFncyk7XHJcblxyXG4gICAgaWYgKFhSZWdFeHAuaXNJbnN0YWxsZWQoJ2FzdHJhbCcpICYmIGZsYWdzLmluZGV4T2YoJ0EnKSA9PT0gLTEpIHtcclxuICAgICAgICAvLyBUaGlzIGNhdXNlcyBhbiBlcnJvciB0byBiZSB0aHJvd24gaWYgdGhlIFVuaWNvZGUgQmFzZSBhZGRvbiBpcyBub3QgYXZhaWxhYmxlXHJcbiAgICAgICAgZmxhZ3MgKz0gJ0EnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghcGF0dGVybkNhY2hlW3BhdHRlcm5dKSB7XHJcbiAgICAgICAgcGF0dGVybkNhY2hlW3BhdHRlcm5dID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFwYXR0ZXJuQ2FjaGVbcGF0dGVybl1bZmxhZ3NdKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgIGhhc05hbWVkQ2FwdHVyZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNhcHR1cmVOYW1lczogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzY29wZSA9IGRlZmF1bHRTY29wZTtcclxuICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XHJcbiAgICAgICAgdmFyIHBvcyA9IDA7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGZsYWctcmVsYXRlZCBlcnJvcnMsIGFuZCBzdHJpcC9hcHBseSBmbGFncyBpbiBhIGxlYWRpbmcgbW9kZSBtb2RpZmllclxyXG4gICAgICAgIHZhciBhcHBsaWVkID0gcHJlcGFyZUZsYWdzKHBhdHRlcm4sIGZsYWdzKTtcclxuICAgICAgICB2YXIgYXBwbGllZFBhdHRlcm4gPSBhcHBsaWVkLnBhdHRlcm47XHJcbiAgICAgICAgdmFyIGFwcGxpZWRGbGFncyA9IGFwcGxpZWQuZmxhZ3M7XHJcblxyXG4gICAgICAgIC8vIFVzZSBYUmVnRXhwJ3MgdG9rZW5zIHRvIHRyYW5zbGF0ZSB0aGUgcGF0dGVybiB0byBhIG5hdGl2ZSByZWdleCBwYXR0ZXJuLlxyXG4gICAgICAgIC8vIGBhcHBsaWVkUGF0dGVybi5sZW5ndGhgIG1heSBjaGFuZ2Ugb24gZWFjaCBpdGVyYXRpb24gaWYgdG9rZW5zIHVzZSBgcmVwYXJzZWBcclxuICAgICAgICB3aGlsZSAocG9zIDwgYXBwbGllZFBhdHRlcm4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBjdXN0b20gdG9rZW5zIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBydW5Ub2tlbnMoYXBwbGllZFBhdHRlcm4sIGFwcGxpZWRGbGFncywgcG9zLCBzY29wZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbWF0Y2hlZCB0b2tlbiB1c2VkIHRoZSBgcmVwYXJzZWAgb3B0aW9uLCBzcGxpY2UgaXRzIG91dHB1dCBpbnRvIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gcGF0dGVybiBiZWZvcmUgcnVubmluZyB0b2tlbnMgYWdhaW4gYXQgdGhlIHNhbWUgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnJlcGFyc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBhcHBsaWVkUGF0dGVybiA9IGFwcGxpZWRQYXR0ZXJuLnNsaWNlKDAsIHBvcykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQub3V0cHV0ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGllZFBhdHRlcm4uc2xpY2UocG9zICsgcmVzdWx0Lm1hdGNoTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAocmVzdWx0ICYmIHJlc3VsdC5yZXBhcnNlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCArPSByZXN1bHQub3V0cHV0O1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IChyZXN1bHQubWF0Y2hMZW5ndGggfHwgMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIG5hdGl2ZSB0b2tlbiBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gWFJlZ0V4cC5leGVjKGFwcGxpZWRQYXR0ZXJuLCBuYXRpdmVUb2tlbnNbc2NvcGVdLCBwb3MsICdzdGlja3knKVswXTtcclxuICAgICAgICAgICAgICAgIG91dHB1dCArPSB0b2tlbjtcclxuICAgICAgICAgICAgICAgIHBvcyArPSB0b2tlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09ICdbJyAmJiBzY29wZSA9PT0gZGVmYXVsdFNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBjbGFzc1Njb3BlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ10nICYmIHNjb3BlID09PSBjbGFzc1Njb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBkZWZhdWx0U2NvcGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhdHRlcm5DYWNoZVtwYXR0ZXJuXVtmbGFnc10gPSB7XHJcbiAgICAgICAgICAgIC8vIFVzZSBiYXNpYyBjbGVhbnVwIHRvIGNvbGxhcHNlIHJlcGVhdGVkIGVtcHR5IGdyb3VwcyBsaWtlIGAoPzopKD86KWAgdG8gYCg/OilgLiBFbXB0eVxyXG4gICAgICAgICAgICAvLyBncm91cHMgYXJlIHNvbWV0aW1lcyBpbnNlcnRlZCBkdXJpbmcgcmVnZXggdHJhbnNwaWxhdGlvbiBpbiBvcmRlciB0byBrZWVwIHRva2Vuc1xyXG4gICAgICAgICAgICAvLyBzZXBhcmF0ZWQuIEhvd2V2ZXIsIG1vcmUgdGhhbiBvbmUgZW1wdHkgZ3JvdXAgaW4gYSByb3cgaXMgbmV2ZXIgbmVlZGVkLlxyXG4gICAgICAgICAgICBwYXR0ZXJuOiBuYXRpdi5yZXBsYWNlLmNhbGwob3V0cHV0LCAvKD86XFwoXFw/OlxcKSkrL2csICcoPzopJyksXHJcbiAgICAgICAgICAgIC8vIFN0cmlwIGFsbCBidXQgbmF0aXZlIGZsYWdzXHJcbiAgICAgICAgICAgIGZsYWdzOiBuYXRpdi5yZXBsYWNlLmNhbGwoYXBwbGllZEZsYWdzLCAvW15naW11eV0rL2csICcnKSxcclxuICAgICAgICAgICAgLy8gYGNvbnRleHQuY2FwdHVyZU5hbWVzYCBoYXMgYW4gaXRlbSBmb3IgZWFjaCBjYXB0dXJpbmcgZ3JvdXAsIGV2ZW4gaWYgdW5uYW1lZFxyXG4gICAgICAgICAgICBjYXB0dXJlczogY29udGV4dC5oYXNOYW1lZENhcHR1cmUgPyBjb250ZXh0LmNhcHR1cmVOYW1lcyA6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBnZW5lcmF0ZWQgPSBwYXR0ZXJuQ2FjaGVbcGF0dGVybl1bZmxhZ3NdO1xyXG4gICAgcmV0dXJuIGF1Z21lbnQoXHJcbiAgICAgICAgbmV3IFJlZ0V4cChnZW5lcmF0ZWQucGF0dGVybiwgZ2VuZXJhdGVkLmZsYWdzKSxcclxuICAgICAgICBnZW5lcmF0ZWQuY2FwdHVyZXMsXHJcbiAgICAgICAgcGF0dGVybixcclxuICAgICAgICBmbGFnc1xyXG4gICAgKTtcclxufVxyXG5cclxuLy8gQWRkIGBSZWdFeHAucHJvdG90eXBlYCB0byB0aGUgcHJvdG90eXBlIGNoYWluXHJcblhSZWdFeHAucHJvdG90eXBlID0gbmV3IFJlZ0V4cCgpO1xyXG5cclxuLy8gPT0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT09XHJcbi8vIFB1YmxpYyBwcm9wZXJ0aWVzXHJcbi8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG5cclxuLyoqXHJcbiAqIFRoZSBYUmVnRXhwIHZlcnNpb24gbnVtYmVyIGFzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhyZWUgZG90LXNlcGFyYXRlZCBwYXJ0cy4gRm9yIGV4YW1wbGUsXHJcbiAqICcyLjAuMC1iZXRhLTMnLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEB0eXBlIFN0cmluZ1xyXG4gKi9cclxuWFJlZ0V4cC52ZXJzaW9uID0gJzMuMS4xJztcclxuXHJcbi8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG4vLyBQdWJsaWMgbWV0aG9kc1xyXG4vLyA9PS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPT1cclxuXHJcbi8vIEludGVudGlvbmFsbHkgdW5kb2N1bWVudGVkOyB1c2VkIGluIHRlc3RzIGFuZCBhZGRvbnNcclxuWFJlZ0V4cC5faGFzTmF0aXZlRmxhZyA9IGhhc05hdGl2ZUZsYWc7XHJcblhSZWdFeHAuX2RlYyA9IGRlYztcclxuWFJlZ0V4cC5faGV4ID0gaGV4O1xyXG5YUmVnRXhwLl9wYWQ0ID0gcGFkNDtcclxuXHJcbi8qKlxyXG4gKiBFeHRlbmRzIFhSZWdFeHAgc3ludGF4IGFuZCBhbGxvd3MgY3VzdG9tIGZsYWdzLiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBhbmQgY2FuIGJlIHVzZWQgdG9cclxuICogY3JlYXRlIFhSZWdFeHAgYWRkb25zLiBJZiBtb3JlIHRoYW4gb25lIHRva2VuIGNhbiBtYXRjaCB0aGUgc2FtZSBzdHJpbmcsIHRoZSBsYXN0IGFkZGVkIHdpbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBuZXcgdG9rZW4uXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbmV3IHBhdHRlcm4gc3RyaW5nICh1c2luZyBuYXRpdmUgcmVnZXggc3ludGF4KVxyXG4gKiAgIHRvIHJlcGxhY2UgdGhlIG1hdGNoZWQgdG9rZW4gd2l0aGluIGFsbCBmdXR1cmUgWFJlZ0V4cCByZWdleGVzLiBIYXMgYWNjZXNzIHRvIHBlcnNpc3RlbnRcclxuICogICBwcm9wZXJ0aWVzIG9mIHRoZSByZWdleCBiZWluZyBidWlsdCwgdGhyb3VnaCBgdGhpc2AuIEludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XHJcbiAqICAgPGxpPlRoZSBtYXRjaCBhcnJheSwgd2l0aCBuYW1lZCBiYWNrcmVmZXJlbmNlIHByb3BlcnRpZXMuXHJcbiAqICAgPGxpPlRoZSByZWdleCBzY29wZSB3aGVyZSB0aGUgbWF0Y2ggd2FzIGZvdW5kOiAnZGVmYXVsdCcgb3IgJ2NsYXNzJy5cclxuICogICA8bGk+VGhlIGZsYWdzIHVzZWQgYnkgdGhlIHJlZ2V4LCBpbmNsdWRpbmcgYW55IGZsYWdzIGluIGEgbGVhZGluZyBtb2RlIG1vZGlmaWVyLlxyXG4gKiAgIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIGJlY29tZXMgcGFydCBvZiB0aGUgWFJlZ0V4cCBjb25zdHJ1Y3Rpb24gcHJvY2Vzcywgc28gYmUgY2FyZWZ1bCBub3QgdG9cclxuICogICBjb25zdHJ1Y3QgWFJlZ0V4cHMgd2l0aGluIHRoZSBmdW5jdGlvbiBvciB5b3Ugd2lsbCB0cmlnZ2VyIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIG9wdGlvbmFsIHByb3BlcnRpZXM6XHJcbiAqICAgPGxpPmBzY29wZWAge1N0cmluZ30gU2NvcGUgd2hlcmUgdGhlIHRva2VuIGFwcGxpZXM6ICdkZWZhdWx0JywgJ2NsYXNzJywgb3IgJ2FsbCcuXHJcbiAqICAgPGxpPmBmbGFnYCB7U3RyaW5nfSBTaW5nbGUtY2hhcmFjdGVyIGZsYWcgdGhhdCB0cmlnZ2VycyB0aGUgdG9rZW4uIFRoaXMgYWxzbyByZWdpc3RlcnMgdGhlXHJcbiAqICAgICBmbGFnLCB3aGljaCBwcmV2ZW50cyBYUmVnRXhwIGZyb20gdGhyb3dpbmcgYW4gJ3Vua25vd24gZmxhZycgZXJyb3Igd2hlbiB0aGUgZmxhZyBpcyB1c2VkLlxyXG4gKiAgIDxsaT5gb3B0aW9uYWxGbGFnc2Age1N0cmluZ30gQW55IGN1c3RvbSBmbGFncyBjaGVja2VkIGZvciB3aXRoaW4gdGhlIHRva2VuIGBoYW5kbGVyYCB0aGF0IGFyZVxyXG4gKiAgICAgbm90IHJlcXVpcmVkIHRvIHRyaWdnZXIgdGhlIHRva2VuLiBUaGlzIHJlZ2lzdGVycyB0aGUgZmxhZ3MsIHRvIHByZXZlbnQgWFJlZ0V4cCBmcm9tXHJcbiAqICAgICB0aHJvd2luZyBhbiAndW5rbm93biBmbGFnJyBlcnJvciB3aGVuIGFueSBvZiB0aGUgZmxhZ3MgYXJlIHVzZWQuXHJcbiAqICAgPGxpPmByZXBhcnNlYCB7Qm9vbGVhbn0gV2hldGhlciB0aGUgYGhhbmRsZXJgIGZ1bmN0aW9uJ3Mgb3V0cHV0IHNob3VsZCBub3QgYmUgdHJlYXRlZCBhc1xyXG4gKiAgICAgZmluYWwsIGFuZCBpbnN0ZWFkIGJlIHJlcGFyc2VhYmxlIGJ5IG90aGVyIHRva2VucyAoaW5jbHVkaW5nIHRoZSBjdXJyZW50IHRva2VuKS4gQWxsb3dzXHJcbiAqICAgICB0b2tlbiBjaGFpbmluZyBvciBkZWZlcnJpbmcuXHJcbiAqICAgPGxpPmBsZWFkQ2hhcmAge1N0cmluZ30gU2luZ2xlIGNoYXJhY3RlciB0aGF0IG9jY3VycyBhdCB0aGUgYmVnaW5uaW5nIG9mIGFueSBzdWNjZXNzZnVsIG1hdGNoXHJcbiAqICAgICBvZiB0aGUgdG9rZW4gKG5vdCBhbHdheXMgYXBwbGljYWJsZSkuIFRoaXMgZG9lc24ndCBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHRoZSB0b2tlbiB1bmxlc3NcclxuICogICAgIHlvdSBwcm92aWRlIGFuIGVycm9uZW91cyB2YWx1ZS4gSG93ZXZlciwgcHJvdmlkaW5nIGl0IGNhbiBpbmNyZWFzZSB0aGUgdG9rZW4ncyBwZXJmb3JtYW5jZVxyXG4gKiAgICAgc2luY2UgdGhlIHRva2VuIGNhbiBiZSBza2lwcGVkIGF0IGFueSBwb3NpdGlvbnMgd2hlcmUgdGhpcyBjaGFyYWN0ZXIgZG9lc24ndCBhcHBlYXIuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIEJhc2ljIHVzYWdlOiBBZGQgXFxhIGZvciB0aGUgQUxFUlQgY29udHJvbCBjb2RlXHJcbiAqIFhSZWdFeHAuYWRkVG9rZW4oXHJcbiAqICAgL1xcXFxhLyxcclxuICogICBmdW5jdGlvbigpIHtyZXR1cm4gJ1xcXFx4MDcnO30sXHJcbiAqICAge3Njb3BlOiAnYWxsJ31cclxuICogKTtcclxuICogWFJlZ0V4cCgnXFxcXGFbXFxcXGEtXFxcXG5dKycpLnRlc3QoJ1xceDA3XFxuXFx4MDcnKTsgLy8gLT4gdHJ1ZVxyXG4gKlxyXG4gKiAvLyBBZGQgdGhlIFUgKHVuZ3JlZWR5KSBmbGFnIGZyb20gUENSRSBhbmQgUkUyLCB3aGljaCByZXZlcnNlcyBncmVlZHkgYW5kIGxhenkgcXVhbnRpZmllcnMuXHJcbiAqIC8vIFNpbmNlIGBzY29wZWAgaXMgbm90IHNwZWNpZmllZCwgaXQgdXNlcyAnZGVmYXVsdCcgKGkuZS4sIHRyYW5zZm9ybWF0aW9ucyBhcHBseSBvdXRzaWRlIG9mXHJcbiAqIC8vIGNoYXJhY3RlciBjbGFzc2VzIG9ubHkpXHJcbiAqIFhSZWdFeHAuYWRkVG9rZW4oXHJcbiAqICAgLyhbPyorXXx7XFxkKyg/OixcXGQqKT99KShcXD8/KS8sXHJcbiAqICAgZnVuY3Rpb24obWF0Y2gpIHtyZXR1cm4gbWF0Y2hbMV0gKyAobWF0Y2hbMl0gPyAnJyA6ICc/Jyk7fSxcclxuICogICB7ZmxhZzogJ1UnfVxyXG4gKiApO1xyXG4gKiBYUmVnRXhwKCdhKycsICdVJykuZXhlYygnYWFhJylbMF07IC8vIC0+ICdhJ1xyXG4gKiBYUmVnRXhwKCdhKz8nLCAnVScpLmV4ZWMoJ2FhYScpWzBdOyAvLyAtPiAnYWFhJ1xyXG4gKi9cclxuWFJlZ0V4cC5hZGRUb2tlbiA9IGZ1bmN0aW9uKHJlZ2V4LCBoYW5kbGVyLCBvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHZhciBvcHRpb25hbEZsYWdzID0gb3B0aW9ucy5vcHRpb25hbEZsYWdzLCBpO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmZsYWcpIHtcclxuICAgICAgICByZWdpc3RlckZsYWcob3B0aW9ucy5mbGFnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9uYWxGbGFncykge1xyXG4gICAgICAgIG9wdGlvbmFsRmxhZ3MgPSBuYXRpdi5zcGxpdC5jYWxsKG9wdGlvbmFsRmxhZ3MsICcnKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9uYWxGbGFncy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICByZWdpc3RlckZsYWcob3B0aW9uYWxGbGFnc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCB0byB0aGUgcHJpdmF0ZSBsaXN0IG9mIHN5bnRheCB0b2tlbnNcclxuICAgIHRva2Vucy5wdXNoKHtcclxuICAgICAgICByZWdleDogY29weVJlZ2V4KHJlZ2V4LCB7XHJcbiAgICAgICAgICAgIGFkZEc6IHRydWUsXHJcbiAgICAgICAgICAgIGFkZFk6IGhhc05hdGl2ZVksXHJcbiAgICAgICAgICAgIGlzSW50ZXJuYWxPbmx5OiB0cnVlXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcclxuICAgICAgICBzY29wZTogb3B0aW9ucy5zY29wZSB8fCBkZWZhdWx0U2NvcGUsXHJcbiAgICAgICAgZmxhZzogb3B0aW9ucy5mbGFnLFxyXG4gICAgICAgIHJlcGFyc2U6IG9wdGlvbnMucmVwYXJzZSxcclxuICAgICAgICBsZWFkQ2hhcjogb3B0aW9ucy5sZWFkQ2hhclxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUmVzZXQgdGhlIHBhdHRlcm4gY2FjaGUgdXNlZCBieSB0aGUgYFhSZWdFeHBgIGNvbnN0cnVjdG9yLCBzaW5jZSB0aGUgc2FtZSBwYXR0ZXJuIGFuZCBmbGFnc1xyXG4gICAgLy8gbWlnaHQgbm93IHByb2R1Y2UgZGlmZmVyZW50IHJlc3VsdHNcclxuICAgIFhSZWdFeHAuY2FjaGUuZmx1c2goJ3BhdHRlcm5zJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FjaGVzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgWFJlZ0V4cChwYXR0ZXJuLCBmbGFncylgLiBPbiBhbnkgc3Vic2VxdWVudCBjYWxsIHdpdGhcclxuICogdGhlIHNhbWUgcGF0dGVybiBhbmQgZmxhZyBjb21iaW5hdGlvbiwgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSByZWdleCBpcyByZXR1cm5lZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gUmVnZXggcGF0dGVybiBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmxhZ3NdIEFueSBjb21iaW5hdGlvbiBvZiBYUmVnRXhwIGZsYWdzLlxyXG4gKiBAcmV0dXJucyB7UmVnRXhwfSBDYWNoZWQgWFJlZ0V4cCBvYmplY3QuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIHdoaWxlIChtYXRjaCA9IFhSZWdFeHAuY2FjaGUoJy4nLCAnZ3MnKS5leGVjKHN0cikpIHtcclxuICogICAvLyBUaGUgcmVnZXggaXMgY29tcGlsZWQgb25jZSBvbmx5XHJcbiAqIH1cclxuICovXHJcblhSZWdFeHAuY2FjaGUgPSBmdW5jdGlvbihwYXR0ZXJuLCBmbGFncykge1xyXG4gICAgaWYgKCFyZWdleENhY2hlW3BhdHRlcm5dKSB7XHJcbiAgICAgICAgcmVnZXhDYWNoZVtwYXR0ZXJuXSA9IHt9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlZ2V4Q2FjaGVbcGF0dGVybl1bZmxhZ3NdIHx8IChcclxuICAgICAgICByZWdleENhY2hlW3BhdHRlcm5dW2ZsYWdzXSA9IFhSZWdFeHAocGF0dGVybiwgZmxhZ3MpXHJcbiAgICApO1xyXG59O1xyXG5cclxuLy8gSW50ZW50aW9uYWxseSB1bmRvY3VtZW50ZWQ7IHVzZWQgaW4gdGVzdHNcclxuWFJlZ0V4cC5jYWNoZS5mbHVzaCA9IGZ1bmN0aW9uKGNhY2hlTmFtZSkge1xyXG4gICAgaWYgKGNhY2hlTmFtZSA9PT0gJ3BhdHRlcm5zJykge1xyXG4gICAgICAgIC8vIEZsdXNoIHRoZSBwYXR0ZXJuIGNhY2hlIHVzZWQgYnkgdGhlIGBYUmVnRXhwYCBjb25zdHJ1Y3RvclxyXG4gICAgICAgIHBhdHRlcm5DYWNoZSA9IHt9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBGbHVzaCB0aGUgcmVnZXggY2FjaGUgcG9wdWxhdGVkIGJ5IGBYUmVnRXhwLmNhY2hlYFxyXG4gICAgICAgIHJlZ2V4Q2FjaGUgPSB7fTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBFc2NhcGVzIGFueSByZWd1bGFyIGV4cHJlc3Npb24gbWV0YWNoYXJhY3RlcnMsIGZvciB1c2Ugd2hlbiBtYXRjaGluZyBsaXRlcmFsIHN0cmluZ3MuIFRoZSByZXN1bHRcclxuICogY2FuIHNhZmVseSBiZSB1c2VkIGF0IGFueSBwb2ludCB3aXRoaW4gYSByZWdleCB0aGF0IHVzZXMgYW55IGZsYWdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBlc2NhcGUuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFN0cmluZyB3aXRoIHJlZ2V4IG1ldGFjaGFyYWN0ZXJzIGVzY2FwZWQuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIFhSZWdFeHAuZXNjYXBlKCdFc2NhcGVkPyA8Lj4nKTtcclxuICogLy8gLT4gJ0VzY2FwZWRcXD9cXCA8XFwuPidcclxuICovXHJcblhSZWdFeHAuZXNjYXBlID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICByZXR1cm4gbmF0aXYucmVwbGFjZS5jYWxsKHRvT2JqZWN0KHN0ciksIC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4ZWN1dGVzIGEgcmVnZXggc2VhcmNoIGluIGEgc3BlY2lmaWVkIHN0cmluZy4gUmV0dXJucyBhIG1hdGNoIGFycmF5IG9yIGBudWxsYC4gSWYgdGhlIHByb3ZpZGVkXHJcbiAqIHJlZ2V4IHVzZXMgbmFtZWQgY2FwdHVyZSwgbmFtZWQgYmFja3JlZmVyZW5jZSBwcm9wZXJ0aWVzIGFyZSBpbmNsdWRlZCBvbiB0aGUgbWF0Y2ggYXJyYXkuXHJcbiAqIE9wdGlvbmFsIGBwb3NgIGFuZCBgc3RpY2t5YCBhcmd1bWVudHMgc3BlY2lmeSB0aGUgc2VhcmNoIHN0YXJ0IHBvc2l0aW9uLCBhbmQgd2hldGhlciB0aGUgbWF0Y2hcclxuICogbXVzdCBzdGFydCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9ubHkuIFRoZSBgbGFzdEluZGV4YCBwcm9wZXJ0eSBvZiB0aGUgcHJvdmlkZWQgcmVnZXggaXMgbm90XHJcbiAqIHVzZWQsIGJ1dCBpcyB1cGRhdGVkIGZvciBjb21wYXRpYmlsaXR5LiBBbHNvIGZpeGVzIGJyb3dzZXIgYnVncyBjb21wYXJlZCB0byB0aGUgbmF0aXZlXHJcbiAqIGBSZWdFeHAucHJvdG90eXBlLmV4ZWNgIGFuZCBjYW4gYmUgdXNlZCByZWxpYWJseSBjcm9zcy1icm93c2VyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzZWFyY2guXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBzZWFyY2ggd2l0aC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtwb3M9MF0gWmVyby1iYXNlZCBpbmRleCBhdCB3aGljaCB0byBzdGFydCB0aGUgc2VhcmNoLlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbc3RpY2t5PWZhbHNlXSBXaGV0aGVyIHRoZSBtYXRjaCBtdXN0IHN0YXJ0IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cclxuICogICBvbmx5LiBUaGUgc3RyaW5nIGAnc3RpY2t5J2AgaXMgYWNjZXB0ZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gYHRydWVgLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IE1hdGNoIGFycmF5IHdpdGggbmFtZWQgYmFja3JlZmVyZW5jZSBwcm9wZXJ0aWVzLCBvciBgbnVsbGAuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIEJhc2ljIHVzZSwgd2l0aCBuYW1lZCBiYWNrcmVmZXJlbmNlXHJcbiAqIHZhciBtYXRjaCA9IFhSZWdFeHAuZXhlYygnVSsyNjIwJywgWFJlZ0V4cCgnVVxcXFwrKD88aGV4PlswLTlBLUZdezR9KScpKTtcclxuICogbWF0Y2guaGV4OyAvLyAtPiAnMjYyMCdcclxuICpcclxuICogLy8gV2l0aCBwb3MgYW5kIHN0aWNreSwgaW4gYSBsb29wXHJcbiAqIHZhciBwb3MgPSAyLCByZXN1bHQgPSBbXSwgbWF0Y2g7XHJcbiAqIHdoaWxlIChtYXRjaCA9IFhSZWdFeHAuZXhlYygnPDE+PDI+PDM+PDQ+NTw2PicsIC88KFxcZCk+LywgcG9zLCAnc3RpY2t5JykpIHtcclxuICogICByZXN1bHQucHVzaChtYXRjaFsxXSk7XHJcbiAqICAgcG9zID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XHJcbiAqIH1cclxuICogLy8gcmVzdWx0IC0+IFsnMicsICczJywgJzQnXVxyXG4gKi9cclxuWFJlZ0V4cC5leGVjID0gZnVuY3Rpb24oc3RyLCByZWdleCwgcG9zLCBzdGlja3kpIHtcclxuICAgIHZhciBjYWNoZUtleSA9ICdnJyxcclxuICAgICAgICBhZGRZID0gZmFsc2UsXHJcbiAgICAgICAgbWF0Y2gsXHJcbiAgICAgICAgcjI7XHJcblxyXG4gICAgYWRkWSA9IGhhc05hdGl2ZVkgJiYgISEoc3RpY2t5IHx8IChyZWdleC5zdGlja3kgJiYgc3RpY2t5ICE9PSBmYWxzZSkpO1xyXG4gICAgaWYgKGFkZFkpIHtcclxuICAgICAgICBjYWNoZUtleSArPSAneSc7XHJcbiAgICB9XHJcblxyXG4gICAgcmVnZXhbUkVHRVhfREFUQV0gPSByZWdleFtSRUdFWF9EQVRBXSB8fCB7fTtcclxuXHJcbiAgICAvLyBTaGFyZXMgY2FjaGVkIGNvcGllcyB3aXRoIGBYUmVnRXhwLm1hdGNoYC9gcmVwbGFjZWBcclxuICAgIHIyID0gcmVnZXhbUkVHRVhfREFUQV1bY2FjaGVLZXldIHx8IChcclxuICAgICAgICByZWdleFtSRUdFWF9EQVRBXVtjYWNoZUtleV0gPSBjb3B5UmVnZXgocmVnZXgsIHtcclxuICAgICAgICAgICAgYWRkRzogdHJ1ZSxcclxuICAgICAgICAgICAgYWRkWTogYWRkWSxcclxuICAgICAgICAgICAgcmVtb3ZlWTogc3RpY2t5ID09PSBmYWxzZSxcclxuICAgICAgICAgICAgaXNJbnRlcm5hbE9ubHk6IHRydWVcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICByMi5sYXN0SW5kZXggPSBwb3MgPSBwb3MgfHwgMDtcclxuXHJcbiAgICAvLyBGaXhlZCBgZXhlY2AgcmVxdWlyZWQgZm9yIGBsYXN0SW5kZXhgIGZpeCwgbmFtZWQgYmFja3JlZmVyZW5jZXMsIGV0Yy5cclxuICAgIG1hdGNoID0gZml4ZWQuZXhlYy5jYWxsKHIyLCBzdHIpO1xyXG5cclxuICAgIGlmIChzdGlja3kgJiYgbWF0Y2ggJiYgbWF0Y2guaW5kZXggIT09IHBvcykge1xyXG4gICAgICAgIG1hdGNoID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVnZXguZ2xvYmFsKSB7XHJcbiAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gbWF0Y2ggPyByMi5sYXN0SW5kZXggOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtYXRjaDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIHJlZ2V4IG1hdGNoLiBTZWFyY2hlcyBhbHdheXMgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGVcclxuICogc3RyaW5nIGFuZCBjb250aW51ZSB1bnRpbCB0aGUgZW5kLCByZWdhcmRsZXNzIG9mIHRoZSBzdGF0ZSBvZiB0aGUgcmVnZXgncyBgZ2xvYmFsYCBwcm9wZXJ0eSBhbmRcclxuICogaW5pdGlhbCBgbGFzdEluZGV4YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggUmVnZXggdG8gc2VhcmNoIHdpdGguXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggbWF0Y2guIEludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcclxuICogICA8bGk+VGhlIG1hdGNoIGFycmF5LCB3aXRoIG5hbWVkIGJhY2tyZWZlcmVuY2UgcHJvcGVydGllcy5cclxuICogICA8bGk+VGhlIHplcm8tYmFzZWQgbWF0Y2ggaW5kZXguXHJcbiAqICAgPGxpPlRoZSBzdHJpbmcgYmVpbmcgdHJhdmVyc2VkLlxyXG4gKiAgIDxsaT5UaGUgcmVnZXggb2JqZWN0IGJlaW5nIHVzZWQgdG8gdHJhdmVyc2UgdGhlIHN0cmluZy5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gRXh0cmFjdHMgZXZlcnkgb3RoZXIgZGlnaXQgZnJvbSBhIHN0cmluZ1xyXG4gKiB2YXIgZXZlbnMgPSBbXTtcclxuICogWFJlZ0V4cC5mb3JFYWNoKCcxYTIzNDUnLCAvXFxkLywgZnVuY3Rpb24obWF0Y2gsIGkpIHtcclxuICogICBpZiAoaSAlIDIpIGV2ZW5zLnB1c2goK21hdGNoWzBdKTtcclxuICogfSk7XHJcbiAqIC8vIGV2ZW5zIC0+IFsyLCA0XVxyXG4gKi9cclxuWFJlZ0V4cC5mb3JFYWNoID0gZnVuY3Rpb24oc3RyLCByZWdleCwgY2FsbGJhY2spIHtcclxuICAgIHZhciBwb3MgPSAwLFxyXG4gICAgICAgIGkgPSAtMSxcclxuICAgICAgICBtYXRjaDtcclxuXHJcbiAgICB3aGlsZSAoKG1hdGNoID0gWFJlZ0V4cC5leGVjKHN0ciwgcmVnZXgsIHBvcykpKSB7XHJcbiAgICAgICAgLy8gQmVjYXVzZSBgcmVnZXhgIGlzIHByb3ZpZGVkIHRvIGBjYWxsYmFja2AsIHRoZSBmdW5jdGlvbiBjb3VsZCB1c2UgdGhlIGRlcHJlY2F0ZWQvXHJcbiAgICAgICAgLy8gbm9uc3RhbmRhcmQgYFJlZ0V4cC5wcm90b3R5cGUuY29tcGlsZWAgdG8gbXV0YXRlIHRoZSByZWdleC4gSG93ZXZlciwgc2luY2UgYFhSZWdFeHAuZXhlY2BcclxuICAgICAgICAvLyBkb2Vzbid0IHVzZSBgbGFzdEluZGV4YCB0byBzZXQgdGhlIHNlYXJjaCBwb3NpdGlvbiwgdGhpcyBjYW4ndCBsZWFkIHRvIGFuIGluZmluaXRlIGxvb3AsXHJcbiAgICAgICAgLy8gYXQgbGVhc3QuIEFjdHVhbGx5LCBiZWNhdXNlIG9mIHRoZSB3YXkgYFhSZWdFeHAuZXhlY2AgY2FjaGVzIGdsb2JhbGl6ZWQgdmVyc2lvbnMgb2ZcclxuICAgICAgICAvLyByZWdleGVzLCBtdXRhdGluZyB0aGUgcmVnZXggd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBpdGVyYXRpb24gb3IgbWF0Y2hlZCBzdHJpbmdzLFxyXG4gICAgICAgIC8vIHdoaWNoIGlzIGEgbmljZSBzaWRlIGVmZmVjdCB0aGF0IGJyaW5ncyBleHRyYSBzYWZldHkuXHJcbiAgICAgICAgY2FsbGJhY2sobWF0Y2gsICsraSwgc3RyLCByZWdleCk7XHJcblxyXG4gICAgICAgIHBvcyA9IG1hdGNoLmluZGV4ICsgKG1hdGNoWzBdLmxlbmd0aCB8fCAxKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3BpZXMgYSByZWdleCBvYmplY3QgYW5kIGFkZHMgZmxhZyBgZ2AuIFRoZSBjb3B5IG1haW50YWlucyBleHRlbmRlZCBkYXRhLCBpcyBhdWdtZW50ZWQgd2l0aFxyXG4gKiBgWFJlZ0V4cC5wcm90b3R5cGVgIHByb3BlcnRpZXMsIGFuZCBoYXMgYSBmcmVzaCBgbGFzdEluZGV4YCBwcm9wZXJ0eSAoc2V0IHRvIHplcm8pLiBOYXRpdmVcclxuICogcmVnZXhlcyBhcmUgbm90IHJlY29tcGlsZWQgdXNpbmcgWFJlZ0V4cCBzeW50YXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleCBSZWdleCB0byBnbG9iYWxpemUuXHJcbiAqIEByZXR1cm5zIHtSZWdFeHB9IENvcHkgb2YgdGhlIHByb3ZpZGVkIHJlZ2V4IHdpdGggZmxhZyBgZ2AgYWRkZWQuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIHZhciBnbG9iYWxDb3B5ID0gWFJlZ0V4cC5nbG9iYWxpemUoL3JlZ2V4Lyk7XHJcbiAqIGdsb2JhbENvcHkuZ2xvYmFsOyAvLyAtPiB0cnVlXHJcbiAqL1xyXG5YUmVnRXhwLmdsb2JhbGl6ZSA9IGZ1bmN0aW9uKHJlZ2V4KSB7XHJcbiAgICByZXR1cm4gY29weVJlZ2V4KHJlZ2V4LCB7YWRkRzogdHJ1ZX0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluc3RhbGxzIG9wdGlvbmFsIGZlYXR1cmVzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIG9wdGlvbnMuIENhbiBiZSB1bmRvbmUgdXNpbmdcclxuICogYFhSZWdFeHAudW5pbnN0YWxsYC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0IG9yIHN0cmluZy5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gV2l0aCBhbiBvcHRpb25zIG9iamVjdFxyXG4gKiBYUmVnRXhwLmluc3RhbGwoe1xyXG4gKiAgIC8vIEVuYWJsZXMgc3VwcG9ydCBmb3IgYXN0cmFsIGNvZGUgcG9pbnRzIGluIFVuaWNvZGUgYWRkb25zIChpbXBsaWNpdGx5IHNldHMgZmxhZyBBKVxyXG4gKiAgIGFzdHJhbDogdHJ1ZSxcclxuICpcclxuICogICAvLyBERVBSRUNBVEVEOiBPdmVycmlkZXMgbmF0aXZlIHJlZ2V4IG1ldGhvZHMgd2l0aCBmaXhlZC9leHRlbmRlZCB2ZXJzaW9uc1xyXG4gKiAgIG5hdGl2ZXM6IHRydWVcclxuICogfSk7XHJcbiAqXHJcbiAqIC8vIFdpdGggYW4gb3B0aW9ucyBzdHJpbmdcclxuICogWFJlZ0V4cC5pbnN0YWxsKCdhc3RyYWwgbmF0aXZlcycpO1xyXG4gKi9cclxuWFJlZ0V4cC5pbnN0YWxsID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IHByZXBhcmVPcHRpb25zKG9wdGlvbnMpO1xyXG5cclxuICAgIGlmICghZmVhdHVyZXMuYXN0cmFsICYmIG9wdGlvbnMuYXN0cmFsKSB7XHJcbiAgICAgICAgc2V0QXN0cmFsKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZmVhdHVyZXMubmF0aXZlcyAmJiBvcHRpb25zLm5hdGl2ZXMpIHtcclxuICAgICAgICBzZXROYXRpdmVzKHRydWUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIGFuIGluZGl2aWR1YWwgb3B0aW9uYWwgZmVhdHVyZSBpcyBpbnN0YWxsZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmZWF0dXJlIE5hbWUgb2YgdGhlIGZlYXR1cmUgdG8gY2hlY2suIE9uZSBvZjpcclxuICogICA8bGk+YGFzdHJhbGBcclxuICogICA8bGk+YG5hdGl2ZXNgXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBmZWF0dXJlIGlzIGluc3RhbGxlZC5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogWFJlZ0V4cC5pc0luc3RhbGxlZCgnYXN0cmFsJyk7XHJcbiAqL1xyXG5YUmVnRXhwLmlzSW5zdGFsbGVkID0gZnVuY3Rpb24oZmVhdHVyZSkge1xyXG4gICAgcmV0dXJuICEhKGZlYXR1cmVzW2ZlYXR1cmVdKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBhbiBvYmplY3QgaXMgYSByZWdleDsgYGZhbHNlYCBpZiBpdCBpc24ndC4gVGhpcyB3b3JrcyBjb3JyZWN0bHkgZm9yIHJlZ2V4ZXNcclxuICogY3JlYXRlZCBpbiBhbm90aGVyIGZyYW1lLCB3aGVuIGBpbnN0YW5jZW9mYCBhbmQgYGNvbnN0cnVjdG9yYCBjaGVja3Mgd291bGQgZmFpbC5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBPYmplY3QgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBvYmplY3QgaXMgYSBgUmVnRXhwYCBvYmplY3QuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIFhSZWdFeHAuaXNSZWdFeHAoJ3N0cmluZycpOyAvLyAtPiBmYWxzZVxyXG4gKiBYUmVnRXhwLmlzUmVnRXhwKC9yZWdleC9pKTsgLy8gLT4gdHJ1ZVxyXG4gKiBYUmVnRXhwLmlzUmVnRXhwKFJlZ0V4cCgnXicsICdtJykpOyAvLyAtPiB0cnVlXHJcbiAqIFhSZWdFeHAuaXNSZWdFeHAoWFJlZ0V4cCgnKD9zKS4nKSk7IC8vIC0+IHRydWVcclxuICovXHJcblhSZWdFeHAuaXNSZWdFeHAgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBSZWdFeHBdJztcclxuICAgIC8vcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ1JlZ0V4cCcpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZpcnN0IG1hdGNoZWQgc3RyaW5nLCBvciBpbiBnbG9iYWwgbW9kZSwgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgbWF0Y2hlZCBzdHJpbmdzLlxyXG4gKiBUaGlzIGlzIGVzc2VudGlhbGx5IGEgbW9yZSBjb252ZW5pZW50IHJlLWltcGxlbWVudGF0aW9uIG9mIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoYCB0aGF0IGdpdmVzXHJcbiAqIHRoZSByZXN1bHQgdHlwZXMgeW91IGFjdHVhbGx5IHdhbnQgKHN0cmluZyBpbnN0ZWFkIG9mIGBleGVjYC1zdHlsZSBhcnJheSBpbiBtYXRjaC1maXJzdCBtb2RlLFxyXG4gKiBhbmQgYW4gZW1wdHkgYXJyYXkgaW5zdGVhZCBvZiBgbnVsbGAgd2hlbiBubyBtYXRjaGVzIGFyZSBmb3VuZCBpbiBtYXRjaC1hbGwgbW9kZSkuIEl0IGFsc28gbGV0c1xyXG4gKiB5b3Ugb3ZlcnJpZGUgZmxhZyBnIGFuZCBpZ25vcmUgYGxhc3RJbmRleGAsIGFuZCBmaXhlcyBicm93c2VyIGJ1Z3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cclxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIHNlYXJjaCB3aXRoLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Njb3BlPSdvbmUnXSBVc2UgJ29uZScgdG8gcmV0dXJuIHRoZSBmaXJzdCBtYXRjaCBhcyBhIHN0cmluZy4gVXNlICdhbGwnIHRvXHJcbiAqICAgcmV0dXJuIGFuIGFycmF5IG9mIGFsbCBtYXRjaGVkIHN0cmluZ3MuIElmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCBhbmQgYHJlZ2V4YCB1c2VzIGZsYWcgZyxcclxuICogICBgc2NvcGVgIGlzICdhbGwnLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfEFycmF5fSBJbiBtYXRjaC1maXJzdCBtb2RlOiBGaXJzdCBtYXRjaCBhcyBhIHN0cmluZywgb3IgYG51bGxgLiBJbiBtYXRjaC1hbGxcclxuICogICBtb2RlOiBBcnJheSBvZiBhbGwgbWF0Y2hlZCBzdHJpbmdzLCBvciBhbiBlbXB0eSBhcnJheS5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gTWF0Y2ggZmlyc3RcclxuICogWFJlZ0V4cC5tYXRjaCgnYWJjJywgL1xcdy8pOyAvLyAtPiAnYSdcclxuICogWFJlZ0V4cC5tYXRjaCgnYWJjJywgL1xcdy9nLCAnb25lJyk7IC8vIC0+ICdhJ1xyXG4gKiBYUmVnRXhwLm1hdGNoKCdhYmMnLCAveC9nLCAnb25lJyk7IC8vIC0+IG51bGxcclxuICpcclxuICogLy8gTWF0Y2ggYWxsXHJcbiAqIFhSZWdFeHAubWF0Y2goJ2FiYycsIC9cXHcvZyk7IC8vIC0+IFsnYScsICdiJywgJ2MnXVxyXG4gKiBYUmVnRXhwLm1hdGNoKCdhYmMnLCAvXFx3LywgJ2FsbCcpOyAvLyAtPiBbJ2EnLCAnYicsICdjJ11cclxuICogWFJlZ0V4cC5tYXRjaCgnYWJjJywgL3gvLCAnYWxsJyk7IC8vIC0+IFtdXHJcbiAqL1xyXG5YUmVnRXhwLm1hdGNoID0gZnVuY3Rpb24oc3RyLCByZWdleCwgc2NvcGUpIHtcclxuICAgIHZhciBnbG9iYWwgPSAocmVnZXguZ2xvYmFsICYmIHNjb3BlICE9PSAnb25lJykgfHwgc2NvcGUgPT09ICdhbGwnLFxyXG4gICAgICAgIGNhY2hlS2V5ID0gKChnbG9iYWwgPyAnZycgOiAnJykgKyAocmVnZXguc3RpY2t5ID8gJ3knIDogJycpKSB8fCAnbm9HWScsXHJcbiAgICAgICAgcmVzdWx0LFxyXG4gICAgICAgIHIyO1xyXG5cclxuICAgIHJlZ2V4W1JFR0VYX0RBVEFdID0gcmVnZXhbUkVHRVhfREFUQV0gfHwge307XHJcblxyXG4gICAgLy8gU2hhcmVzIGNhY2hlZCBjb3BpZXMgd2l0aCBgWFJlZ0V4cC5leGVjYC9gcmVwbGFjZWBcclxuICAgIHIyID0gcmVnZXhbUkVHRVhfREFUQV1bY2FjaGVLZXldIHx8IChcclxuICAgICAgICByZWdleFtSRUdFWF9EQVRBXVtjYWNoZUtleV0gPSBjb3B5UmVnZXgocmVnZXgsIHtcclxuICAgICAgICAgICAgYWRkRzogISFnbG9iYWwsXHJcbiAgICAgICAgICAgIHJlbW92ZUc6IHNjb3BlID09PSAnb25lJyxcclxuICAgICAgICAgICAgaXNJbnRlcm5hbE9ubHk6IHRydWVcclxuICAgICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICByZXN1bHQgPSBuYXRpdi5tYXRjaC5jYWxsKHRvT2JqZWN0KHN0ciksIHIyKTtcclxuXHJcbiAgICBpZiAocmVnZXguZ2xvYmFsKSB7XHJcbiAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gKFxyXG4gICAgICAgICAgICAoc2NvcGUgPT09ICdvbmUnICYmIHJlc3VsdCkgP1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdXNlIGByMi5sYXN0SW5kZXhgIHNpbmNlIGByMmAgaXMgbm9uZ2xvYmFsIGluIHRoaXMgY2FzZVxyXG4gICAgICAgICAgICAgICAgKHJlc3VsdC5pbmRleCArIHJlc3VsdFswXS5sZW5ndGgpIDogMFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdsb2JhbCA/IChyZXN1bHQgfHwgW10pIDogKHJlc3VsdCAmJiByZXN1bHRbMF0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlcyB0aGUgbWF0Y2hlcyBmcm9tIHNlYXJjaGluZyBhIHN0cmluZyB1c2luZyBhIGNoYWluIG9mIHJlZ2V4ZXMgdGhhdCBzdWNjZXNzaXZlbHkgc2VhcmNoXHJcbiAqIHdpdGhpbiBwcmV2aW91cyBtYXRjaGVzLiBUaGUgcHJvdmlkZWQgYGNoYWluYCBhcnJheSBjYW4gY29udGFpbiByZWdleGVzIGFuZCBvciBvYmplY3RzIHdpdGhcclxuICogYHJlZ2V4YCBhbmQgYGJhY2tyZWZgIHByb3BlcnRpZXMuIFdoZW4gYSBiYWNrcmVmZXJlbmNlIGlzIHNwZWNpZmllZCwgdGhlIG5hbWVkIG9yIG51bWJlcmVkXHJcbiAqIGJhY2tyZWZlcmVuY2UgaXMgcGFzc2VkIGZvcndhcmQgdG8gdGhlIG5leHQgcmVnZXggb3IgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cclxuICogQHBhcmFtIHtBcnJheX0gY2hhaW4gUmVnZXhlcyB0aGF0IGVhY2ggc2VhcmNoIGZvciBtYXRjaGVzIHdpdGhpbiBwcmVjZWRpbmcgcmVzdWx0cy5cclxuICogQHJldHVybnMge0FycmF5fSBNYXRjaGVzIGJ5IHRoZSBsYXN0IHJlZ2V4IGluIHRoZSBjaGFpbiwgb3IgYW4gZW1wdHkgYXJyYXkuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIEJhc2ljIHVzYWdlOyBtYXRjaGVzIG51bWJlcnMgd2l0aGluIDxiPiB0YWdzXHJcbiAqIFhSZWdFeHAubWF0Y2hDaGFpbignMSA8Yj4yPC9iPiAzIDxiPjQgYSA1NjwvYj4nLCBbXHJcbiAqICAgWFJlZ0V4cCgnKD9pcyk8Yj4uKj88L2I+JyksXHJcbiAqICAgL1xcZCsvXHJcbiAqIF0pO1xyXG4gKiAvLyAtPiBbJzInLCAnNCcsICc1NiddXHJcbiAqXHJcbiAqIC8vIFBhc3NpbmcgZm9yd2FyZCBhbmQgcmV0dXJuaW5nIHNwZWNpZmljIGJhY2tyZWZlcmVuY2VzXHJcbiAqIGh0bWwgPSAnPGEgaHJlZj1cImh0dHA6Ly94cmVnZXhwLmNvbS9hcGkvXCI+WFJlZ0V4cDwvYT5cXFxyXG4gKiAgICAgICAgIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmdvb2dsZS5jb20vXCI+R29vZ2xlPC9hPic7XHJcbiAqIFhSZWdFeHAubWF0Y2hDaGFpbihodG1sLCBbXHJcbiAqICAge3JlZ2V4OiAvPGEgaHJlZj1cIihbXlwiXSspXCI+L2ksIGJhY2tyZWY6IDF9LFxyXG4gKiAgIHtyZWdleDogWFJlZ0V4cCgnKD9pKV5odHRwcz86Ly8oPzxkb21haW4+W14vPyNdKyknKSwgYmFja3JlZjogJ2RvbWFpbid9XHJcbiAqIF0pO1xyXG4gKiAvLyAtPiBbJ3hyZWdleHAuY29tJywgJ3d3dy5nb29nbGUuY29tJ11cclxuICovXHJcblhSZWdFeHAubWF0Y2hDaGFpbiA9IGZ1bmN0aW9uKHN0ciwgY2hhaW4pIHtcclxuICAgIHJldHVybiAoZnVuY3Rpb24gcmVjdXJzZUNoYWluKHZhbHVlcywgbGV2ZWwpIHtcclxuICAgICAgICB2YXIgaXRlbSA9IGNoYWluW2xldmVsXS5yZWdleCA/IGNoYWluW2xldmVsXSA6IHtyZWdleDogY2hhaW5bbGV2ZWxdfTtcclxuICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBhZGRNYXRjaChtYXRjaCkge1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5iYWNrcmVmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgNC4wLjUgKGJ1dCBub3QgNS4wLjUrKSBpbmFwcHJvcHJpYXRlbHkgdXNlcyBzcGFyc2UgYXJyYXlzIHRvIGhvbGQgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBgdW5kZWZpbmVkYHMgZm9yIGJhY2tyZWZlcmVuY2VzIHRvIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwcy4gSW4gc3VjaFxyXG4gICAgICAgICAgICAgICAgLy8gY2FzZXMsIGEgYGhhc093blByb3BlcnR5YCBvciBgaW5gIGNoZWNrIG9uIGl0cyBvd24gd291bGQgaW5hcHByb3ByaWF0ZWx5IHRocm93XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZXhjZXB0aW9uLCBzbyBhbHNvIGNoZWNrIGlmIHRoZSBiYWNrcmVmZXJlbmNlIGlzIGEgbnVtYmVyIHRoYXQgaXMgd2l0aGluIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gYm91bmRzIG9mIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgICAgIGlmICghKG1hdGNoLmhhc093blByb3BlcnR5KGl0ZW0uYmFja3JlZikgfHwgK2l0ZW0uYmFja3JlZiA8IG1hdGNoLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0JhY2tyZWZlcmVuY2UgdG8gdW5kZWZpbmVkIGdyb3VwOiAnICsgaXRlbS5iYWNrcmVmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobWF0Y2hbaXRlbS5iYWNrcmVmXSB8fCAnJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobWF0Y2hbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBYUmVnRXhwLmZvckVhY2godmFsdWVzW2ldLCBpdGVtLnJlZ2V4LCBhZGRNYXRjaCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKChsZXZlbCA9PT0gY2hhaW4ubGVuZ3RoIC0gMSkgfHwgIW1hdGNoZXMubGVuZ3RoKSA/XHJcbiAgICAgICAgICAgIG1hdGNoZXMgOlxyXG4gICAgICAgICAgICByZWN1cnNlQ2hhaW4obWF0Y2hlcywgbGV2ZWwgKyAxKTtcclxuICAgIH0oW3N0cl0sIDApKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IHN0cmluZyB3aXRoIG9uZSBvciBhbGwgbWF0Y2hlcyBvZiBhIHBhdHRlcm4gcmVwbGFjZWQuIFRoZSBwYXR0ZXJuIGNhbiBiZSBhIHN0cmluZ1xyXG4gKiBvciByZWdleCwgYW5kIHRoZSByZXBsYWNlbWVudCBjYW4gYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggbWF0Y2guIFRvXHJcbiAqIHBlcmZvcm0gYSBnbG9iYWwgc2VhcmNoIGFuZCByZXBsYWNlLCB1c2UgdGhlIG9wdGlvbmFsIGBzY29wZWAgYXJndW1lbnQgb3IgaW5jbHVkZSBmbGFnIGcgaWYgdXNpbmdcclxuICogYSByZWdleC4gUmVwbGFjZW1lbnQgc3RyaW5ncyBjYW4gdXNlIGAke259YCBmb3IgbmFtZWQgYW5kIG51bWJlcmVkIGJhY2tyZWZlcmVuY2VzLiBSZXBsYWNlbWVudFxyXG4gKiBmdW5jdGlvbnMgY2FuIHVzZSBuYW1lZCBiYWNrcmVmZXJlbmNlcyB2aWEgYGFyZ3VtZW50c1swXS5uYW1lYC4gQWxzbyBmaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWRcclxuICogdG8gdGhlIG5hdGl2ZSBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHkgY3Jvc3MtYnJvd3Nlci5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxyXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlYXJjaCBTZWFyY2ggcGF0dGVybiB0byBiZSByZXBsYWNlZC5cclxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHJlcGxhY2VtZW50IFJlcGxhY2VtZW50IHN0cmluZyBvciBhIGZ1bmN0aW9uIGludm9rZWQgdG8gY3JlYXRlIGl0LlxyXG4gKiAgIFJlcGxhY2VtZW50IHN0cmluZ3MgY2FuIGluY2x1ZGUgc3BlY2lhbCByZXBsYWNlbWVudCBzeW50YXg6XHJcbiAqICAgICA8bGk+JCQgLSBJbnNlcnRzIGEgbGl0ZXJhbCAkIGNoYXJhY3Rlci5cclxuICogICAgIDxsaT4kJiwgJDAgLSBJbnNlcnRzIHRoZSBtYXRjaGVkIHN1YnN0cmluZy5cclxuICogICAgIDxsaT4kYCAtIEluc2VydHMgdGhlIHN0cmluZyB0aGF0IHByZWNlZGVzIHRoZSBtYXRjaGVkIHN1YnN0cmluZyAobGVmdCBjb250ZXh0KS5cclxuICogICAgIDxsaT4kJyAtIEluc2VydHMgdGhlIHN0cmluZyB0aGF0IGZvbGxvd3MgdGhlIG1hdGNoZWQgc3Vic3RyaW5nIChyaWdodCBjb250ZXh0KS5cclxuICogICAgIDxsaT4kbiwgJG5uIC0gV2hlcmUgbi9ubiBhcmUgZGlnaXRzIHJlZmVyZW5jaW5nIGFuIGV4aXN0ZW50IGNhcHR1cmluZyBncm91cCwgaW5zZXJ0c1xyXG4gKiAgICAgICBiYWNrcmVmZXJlbmNlIG4vbm4uXHJcbiAqICAgICA8bGk+JHtufSAtIFdoZXJlIG4gaXMgYSBuYW1lIG9yIGFueSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgcmVmZXJlbmNlIGFuIGV4aXN0ZW50IGNhcHR1cmluZ1xyXG4gKiAgICAgICBncm91cCwgaW5zZXJ0cyBiYWNrcmVmZXJlbmNlIG4uXHJcbiAqICAgUmVwbGFjZW1lbnQgZnVuY3Rpb25zIGFyZSBpbnZva2VkIHdpdGggdGhyZWUgb3IgbW9yZSBhcmd1bWVudHM6XHJcbiAqICAgICA8bGk+VGhlIG1hdGNoZWQgc3Vic3RyaW5nIChjb3JyZXNwb25kcyB0byAkJiBhYm92ZSkuIE5hbWVkIGJhY2tyZWZlcmVuY2VzIGFyZSBhY2Nlc3NpYmxlIGFzXHJcbiAqICAgICAgIHByb3BlcnRpZXMgb2YgdGhpcyBmaXJzdCBhcmd1bWVudC5cclxuICogICAgIDxsaT4wLi5uIGFyZ3VtZW50cywgb25lIGZvciBlYWNoIGJhY2tyZWZlcmVuY2UgKGNvcnJlc3BvbmRpbmcgdG8gJDEsICQyLCBldGMuIGFib3ZlKS5cclxuICogICAgIDxsaT5UaGUgemVyby1iYXNlZCBpbmRleCBvZiB0aGUgbWF0Y2ggd2l0aGluIHRoZSB0b3RhbCBzZWFyY2ggc3RyaW5nLlxyXG4gKiAgICAgPGxpPlRoZSB0b3RhbCBzdHJpbmcgYmVpbmcgc2VhcmNoZWQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2NvcGU9J29uZSddIFVzZSAnb25lJyB0byByZXBsYWNlIHRoZSBmaXJzdCBtYXRjaCBvbmx5LCBvciAnYWxsJy4gSWYgbm90XHJcbiAqICAgZXhwbGljaXRseSBzcGVjaWZpZWQgYW5kIHVzaW5nIGEgcmVnZXggd2l0aCBmbGFnIGcsIGBzY29wZWAgaXMgJ2FsbCcuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IE5ldyBzdHJpbmcgd2l0aCBvbmUgb3IgYWxsIG1hdGNoZXMgcmVwbGFjZWQuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIC8vIFJlZ2V4IHNlYXJjaCwgdXNpbmcgbmFtZWQgYmFja3JlZmVyZW5jZXMgaW4gcmVwbGFjZW1lbnQgc3RyaW5nXHJcbiAqIHZhciBuYW1lID0gWFJlZ0V4cCgnKD88Zmlyc3Q+XFxcXHcrKSAoPzxsYXN0PlxcXFx3KyknKTtcclxuICogWFJlZ0V4cC5yZXBsYWNlKCdKb2huIFNtaXRoJywgbmFtZSwgJyR7bGFzdH0sICR7Zmlyc3R9Jyk7XHJcbiAqIC8vIC0+ICdTbWl0aCwgSm9obidcclxuICpcclxuICogLy8gUmVnZXggc2VhcmNoLCB1c2luZyBuYW1lZCBiYWNrcmVmZXJlbmNlcyBpbiByZXBsYWNlbWVudCBmdW5jdGlvblxyXG4gKiBYUmVnRXhwLnJlcGxhY2UoJ0pvaG4gU21pdGgnLCBuYW1lLCBmdW5jdGlvbihtYXRjaCkge1xyXG4gKiAgIHJldHVybiBtYXRjaC5sYXN0ICsgJywgJyArIG1hdGNoLmZpcnN0O1xyXG4gKiB9KTtcclxuICogLy8gLT4gJ1NtaXRoLCBKb2huJ1xyXG4gKlxyXG4gKiAvLyBTdHJpbmcgc2VhcmNoLCB3aXRoIHJlcGxhY2UtYWxsXHJcbiAqIFhSZWdFeHAucmVwbGFjZSgnUmVnRXhwIGJ1aWxkcyBSZWdFeHBzJywgJ1JlZ0V4cCcsICdYUmVnRXhwJywgJ2FsbCcpO1xyXG4gKiAvLyAtPiAnWFJlZ0V4cCBidWlsZHMgWFJlZ0V4cHMnXHJcbiAqL1xyXG5YUmVnRXhwLnJlcGxhY2UgPSBmdW5jdGlvbihzdHIsIHNlYXJjaCwgcmVwbGFjZW1lbnQsIHNjb3BlKSB7XHJcbiAgICB2YXIgaXNSZWdleCA9IFhSZWdFeHAuaXNSZWdFeHAoc2VhcmNoKSxcclxuICAgICAgICBnbG9iYWwgPSAoc2VhcmNoLmdsb2JhbCAmJiBzY29wZSAhPT0gJ29uZScpIHx8IHNjb3BlID09PSAnYWxsJyxcclxuICAgICAgICBjYWNoZUtleSA9ICgoZ2xvYmFsID8gJ2cnIDogJycpICsgKHNlYXJjaC5zdGlja3kgPyAneScgOiAnJykpIHx8ICdub0dZJyxcclxuICAgICAgICBzMiA9IHNlYXJjaCxcclxuICAgICAgICByZXN1bHQ7XHJcblxyXG4gICAgaWYgKGlzUmVnZXgpIHtcclxuICAgICAgICBzZWFyY2hbUkVHRVhfREFUQV0gPSBzZWFyY2hbUkVHRVhfREFUQV0gfHwge307XHJcblxyXG4gICAgICAgIC8vIFNoYXJlcyBjYWNoZWQgY29waWVzIHdpdGggYFhSZWdFeHAuZXhlY2AvYG1hdGNoYC4gU2luY2UgYSBjb3B5IGlzIHVzZWQsIGBzZWFyY2hgJ3NcclxuICAgICAgICAvLyBgbGFzdEluZGV4YCBpc24ndCB1cGRhdGVkICpkdXJpbmcqIHJlcGxhY2VtZW50IGl0ZXJhdGlvbnNcclxuICAgICAgICBzMiA9IHNlYXJjaFtSRUdFWF9EQVRBXVtjYWNoZUtleV0gfHwgKFxyXG4gICAgICAgICAgICBzZWFyY2hbUkVHRVhfREFUQV1bY2FjaGVLZXldID0gY29weVJlZ2V4KHNlYXJjaCwge1xyXG4gICAgICAgICAgICAgICAgYWRkRzogISFnbG9iYWwsXHJcbiAgICAgICAgICAgICAgICByZW1vdmVHOiBzY29wZSA9PT0gJ29uZScsXHJcbiAgICAgICAgICAgICAgICBpc0ludGVybmFsT25seTogdHJ1ZVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICB9IGVsc2UgaWYgKGdsb2JhbCkge1xyXG4gICAgICAgIHMyID0gbmV3IFJlZ0V4cChYUmVnRXhwLmVzY2FwZShTdHJpbmcoc2VhcmNoKSksICdnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRml4ZWQgYHJlcGxhY2VgIHJlcXVpcmVkIGZvciBuYW1lZCBiYWNrcmVmZXJlbmNlcywgZXRjLlxyXG4gICAgcmVzdWx0ID0gZml4ZWQucmVwbGFjZS5jYWxsKHRvT2JqZWN0KHN0ciksIHMyLCByZXBsYWNlbWVudCk7XHJcblxyXG4gICAgaWYgKGlzUmVnZXggJiYgc2VhcmNoLmdsb2JhbCkge1xyXG4gICAgICAgIC8vIEZpeGVzIElFLCBTYWZhcmkgYnVnIChsYXN0IHRlc3RlZCBJRSA5LCBTYWZhcmkgNS4xKVxyXG4gICAgICAgIHNlYXJjaC5sYXN0SW5kZXggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUGVyZm9ybXMgYmF0Y2ggcHJvY2Vzc2luZyBvZiBzdHJpbmcgcmVwbGFjZW1lbnRzLiBVc2VkIGxpa2UgYFhSZWdFeHAucmVwbGFjZWAsIGJ1dCBhY2NlcHRzIGFuXHJcbiAqIGFycmF5IG9mIHJlcGxhY2VtZW50IGRldGFpbHMuIExhdGVyIHJlcGxhY2VtZW50cyBvcGVyYXRlIG9uIHRoZSBvdXRwdXQgb2YgZWFybGllciByZXBsYWNlbWVudHMuXHJcbiAqIFJlcGxhY2VtZW50IGRldGFpbHMgYXJlIGFjY2VwdGVkIGFzIGFuIGFycmF5IHdpdGggYSByZWdleCBvciBzdHJpbmcgdG8gc2VhcmNoIGZvciwgdGhlXHJcbiAqIHJlcGxhY2VtZW50IHN0cmluZyBvciBmdW5jdGlvbiwgYW5kIGFuIG9wdGlvbmFsIHNjb3BlIG9mICdvbmUnIG9yICdhbGwnLiBVc2VzIHRoZSBYUmVnRXhwXHJcbiAqIHJlcGxhY2VtZW50IHRleHQgc3ludGF4LCB3aGljaCBzdXBwb3J0cyBuYW1lZCBiYWNrcmVmZXJlbmNlIHByb3BlcnRpZXMgdmlhIGAke25hbWV9YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc2VhcmNoLlxyXG4gKiBAcGFyYW0ge0FycmF5fSByZXBsYWNlbWVudHMgQXJyYXkgb2YgcmVwbGFjZW1lbnQgZGV0YWlsIGFycmF5cy5cclxuICogQHJldHVybnMge1N0cmluZ30gTmV3IHN0cmluZyB3aXRoIGFsbCByZXBsYWNlbWVudHMuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIHN0ciA9IFhSZWdFeHAucmVwbGFjZUVhY2goc3RyLCBbXHJcbiAqICAgW1hSZWdFeHAoJyg/PG5hbWU+YSknKSwgJ3oke25hbWV9J10sXHJcbiAqICAgWy9iL2dpLCAneSddLFxyXG4gKiAgIFsvYy9nLCAneCcsICdvbmUnXSwgLy8gc2NvcGUgJ29uZScgb3ZlcnJpZGVzIC9nXHJcbiAqICAgWy9kLywgJ3cnLCAnYWxsJ10sICAvLyBzY29wZSAnYWxsJyBvdmVycmlkZXMgbGFjayBvZiAvZ1xyXG4gKiAgIFsnZScsICd2JywgJ2FsbCddLCAgLy8gc2NvcGUgJ2FsbCcgYWxsb3dzIHJlcGxhY2UtYWxsIGZvciBzdHJpbmdzXHJcbiAqICAgWy9mL2csIGZ1bmN0aW9uKCQwKSB7XHJcbiAqICAgICByZXR1cm4gJDAudG9VcHBlckNhc2UoKTtcclxuICogICB9XVxyXG4gKiBdKTtcclxuICovXHJcblhSZWdFeHAucmVwbGFjZUVhY2ggPSBmdW5jdGlvbihzdHIsIHJlcGxhY2VtZW50cykge1xyXG4gICAgdmFyIGksIHI7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHJlcGxhY2VtZW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHIgPSByZXBsYWNlbWVudHNbaV07XHJcbiAgICAgICAgc3RyID0gWFJlZ0V4cC5yZXBsYWNlKHN0ciwgclswXSwgclsxXSwgclsyXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGEgcmVnZXggb3Igc3RyaW5nIHNlcGFyYXRvci4gTWF0Y2hlcyBvZiB0aGVcclxuICogc2VwYXJhdG9yIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBhcnJheS4gSG93ZXZlciwgaWYgYHNlcGFyYXRvcmAgaXMgYSByZWdleCB0aGF0IGNvbnRhaW5zXHJcbiAqIGNhcHR1cmluZyBncm91cHMsIGJhY2tyZWZlcmVuY2VzIGFyZSBzcGxpY2VkIGludG8gdGhlIHJlc3VsdCBlYWNoIHRpbWUgYHNlcGFyYXRvcmAgaXMgbWF0Y2hlZC5cclxuICogRml4ZXMgYnJvd3NlciBidWdzIGNvbXBhcmVkIHRvIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIGFuZCBjYW4gYmUgdXNlZCByZWxpYWJseVxyXG4gKiBjcm9zcy1icm93c2VyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzcGxpdC5cclxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBzZXBhcmF0b3IgUmVnZXggb3Igc3RyaW5nIHRvIHVzZSBmb3Igc2VwYXJhdGluZyB0aGUgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Ygc3Vic3RyaW5ncy5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gQmFzaWMgdXNlXHJcbiAqIFhSZWdFeHAuc3BsaXQoJ2EgYiBjJywgJyAnKTtcclxuICogLy8gLT4gWydhJywgJ2InLCAnYyddXHJcbiAqXHJcbiAqIC8vIFdpdGggbGltaXRcclxuICogWFJlZ0V4cC5zcGxpdCgnYSBiIGMnLCAnICcsIDIpO1xyXG4gKiAvLyAtPiBbJ2EnLCAnYiddXHJcbiAqXHJcbiAqIC8vIEJhY2tyZWZlcmVuY2VzIGluIHJlc3VsdCBhcnJheVxyXG4gKiBYUmVnRXhwLnNwbGl0KCcuLndvcmQxLi4nLCAvKFthLXpdKykoXFxkKykvaSk7XHJcbiAqIC8vIC0+IFsnLi4nLCAnd29yZCcsICcxJywgJy4uJ11cclxuICovXHJcblhSZWdFeHAuc3BsaXQgPSBmdW5jdGlvbihzdHIsIHNlcGFyYXRvciwgbGltaXQpIHtcclxuICAgIHJldHVybiBmaXhlZC5zcGxpdC5jYWxsKHRvT2JqZWN0KHN0ciksIHNlcGFyYXRvciwgbGltaXQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4ZWN1dGVzIGEgcmVnZXggc2VhcmNoIGluIGEgc3BlY2lmaWVkIHN0cmluZy4gUmV0dXJucyBgdHJ1ZWAgb3IgYGZhbHNlYC4gT3B0aW9uYWwgYHBvc2AgYW5kXHJcbiAqIGBzdGlja3lgIGFyZ3VtZW50cyBzcGVjaWZ5IHRoZSBzZWFyY2ggc3RhcnQgcG9zaXRpb24sIGFuZCB3aGV0aGVyIHRoZSBtYXRjaCBtdXN0IHN0YXJ0IGF0IHRoZVxyXG4gKiBzcGVjaWZpZWQgcG9zaXRpb24gb25seS4gVGhlIGBsYXN0SW5kZXhgIHByb3BlcnR5IG9mIHRoZSBwcm92aWRlZCByZWdleCBpcyBub3QgdXNlZCwgYnV0IGlzXHJcbiAqIHVwZGF0ZWQgZm9yIGNvbXBhdGliaWxpdHkuIEFsc28gZml4ZXMgYnJvd3NlciBidWdzIGNvbXBhcmVkIHRvIHRoZSBuYXRpdmVcclxuICogYFJlZ0V4cC5wcm90b3R5cGUudGVzdGAgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5IGNyb3NzLWJyb3dzZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cclxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4IFJlZ2V4IHRvIHNlYXJjaCB3aXRoLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3Bvcz0wXSBaZXJvLWJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IHRoZSBzZWFyY2guXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtzdGlja3k9ZmFsc2VdIFdoZXRoZXIgdGhlIG1hdGNoIG11c3Qgc3RhcnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG4gKiAgIG9ubHkuIFRoZSBzdHJpbmcgYCdzdGlja3knYCBpcyBhY2NlcHRlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBgdHJ1ZWAuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSByZWdleCBtYXRjaGVkIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gQmFzaWMgdXNlXHJcbiAqIFhSZWdFeHAudGVzdCgnYWJjJywgL2MvKTsgLy8gLT4gdHJ1ZVxyXG4gKlxyXG4gKiAvLyBXaXRoIHBvcyBhbmQgc3RpY2t5XHJcbiAqIFhSZWdFeHAudGVzdCgnYWJjJywgL2MvLCAwLCAnc3RpY2t5Jyk7IC8vIC0+IGZhbHNlXHJcbiAqIFhSZWdFeHAudGVzdCgnYWJjJywgL2MvLCAyLCAnc3RpY2t5Jyk7IC8vIC0+IHRydWVcclxuICovXHJcblhSZWdFeHAudGVzdCA9IGZ1bmN0aW9uKHN0ciwgcmVnZXgsIHBvcywgc3RpY2t5KSB7XHJcbiAgICAvLyBEbyB0aGlzIHRoZSBlYXN5IHdheSA6LSlcclxuICAgIHJldHVybiAhIVhSZWdFeHAuZXhlYyhzdHIsIHJlZ2V4LCBwb3MsIHN0aWNreSk7XHJcbn07XHJcblxyXG4vKipcclxuICogVW5pbnN0YWxscyBvcHRpb25hbCBmZWF0dXJlcyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBvcHRpb25zLiBBbGwgb3B0aW9uYWwgZmVhdHVyZXMgc3RhcnQgb3V0XHJcbiAqIHVuaW5zdGFsbGVkLCBzbyB0aGlzIGlzIHVzZWQgdG8gdW5kbyB0aGUgYWN0aW9ucyBvZiBgWFJlZ0V4cC5pbnN0YWxsYC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0IG9yIHN0cmluZy5cclxuICogQGV4YW1wbGVcclxuICpcclxuICogLy8gV2l0aCBhbiBvcHRpb25zIG9iamVjdFxyXG4gKiBYUmVnRXhwLnVuaW5zdGFsbCh7XHJcbiAqICAgLy8gRGlzYWJsZXMgc3VwcG9ydCBmb3IgYXN0cmFsIGNvZGUgcG9pbnRzIGluIFVuaWNvZGUgYWRkb25zXHJcbiAqICAgYXN0cmFsOiB0cnVlLFxyXG4gKlxyXG4gKiAgIC8vIERFUFJFQ0FURUQ6IFJlc3RvcmVzIG5hdGl2ZSByZWdleCBtZXRob2RzXHJcbiAqICAgbmF0aXZlczogdHJ1ZVxyXG4gKiB9KTtcclxuICpcclxuICogLy8gV2l0aCBhbiBvcHRpb25zIHN0cmluZ1xyXG4gKiBYUmVnRXhwLnVuaW5zdGFsbCgnYXN0cmFsIG5hdGl2ZXMnKTtcclxuICovXHJcblhSZWdFeHAudW5pbnN0YWxsID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IHByZXBhcmVPcHRpb25zKG9wdGlvbnMpO1xyXG5cclxuICAgIGlmIChmZWF0dXJlcy5hc3RyYWwgJiYgb3B0aW9ucy5hc3RyYWwpIHtcclxuICAgICAgICBzZXRBc3RyYWwoZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChmZWF0dXJlcy5uYXRpdmVzICYmIG9wdGlvbnMubmF0aXZlcykge1xyXG4gICAgICAgIHNldE5hdGl2ZXMoZmFsc2UpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gWFJlZ0V4cCBvYmplY3QgdGhhdCBpcyB0aGUgdW5pb24gb2YgdGhlIGdpdmVuIHBhdHRlcm5zLiBQYXR0ZXJucyBjYW4gYmUgcHJvdmlkZWQgYXNcclxuICogcmVnZXggb2JqZWN0cyBvciBzdHJpbmdzLiBNZXRhY2hhcmFjdGVycyBhcmUgZXNjYXBlZCBpbiBwYXR0ZXJucyBwcm92aWRlZCBhcyBzdHJpbmdzLlxyXG4gKiBCYWNrcmVmZXJlbmNlcyBpbiBwcm92aWRlZCByZWdleCBvYmplY3RzIGFyZSBhdXRvbWF0aWNhbGx5IHJlbnVtYmVyZWQgdG8gd29yayBjb3JyZWN0bHkgd2l0aGluXHJcbiAqIHRoZSBsYXJnZXIgY29tYmluZWQgcGF0dGVybi4gTmF0aXZlIGZsYWdzIHVzZWQgYnkgcHJvdmlkZWQgcmVnZXhlcyBhcmUgaWdub3JlZCBpbiBmYXZvciBvZiB0aGVcclxuICogYGZsYWdzYCBhcmd1bWVudC5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gcGF0dGVybnMgUmVnZXhlcyBhbmQgc3RyaW5ncyB0byBjb21iaW5lLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZsYWdzXSBBbnkgY29tYmluYXRpb24gb2YgWFJlZ0V4cCBmbGFncy5cclxuICogQHJldHVybnMge1JlZ0V4cH0gVW5pb24gb2YgdGhlIHByb3ZpZGVkIHJlZ2V4ZXMgYW5kIHN0cmluZ3MuXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIFhSZWdFeHAudW5pb24oWydhK2IqYycsIC8oZG9ncylcXDEvLCAvKGNhdHMpXFwxL10sICdpJyk7XHJcbiAqIC8vIC0+IC9hXFwrYlxcKmN8KGRvZ3MpXFwxfChjYXRzKVxcMi9pXHJcbiAqL1xyXG5YUmVnRXhwLnVuaW9uID0gZnVuY3Rpb24ocGF0dGVybnMsIGZsYWdzKSB7XHJcbiAgICB2YXIgbnVtQ2FwdHVyZXMgPSAwO1xyXG4gICAgdmFyIG51bVByaW9yQ2FwdHVyZXM7XHJcbiAgICB2YXIgY2FwdHVyZU5hbWVzO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJld3JpdGUobWF0Y2gsIHBhcmVuLCBiYWNrcmVmKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBjYXB0dXJlTmFtZXNbbnVtQ2FwdHVyZXMgLSBudW1QcmlvckNhcHR1cmVzXTtcclxuXHJcbiAgICAgICAgLy8gQ2FwdHVyaW5nIGdyb3VwXHJcbiAgICAgICAgaWYgKHBhcmVuKSB7XHJcbiAgICAgICAgICAgICsrbnVtQ2FwdHVyZXM7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNhcHR1cmUgaGFzIGEgbmFtZSwgcHJlc2VydmUgdGhlIG5hbWVcclxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnKD88JyArIG5hbWUgKyAnPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAvLyBCYWNrcmVmZXJlbmNlXHJcbiAgICAgICAgfSBlbHNlIGlmIChiYWNrcmVmKSB7XHJcbiAgICAgICAgICAgIC8vIFJld3JpdGUgdGhlIGJhY2tyZWZlcmVuY2VcclxuICAgICAgICAgICAgcmV0dXJuICdcXFxcJyArICgrYmFja3JlZiArIG51bVByaW9yQ2FwdHVyZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKGlzVHlwZShwYXR0ZXJucywgJ0FycmF5JykgJiYgcGF0dGVybnMubGVuZ3RoKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIG5vbmVtcHR5IGFycmF5IG9mIHBhdHRlcm5zIHRvIG1lcmdlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBhcnRzID0gLyhcXCgpKD8hXFw/KXxcXFxcKFsxLTldXFxkKil8XFxcXFtcXHNcXFNdfFxcWyg/OlteXFxcXFxcXV18XFxcXFtcXHNcXFNdKSpdL2c7XHJcbiAgICB2YXIgb3V0cHV0ID0gW107XHJcbiAgICB2YXIgcGF0dGVybjtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybnNbaV07XHJcblxyXG4gICAgICAgIGlmIChYUmVnRXhwLmlzUmVnRXhwKHBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgIG51bVByaW9yQ2FwdHVyZXMgPSBudW1DYXB0dXJlcztcclxuICAgICAgICAgICAgY2FwdHVyZU5hbWVzID0gKHBhdHRlcm5bUkVHRVhfREFUQV0gJiYgcGF0dGVybltSRUdFWF9EQVRBXS5jYXB0dXJlTmFtZXMpIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV3cml0ZSBiYWNrcmVmZXJlbmNlcy4gUGFzc2luZyB0byBYUmVnRXhwIGRpZXMgb24gb2N0YWxzIGFuZCBlbnN1cmVzIHBhdHRlcm5zIGFyZVxyXG4gICAgICAgICAgICAvLyBpbmRlcGVuZGVudGx5IHZhbGlkOyBoZWxwcyBrZWVwIHRoaXMgc2ltcGxlLiBOYW1lZCBjYXB0dXJlcyBhcmUgcHV0IGJhY2tcclxuICAgICAgICAgICAgb3V0cHV0LnB1c2gobmF0aXYucmVwbGFjZS5jYWxsKFhSZWdFeHAocGF0dGVybi5zb3VyY2UpLnNvdXJjZSwgcGFydHMsIHJld3JpdGUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChYUmVnRXhwLmVzY2FwZShwYXR0ZXJuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBYUmVnRXhwKG91dHB1dC5qb2luKCd8JyksIGZsYWdzKTtcclxufTtcclxuXHJcbi8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG4vLyBGaXhlZC9leHRlbmRlZCBuYXRpdmUgbWV0aG9kc1xyXG4vLyA9PS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPT1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIG5hbWVkIGNhcHR1cmUgc3VwcG9ydCAod2l0aCBiYWNrcmVmZXJlbmNlcyByZXR1cm5lZCBhcyBgcmVzdWx0Lm5hbWVgKSwgYW5kIGZpeGVzIGJyb3dzZXJcclxuICogYnVncyBpbiB0aGUgbmF0aXZlIGBSZWdFeHAucHJvdG90eXBlLmV4ZWNgLiBDYWxsaW5nIGBYUmVnRXhwLmluc3RhbGwoJ25hdGl2ZXMnKWAgdXNlcyB0aGlzIHRvXHJcbiAqIG92ZXJyaWRlIHRoZSBuYXRpdmUgbWV0aG9kLiBVc2UgdmlhIGBYUmVnRXhwLmV4ZWNgIHdpdGhvdXQgb3ZlcnJpZGluZyBuYXRpdmVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzZWFyY2guXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gTWF0Y2ggYXJyYXkgd2l0aCBuYW1lZCBiYWNrcmVmZXJlbmNlIHByb3BlcnRpZXMsIG9yIGBudWxsYC5cclxuICovXHJcbmZpeGVkLmV4ZWMgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgIHZhciBvcmlnTGFzdEluZGV4ID0gdGhpcy5sYXN0SW5kZXgsXHJcbiAgICAgICAgbWF0Y2ggPSBuYXRpdi5leGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICByMixcclxuICAgICAgICBpO1xyXG5cclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nXHJcbiAgICAgICAgLy8gZ3JvdXBzLiBUaGlzIGZpeGVzIElFIDUuNS04LCBidXQgbm90IElFIDkncyBxdWlya3MgbW9kZSBvciBlbXVsYXRpb24gb2Ygb2xkZXIgSUVzLiBJRSA5XHJcbiAgICAgICAgLy8gaW4gc3RhbmRhcmRzIG1vZGUgZm9sbG93cyB0aGUgc3BlYy5cclxuICAgICAgICBpZiAoIWNvcnJlY3RFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxICYmIGluZGV4T2YobWF0Y2gsICcnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHIyID0gY29weVJlZ2V4KHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUc6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBpc0ludGVybmFsT25seTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gVXNpbmcgYHN0ci5zbGljZShtYXRjaC5pbmRleClgIHJhdGhlciB0aGFuIGBtYXRjaFswXWAgaW4gY2FzZSBsb29rYWhlYWQgYWxsb3dlZFxyXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBkdWUgdG8gY2hhcmFjdGVycyBvdXRzaWRlIHRoZSBtYXRjaFxyXG4gICAgICAgICAgICBuYXRpdi5yZXBsYWNlLmNhbGwoU3RyaW5nKHN0cikuc2xpY2UobWF0Y2guaW5kZXgpLCByMiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaTtcclxuICAgICAgICAgICAgICAgIC8vIFNraXAgaW5kZXggMCBhbmQgdGhlIGxhc3QgMlxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbiAtIDI7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXR0YWNoIG5hbWVkIGNhcHR1cmUgcHJvcGVydGllc1xyXG4gICAgICAgIGlmICh0aGlzW1JFR0VYX0RBVEFdICYmIHRoaXNbUkVHRVhfREFUQV0uY2FwdHVyZU5hbWVzKSB7XHJcbiAgICAgICAgICAgIC8vIFNraXAgaW5kZXggMFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbWF0Y2gubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzW1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lc1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoW25hbWVdID0gbWF0Y2hbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZpeCBicm93c2VycyB0aGF0IGluY3JlbWVudCBgbGFzdEluZGV4YCBhZnRlciB6ZXJvLWxlbmd0aCBtYXRjaGVzXHJcbiAgICAgICAgaWYgKHRoaXMuZ2xvYmFsICYmICFtYXRjaFswXS5sZW5ndGggJiYgKHRoaXMubGFzdEluZGV4ID4gbWF0Y2guaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEluZGV4ID0gbWF0Y2guaW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5nbG9iYWwpIHtcclxuICAgICAgICAvLyBGaXhlcyBJRSwgT3BlcmEgYnVnIChsYXN0IHRlc3RlZCBJRSA5LCBPcGVyYSAxMS42KVxyXG4gICAgICAgIHRoaXMubGFzdEluZGV4ID0gb3JpZ0xhc3RJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWF0Y2g7XHJcbn07XHJcblxyXG4vKipcclxuICogRml4ZXMgYnJvd3NlciBidWdzIGluIHRoZSBuYXRpdmUgYFJlZ0V4cC5wcm90b3R5cGUudGVzdGAuIENhbGxpbmcgYFhSZWdFeHAuaW5zdGFsbCgnbmF0aXZlcycpYFxyXG4gKiB1c2VzIHRoaXMgdG8gb3ZlcnJpZGUgdGhlIG5hdGl2ZSBtZXRob2QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNlYXJjaC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlZ2V4IG1hdGNoZWQgdGhlIHByb3ZpZGVkIHZhbHVlLlxyXG4gKi9cclxuZml4ZWQudGVzdCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgLy8gRG8gdGhpcyB0aGUgZWFzeSB3YXkgOi0pXHJcbiAgICByZXR1cm4gISFmaXhlZC5leGVjLmNhbGwodGhpcywgc3RyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIG5hbWVkIGNhcHR1cmUgc3VwcG9ydCAod2l0aCBiYWNrcmVmZXJlbmNlcyByZXR1cm5lZCBhcyBgcmVzdWx0Lm5hbWVgKSwgYW5kIGZpeGVzIGJyb3dzZXJcclxuICogYnVncyBpbiB0aGUgbmF0aXZlIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoYC4gQ2FsbGluZyBgWFJlZ0V4cC5pbnN0YWxsKCduYXRpdmVzJylgIHVzZXMgdGhpcyB0b1xyXG4gKiBvdmVycmlkZSB0aGUgbmF0aXZlIG1ldGhvZC5cclxuICpcclxuICogQHBhcmFtIHtSZWdFeHB8Kn0gcmVnZXggUmVnZXggdG8gc2VhcmNoIHdpdGguIElmIG5vdCBhIHJlZ2V4IG9iamVjdCwgaXQgaXMgcGFzc2VkIHRvIGBSZWdFeHBgLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IElmIGByZWdleGAgdXNlcyBmbGFnIGcsIGFuIGFycmF5IG9mIG1hdGNoIHN0cmluZ3Mgb3IgYG51bGxgLiBXaXRob3V0IGZsYWcgZyxcclxuICogICB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYHJlZ2V4LmV4ZWModGhpcylgLlxyXG4gKi9cclxuZml4ZWQubWF0Y2ggPSBmdW5jdGlvbihyZWdleCkge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICBpZiAoIVhSZWdFeHAuaXNSZWdFeHAocmVnZXgpKSB7XHJcbiAgICAgICAgLy8gVXNlIHRoZSBuYXRpdmUgYFJlZ0V4cGAgcmF0aGVyIHRoYW4gYFhSZWdFeHBgXHJcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4KTtcclxuICAgIH0gZWxzZSBpZiAocmVnZXguZ2xvYmFsKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gbmF0aXYubWF0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAvLyBGaXhlcyBJRSBidWdcclxuICAgICAgICByZWdleC5sYXN0SW5kZXggPSAwO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmaXhlZC5leGVjLmNhbGwocmVnZXgsIHRvT2JqZWN0KHRoaXMpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIHN1cHBvcnQgZm9yIGAke259YCB0b2tlbnMgZm9yIG5hbWVkIGFuZCBudW1iZXJlZCBiYWNrcmVmZXJlbmNlcyBpbiByZXBsYWNlbWVudCB0ZXh0LCBhbmRcclxuICogcHJvdmlkZXMgbmFtZWQgYmFja3JlZmVyZW5jZXMgdG8gcmVwbGFjZW1lbnQgZnVuY3Rpb25zIGFzIGBhcmd1bWVudHNbMF0ubmFtZWAuIEFsc28gZml4ZXMgYnJvd3NlclxyXG4gKiBidWdzIGluIHJlcGxhY2VtZW50IHRleHQgc3ludGF4IHdoZW4gcGVyZm9ybWluZyBhIHJlcGxhY2VtZW50IHVzaW5nIGEgbm9ucmVnZXggc2VhcmNoIHZhbHVlLCBhbmRcclxuICogdGhlIHZhbHVlIG9mIGEgcmVwbGFjZW1lbnQgcmVnZXgncyBgbGFzdEluZGV4YCBwcm9wZXJ0eSBkdXJpbmcgcmVwbGFjZW1lbnQgaXRlcmF0aW9ucyBhbmQgdXBvblxyXG4gKiBjb21wbGV0aW9uLiBDYWxsaW5nIGBYUmVnRXhwLmluc3RhbGwoJ25hdGl2ZXMnKWAgdXNlcyB0aGlzIHRvIG92ZXJyaWRlIHRoZSBuYXRpdmUgbWV0aG9kLiBOb3RlXHJcbiAqIHRoYXQgdGhpcyBkb2Vzbid0IHN1cHBvcnQgU3BpZGVyTW9ua2V5J3MgcHJvcHJpZXRhcnkgdGhpcmQgKGBmbGFnc2ApIGFyZ3VtZW50LiBVc2UgdmlhXHJcbiAqIGBYUmVnRXhwLnJlcGxhY2VgIHdpdGhvdXQgb3ZlcnJpZGluZyBuYXRpdmVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlYXJjaCBTZWFyY2ggcGF0dGVybiB0byBiZSByZXBsYWNlZC5cclxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHJlcGxhY2VtZW50IFJlcGxhY2VtZW50IHN0cmluZyBvciBhIGZ1bmN0aW9uIGludm9rZWQgdG8gY3JlYXRlIGl0LlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBOZXcgc3RyaW5nIHdpdGggb25lIG9yIGFsbCBtYXRjaGVzIHJlcGxhY2VkLlxyXG4gKi9cclxuZml4ZWQucmVwbGFjZSA9IGZ1bmN0aW9uKHNlYXJjaCwgcmVwbGFjZW1lbnQpIHtcclxuICAgIHZhciBpc1JlZ2V4ID0gWFJlZ0V4cC5pc1JlZ0V4cChzZWFyY2gpLFxyXG4gICAgICAgIG9yaWdMYXN0SW5kZXgsXHJcbiAgICAgICAgY2FwdHVyZU5hbWVzLFxyXG4gICAgICAgIHJlc3VsdDtcclxuXHJcbiAgICBpZiAoaXNSZWdleCkge1xyXG4gICAgICAgIGlmIChzZWFyY2hbUkVHRVhfREFUQV0pIHtcclxuICAgICAgICAgICAgY2FwdHVyZU5hbWVzID0gc2VhcmNoW1JFR0VYX0RBVEFdLmNhcHR1cmVOYW1lcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT25seSBuZWVkZWQgaWYgYHNlYXJjaGAgaXMgbm9uZ2xvYmFsXHJcbiAgICAgICAgb3JpZ0xhc3RJbmRleCA9IHNlYXJjaC5sYXN0SW5kZXg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlYXJjaCArPSAnJzsgLy8gVHlwZS1jb252ZXJ0XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG9uJ3QgdXNlIGB0eXBlb2ZgOyBzb21lIG9sZGVyIGJyb3dzZXJzIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleCBvYmplY3RzXHJcbiAgICBpZiAoaXNUeXBlKHJlcGxhY2VtZW50LCAnRnVuY3Rpb24nKSkge1xyXG4gICAgICAgIC8vIFN0cmluZ2lmeWluZyBgdGhpc2AgZml4ZXMgYSBidWcgaW4gSUUgPCA5IHdoZXJlIHRoZSBsYXN0IGFyZ3VtZW50IGluIHJlcGxhY2VtZW50XHJcbiAgICAgICAgLy8gZnVuY3Rpb25zIGlzbid0IHR5cGUtY29udmVydGVkIHRvIGEgc3RyaW5nXHJcbiAgICAgICAgcmVzdWx0ID0gbmF0aXYucmVwbGFjZS5jYWxsKFN0cmluZyh0aGlzKSwgc2VhcmNoLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIGk7XHJcbiAgICAgICAgICAgIGlmIChjYXB0dXJlTmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgYGFyZ3VtZW50c1swXWAgc3RyaW5nIHByaW1pdGl2ZSB0byBhIGBTdHJpbmdgIG9iamVjdCB0aGF0IGNhbiBzdG9yZVxyXG4gICAgICAgICAgICAgICAgLy8gcHJvcGVydGllcy4gVGhpcyByZWFsbHkgZG9lcyBuZWVkIHRvIHVzZSBgU3RyaW5nYCBhcyBhIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gbmV3IFN0cmluZyhhcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIG5hbWVkIGJhY2tyZWZlcmVuY2VzIG9uIHRoZSBmaXJzdCBhcmd1bWVudFxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNhcHR1cmVOYW1lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlTmFtZXNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1swXVtjYXB0dXJlTmFtZXNbaV1dID0gYXJnc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgY2FsbGluZyBgcmVwbGFjZW1lbnRgLiBGaXhlcyBJRSwgQ2hyb21lLCBGaXJlZm94LCBTYWZhcmlcclxuICAgICAgICAgICAgLy8gYnVnIChsYXN0IHRlc3RlZCBJRSA5LCBDaHJvbWUgMTcsIEZpcmVmb3ggMTEsIFNhZmFyaSA1LjEpXHJcbiAgICAgICAgICAgIGlmIChpc1JlZ2V4ICYmIHNlYXJjaC5nbG9iYWwpIHtcclxuICAgICAgICAgICAgICAgIHNlYXJjaC5sYXN0SW5kZXggPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMl0gKyBhcmdzWzBdLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBFUzYgc3BlY3MgdGhlIGNvbnRleHQgZm9yIHJlcGxhY2VtZW50IGZ1bmN0aW9ucyBhcyBgdW5kZWZpbmVkYFxyXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGxhc3QgdmFsdWUgb2YgYGFyZ3NgIHdpbGwgYmUgYSBzdHJpbmcgd2hlbiBnaXZlbiBub25zdHJpbmcgYHRoaXNgLFxyXG4gICAgICAgIC8vIHdoaWxlIHN0aWxsIHRocm93aW5nIG9uIG51bGwgb3IgdW5kZWZpbmVkIGNvbnRleHRcclxuICAgICAgICByZXN1bHQgPSBuYXRpdi5yZXBsYWNlLmNhbGwodGhpcyA9PSBudWxsID8gdGhpcyA6IFN0cmluZyh0aGlzKSwgc2VhcmNoLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gS2VlcCB0aGlzIGZ1bmN0aW9uJ3MgYGFyZ3VtZW50c2AgYXZhaWxhYmxlIHRocm91Z2ggY2xvc3VyZVxyXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgcmV0dXJuIG5hdGl2LnJlcGxhY2UuY2FsbChTdHJpbmcocmVwbGFjZW1lbnQpLCByZXBsYWNlbWVudFRva2VuLCBmdW5jdGlvbigkMCwgJDEsICQyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbjtcclxuICAgICAgICAgICAgICAgIC8vIE5hbWVkIG9yIG51bWJlcmVkIGJhY2tyZWZlcmVuY2Ugd2l0aCBjdXJseSBicmFjZXNcclxuICAgICAgICAgICAgICAgIGlmICgkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFhSZWdFeHAgYmVoYXZpb3IgZm9yIGAke259YDpcclxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBCYWNrcmVmZXJlbmNlIHRvIG51bWJlcmVkIGNhcHR1cmUsIGlmIGBuYCBpcyBhbiBpbnRlZ2VyLiBVc2UgYDBgIGZvciB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICBlbnRpcmUgbWF0Y2guIEFueSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBtYXkgYmUgdXNlZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyAyLiBCYWNrcmVmZXJlbmNlIHRvIG5hbWVkIGNhcHR1cmUgYG5gLCBpZiBpdCBleGlzdHMgYW5kIGlzIG5vdCBhbiBpbnRlZ2VyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgb3ZlcnJpZGRlbiBieSBudW1iZXJlZCBjYXB0dXJlLiBJbiBwcmFjdGljZSwgdGhpcyBkb2VzIG5vdCBvdmVybGFwIHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICBudW1iZXJlZCBjYXB0dXJlIHNpbmNlIFhSZWdFeHAgZG9lcyBub3QgYWxsb3cgbmFtZWQgY2FwdHVyZSB0byB1c2UgYSBiYXJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgaW50ZWdlciBhcyB0aGUgbmFtZS5cclxuICAgICAgICAgICAgICAgICAgICAvLyAzLiBJZiB0aGUgbmFtZSBvciBudW1iZXIgZG9lcyBub3QgcmVmZXIgdG8gYW4gZXhpc3RpbmcgY2FwdHVyaW5nIGdyb3VwLCBpdCdzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgYW4gZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9ICskMTsgLy8gVHlwZS1jb252ZXJ0OyBkcm9wIGxlYWRpbmcgemVyb3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAobiA8PSBhcmdzLmxlbmd0aCAtIDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3Nbbl0gfHwgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdyb3VwcyB3aXRoIHRoZSBzYW1lIG5hbWUgaXMgYW4gZXJyb3IsIGVsc2Ugd291bGQgbmVlZCBgbGFzdEluZGV4T2ZgXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IGNhcHR1cmVOYW1lcyA/IGluZGV4T2YoY2FwdHVyZU5hbWVzLCAkMSkgOiAtMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobiA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdCYWNrcmVmZXJlbmNlIHRvIHVuZGVmaW5lZCBncm91cCAnICsgJDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tuICsgMV0gfHwgJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBFbHNlLCBzcGVjaWFsIHZhcmlhYmxlIG9yIG51bWJlcmVkIGJhY2tyZWZlcmVuY2Ugd2l0aG91dCBjdXJseSBicmFjZXNcclxuICAgICAgICAgICAgICAgIGlmICgkMiA9PT0gJyQnKSB7IC8vICQkXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgkMiA9PT0gJyYnIHx8ICskMiA9PT0gMCkgeyAvLyAkJiwgJDAgKG5vdCBmb2xsb3dlZCBieSAxLTkpLCAkMDBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgkMiA9PT0gJ2AnKSB7IC8vICRgIChsZWZ0IGNvbnRleHQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbYXJncy5sZW5ndGggLSAxXS5zbGljZSgwLCBhcmdzW2FyZ3MubGVuZ3RoIC0gMl0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCQyID09PSBcIidcIikgeyAvLyAkJyAocmlnaHQgY29udGV4dClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1thcmdzLmxlbmd0aCAtIDFdLnNsaWNlKGFyZ3NbYXJncy5sZW5ndGggLSAyXSArIGFyZ3NbMF0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEVsc2UsIG51bWJlcmVkIGJhY2tyZWZlcmVuY2Ugd2l0aG91dCBjdXJseSBicmFjZXNcclxuICAgICAgICAgICAgICAgICQyID0gKyQyOyAvLyBUeXBlLWNvbnZlcnQ7IGRyb3AgbGVhZGluZyB6ZXJvXHJcbiAgICAgICAgICAgICAgICAvLyBYUmVnRXhwIGJlaGF2aW9yIGZvciBgJG5gIGFuZCBgJG5uYDpcclxuICAgICAgICAgICAgICAgIC8vIC0gQmFja3JlZnMgZW5kIGFmdGVyIDEgb3IgMiBkaWdpdHMuIFVzZSBgJHsuLn1gIGZvciBtb3JlIGRpZ2l0cy5cclxuICAgICAgICAgICAgICAgIC8vIC0gYCQxYCBpcyBhbiBlcnJvciBpZiBubyBjYXB0dXJpbmcgZ3JvdXBzLlxyXG4gICAgICAgICAgICAgICAgLy8gLSBgJDEwYCBpcyBhbiBlcnJvciBpZiBsZXNzIHRoYW4gMTAgY2FwdHVyaW5nIGdyb3Vwcy4gVXNlIGAkezF9MGAgaW5zdGVhZC5cclxuICAgICAgICAgICAgICAgIC8vIC0gYCQwMWAgaXMgYCQxYCBpZiBhdCBsZWFzdCBvbmUgY2FwdHVyaW5nIGdyb3VwLCBlbHNlIGl0J3MgYW4gZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAvLyAtIGAkMGAgKG5vdCBmb2xsb3dlZCBieSAxLTkpIGFuZCBgJDAwYCBhcmUgdGhlIGVudGlyZSBtYXRjaC5cclxuICAgICAgICAgICAgICAgIC8vIE5hdGl2ZSBiZWhhdmlvciwgZm9yIGNvbXBhcmlzb246XHJcbiAgICAgICAgICAgICAgICAvLyAtIEJhY2tyZWZzIGVuZCBhZnRlciAxIG9yIDIgZGlnaXRzLiBDYW5ub3QgcmVmZXJlbmNlIGNhcHR1cmluZyBncm91cCAxMDArLlxyXG4gICAgICAgICAgICAgICAgLy8gLSBgJDFgIGlzIGEgbGl0ZXJhbCBgJDFgIGlmIG5vIGNhcHR1cmluZyBncm91cHMuXHJcbiAgICAgICAgICAgICAgICAvLyAtIGAkMTBgIGlzIGAkMWAgZm9sbG93ZWQgYnkgYSBsaXRlcmFsIGAwYCBpZiBsZXNzIHRoYW4gMTAgY2FwdHVyaW5nIGdyb3Vwcy5cclxuICAgICAgICAgICAgICAgIC8vIC0gYCQwMWAgaXMgYCQxYCBpZiBhdCBsZWFzdCBvbmUgY2FwdHVyaW5nIGdyb3VwLCBlbHNlIGl0J3MgYSBsaXRlcmFsIGAkMDFgLlxyXG4gICAgICAgICAgICAgICAgLy8gLSBgJDBgIGlzIGEgbGl0ZXJhbCBgJDBgLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTigkMikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoJDIgPiBhcmdzLmxlbmd0aCAtIDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdCYWNrcmVmZXJlbmNlIHRvIHVuZGVmaW5lZCBncm91cCAnICsgJDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1skMl0gfHwgJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBgJGAgZm9sbG93ZWQgYnkgYW4gdW5zdXBwb3J0ZWQgY2hhciBpcyBhbiBlcnJvciwgdW5saWtlIG5hdGl2ZSBKU1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIHRva2VuICcgKyAkMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1JlZ2V4KSB7XHJcbiAgICAgICAgaWYgKHNlYXJjaC5nbG9iYWwpIHtcclxuICAgICAgICAgICAgLy8gRml4ZXMgSUUsIFNhZmFyaSBidWcgKGxhc3QgdGVzdGVkIElFIDksIFNhZmFyaSA1LjEpXHJcbiAgICAgICAgICAgIHNlYXJjaC5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEZpeGVzIElFLCBPcGVyYSBidWcgKGxhc3QgdGVzdGVkIElFIDksIE9wZXJhIDExLjYpXHJcbiAgICAgICAgICAgIHNlYXJjaC5sYXN0SW5kZXggPSBvcmlnTGFzdEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpeGVzIGJyb3dzZXIgYnVncyBpbiB0aGUgbmF0aXZlIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YC4gQ2FsbGluZyBgWFJlZ0V4cC5pbnN0YWxsKCduYXRpdmVzJylgXHJcbiAqIHVzZXMgdGhpcyB0byBvdmVycmlkZSB0aGUgbmF0aXZlIG1ldGhvZC4gVXNlIHZpYSBgWFJlZ0V4cC5zcGxpdGAgd2l0aG91dCBvdmVycmlkaW5nIG5hdGl2ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gc2VwYXJhdG9yIFJlZ2V4IG9yIHN0cmluZyB0byB1c2UgZm9yIHNlcGFyYXRpbmcgdGhlIHN0cmluZy5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdF0gTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzdWx0IGFycmF5LlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN1YnN0cmluZ3MuXHJcbiAqL1xyXG5maXhlZC5zcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpIHtcclxuICAgIGlmICghWFJlZ0V4cC5pc1JlZ0V4cChzZXBhcmF0b3IpKSB7XHJcbiAgICAgICAgLy8gQnJvd3NlcnMgaGFuZGxlIG5vbnJlZ2V4IHNwbGl0IGNvcnJlY3RseSwgc28gdXNlIHRoZSBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxyXG4gICAgICAgIHJldHVybiBuYXRpdi5zcGxpdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdHIgPSBTdHJpbmcodGhpcyksXHJcbiAgICAgICAgb3V0cHV0ID0gW10sXHJcbiAgICAgICAgb3JpZ0xhc3RJbmRleCA9IHNlcGFyYXRvci5sYXN0SW5kZXgsXHJcbiAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXHJcbiAgICAgICAgbGFzdExlbmd0aDtcclxuXHJcbiAgICAvLyBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcclxuICAgIC8vIElmIHVuZGVmaW5lZDogcG93KDIsMzIpIC0gMVxyXG4gICAgLy8gSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxyXG4gICAgLy8gSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IGZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID49IHBvdygyLDMyKSkgbGltaXQgLT0gcG93KDIsMzIpO1xyXG4gICAgLy8gSWYgbmVnYXRpdmUgbnVtYmVyOiBwb3coMiwzMikgLSBmbG9vcihhYnMobGltaXQpKVxyXG4gICAgLy8gSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXHJcbiAgICAvLyBUaGlzIGxpbmUgZmFpbHMgaW4gdmVyeSBzdHJhbmdlIHdheXMgZm9yIHNvbWUgdmFsdWVzIG9mIGBsaW1pdGAgaW4gT3BlcmEgMTAuNS0xMC42MywgdW5sZXNzXHJcbiAgICAvLyBPcGVyYSBEcmFnb25mbHkgaXMgb3BlbiAoZ28gZmlndXJlKS4gSXQgd29ya3MgaW4gYXQgbGVhc3QgT3BlcmEgOS41LTEwLjEgYW5kIDExK1xyXG4gICAgbGltaXQgPSAobGltaXQgPT09IHVuZGVmaW5lZCA/IC0xIDogbGltaXQpID4+PiAwO1xyXG5cclxuICAgIFhSZWdFeHAuZm9yRWFjaChzdHIsIHNlcGFyYXRvciwgZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICAvLyBUaGlzIGNvbmRpdGlvbiBpcyBub3QgdGhlIHNhbWUgYXMgYGlmIChtYXRjaFswXS5sZW5ndGgpYFxyXG4gICAgICAgIGlmICgobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpID4gbGFzdExhc3RJbmRleCkge1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBsYXN0TGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHIubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFuYXRpdi50ZXN0LmNhbGwoc2VwYXJhdG9yLCAnJykgfHwgbGFzdExlbmd0aCkge1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSBvcmlnTGFzdEluZGV4O1xyXG4gICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XHJcbn07XHJcblxyXG4vLyA9PS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPT1cclxuLy8gQnVpbHQtaW4gc3ludGF4L2ZsYWcgdG9rZW5zXHJcbi8vID09LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS09PVxyXG5cclxuLypcclxuICogTGV0dGVyIGVzY2FwZXMgdGhhdCBuYXRpdmVseSBtYXRjaCBsaXRlcmFsIGNoYXJhY3RlcnM6IGBcXGFgLCBgXFxBYCwgZXRjLiBUaGVzZSBzaG91bGQgYmVcclxuICogU3ludGF4RXJyb3JzIGJ1dCBhcmUgYWxsb3dlZCBpbiB3ZWIgcmVhbGl0eS4gWFJlZ0V4cCBtYWtlcyB0aGVtIGVycm9ycyBmb3IgY3Jvc3MtYnJvd3NlclxyXG4gKiBjb25zaXN0ZW5jeSBhbmQgdG8gcmVzZXJ2ZSB0aGVpciBzeW50YXgsIGJ1dCBsZXRzIHRoZW0gYmUgc3VwZXJzZWRlZCBieSBhZGRvbnMuXHJcbiAqL1xyXG5YUmVnRXhwLmFkZFRva2VuKFxyXG4gICAgL1xcXFwoW0FCQ0UtUlRVVlhZWmFlZy1tb3BxeXpdfGMoPyFbQS1aYS16XSl8dSg/IVtcXGRBLUZhLWZdezR9fHtbXFxkQS1GYS1mXSt9KXx4KD8hW1xcZEEtRmEtZl17Mn0pKS8sXHJcbiAgICBmdW5jdGlvbihtYXRjaCwgc2NvcGUpIHtcclxuICAgICAgICAvLyBcXEIgaXMgYWxsb3dlZCBpbiBkZWZhdWx0IHNjb3BlIG9ubHlcclxuICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICdCJyAmJiBzY29wZSA9PT0gZGVmYXVsdFNjb3BlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaFswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIGVzY2FwZSAnICsgbWF0Y2hbMF0pO1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBzY29wZTogJ2FsbCcsXHJcbiAgICAgICAgbGVhZENoYXI6ICdcXFxcJ1xyXG4gICAgfVxyXG4pO1xyXG5cclxuLypcclxuICogVW5pY29kZSBjb2RlIHBvaW50IGVzY2FwZSB3aXRoIGN1cmx5IGJyYWNlczogYFxcdXtOLi59YC4gYE4uLmAgaXMgYW55IG9uZSBvciBtb3JlIGRpZ2l0XHJcbiAqIGhleGFkZWNpbWFsIG51bWJlciBmcm9tIDAtMTBGRkZGLCBhbmQgY2FuIGluY2x1ZGUgbGVhZGluZyB6ZXJvcy4gUmVxdWlyZXMgdGhlIG5hdGl2ZSBFUzYgYHVgIGZsYWdcclxuICogdG8gc3VwcG9ydCBjb2RlIHBvaW50cyBncmVhdGVyIHRoYW4gVStGRkZGLiBBdm9pZHMgY29udmVydGluZyBjb2RlIHBvaW50cyBhYm92ZSBVK0ZGRkYgdG9cclxuICogc3Vycm9nYXRlIHBhaXJzICh3aGljaCBjb3VsZCBiZSBkb25lIHdpdGhvdXQgZmxhZyBgdWApLCBzaW5jZSB0aGF0IGNvdWxkIGxlYWQgdG8gYnJva2VuIGJlaGF2aW9yXHJcbiAqIGlmIHlvdSBmb2xsb3cgYSBgXFx1e04uLn1gIHRva2VuIHRoYXQgcmVmZXJlbmNlcyBhIGNvZGUgcG9pbnQgYWJvdmUgVStGRkZGIHdpdGggYSBxdWFudGlmaWVyLCBvclxyXG4gKiBpZiB5b3UgdXNlIHRoZSBzYW1lIGluIGEgY2hhcmFjdGVyIGNsYXNzLlxyXG4gKi9cclxuWFJlZ0V4cC5hZGRUb2tlbihcclxuICAgIC9cXFxcdXsoW1xcZEEtRmEtZl0rKX0vLFxyXG4gICAgZnVuY3Rpb24obWF0Y2gsIHNjb3BlLCBmbGFncykge1xyXG4gICAgICAgIHZhciBjb2RlID0gZGVjKG1hdGNoWzFdKTtcclxuICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBVbmljb2RlIGNvZGUgcG9pbnQgJyArIG1hdGNoWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnRpbmcgdG8gXFx1Tk5OTiBhdm9pZHMgbmVlZGluZyB0byBlc2NhcGUgdGhlIGxpdGVyYWwgY2hhcmFjdGVyIGFuZCBrZWVwIGl0XHJcbiAgICAgICAgICAgIC8vIHNlcGFyYXRlIGZyb20gcHJlY2VkaW5nIHRva2Vuc1xyXG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArIHBhZDQoaGV4KGNvZGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYGNvZGVgIGlzIGJldHdlZW4gMHhGRkZGIGFuZCAweDEwRkZGRiwgcmVxdWlyZSBhbmQgZGVmZXIgdG8gbmF0aXZlIGhhbmRsaW5nXHJcbiAgICAgICAgaWYgKGhhc05hdGl2ZVUgJiYgZmxhZ3MuaW5kZXhPZigndScpID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCB1c2UgVW5pY29kZSBjb2RlIHBvaW50IGFib3ZlIFxcXFx1e0ZGRkZ9IHdpdGhvdXQgZmxhZyB1Jyk7XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIHNjb3BlOiAnYWxsJyxcclxuICAgICAgICBsZWFkQ2hhcjogJ1xcXFwnXHJcbiAgICB9XHJcbik7XHJcblxyXG4vKlxyXG4gKiBFbXB0eSBjaGFyYWN0ZXIgY2xhc3M6IGBbXWAgb3IgYFteXWAuIFRoaXMgZml4ZXMgYSBjcml0aWNhbCBjcm9zcy1icm93c2VyIHN5bnRheCBpbmNvbnNpc3RlbmN5LlxyXG4gKiBVbmxlc3MgdGhpcyBpcyBzdGFuZGFyZGl6ZWQgKHBlciB0aGUgRVMgc3BlYyksIHJlZ2V4IHN5bnRheCBjYW4ndCBiZSBhY2N1cmF0ZWx5IHBhcnNlZCBiZWNhdXNlXHJcbiAqIGNoYXJhY3RlciBjbGFzcyBlbmRpbmdzIGNhbid0IGJlIGRldGVybWluZWQuXHJcbiAqL1xyXG5YUmVnRXhwLmFkZFRva2VuKFxyXG4gICAgL1xcWyhcXF4/KV0vLFxyXG4gICAgZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICAvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5IHdpdGggRVMzLCBjb252ZXJ0IFtdIHRvIFxcYlxcQiBhbmQgW15dIHRvIFtcXHNcXFNdLlxyXG4gICAgICAgIC8vICg/ISkgc2hvdWxkIHdvcmsgbGlrZSBcXGJcXEIsIGJ1dCBpcyB1bnJlbGlhYmxlIGluIHNvbWUgdmVyc2lvbnMgb2YgRmlyZWZveFxyXG4gICAgICAgIHJldHVybiBtYXRjaFsxXSA/ICdbXFxcXHNcXFxcU10nIDogJ1xcXFxiXFxcXEInO1xyXG4gICAgfSxcclxuICAgIHtsZWFkQ2hhcjogJ1snfVxyXG4pO1xyXG5cclxuLypcclxuICogQ29tbWVudCBwYXR0ZXJuOiBgKD8jIClgLiBJbmxpbmUgY29tbWVudHMgYXJlIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBsaW5lIGNvbW1lbnRzIGFsbG93ZWQgaW5cclxuICogZnJlZS1zcGFjaW5nIG1vZGUgKGZsYWcgeCkuXHJcbiAqL1xyXG5YUmVnRXhwLmFkZFRva2VuKFxyXG4gICAgL1xcKFxcPyNbXildKlxcKS8sXHJcbiAgICBmdW5jdGlvbihtYXRjaCwgc2NvcGUsIGZsYWdzKSB7XHJcbiAgICAgICAgLy8gS2VlcCB0b2tlbnMgc2VwYXJhdGVkIHVubGVzcyB0aGUgZm9sbG93aW5nIHRva2VuIGlzIGEgcXVhbnRpZmllci4gVGhpcyBhdm9pZHMgZS5nLlxyXG4gICAgICAgIC8vIGluYWR2ZXJ0ZWRseSBjaGFuZ2luZyBgXFwxKD8jKTFgIHRvIGBcXDExYC5cclxuICAgICAgICByZXR1cm4gaXNRdWFudGlmaWVyTmV4dChtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgsIGZsYWdzKSA/XHJcbiAgICAgICAgICAgICcnIDogJyg/OiknO1xyXG4gICAgfSxcclxuICAgIHtsZWFkQ2hhcjogJygnfVxyXG4pO1xyXG5cclxuLypcclxuICogV2hpdGVzcGFjZSBhbmQgbGluZSBjb21tZW50cywgaW4gZnJlZS1zcGFjaW5nIG1vZGUgKGFrYSBleHRlbmRlZCBtb2RlLCBmbGFnIHgpIG9ubHkuXHJcbiAqL1xyXG5YUmVnRXhwLmFkZFRva2VuKFxyXG4gICAgL1xccyt8I1teXFxuXSpcXG4/LyxcclxuICAgIGZ1bmN0aW9uKG1hdGNoLCBzY29wZSwgZmxhZ3MpIHtcclxuICAgICAgICAvLyBLZWVwIHRva2VucyBzZXBhcmF0ZWQgdW5sZXNzIHRoZSBmb2xsb3dpbmcgdG9rZW4gaXMgYSBxdWFudGlmaWVyLiBUaGlzIGF2b2lkcyBlLmcuXHJcbiAgICAgICAgLy8gaW5hZHZlcnRlZGx5IGNoYW5naW5nIGBcXDEgMWAgdG8gYFxcMTFgLlxyXG4gICAgICAgIHJldHVybiBpc1F1YW50aWZpZXJOZXh0KG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCwgZmxhZ3MpID9cclxuICAgICAgICAgICAgJycgOiAnKD86KSc7XHJcbiAgICB9LFxyXG4gICAge2ZsYWc6ICd4J31cclxuKTtcclxuXHJcbi8qXHJcbiAqIERvdCwgaW4gZG90YWxsIG1vZGUgKGFrYSBzaW5nbGVsaW5lIG1vZGUsIGZsYWcgcykgb25seS5cclxuICovXHJcblhSZWdFeHAuYWRkVG9rZW4oXHJcbiAgICAvXFwuLyxcclxuICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAnW1xcXFxzXFxcXFNdJztcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgZmxhZzogJ3MnLFxyXG4gICAgICAgIGxlYWRDaGFyOiAnLidcclxuICAgIH1cclxuKTtcclxuXHJcbi8qXHJcbiAqIE5hbWVkIGJhY2tyZWZlcmVuY2U6IGBcXGs8bmFtZT5gLiBCYWNrcmVmZXJlbmNlIG5hbWVzIGNhbiB1c2UgdGhlIGNoYXJhY3RlcnMgQS1aLCBhLXosIDAtOSwgXyxcclxuICogYW5kICQgb25seS4gQWxzbyBhbGxvd3MgbnVtYmVyZWQgYmFja3JlZmVyZW5jZXMgYXMgYFxcazxuPmAuXHJcbiAqL1xyXG5YUmVnRXhwLmFkZFRva2VuKFxyXG4gICAgL1xcXFxrPChbXFx3JF0rKT4vLFxyXG4gICAgZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICAvLyBHcm91cHMgd2l0aCB0aGUgc2FtZSBuYW1lIGlzIGFuIGVycm9yLCBlbHNlIHdvdWxkIG5lZWQgYGxhc3RJbmRleE9mYFxyXG4gICAgICAgIHZhciBpbmRleCA9IGlzTmFOKG1hdGNoWzFdKSA/IChpbmRleE9mKHRoaXMuY2FwdHVyZU5hbWVzLCBtYXRjaFsxXSkgKyAxKSA6ICttYXRjaFsxXSxcclxuICAgICAgICAgICAgZW5kSW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcclxuICAgICAgICBpZiAoIWluZGV4IHx8IGluZGV4ID4gdGhpcy5jYXB0dXJlTmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQmFja3JlZmVyZW5jZSB0byB1bmRlZmluZWQgZ3JvdXAgJyArIG1hdGNoWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gS2VlcCBiYWNrcmVmZXJlbmNlcyBzZXBhcmF0ZSBmcm9tIHN1YnNlcXVlbnQgbGl0ZXJhbCBudW1iZXJzLiBUaGlzIGF2b2lkcyBlLmcuXHJcbiAgICAgICAgLy8gaW5hZHZlcnRlZGx5IGNoYW5naW5nIGAoPzxuPilcXGs8bj4xYCB0byBgKClcXDExYC5cclxuICAgICAgICByZXR1cm4gJ1xcXFwnICsgaW5kZXggKyAoXHJcbiAgICAgICAgICAgIGVuZEluZGV4ID09PSBtYXRjaC5pbnB1dC5sZW5ndGggfHwgaXNOYU4obWF0Y2guaW5wdXQuY2hhckF0KGVuZEluZGV4KSkgP1xyXG4gICAgICAgICAgICAgICAgJycgOiAnKD86KSdcclxuICAgICAgICApO1xyXG4gICAgfSxcclxuICAgIHtsZWFkQ2hhcjogJ1xcXFwnfVxyXG4pO1xyXG5cclxuLypcclxuICogTnVtYmVyZWQgYmFja3JlZmVyZW5jZSBvciBvY3RhbCwgcGx1cyBhbnkgZm9sbG93aW5nIGRpZ2l0czogYFxcMGAsIGBcXDExYCwgZXRjLiBPY3RhbHMgZXhjZXB0IGBcXDBgXHJcbiAqIG5vdCBmb2xsb3dlZCBieSAwLTkgYW5kIGJhY2tyZWZlcmVuY2VzIHRvIHVub3BlbmVkIGNhcHR1cmUgZ3JvdXBzIHRocm93IGFuIGVycm9yLiBPdGhlciBtYXRjaGVzXHJcbiAqIGFyZSByZXR1cm5lZCB1bmFsdGVyZWQuIElFIDwgOSBkb2Vzbid0IHN1cHBvcnQgYmFja3JlZmVyZW5jZXMgYWJvdmUgYFxcOTlgIGluIHJlZ2V4IHN5bnRheC5cclxuICovXHJcblhSZWdFeHAuYWRkVG9rZW4oXHJcbiAgICAvXFxcXChcXGQrKS8sXHJcbiAgICBmdW5jdGlvbihtYXRjaCwgc2NvcGUpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICEoXHJcbiAgICAgICAgICAgICAgICBzY29wZSA9PT0gZGVmYXVsdFNjb3BlICYmXHJcbiAgICAgICAgICAgICAgICAvXlsxLTldLy50ZXN0KG1hdGNoWzFdKSAmJlxyXG4gICAgICAgICAgICAgICAgK21hdGNoWzFdIDw9IHRoaXMuY2FwdHVyZU5hbWVzLmxlbmd0aFxyXG4gICAgICAgICAgICApICYmXHJcbiAgICAgICAgICAgIG1hdGNoWzFdICE9PSAnMCdcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDYW5ub3QgdXNlIG9jdGFsIGVzY2FwZSBvciBiYWNrcmVmZXJlbmNlIHRvIHVuZGVmaW5lZCBncm91cCAnICtcclxuICAgICAgICAgICAgICAgIG1hdGNoWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoWzBdO1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBzY29wZTogJ2FsbCcsXHJcbiAgICAgICAgbGVhZENoYXI6ICdcXFxcJ1xyXG4gICAgfVxyXG4pO1xyXG5cclxuLypcclxuICogTmFtZWQgY2FwdHVyaW5nIGdyb3VwOyBtYXRjaCB0aGUgb3BlbmluZyBkZWxpbWl0ZXIgb25seTogYCg/PG5hbWU+YC4gQ2FwdHVyZSBuYW1lcyBjYW4gdXNlIHRoZVxyXG4gKiBjaGFyYWN0ZXJzIEEtWiwgYS16LCAwLTksIF8sIGFuZCAkIG9ubHkuIE5hbWVzIGNhbid0IGJlIGludGVnZXJzLiBTdXBwb3J0cyBQeXRob24tc3R5bGVcclxuICogYCg/UDxuYW1lPmAgYXMgYW4gYWx0ZXJuYXRlIHN5bnRheCB0byBhdm9pZCBpc3N1ZXMgaW4gc29tZSBvbGRlciB2ZXJzaW9ucyBvZiBPcGVyYSB3aGljaCBuYXRpdmVseVxyXG4gKiBzdXBwb3J0ZWQgdGhlIFB5dGhvbi1zdHlsZSBzeW50YXguIE90aGVyd2lzZSwgWFJlZ0V4cCBtaWdodCB0cmVhdCBudW1iZXJlZCBiYWNrcmVmZXJlbmNlcyB0b1xyXG4gKiBQeXRob24tc3R5bGUgbmFtZWQgY2FwdHVyZSBhcyBvY3RhbHMuXHJcbiAqL1xyXG5YUmVnRXhwLmFkZFRva2VuKFxyXG4gICAgL1xcKFxcP1A/PChbXFx3JF0rKT4vLFxyXG4gICAgZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICAvLyBEaXNhbGxvdyBiYXJlIGludGVnZXJzIGFzIG5hbWVzIGJlY2F1c2UgbmFtZWQgYmFja3JlZmVyZW5jZXMgYXJlIGFkZGVkIHRvIG1hdGNoIGFycmF5c1xyXG4gICAgICAgIC8vIGFuZCB0aGVyZWZvcmUgbnVtZXJpYyBwcm9wZXJ0aWVzIG1heSBsZWFkIHRvIGluY29ycmVjdCBsb29rdXBzXHJcbiAgICAgICAgaWYgKCFpc05hTihtYXRjaFsxXSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDYW5ub3QgdXNlIGludGVnZXIgYXMgY2FwdHVyZSBuYW1lICcgKyBtYXRjaFswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJ2xlbmd0aCcgfHwgbWF0Y2hbMV0gPT09ICdfX3Byb3RvX18nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ2Fubm90IHVzZSByZXNlcnZlZCB3b3JkIGFzIGNhcHR1cmUgbmFtZSAnICsgbWF0Y2hbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5kZXhPZih0aGlzLmNhcHR1cmVOYW1lcywgbWF0Y2hbMV0pID4gLTEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDYW5ub3QgdXNlIHNhbWUgbmFtZSBmb3IgbXVsdGlwbGUgZ3JvdXBzICcgKyBtYXRjaFswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FwdHVyZU5hbWVzLnB1c2gobWF0Y2hbMV0pO1xyXG4gICAgICAgIHRoaXMuaGFzTmFtZWRDYXB0dXJlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gJygnO1xyXG4gICAgfSxcclxuICAgIHtsZWFkQ2hhcjogJygnfVxyXG4pO1xyXG5cclxuLypcclxuICogQ2FwdHVyaW5nIGdyb3VwOyBtYXRjaCB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyBvbmx5LiBSZXF1aXJlZCBmb3Igc3VwcG9ydCBvZiBuYW1lZCBjYXB0dXJpbmdcclxuICogZ3JvdXBzLiBBbHNvIGFkZHMgZXhwbGljaXQgY2FwdHVyZSBtb2RlIChmbGFnIG4pLlxyXG4gKi9cclxuWFJlZ0V4cC5hZGRUb2tlbihcclxuICAgIC9cXCgoPyFcXD8pLyxcclxuICAgIGZ1bmN0aW9uKG1hdGNoLCBzY29wZSwgZmxhZ3MpIHtcclxuICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZignbicpID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcoPzonO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhcHR1cmVOYW1lcy5wdXNoKG51bGwpO1xyXG4gICAgICAgIHJldHVybiAnKCc7XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG9wdGlvbmFsRmxhZ3M6ICduJyxcclxuICAgICAgICBsZWFkQ2hhcjogJygnXHJcbiAgICB9XHJcbik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhSZWdFeHA7XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgY29tcG9uZW50U3R5bGVTaGVldCBmcm9tICdzb3VyY2UvdXRpbC9hcHAnO1xyXG5cclxuY29tcG9uZW50U3R5bGVTaGVldC5hZGRTdHlsZXMoe1xyXG4gICAgXCJkb3JpYy1iYWNrZ3JvdW5kLWltYWdlXCI6IHtcclxuICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogJ2NlbnRlciBjZW50ZXInLFxyXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6ICduby1yZXBlYXQnLFxyXG4gICAgICAgIGJhY2tncm91bmRTaXplOiAnY29udGFpbicsXHJcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICBvdmVyZmxvdzogJ2F1dG8nLFxyXG4gICAgfVxyXG59KTtcclxuY29uc3QgQmFja2dyb3VuZEltYWdlID0gKHtjaGlsZHJlbiwgc3R5bGUgPSB7fSwgc291cmNlLCAuLi5wcm9wc30pID0+IHtcclxuICAgIGNvbnN0IGltZ1N0eWxlID0ge1xyXG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybChcIiR7c291cmNlfVwiKWAsXHJcbiAgICAgICAgLi4uc3R5bGVcclxuICAgIH07XHJcbiAgICByZXR1cm4gPGRvcmljLWJhY2tncm91bmQtaW1hZ2Ugey4uLnByb3BzfSBzdHlsZT17aW1nU3R5bGV9PntjaGlsZHJlbn08L2RvcmljLWJhY2tncm91bmQtaW1hZ2U+O1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmFja2dyb3VuZEltYWdlO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuaW1wb3J0IHRoZW1lIGZyb20gJ3NvdXJjZS91dGlsL3RoZW1lJztcclxuXHJcbmltcG9ydCBDdXN0b21FdmVudHMgZnJvbSBcInNvdXJjZS9jb21wb25lbnQvQ3VzdG9tRXZlbnRzXCI7XHJcblxyXG5jb21wb25lbnRTdHlsZVNoZWV0LmFkZFN0eWxlcyh7XHJcbiAgICBcImRvcmljLWJ1dHRvblwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogWyctd2Via2l0LWlubGluZS1mbGV4JywgJ2lubGluZS1mbGV4J10sXHJcbiAgICAgICAgY29sb3I6IHRoZW1lLmJ1dHRvbi50ZXh0LmNvbG9yLFxyXG4gICAgICAgIHBhZGRpbmc6ICcwLjdlbSAwLjVlbScsXHJcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXHJcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcclxuICAgICAgICBib3JkZXJSYWRpdXM6IDMsXHJcbiAgICAgICAgYm9yZGVyV2lkdGg6IDAsXHJcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxyXG4gICAgICAgIG1hcmdpbjogNVxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtYnV0dG9uOmFmdGVyXCI6IHtcclxuICAgICAgICBjb250ZW50OiAnXCJcIicsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDI1MG1zIGxpbmVhcidcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWJ1dHRvbltwcmVzc2VkXTpub3QoW2Rpc2FibGVkXSk6YWZ0ZXJcIjoge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4yNSknLFxyXG4gICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xyXG4gICAgfSxcclxuXHJcbiAgICBcImRvcmljLWJ1dHRvbltkaXNhYmxlZF1cIjoge1xyXG4gICAgICAgIGJveFNoYWRvdzogJ25vbmUnLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNlNmU2ZTYnLFxyXG4gICAgICAgIGNvbG9yOiAnIzgwODA4MCdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWJ1dHRvbltyYWlzZWRdXCI6IHtcclxuICAgICAgICBib3hTaGFkb3c6IHRoZW1lLmdlbmVyYWwuYm94U2hhZG93XHJcbiAgICB9LFxyXG59KTtcclxuY29uc3QgQnV0dG9uID0gcHJvcHMgPT4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHRleHQgPSBudWxsLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGNsYXNzTmFtZSA9IFwiXCIsXHJcbiAgICAgICAgLi4ucGFzc1Rocm91Z2hcclxuICAgIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IHBhc3NlZE9uVGFwID0gcGFzc1Rocm91Z2gub25UYXAgfHwgKCgpID0+IHt9KTtcclxuXHJcbiAgICBwYXNzVGhyb3VnaC5vblRhcCA9IGV2dCA9PiB7XHJcbiAgICAgICAgaWYgKHBhc3NUaHJvdWdoLmRpc2FibGVkICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHBhc3NlZE9uVGFwKGV2dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gPEN1c3RvbUV2ZW50cyBjb21wb25lbnQ9XCJkb3JpYy1idXR0b25cIiB7Li4ucGFzc1Rocm91Z2h9IGNsYXNzPXtjbGFzc05hbWV9Pnt0ZXh0fXtjaGlsZHJlbn08L0N1c3RvbUV2ZW50cz47XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCdXR0b247XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgY29tcG9uZW50U3R5bGVTaGVldCBmcm9tICdzb3VyY2UvdXRpbC9hcHAnO1xyXG5pbXBvcnQgdGhlbWUgZnJvbSAnc291cmNlL3V0aWwvdGhlbWUnO1xyXG5cclxuY29tcG9uZW50U3R5bGVTaGVldC5hZGRTdHlsZXMoe1xyXG4gICAgXCJkb3JpYy1jYXJkXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgICAgIGJveFNoYWRvdzogdGhlbWUuZ2VuZXJhbC5ib3hTaGFkb3csXHJcbiAgICAgICAgbWFyZ2luOiA1LFxyXG4gICAgICAgIGJvcmRlclJhZGl1czogMyxcclxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1jYXJkIC5jb250ZW50XCI6IHtcclxuICAgICAgICBwYWRkaW5nOiA1XHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1jYXJkIC50aXRsZVwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgIFdlYmtpdEZvbnRTbW9vdGhpbmc6ICdhbnRpYWxpYXNlZCcsXHJcbiAgICAgICAgZm9udFdlaWdodDogOTAwLFxyXG4gICAgICAgIGZvbnRTaXplOiAxOCxcclxuICAgICAgICBwYWRkaW5nOiA1LFxyXG4gICAgICAgIGJvcmRlckJvdHRvbTogJzFweCBzb2xpZCBsaWdodGdyYXknXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1jYXJkIC5hY3Rpb25zXCI6IHtcclxuICAgICAgICBwYWRkaW5nOiA1LFxyXG4gICAgICAgIGJvcmRlclRvcDogJzFweCBzb2xpZCBsaWdodGdyYXknXHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBDYXJkID0gcHJvcHMgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICB0aXRsZSA9IG51bGwsXHJcbiAgICAgICAgYWN0aW9ucyA9IG51bGwsXHJcbiAgICAgICAgLi4ucGFzc1Rocm91Z2hcclxuICAgIH0gPSBwcm9wcztcclxuICAgIGxldCB0aXRsZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgbGV0IGFjdGlvbkVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIGlmICh0aXRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRpdGxlRWxlbWVudCA9IDxkaXYgY2xhc3NOYW1lPVwidGl0bGVcIj57dGl0bGV9PC9kaXY+O1xyXG4gICAgfVxyXG4gICAgaWYgKGFjdGlvbnMgIT09IG51bGwpIHtcclxuICAgICAgICBhY3Rpb25FbGVtZW50ID0gPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zXCI+e2FjdGlvbnN9PC9kaXY+O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRvcmljLWNhcmQgey4uLnBhc3NUaHJvdWdofT5cclxuICAgICAgICAgICAge3RpdGxlRWxlbWVudH1cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250ZW50XCI+e2NoaWxkcmVufTwvZGl2PlxyXG4gICAgICAgICAgICB7YWN0aW9uRWxlbWVudH1cclxuICAgICAgICA8L2RvcmljLWNhcmQ+XHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2FyZDtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBjb21wb25lbnRTdHlsZVNoZWV0IGZyb20gJ3NvdXJjZS91dGlsL2FwcCc7XHJcbmltcG9ydCBjb25zdHMgZnJvbSAnc291cmNlL3V0aWwvY29uc3RzJztcclxuaW1wb3J0IHtDU1N9IGZyb20gJ3NvdXJjZS91dGlsL3N0eWxlc2hlZXQnO1xyXG5cclxuaW1wb3J0IHtDZW50ZXJDb250ZW50fSBmcm9tICdzb3VyY2UvY29tcG9uZW50L0NvbnRlbnRBbGlnbmVycyc7XHJcbmltcG9ydCBDdXN0b21FdmVudHMgZnJvbSBcInNvdXJjZS9jb21wb25lbnQvQ3VzdG9tRXZlbnRzXCI7XHJcbmltcG9ydCB7SWNvbn0gZnJvbSAnc291cmNlL2NvbXBvbmVudC9JY29uJztcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtY2hlY2tib3hcIjoge1xyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1jaGVja2JveFtkaXNhYmxlZD0ndHJ1ZSddXCI6IHtcclxuICAgICAgICBjb2xvcjogJ2dyYXknLFxyXG4gICAgICAgIG9wYWNpdHk6IDAuNlxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtY2hlY2tib3g6YWZ0ZXJcIjoge1xyXG4gICAgICAgIGNvbnRlbnQ6IFwiJydcIixcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogY29uc3RzLmNzcy5iYWNrZ3JvdW5kVHJhbnNpdGlvblxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtY2hlY2tib3hbcHJlc3NlZF06bm90KFtkaXNhYmxlZD0ndHJ1ZSddKTphZnRlclwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBDU1MucmdiYSgwLCAwLCAwLCAwLjI1KSxcclxuICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWNoZWNrYm94IGRvcmljLWljb25cIjoge1xyXG4gICAgICAgIHRyYW5zaXRpb246ICdjb2xvciAyNTBtcyBsaW5lYXInXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1jaGVja2JveFtjaGVja2VkPSd0cnVlJ106bm90KFtkaXNhYmxlZD0ndHJ1ZSddKSBkb3JpYy1pY29uXCI6IHtcclxuICAgICAgICBjb2xvcjogY29uc3RzLnRoZW1lLmJsdWlzaFxyXG4gICAgfVxyXG59KTtcclxuY29uc3QgQ2hlY2tib3ggPSBwcm9wcyA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgY2hlY2tlZCA9IGZhbHNlLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIG9uQ2hhbmdlID0gd2FybmluZ0Z1bmMoXCJDaGVja2JveCBoYXMgbm8gb25DaGFuZ2UgZnVuY3Rpb25cIiksXHJcbiAgICAgICAgb25JY29uID0gXCJpb24tYW5kcm9pZC1jaGVja2JveFwiLFxyXG4gICAgICAgIG9mZkljb24gPSBcImlvbi1hbmRyb2lkLWNoZWNrYm94LW91dGxpbmUtYmxhbmtcIixcclxuICAgICAgICBzaWRlID0gJ2xlZnQnLFxyXG4gICAgICAgIGNsYXNzTmFtZSA9IFwiXCIsXHJcbiAgICAgICAgc3R5bGUgPSB7fSxcclxuICAgICAgICAuLi5wYXNzVGhyb3VnaFxyXG4gICAgfSA9IHByb3BzO1xyXG4gICAgY29uc3QgY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChwcm9wcy5kaXNhYmxlZCAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBvbkNoYW5nZShjaGVja2VkID09PSBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgaWNvbk5hbWUgPSAoY2hlY2tlZCA9PT0gdHJ1ZSkgPyBvbkljb24gOiBvZmZJY29uO1xyXG4gICAgY29uc3QgcGFkZGluZyA9IHtcclxuICAgICAgICBwYWRkaW5nOiA1LFxyXG4gICAgICAgIFtgcGFkZGluZyR7c2lkZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3NpZGUuc2xpY2UoMSl9YF06IDMwXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEN1c3RvbUV2ZW50cyBjb21wb25lbnQ9XCJkb3JpYy1jaGVja2JveFwiIGNsYXNzPXtjbGFzc05hbWV9IG9uVGFwPXtjaGFuZ2V9IHsuLi5wYXNzVGhyb3VnaH0gc3R5bGU9e3suLi5zdHlsZSwgLi4ucGFkZGluZ319IGNoZWNrZWQ9e2NoZWNrZWR9PlxyXG4gICAgICAgICAgICA8Q2VudGVyQ29udGVudCBkYXRhLW5vLXByZXNzIHN0eWxlPXt7W3NpZGVdOiAwLCB0b3A6IDAsIHBvc2l0aW9uOiAnYWJzb2x1dGUnfX0gd2lkdGg9ezMwfSBoZWlnaHQ9XCIxMDAlXCI+XHJcbiAgICAgICAgICAgICAgICA8SWNvbiBpY29uPXtpY29uTmFtZX0gZGF0YS1uby1wcmVzcyBzdHlsZT17e2ZvbnRTaXplOiAyNn19IC8+XHJcbiAgICAgICAgICAgIDwvQ2VudGVyQ29udGVudD5cclxuICAgICAgICAgICAge2xhYmVsfXtjaGlsZHJlbn1cclxuICAgICAgICA8L0N1c3RvbUV2ZW50cz5cclxuICAgICk7XHJcbn07XHJcbkNoZWNrYm94LmZvcm1WYWx1ZSA9IFwiY2hlY2tlZFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2hlY2tib3g7XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgY29tcG9uZW50U3R5bGVTaGVldCBmcm9tICdzb3VyY2UvdXRpbC9hcHAnO1xyXG5cclxuY29tcG9uZW50U3R5bGVTaGVldC5hZGRTdHlsZXMoe1xyXG4gICAgXCJkb3JpYy1jZW50ZXItY29udGVudFwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogWyctd2Via2l0LWlubGluZS1mbGV4JywgJ2lubGluZS1mbGV4J10sXHJcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXHJcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1hbGlnbi1jb250ZW50XCI6IHtcclxuICAgICAgICBkaXNwbGF5OiBbJy13ZWJraXQtaW5saW5lLWZsZXgnLCAnaW5saW5lLWZsZXgnXSxcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWNlbnRlci1jb250ZW50LmJsb2NrLCBkb3JpYy1hbGlnbi1jb250ZW50LmJsb2NrXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiBbJy13ZWJraXQtZmxleCcsICdmbGV4J11cclxuICAgIH1cclxufSk7XHJcbmNvbnN0IENlbnRlckNvbnRlbnQgPSAoe3dpZHRoLCBoZWlnaHQsIGNsYXNzTmFtZSA9IFwiXCIsIGJsb2NrLCBzdHlsZSA9IHt9LCAuLi5wYXNzVGhyb3VnaH0pID0+XHJcbiAgICA8ZG9yaWMtY2VudGVyLWNvbnRlbnQgY2xhc3M9e2Ake2Jsb2NrID8gXCJibG9ja1wiIDogXCJcIn0gJHtjbGFzc05hbWV9YC50cmltKCl9IHsuLi5wYXNzVGhyb3VnaH0gc3R5bGU9e3suLi5zdHlsZSwgd2lkdGgsIGhlaWdodH19IC8+O1xyXG5jb25zdCBBbGlnbkNvbnRlbnQgPSAoe3dpZHRoLCBoZWlnaHQsIGNsYXNzTmFtZSA9IFwiXCIsIGJsb2NrLCBob3Jpem9udGFsID0gXCJjZW50ZXJcIiwgdmVydGljYWwgPSBcImNlbnRlclwiLCBzdHlsZSA9IHt9LCAuLi5wYXNzVGhyb3VnaH0pID0+XHJcbiAgICA8ZG9yaWMtYWxpZ24tY29udGVudFxyXG4gICAgICAgIGNsYXNzPXtgJHtibG9jayA/IFwiYmxvY2tcIiA6IFwiXCJ9ICR7Y2xhc3NOYW1lfWAudHJpbSgpfVxyXG4gICAgICAgIHsuLi5wYXNzVGhyb3VnaH1cclxuICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgICAuLi5zdHlsZSxcclxuICAgICAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodCxcclxuICAgICAgICAgICAgV2Via2l0QWxpZ25JdGVtczogdmVydGljYWwsXHJcbiAgICAgICAgICAgIFdlYmtpdEp1c3RpZnlDb250ZW50OiBob3Jpem9udGFsLFxyXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiB2ZXJ0aWNhbCxcclxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IGhvcml6b250YWxcclxuICAgICAgICB9fSAvPjtcclxuXHJcbmV4cG9ydCB7XHJcbiAgICBDZW50ZXJDb250ZW50LFxyXG4gICAgQWxpZ25Db250ZW50XHJcbn07XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xyXG5cclxuY29uc3QgdHJhdmVyc2UgPSAobm9kZSwgZXZ0LCBoYW5kbGVycykgPT4ge1xyXG4gICAgY29uc3QgdHJpZ2dlcnMgPSBbXTtcclxuICAgIGxldCBjdXJyZW50ID0gbm9kZTtcclxuICAgIGxldCBjb250ID0gdHJ1ZTtcclxuXHJcbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uID0gKCkgPT4gY29udCA9IGZhbHNlO1xyXG4gICAgd2hpbGUgKGNvbnQgPT0gdHJ1ZSAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKGhhbmRsZXJzLmhhcyhjdXJyZW50LmRhdGFzZXQuc3ludGhJZCkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaGFuZGxlcnMuZ2V0KGN1cnJlbnQuZGF0YXNldC5zeW50aElkKShldnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBoYW5kbGVycyA9IHt9O1xyXG5sZXQgbmV4dElEID0gMDtcclxuY29uc3QgZ2VuSUQgPSAoKSA9PiB7XHJcbiAgICBuZXh0SUQgKz0gMTtcclxuICAgIHJldHVybiBuZXh0SUQudG9TdHJpbmcoKTtcclxufTtcclxuY29uc3QgcmVnaXN0ZXJIYW5kbGVyID0gKHR5cGUsIGlkLCBoYW5kbGVyKSA9PiB7XHJcbiAgICBpZiAoaGFuZGxlcnNbdHlwZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBldnQgPT4gdHJhdmVyc2UoZXZ0LnRhcmdldCwgZXZ0LCBoYW5kbGVyc1tldnQudHlwZS50b0xvd2VyQ2FzZSgpXSksXHJcbiAgICAgICAgICAgIHRydWVcclxuICAgICAgICApO1xyXG4gICAgICAgIGhhbmRsZXJzW3R5cGVdID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlcnNbdHlwZV0uc2V0KGlkLCBoYW5kbGVyKTtcclxufTtcclxuY29uc3QgdW5yZWdpc3RlckhhbmRsZXJzID0gaWQgPT4ge1xyXG4gICAgZm9yIChjb25zdCBtYXBwaW5nIG9mIE9iamVjdC52YWx1ZXMoaGFuZGxlcnMpKSB7XHJcbiAgICAgICAgbWFwcGluZy5kZWxldGUoaWQpO1xyXG4gICAgfVxyXG59O1xyXG53aW5kb3cuc2hvd0hhbmRsZXJzID0gKCkgPT4gY2Jsb2coaGFuZGxlcnMpO1xyXG5cclxuY29uc3QgbmF0aXZlRXZlbnRzID0gbmV3IFNldChbXHJcbiAgICAnb25DdXQnLCAnb25Db3B5JywgJ29uUGFzdGUnLFxyXG4gICAgJ29uQ29tcG9zaXRpb25FbmQnLCAnb25Db21wb3NpdGlvblN0YXJ0JywgJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxyXG4gICAgJ29uS2V5RG93bicsICdvbktleVByZXNzJywgJ29uS2V5VXAnLFxyXG4gICAgJ29uRm9jdXMnLCAnb25CbHVyJyxcclxuICAgICdvbkNoYW5nZScsICdvbklucHV0JywgJ29uU3VibWl0JyxcclxuICAgICdvbkNsaWNrJywgJ29uQ29udGV4dE1lbnUnLCAnb25Eb3VibGVDbGljaycsICdvbkRyYWcnLCAnb25EcmFnRW5kJywgJ29uRHJhZ0VudGVyJywgJ29uRHJhZ0V4aXQnLCAnb25EcmFnTGVhdmUnLCAnb25EcmFnT3ZlcicsICdvbkRyYWdTdGFydCcsICdvbkRyb3AnLCAnb25Nb3VzZURvd24nLCAnb25Nb3VzZUVudGVyJywgJ29uTW91c2VMZWF2ZScsICdvbk1vdXNlTW92ZScsICdvbk1vdXNlT3V0JywgJ29uTW91c2VPdmVyJywgJ29uTW91c2VVcCcsXHJcbiAgICAnb25TZWxlY3QnLFxyXG4gICAgJ29uVG91Y2hDYW5jZWwnLCAnb25Ub3VjaEVuZCcsICdvblRvdWNoTW92ZScsICdvblRvdWNoU3RhcnQnLFxyXG4gICAgJ29uU2Nyb2xsJyxcclxuICAgICdvbldoZWVsJyxcclxuICAgICdvbkFib3J0JywgJ29uQ2FuUGxheScsICdvbkNhblBsYXlUaHJvdWdoJywgJ29uRHVyYXRpb25DaGFuZ2UnLCAnb25FbXB0aWVkJywgJ29uRW5jcnlwdGVkJywgJ29uRW5kZWQnLCAnb25FcnJvcicsICdvbkxvYWRlZERhdGEnLCAnb25Mb2FkZWRNZXRhZGF0YScsICdvbkxvYWRTdGFydCcsICdvblBhdXNlJywgJ29uUGxheScsICdvblBsYXlpbmcnLCAnb25Qcm9ncmVzcycsICdvblJhdGVDaGFuZ2UnLCAnb25TZWVrZWQnLCAnb25TZWVraW5nJywgJ29uU3RhbGxlZCcsICdvblN1c3BlbmQnLCAnb25UaW1lVXBkYXRlJywgJ29uVm9sdW1lQ2hhbmdlJywgJ29uV2FpdGluZycsXHJcbiAgICAnb25BbmltYXRpb25TdGFydCcsICdvbkFuaW1hdGlvbkVuZCcsICdvbkFuaW1hdGlvbkl0ZXJhdGlvbicsXHJcbiAgICAnb25UcmFuc2l0aW9uRW5kJ1xyXG5dKTtcclxuY2xhc3MgQ3VzdG9tRXZlbnRzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgICAgIHRoaXMuaWQgPSBnZW5JRCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUNhbGxiYWNrcyA9ICgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLnByb3BzKSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5LnNsaWNlKDAsIDIpID09PSAnb24nICYmIG5hdGl2ZUV2ZW50cy5oYXMoa2V5KSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVySGFuZGxlcihrZXkuc2xpY2UoMikudG9Mb3dlckNhc2UoKSwgdGhpcy5pZCwgdGhpcy5wcm9wc1trZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrcygpO1xyXG4gICAgICAgIGlmIChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5kYXRhc2V0LnN5bnRoSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7dGhpcy5wcm9wcy5jb21wb25lbnQubmFtZX0gbXVzdCBwYXNzIHRoZSBkYXRhLXN5bnRoLWlkIHByb3AgaW50byB0aGUgRE9NIGVsZW1lbnRzIHJlbmRlcmVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29tcG9uZW50RGlkVXBkYXRlID0gKCkgPT4ge1xyXG4gICAgICAgIHVucmVnaXN0ZXJIYW5kbGVycyh0aGlzLmlkKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrcygpO1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQgPSAoKSA9PiB7XHJcbiAgICAgICAgdW5yZWdpc3RlckhhbmRsZXJzKHRoaXMuaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBpZiAoKHRoaXMucHJvcHMuY29tcG9uZW50IHx8IG51bGwpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbXBvbmVudCBtdXN0IGJlIHBhc3NlZCBpbnRvIEN1c3RvbUV2ZW50c1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gdGhpcy5wcm9wcy5jb21wb25lbnQ7XHJcbiAgICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3BzKS5yZWR1Y2UoXHJcbiAgICAgICAgICAgIChwLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICgoa2V5ICE9PSAnY29tcG9uZW50JyAmJiBrZXkuc2xpY2UoMCwgMikgIT09ICdvbicpIHx8IG5hdGl2ZUV2ZW50cy5oYXMoa2V5KSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBba2V5XSA9IHRoaXMucHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7fVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIDxDb21wb25lbnQgZGF0YS1zeW50aC1pZD17dGhpcy5pZH0gey4uLnByb3BzfSAvPjtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ3VzdG9tRXZlbnRzO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuXHJcbmltcG9ydCBzcGlubmVyR0lGIGZyb20gJ3NvdXJjZS9kYXRhLXVyaS9zcGlubmVyLmdpZi5zb3VyY2UnO1xyXG5cclxuY29tcG9uZW50U3R5bGVTaGVldC5hZGRTdHlsZXMoe1xyXG4gICAgXCJkb3JpYy1idXR0b25bZmlsbF1cIjoge1xyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgIGJvcmRlclJhZGl1czogMFxyXG4gICAgfSxcclxuICAgIFwiQGtleWZyYW1lcyBkb3JpYy1hbGVydC1hcHBlYXJcIjoge1xyXG4gICAgICAgIGZyb206IHtcclxuICAgICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG86IHtcclxuICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcImRvcmljLWFsZXJ0LXdyYXBwZXJcIjoge1xyXG4gICAgICAgIGFuaW1hdGlvbk5hbWU6ICdkb3JpYy1hbGVydC1hcHBlYXInLFxyXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAnMjUwbXMnLFxyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcclxuICAgICAgICB6SW5kZXg6IDEwMDAwLFxyXG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcclxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXHJcbiAgICAgICAgYWxpZ25JdGVtczogJ2ZsZXgtc3RhcnQnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1hbGVydFwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgIG1heFdpZHRoOiAnODB2dycsXHJcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAzLFxyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgbWFyZ2luVG9wOiAnNXZoJyxcclxuICAgICAgICBib3hTaGFkb3c6ICcycHggMnB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMyknLFxyXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtYWxlcnQtdGl0bGVcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgYm9yZGVyQm90dG9tOiAnMXB4IHNvbGlkIGxpZ2h0Z3JheScsXHJcbiAgICAgICAgcGFkZGluZzogMixcclxuICAgICAgICBmb250U2l6ZTogMTgsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM1ZTliZmZcIixcclxuICAgICAgICBjb2xvcjogJ3doaXRlJ1xyXG4gICAgfVxyXG59KTtcclxuY29uc3QgZGlhbG9nU3RhY2sgPSBbXTtcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAna2V5ZG93bicsXHJcbiAgICBldnQgPT4ge1xyXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gMjcgJiYgZGlhbG9nU3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBkaWFsb2dTdGFjay5zbGljZSgtMSlbMF0uZXNjYXBlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuY29uc3QgZGlhbG9nID0ge1xyXG4gICAgc2hvdyhkaWFsb2dJbmZvKSB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBjb250ZW50OiBDb250ZW50LFxyXG4gICAgICAgICAgICBwcm9wcyA9IHt9LFxyXG4gICAgICAgICAgICB0aXRsZSA9IG51bGwsXHJcbiAgICAgICAgICAgIGRpc2FibGVFc2NhcGUgPSBmYWxzZSxcclxuICAgICAgICAgICAgYnV0dG9ucyA9IFtcclxuICAgICAgICAgICAgICAgIHt0ZXh0OiBcIk9rXCIsIGNsb3NlOiB0cnVlfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSA9IGRpYWxvZ0luZm87XHJcbiAgICAgICAgY29uc3QgdGl0bGVFbGVtZW50ID0gdGl0bGUgPT09IG51bGxcclxuICAgICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICAgIDogPGRvcmljLWFsZXJ0LXRpdGxlPnt0aXRsZX08L2RvcmljLWFsZXJ0LXRpdGxlPlxyXG5cclxuICAgICAgICBjb25zdCB0cmlnZ2VycyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGRpYWxvZ0J1dHRvbnMgPSBidXR0b25zLm1hcChcclxuICAgICAgICAgICAgKHt0ZXh0LCBjbG9zZSA9IGZhbHNlLCBjbGFzc05hbWUgPSAnJywgdHJpZ2dlciA9IG51bGx9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb25UYXA7XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAoY2xvc2UgPT09IHRydWUpOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblRhcCA9ICgpID0+IGRvYmouY2xvc2UobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICh0cmlnZ2VyICE9PSBudWxsKTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25UYXAgPSAoKSA9PiByZWZbdHJpZ2dlcl0oZG9iai5jbG9zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiA8RG9yaWMuQnV0dG9uIHsuLi57Y2xhc3NOYW1lLCB0ZXh0LCBvblRhcH19IGZpbGwgLz47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IHJlbmRlckVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICBsZXQgcmVzb2x2ZXI7XHJcbiAgICAgICAgY29uc3QgdmFsdWVQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiByZXNvbHZlciA9IHJlc29sdmUpO1xyXG4gICAgICAgIGNvbnN0IGNsb3NlID0gKHZhbHVlID0gbnVsbCkgPT4ge1xyXG4gICAgICAgICAgICBkaWFsb2dTdGFjay5zcGxpY2UoZGlhbG9nU3RhY2suaW5kZXhPZihkb2JqKSwgMSk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocmVuZGVyRWxlbSk7XHJcbiAgICAgICAgICAgIHJlc29sdmVyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZG9iaiA9IHtcclxuICAgICAgICAgICAgZXNjYXBlKHZhbHVlID0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVFc2NhcGUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9zZSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xvc2UsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVByb21pc2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCByZWY7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IChcclxuICAgICAgICAgICAgPGRvcmljLWFsZXJ0LXdyYXBwZXI+XHJcbiAgICAgICAgICAgICAgICA8ZG9yaWMtYWxlcnQ+XHJcbiAgICAgICAgICAgICAgICAgICAge3RpdGxlRWxlbWVudH1cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7bWF4SGVpZ2h0OiAnMzN2aCcsIGJvcmRlckJvdHRvbTogJzFweCBzb2xpZCBsaWdodGdyYXknfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxDb250ZW50IHsuLi5wcm9wc30gey4uLnRyaWdnZXJzfSByZWY9e3NlbGYgPT4gcmVmID0gc2VsZn0gY2xvc2U9e2RvYmouY2xvc2V9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPERvcmljLkdyaWQgY2VsbEhlaWdodD17MzB9IGNvbENvdW50PXtkaWFsb2dCdXR0b25zLmxlbmd0aH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtkaWFsb2dCdXR0b25zfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvRG9yaWMuR3JpZD5cclxuICAgICAgICAgICAgICAgIDwvZG9yaWMtYWxlcnQ+XHJcbiAgICAgICAgICAgIDwvZG9yaWMtYWxlcnQtd3JhcHBlcj5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBkaWFsb2dTdGFjay5wdXNoKGRvYmopO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocmVuZGVyRWxlbSk7XHJcbiAgICAgICAgUmVhY3RET00ucmVuZGVyKGNvbnRhaW5lciwgcmVuZGVyRWxlbSk7XHJcblxyXG4gICAgICAgIHJldHVybiBkb2JqO1xyXG4gICAgfSxcclxuICAgIGNsb3NlVG9wKHZhbHVlID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChkaWFsb2dTdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGRpYWxvZ1N0YWNrLnNsaWNlKC0xKVswXS5jbG9zZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5kaWFsb2cuYWxlcnQgPSAob3B0aW9ucywgLi4ub3RoZXJzKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcclxuICAgICAgICAgICAgdGl0bGU6IG90aGVyc1swXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7bWVzc2FnZSwgdGl0bGUgPSBudWxsfSA9IG9wdGlvbnM7XHJcblxyXG4gICAgcmV0dXJuIGRpYWxvZy5zaG93KHtcclxuICAgICAgICBjb250ZW50OiAoKSA9PiA8ZGl2IHN0eWxlPXt7cGFkZGluZzogMywgdGV4dEFsaWduOiAnY2VudGVyJ319PnttZXNzYWdlfTwvZGl2PixcclxuICAgICAgICB0aXRsZVxyXG4gICAgfSk7XHJcbn07XHJcbmNsYXNzIENvbmZpcm1EaWFsb2dEaXNwbGF5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRydWVSZXNwb25zZSA9IChjbG9zZSkgPT4gY2xvc2UodHJ1ZSlcclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgc3R5bGU9e3twYWRkaW5nOiAzLCB0ZXh0QWxpZ246ICdjZW50ZXInfX0+e3RoaXMucHJvcHMubWVzc2FnZX08L2Rpdj47XHJcbiAgICB9XHJcbn1cclxuZGlhbG9nLmNvbmZpcm0gPSAob3B0aW9ucywgLi4ub3RoZXJzKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcclxuICAgICAgICAgICAgdGl0bGU6IG90aGVyc1swXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7bWVzc2FnZSwgdGl0bGUgPSBudWxsLCBva1RleHQsIGNhbmNlbFRleHR9ID0gb3B0aW9ucztcclxuXHJcbiAgICByZXR1cm4gZGlhbG9nLnNob3coe1xyXG4gICAgICAgIHRpdGxlLFxyXG4gICAgICAgIGJ1dHRvbnM6IFtcclxuICAgICAgICAgICAge3RleHQ6IG9rVGV4dCB8fCBcIk9LXCIsIHRyaWdnZXI6ICd0cnVlUmVzcG9uc2UnfSxcclxuICAgICAgICAgICAge3RleHQ6IGNhbmNlbFRleHQgfHwgXCJDYW5jZWxcIiwgY2xvc2U6IHRydWV9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBjb250ZW50OiBDb25maXJtRGlhbG9nRGlzcGxheSxcclxuICAgICAgICBwcm9wczoge21lc3NhZ2V9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbmNsYXNzIFByb21wdERpYWxvZ0Rpc3BsYXkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt2YWx1ZTogdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWV9O1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmlzaCA9IChjbG9zZSkgPT4gY2xvc2UodGhpcy5zdGF0ZS52YWx1ZSlcclxuICAgIG9uRW50ZXIgPSAoZXZ0KSA9PiB7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy5wcm9wcy5jbG9zZSh0aGlzLnN0YXRlLnZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGZvcm0gb25TdWJtaXQ9e3RoaXMub25FbnRlcn0+XHJcbiAgICAgICAgICAgICAgICA8RG9yaWMuSW5wdXQuVGV4dCBsYWJlbD17dGhpcy5wcm9wcy5sYWJlbH0gdmFsdWU9e3RoaXMuc3RhdGUudmFsdWV9IG9uQ2hhbmdlPXt2YWx1ZSA9PiB0aGlzLnNldFN0YXRlKHt2YWx1ZX0pfSAvPlxyXG4gICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5kaWFsb2cucHJvbXB0ID0gKG9wdGlvbnMsIC4uLm90aGVycykgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXHJcbiAgICAgICAgICAgIHRpdGxlOiBvdGhlcnNbMF1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge21lc3NhZ2UsIHZhbHVlID0gXCJcIiwgdGl0bGUgPSBudWxsLCBva1RleHQsIGNhbmNlbFRleHR9ID0gb3B0aW9ucztcclxuXHJcbiAgICByZXR1cm4gZGlhbG9nLnNob3coe1xyXG4gICAgICAgIHRpdGxlLFxyXG4gICAgICAgIGJ1dHRvbnM6IFtcclxuICAgICAgICAgICAge3RleHQ6IG9rVGV4dCB8fCBcIk9LXCIsIHRyaWdnZXI6ICdmaW5pc2gnfSxcclxuICAgICAgICAgICAge3RleHQ6IGNhbmNlbFRleHQgfHwgXCJDYW5jZWxcIiwgY2xvc2U6IHRydWV9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBjb250ZW50OiBQcm9tcHREaWFsb2dEaXNwbGF5LFxyXG4gICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICAgIGxhYmVsOiBtZXNzYWdlLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmRpYWxvZy5zcGlubmVyID0gKG1lc3NhZ2UpID0+IGRpYWxvZy5zaG93KHtcclxuICAgIGNvbnRlbnQ6ICgpID0+IDxkaXYgc3R5bGU9e3t0ZXh0QWxpZ246ICdjZW50ZXInfX0+e21lc3NhZ2V9PERvcmljLkltYWdlIHdpZHRoPVwiMTAwJVwiIGhlaWdodD17MzB9IHNvdXJjZT17c3Bpbm5lckdJRn0gLz48L2Rpdj4sXHJcbiAgICBidXR0b25zOiBbXSxcclxuICAgIGRpc2FibGVFc2NhcGU6IHRydWVcclxufSlcclxuXHJcbndpbmRvdy5kaWFsb2cgPSBkaWFsb2c7XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgY29tcG9uZW50U3R5bGVTaGVldCBmcm9tICdzb3VyY2UvdXRpbC9hcHAnO1xyXG5cclxuY29tcG9uZW50U3R5bGVTaGVldC5hZGRTdHlsZXMoe1xyXG4gICAgXCJkb3JpYy1mb3JtLCBkb3JpYy1mb3JtLWxheW91dFwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtYnV0dG9uLmZvcm0tYnV0dG9uXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiBbXCItd2Via2l0LWZsZXhcIiwgXCJmbGV4XCJdLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM0Mjg1ZjQnLFxyXG4gICAgICAgIGNvbG9yOiAnd2hpdGUnXHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBGb3JtTGF5b3V0ID0gKHtzdHlsZSwgY2hpbGRyZW59KSA9PiA8ZG9yaWMtZm9ybS1sYXlvdXQgc3R5bGU9e3N0eWxlfT57Y2hpbGRyZW59PC9kb3JpYy1mb3JtLWxheW91dD47XHJcbkZvcm1MYXlvdXQuRm9ybUl0ZW0gPSAoe2NoaWxkcmVuLCAuLi5wcm9wc30pID0+IDxkaXYgey4uLnByb3BzfT57Y2hpbGRyZW59PC9kaXY+O1xyXG5jbGFzcyBGb3JtVXBkYXRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge3ZhbHVlOiB1bmRlZmluZWR9O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlID0gKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWV9KTtcclxuICAgICAgICB0aGlzLnByb3BzLnVwZGF0ZSh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHtUeXBlLCBwcm9wcywgdmFsdWVOYW1lLCB2YWx1ZUNoYW5nZWQsIGRlZmF1bHRWYWx1ZX0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGxldCB7dmFsdWV9ID0gdGhpcy5zdGF0ZTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBmb3JtUHJvcHMgPSB7XHJcbiAgICAgICAgICAgIFt2YWx1ZU5hbWVdOiB2YWx1ZSxcclxuICAgICAgICAgICAgW3ZhbHVlQ2hhbmdlZF06IHRoaXMudXBkYXRlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIDxUeXBlIHsuLi5wcm9wc30gey4uLmZvcm1Qcm9wc30gLz47XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRm9ybSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnZhbHVlcyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHN1Ym1pdCA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7b25TdWJtaXQgPSAoKCkgPT4ge30pfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIG9uU3VibWl0KHRoaXMudmFsdWVzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge3N1Ym1pdFRleHQgPSBcIlN1Ym1pdFwiLCBsYXlvdXQ6TGF5b3V0ID0gRm9ybUxheW91dH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGNvbnN0IHt2YWx1ZXN9ID0gdGhpcztcclxuICAgICAgICBjb25zdCBsYXlvdXRQcm9wcyA9IE9iamVjdFxyXG4gICAgICAgICAgICAua2V5cyh0aGlzLnByb3BzKVxyXG4gICAgICAgICAgICAucmVkdWNlKFxyXG4gICAgICAgICAgICAgICAgKG5ld1Byb3BzLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJsYXlvdXQtXCIpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2tleS5zbGljZSg3KV0gPSB0aGlzLnByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdQcm9wcztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7fVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBJdGVtID0gTGF5b3V0LkZvcm1JdGVtIHx8IEZvcm1MYXlvdXQuRm9ybUl0ZW07XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYXlDaGlsZHJlbiA9IGNoaWxkcmVuLm1hcChcclxuICAgICAgICAgICAgY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNoaWxkLnByb3BzLmZvcm1OYW1lO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge2RlZmF1bHRWYWx1ZX0gPSBjaGlsZC5wcm9wcztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlTmFtZSA9IGNoaWxkLnR5cGUuZm9ybVZhbHVlIHx8ICd2YWx1ZSc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUNoYW5nZWQgPSBjaGlsZC50eXBlLmZvcm1WYWx1ZUNoYW5nZWQgfHwgXCJvbkNoYW5nZVwiO1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgVHlwZSA9IGNoaWxkLnR5cGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2hpbGQucHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGF5b3V0UHJvcHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUHJvcHMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKFwibGF5b3V0LVwiKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRQcm9wc1trZXkuc2xpY2UoNyldID0gY2hpbGQucHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BzW2tleV0gPSBjaGlsZC5wcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVDaGFuZ2VkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHZhbHVlID0+IHRoaXMudmFsdWVzW25hbWVdID0gdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGNoaWxkUHJvcHNcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICA8SXRlbSB7Li4ubGF5b3V0UHJvcHN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Rm9ybVVwZGF0ZXIgey4uLnVwZGF0ZXJQcm9wc30gLz5cclxuICAgICAgICAgICAgICAgICAgICA8L0l0ZW0+XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRvcmljLWZvcm0gc3R5bGU9e3RoaXMucHJvcHMuc3R5bGV9IGNsYXNzPXt0aGlzLnByb3BzLmNsYXNzTmFtZX0+XHJcbiAgICAgICAgICAgICAgICA8TGF5b3V0IHsuLi5sYXlvdXRQcm9wc30+XHJcbiAgICAgICAgICAgICAgICAgICAge2Rpc3BsYXlDaGlsZHJlbn1cclxuICAgICAgICAgICAgICAgIDwvTGF5b3V0PlxyXG4gICAgICAgICAgICAgICAgPERvcmljLkJ1dHRvbiB0ZXh0PXtzdWJtaXRUZXh0fSBjbGFzc05hbWU9XCJmb3JtLWJ1dHRvblwiIG9uVGFwPXt0aGlzLnN1Ym1pdH0gcmFpc2VkIC8+XHJcbiAgICAgICAgICAgIDwvZG9yaWMtZm9ybT5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGb3JtO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtZ3JpZFwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICBvdmVyZmxvdzogJ2F1dG8nXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1ncmlkLWl0ZW1cIjoge1xyXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxyXG4gICAgICAgIG1hcmdpbjogMCxcclxuICAgICAgICBwYWRkaW5nOiAwLFxyXG4gICAgICAgIGJvcmRlcldpZHRoOiAwLFxyXG4gICAgICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxyXG4gICAgICAgIGJvcmRlckNvbG9yOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgIC8vIG92ZXJmbG93OiAnaGlkZGVuJyxcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICBmbG9hdDogJ2xlZnQnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1yYWRpby1pdGVtXCI6IHtcclxuICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgIGRpc3BsYXk6IFsnLXdlYmtpdC1mbGV4JywgJ2ZsZXgnXSxcclxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXHJcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcidcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXJhZGlvLWl0ZW1bc2VsZWN0ZWQ9J3RydWUnXVwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3lhbidcclxuICAgIH1cclxufSk7XHJcblxyXG5jb25zdCBHcmlkID0gcHJvcHMgPT4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIGNlbGxTcGFjaW5nID0gWzAsIDBdLFxyXG4gICAgICAgIGNlbGxIZWlnaHQgPSAzMCxcclxuICAgICAgICBjb2xDb3VudCA9IDEyLFxyXG4gICAgICAgIHN0eWxlID0ge30sXHJcbiAgICAgICAgY2xhc3NOYW1lXHJcbiAgICB9ID0gcHJvcHM7XHJcbiAgICBjb25zdCBbY2VsbFNwYWNpbmdILCBjZWxsU3BhY2luZ1ZdID0gKHR5cGVvZiBjZWxsU3BhY2luZyA9PT0gJ251bWJlcicpID8gW2NlbGxTcGFjaW5nLCBjZWxsU3BhY2luZ10gOiBjZWxsU3BhY2luZztcclxuICAgIGNvbnN0IGdyaWRTdHlsZSA9IHtcclxuICAgICAgICAuLi5zdHlsZSxcclxuICAgICAgICBwYWRkaW5nTGVmdDogY2VsbFNwYWNpbmdILFxyXG4gICAgICAgIHBhZGRpbmdUb3A6IGNlbGxTcGFjaW5nVlxyXG4gICAgfTtcclxuICAgIGNvbnN0IGJhc2VJdGVtU3R5bGUgPSB7XHJcbiAgICAgICAgYm9yZGVyV2lkdGg6IGAke2NlbGxTcGFjaW5nVn1weCAke2NlbGxTcGFjaW5nSH1weGBcclxuICAgIH07XHJcbiAgICBsZXQge2NoaWxkcmVufSA9IHByb3BzO1xyXG5cclxuICAgIGlmIChjZWxsSGVpZ2h0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgYmFzZUl0ZW1TdHlsZS5oZWlnaHQgPSBjZWxsSGVpZ2h0ICsgY2VsbFNwYWNpbmdWICogMjtcclxuICAgIH1cclxuXHJcbiAgICBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xyXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5tYXAoXHJcbiAgICAgICAgY2hpbGQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7Y29sU3BhbiA9IDEsIC4uLmNoaWxkUHJvcHN9ID0gY2hpbGQucHJvcHM7XHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gYGNhbGMoJHsoY29sU3BhbiAqIDEwMCkgLyBjb2xDb3VudH0lICsgJHtjZWxsU3BhY2luZ0h9cHgpYDtcclxuICAgICAgICAgICAgY29uc3QgbWFyZ2luTGVmdCA9IC1jZWxsU3BhY2luZ0g7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmdpblRvcCA9IC1jZWxsU3BhY2luZ1Y7XHJcbiAgICAgICAgICAgIHJldHVybiA8ZG9yaWMtZ3JpZC1pdGVtIHN0eWxlPXt7Li4uYmFzZUl0ZW1TdHlsZSwgd2lkdGgsIG1hcmdpblRvcCwgbWFyZ2luTGVmdH19PjxjaGlsZC50eXBlIHsuLi5jaGlsZFByb3BzfSByZWY9e2NoaWxkLnJlZn0gLz48L2RvcmljLWdyaWQtaXRlbT47XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkb3JpYy1ncmlkIHN0eWxlPXtncmlkU3R5bGV9IGNsYXNzPXtjbGFzc05hbWV9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9kb3JpYy1ncmlkPlxyXG4gICAgKTtcclxufTtcclxuXHJcbkdyaWQuUmFkaW9JdGVtID0gKHtjaGlsZHJlbiwgc2VsZWN0ZWQsIGl0ZW1TdHlsZSA9IHt9fSkgPT4gKFxyXG4gICAgPGRvcmljLXJhZGlvLWl0ZW0gc2VsZWN0ZWQ9e3NlbGVjdGVkfSBzdHlsZT17aXRlbVN0eWxlfT5cclxuICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L2RvcmljLXJhZGlvLWl0ZW0+XHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHcmlkO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IEJ1dHRvbiBmcm9tICdzb3VyY2UvY29tcG9uZW50L2J1dHRvbic7XHJcblxyXG5pbXBvcnQgY29tcG9uZW50U3R5bGVTaGVldCBmcm9tICdzb3VyY2UvdXRpbC9hcHAnO1xyXG5pbXBvcnQgaWNvbnMgZnJvbSAnc291cmNlL3V0aWwvaWNvbnMnO1xyXG5cclxuY29tcG9uZW50U3R5bGVTaGVldC5hZGRTdHlsZXMoe1xyXG4gICAgXCJkb3JpYy1pY29uXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lJyxcclxuICAgICAgICBmb250U2l6ZTogMTYsXHJcbiAgICAgICAgZm9udEZhbWlseTogXCJJb25pY1wiLFxyXG4gICAgICAgIHBhZGRpbmc6IDJcclxuICAgIH1cclxufSk7XHJcbmNvbnN0IEljb24gPSAoe2ljb24sIGNsYXNzTmFtZSwgLi4ucGFzc1Rocm91Z2h9KSA9PiA8ZG9yaWMtaWNvbiB7Li4ucGFzc1Rocm91Z2h9IGNsYXNzPXtjbGFzc05hbWV9PntpY29uc1tpY29uXX08L2RvcmljLWljb24+O1xyXG5jb25zdCBJY29uQnV0dG9uID0gKHtpY29uLCBpY29uU3R5bGUsIHRleHQgPSBcIlwiLCBjaGlsZHJlbiwgLi4ucHJvcHN9KSA9PiA8QnV0dG9uIHsuLi5wcm9wc30gdGV4dD17PEljb24gaWNvbj17aWNvbn0gc3R5bGU9e2ljb25TdHlsZX0gLz59Pnt0ZXh0fXtjaGlsZHJlbn08L0J1dHRvbj47XHJcblxyXG5leHBvcnQge0ljb24sIEljb25CdXR0b259O1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtaW1hZ2VcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxyXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6ICduby1yZXBlYXQnLFxyXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogJ2NlbnRlciBjZW50ZXInLFxyXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnXHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBJbWFnZSA9ICh7c291cmNlLCBjb3ZlciA9IGZhbHNlLCBjb250YWluID0gZmFsc2UsIHdpZHRoID0gbnVsbCwgaGVpZ2h0ID0gbnVsbCwgc3R5bGUgPSB7fSwgLi4ucGFzc1Rocm91Z2h9KSA9PiB7XHJcbiAgICBsZXQgYmdTaXplID0gJ2NvbnRhaW4nO1xyXG5cclxuICAgIGlmIChjb3ZlciA9PT0gdHJ1ZSAmJiBjb250YWluID09PSBmYWxzZSkge1xyXG4gICAgICAgIGJnU2l6ZSA9ICdjb3Zlcic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDxkb3JpYy1pbWFnZSBzdHlsZT17ey4uLnN0eWxlLCBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoXCIke3NvdXJjZX1cIilgLCB3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kU2l6ZTogYmdTaXplfX0gey4uLnBhc3NUaHJvdWdofSAvPjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEltYWdlO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuaW1wb3J0IGNvbnN0cyBmcm9tICdzb3VyY2UvdXRpbC9jb25zdHMnO1xyXG5cclxuaW1wb3J0IEN1c3RvbUV2ZW50cyBmcm9tIFwic291cmNlL2NvbXBvbmVudC9DdXN0b21FdmVudHNcIjtcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtaW5wdXRcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgbWFyZ2luOiAzLFxyXG4gICAgICAgIHBhZGRpbmdUb3A6IDIyLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcclxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtaW5wdXQgPiBpbnB1dFwiOiB7XHJcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICBib3JkZXJXaWR0aDogMCxcclxuICAgICAgICBwYWRkaW5nOiA1LFxyXG4gICAgICAgIGJvcmRlckJvdHRvbTogYDJweCBzb2xpZCAke2NvbnN0cy50aGVtZS5ncmF5Qkd9YCxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgekluZGV4OiBcIisxXCJcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWlucHV0ID4gaW5wdXQ6Zm9jdXNcIjoge1xyXG4gICAgICAgIG91dGxpbmU6ICdub25lJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtaW5wdXQgPiBkb3JpYy1pbnB1dC1sYWJlbFwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgcGFkZGluZ0xlZnQ6IDIsXHJcbiAgICAgICAgaGVpZ2h0OiAyMixcclxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICdsZWZ0IHRvcCcsXHJcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsIDNweCkgc2NhbGUoMC44NSknLFxyXG4gICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMTUwbXMgbGluZWFyJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtaW5wdXQgPiBpbnB1dDpmb2N1cyB+IGRvcmljLWlucHV0LWxhYmVsOm5vdChbcGxhY2Vob2xkZXJdKVwiOiB7XHJcbiAgICAgICAgY29sb3I6ICcjNDM1ZGVjJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtaW5wdXQgPiBkb3JpYy1pbnB1dC1sYWJlbFtwbGFjZWhvbGRlcl1cIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSg1cHgsIDEwMCUpJyxcclxuICAgICAgICBjb2xvcjogJ2dyYXknXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1pbnB1dCA+IGlucHV0ICsgZG9yaWMtaW5wdXQtZmxvdXJpc2hcIjoge1xyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIGhlaWdodDogMixcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbnN0cy50aGVtZS5ibHVpc2gsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICByaWdodDogMCxcclxuICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGVYKDApJyxcclxuICAgICAgICB6SW5kZXg6IFwiKzJcIlxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtaW5wdXQgPiBpbnB1dDpmb2N1cyArIGRvcmljLWlucHV0LWZsb3VyaXNoXCI6IHtcclxuICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIDEwMG1zIGxpbmVhcicsXHJcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGVYKDEpJ1xyXG4gICAgfVxyXG59KTtcclxuY2xhc3MgVGV4dElucHV0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlciA9ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gXCJcIixcclxuICAgICAgICAgICAgdHlwZSA9IFwidGV4dFwiLFxyXG4gICAgICAgICAgICBsYWJlbCA9IG51bGxcclxuICAgICAgICB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCBsYWJlbFByb3BzID0ge1xyXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSBudWxsKSA/IFwiXCIgOiBudWxsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwb2MgPSB0aGlzLnByb3BzLm9uQ2hhbmdlIHx8ICgoKSA9PiB7fSk7XHJcbiAgICAgICAgY29uc3Qgb25DaGFuZ2UgPSBldnQgPT4gcG9jKGV2dC50YXJnZXQudmFsdWUsIGV2dCk7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxDdXN0b21FdmVudHMgY29tcG9uZW50PVwiZG9yaWMtaW5wdXRcIiBvblRhcD17KCkgPT4gdGhpcy5yZWZzLnRleHRJbnB1dC5mb2N1cygpfT5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCB7Li4ue3R5cGUsIG9uQ2hhbmdlLCB2YWx1ZX19IHJlZj1cInRleHRJbnB1dFwiIC8+XHJcbiAgICAgICAgICAgICAgICA8ZG9yaWMtaW5wdXQtZmxvdXJpc2ggLz5cclxuICAgICAgICAgICAgICAgIDxkb3JpYy1pbnB1dC1sYWJlbCB7Li4ubGFiZWxQcm9wc30+e2xhYmVsfTwvZG9yaWMtaW5wdXQtbGFiZWw+XHJcbiAgICAgICAgICAgIDwvQ3VzdG9tRXZlbnRzPlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtaW5wdXQtbXVsdGlsaW5lXCI6IHtcclxuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgICAgIG1hcmdpbjogMyxcclxuICAgICAgICBwYWRkaW5nVG9wOiAyMixcclxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWlucHV0LW11bHRpbGluZSA+IHRleHRhcmVhXCI6IHtcclxuICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgIGJvcmRlcldpZHRoOiAxLFxyXG4gICAgICAgIGJvcmRlckNvbG9yOiAnbGlnaHRncmF5JyxcclxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcclxuICAgICAgICBwYWRkaW5nOiAzLFxyXG4gICAgICAgIG1hcmdpbjogMCxcclxuICAgICAgICBib3JkZXJCb3R0b206IGAycHggc29saWQgI2QwZDBkMGAsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHpJbmRleDogXCIrMVwiLFxyXG4gICAgICAgIHJlc2l6ZTogJ25vbmUnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1pbnB1dC1tdWx0aWxpbmUgPiB0ZXh0YXJlYTpmb2N1c1wiOiB7XHJcbiAgICAgICAgb3V0bGluZTogJ25vbmUnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1pbnB1dC1tdWx0aWxpbmUgPiB0ZXh0YXJlYTpmb2N1cyB+IGRvcmljLWlucHV0LWxhYmVsOm5vdChbcGxhY2Vob2xkZXJdKVwiOiB7XHJcbiAgICAgICAgY29sb3I6ICcjNDM1ZGVjJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtaW5wdXQtbXVsdGlsaW5lID4gZG9yaWMtaW5wdXQtbGFiZWxcIjoge1xyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHBhZGRpbmdMZWZ0OiAyLFxyXG4gICAgICAgIGhlaWdodDogMjIsXHJcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnbGVmdCB0b3AnLFxyXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLCAzcHgpIHNjYWxlKDAuODUpJyxcclxuICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIDE1MG1zIGxpbmVhcidcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWlucHV0LW11bHRpbGluZSA+IGRvcmljLWlucHV0LWxhYmVsW3BsYWNlaG9sZGVyXVwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDVweCwgMTAwJSknLFxyXG4gICAgICAgIGNvbG9yOiAnZ3JheSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWlucHV0LW11bHRpbGluZSA+IHRleHRhcmVhICsgZG9yaWMtaW5wdXQtbXVsdGlsaW5lLWZsb3VyaXNoXCI6IHtcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICBoZWlnaHQ6IDIsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzQyODVmNCcsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICByaWdodDogMCxcclxuICAgICAgICBib3R0b206IDAsXHJcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGVYKDApJyxcclxuICAgICAgICB6SW5kZXg6IFwiKzJcIlxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtaW5wdXQtbXVsdGlsaW5lID4gdGV4dGFyZWE6Zm9jdXMgKyBkb3JpYy1pbnB1dC1tdWx0aWxpbmUtZmxvdXJpc2hcIjoge1xyXG4gICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMTAwbXMgbGluZWFyJyxcclxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVgoMSknXHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBNdWx0aWxpbmVJbnB1dCA9IChwcm9wcykgPT4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIGxhYmVsID0gbnVsbCxcclxuICAgICAgICBsaW5lcyA9IDNcclxuICAgIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IGxhYmVsUHJvcHMgPSB7XHJcbiAgICAgICAgcGxhY2Vob2xkZXI6ICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PT0gbnVsbCkgPyBcIlwiIDogbnVsbFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBvYyA9IHByb3BzLm9uQ2hhbmdlIHx8ICgoKSA9PiB7fSk7XHJcbiAgICBjb25zdCBvbkNoYW5nZSA9IGV2dCA9PiBwb2MoZXZ0LnRhcmdldC52YWx1ZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8Q3VzdG9tRXZlbnRzIGNvbXBvbmVudD1cImRvcmljLWlucHV0LW11bHRpbGluZVwiPlxyXG4gICAgICAgICAgICA8dGV4dGFyZWEgdmFsdWU9e3ZhbHVlfSBvbkNoYW5nZT17b25DaGFuZ2V9IHJvd3M9e2xpbmVzfSAvPlxyXG4gICAgICAgICAgICA8ZG9yaWMtaW5wdXQtbXVsdGlsaW5lLWZsb3VyaXNoIC8+XHJcbiAgICAgICAgICAgIDxkb3JpYy1pbnB1dC1sYWJlbCB7Li4ubGFiZWxQcm9wc30+e2xhYmVsfTwvZG9yaWMtaW5wdXQtbGFiZWw+XHJcbiAgICAgICAgPC9DdXN0b21FdmVudHM+XHJcbiAgICApO1xyXG59O1xyXG5cclxuY29uc3QgSW5wdXQgPSB7XHJcbiAgICBUZXh0OiBwcm9wcyA9PiA8VGV4dElucHV0IHsuLi5wcm9wc30gdHlwZT1cInRleHRcIiAvPixcclxuICAgIFBhc3N3b3JkOiBwcm9wcyA9PiA8VGV4dElucHV0IHsuLi5wcm9wc30gdHlwZT1cInBhc3N3b3JkXCIgLz4sXHJcbiAgICBTZWFyY2g6IHByb3BzID0+IDxUZXh0SW5wdXQgey4uLnByb3BzfSB0eXBlPVwic2VhcmNoXCIgLz4sXHJcbiAgICBVUkw6IHByb3BzID0+IDxUZXh0SW5wdXQgey4uLnByb3BzfSB0eXBlPVwidXJsXCIgLz4sXHJcbiAgICBFbWFpbDogcHJvcHMgPT4gPFRleHRJbnB1dCB7Li4ucHJvcHN9IHR5cGU9XCJlbWFpbFwiIC8+LFxyXG4gICAgTnVtYmVyOiBwcm9wcyA9PiA8VGV4dElucHV0IHsuLi5wcm9wc30gdHlwZT1cIm51bWJlclwiIC8+LFxyXG4gICAgTXVsdGlsaW5lOiBNdWx0aWxpbmVJbnB1dFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW5wdXQ7XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgY29tcG9uZW50U3R5bGVTaGVldCBmcm9tICdzb3VyY2UvdXRpbC9hcHAnO1xyXG5cclxuY29tcG9uZW50U3R5bGVTaGVldC5hZGRTdHlsZXMoe1xyXG4gICAgXCJkb3JpYy1waW5ib2FyZFwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtcGluXCI6IHtcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xyXG4gICAgfVxyXG59KTtcclxuY29uc3QgUGluYm9hcmQgPSAoe3N0eWxlID0ge30sIHdpZHRoID0gXCIxMDAlXCIsIGhlaWdodCA9IFwiMTAwJVwiLCBjbGFzc05hbWUgPSBcIlwiLCBjaGlsZHJlbiwgLi4ucGFzc1Rocm91Z2h9KSA9PiB7XHJcbiAgICBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xyXG5cclxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ubWFwKFxyXG4gICAgICAgIChjaGlsZCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qge3BpblN0eWxlLCAuLi5jaGlsZFByb3BzfSA9IGNoaWxkLnByb3BzO1xyXG4gICAgICAgICAgICBjb25zdCBhY3R1YWxDaGlsZCA9IDxjaGlsZC50eXBlIHsuLi5jaGlsZFByb3BzfSByZWY9e2NoaWxkLnJlZn0gLz47XHJcbiAgICAgICAgICAgIHJldHVybiA8ZG9yaWMtcGluIGtleT17aW5kZXh9IHN0eWxlPXtwaW5TdHlsZX0+e2FjdHVhbENoaWxkfTwvZG9yaWMtcGluPjtcclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiA8ZG9yaWMtcGluYm9hcmQgY2xhc3M9e2NsYXNzTmFtZX0gc3R5bGU9e3suLi5zdHlsZSwgd2lkdGgsIGhlaWdodH19PntjaGlsZHJlbn08L2RvcmljLXBpbmJvYXJkPjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBpbmJvYXJkO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtcHJvZ3Jlc3NcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgaGVpZ2h0OiAxMCxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2UwZTBlMFwiLFxyXG4gICAgICAgIG1hcmdpblRvcDogMTAsXHJcbiAgICAgICAgbWFyZ2luQm90dG9tOiAxMCxcclxuICAgICAgICBtYXJnaW5MZWZ0OiA1LFxyXG4gICAgICAgIG1hcmdpblJpZ2h0OiA1LFxyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1wcm9ncmVzcy1iYXJcIjoge1xyXG4gICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnbGVmdCBjZW50ZXInLFxyXG4gICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gMjAwbXMgZWFzZS1vdXQnLFxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtcHJvZ3Jlc3MtYmFyLnByaW1hcnlcIjoge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM0Mjg1ZjQnLFxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtcHJvZ3Jlc3MtYmFyLnNlY29uZGFyeVwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2IzY2VmYicsXHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBQcm9ncmVzcyA9ICh7cHJvZ3Jlc3MsIHNlY29uZGFyeVByb2dyZXNzID0gbnVsbCwgY2xhc3NOYW1lLCBjaGlsZHJlbiwgLi4ucGFzc1Rocm91Z2h9KSA9PiB7XHJcbiAgICBjb25zdCBzY2FsZSA9IGBzY2FsZVgoJHtwcm9ncmVzc30pYDtcclxuICAgIGxldCBzZWNvbmRhcnlQcm9ncmVzc0JhciA9IG51bGw7XHJcblxyXG4gICAgaWYgKHNlY29uZGFyeVByb2dyZXNzICE9PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3Qgc2NhbGUyID0gYHNjYWxlWCgke3NlY29uZGFyeVByb2dyZXNzfSlgO1xyXG4gICAgICAgIHNlY29uZGFyeVByb2dyZXNzQmFyID0gPGRvcmljLXByb2dyZXNzLWJhciBjbGFzcz1cInNlY29uZGFyeVwiIHN0eWxlPXt7V2Via2l0VHJhbnNmb3JtOiBzY2FsZTIsIHRyYW5zZm9ybTogc2NhbGUyfX0gLz5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkb3JpYy1wcm9ncmVzcyBjbGFzcz17Y2xhc3NOYW1lfSB7Li4ucGFzc1Rocm91Z2h9PlxyXG4gICAgICAgICAgICB7c2Vjb25kYXJ5UHJvZ3Jlc3NCYXJ9XHJcbiAgICAgICAgICAgIDxkb3JpYy1wcm9ncmVzcy1iYXIgY2xhc3M9XCJwcmltYXJ5XCIgc3R5bGU9e3tXZWJraXRUcmFuc2Zvcm06IHNjYWxlLCB0cmFuc2Zvcm06IHNjYWxlfX0gLz5cclxuICAgICAgICA8L2RvcmljLXByb2dyZXNzPlxyXG4gICAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFByb2dyZXNzO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuaW1wb3J0IHtDU1N9IGZyb20gJ3NvdXJjZS91dGlsL3N0eWxlc2hlZXQnO1xyXG5cclxuY29uc3QgYW5pbVRpbWUgPSAyMDA7XHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiZG9yaWMtc2NyZWVuXCI6IHtcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgIGhlaWdodDogJzEwMCUnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1zY3JlZW4tdGl0bGVcIjoge1xyXG4gICAgICAgIGRpc3BsYXk6IFsnd2Via2l0LWZsZXgnLCAnZmxleCddLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM0Mjg1ZjQnLFxyXG4gICAgICAgIGNvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgaGVpZ2h0OiA0MCxcclxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXHJcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXHJcbiAgICAgICAgYm94U2hhZG93OiAnMCAycHggMnB4IDAgcmdiYSgwLCAwLCAwLCAwLjI1KScsXHJcbiAgICAgICAgZm9udFNpemU6IDIwLFxyXG4gICAgICAgIHpJbmRleDogJys1JyxcclxuICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1zY3JlZW4tY29udGVudFwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiA0MCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICBvdmVyZmxvdzogJ2F1dG8nXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1zY3JlZW4tbWVudVwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiA0MCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICByaWdodDogMCxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENTUy5yZ2JhKDAsIDAsIDAsIDAuMiksXHJcbiAgICAgICAgYm94U2hhZG93OiAnMCAycHggMnB4IDAgcmdiYSgwLCAwLCAwLCAwLjI1KScsXHJcbiAgICAgICAgekluZGV4OiAnKzUnLFxyXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTEwMCUpJyxcclxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgICAgb3BhY2l0eTogMCxcclxuICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke2FuaW1UaW1lfW1zIGxpbmVhciwgdHJhbnNmb3JtIDBtcyBsaW5lYXIgMjUwbXNgXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1zY3JlZW4tbWVudSA+IGRpdlwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtMTAwJSknLFxyXG4gICAgICAgIHRyYW5zaXRpb246IGB0cmFuc2Zvcm0gJHthbmltVGltZX1tcyBsaW5lYXJgXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1zY3JlZW4tbWVudVt2aXNpYmxlPSd0cnVlJ11cIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknLFxyXG4gICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHthbmltVGltZX1tcyBsaW5lYXJgXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1zY3JlZW4tbWVudVt2aXNpYmxlPSd0cnVlJ10gPiBkaXZcIjoge1xyXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMCUpJ1xyXG4gICAgfSxcclxuICAgIFwiLmRvcmljLXNjcmVlbi1tZW51LWJ1dHRvblwiOiB7XHJcbiAgICAgICAgd2lkdGg6IDQ1LFxyXG4gICAgICAgIGhlaWdodDogNDAsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIGNvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgIGJvcmRlclJhZGl1czogMCxcclxuICAgICAgICBtYXJnaW46IDBcclxuICAgIH0sXHJcbiAgICBcIi5kb3JpYy1zY3JlZW4tYmFjay1idXR0b25cIjoge1xyXG4gICAgICAgIGhlaWdodDogNDAsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgY29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxyXG4gICAgICAgIG1hcmdpbjogMCxcclxuICAgICAgICBmb250U2l6ZTogMTRcclxuICAgIH1cclxufSk7XHJcbmNsYXNzIFNjcmVlbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge2V4cGFuZGVkOiBmYWxzZX07XHJcbiAgICB9XHJcblxyXG4gICAgdG9nZ2xlID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBleHBhbmRlZDogIXRoaXMuc3RhdGUuZXhwYW5kZWRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgICAgbWVudSA9IG51bGwsXHJcbiAgICAgICAgICAgIGJhY2tUZXh0ID0gbnVsbFxyXG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGxldCB7XHJcbiAgICAgICAgICAgIG9uQmFjayA9IG51bGxcclxuICAgICAgICB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIGV4cGFuZGVkXHJcbiAgICAgICAgfSA9IHRoaXMuc3RhdGU7XHJcblxyXG4gICAgICAgIGxldCBtZW51QnV0dG9uID0gbnVsbDtcclxuICAgICAgICBsZXQgYmFja0J1dHRvbiA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChvbkJhY2sgIT09IG51bGwgfHwgYmFja1RleHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgb25CYWNrID0gb25CYWNrIHx8ICgoKSA9PiBBcHAubmF2LnBvcCgpKTtcclxuICAgICAgICAgICAgYmFja0J1dHRvbiA9IDxEb3JpYy5JY29uQnV0dG9uIGljb249XCJpb24tY2hldnJvbi1sZWZ0XCIgdGV4dD17YmFja1RleHR9IGNsYXNzTmFtZT1cImRvcmljLXNjcmVlbi1iYWNrLWJ1dHRvblwiIG9uVGFwPXtvbkJhY2t9IC8+O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1lbnUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgbWVudUJ1dHRvbiA9IDxEb3JpYy5JY29uQnV0dG9uIGNsYXNzTmFtZT1cImRvcmljLXNjcmVlbi1tZW51LWJ1dHRvblwiIGljb249XCJpb24tbmF2aWNvblwiIG9uVGFwPXt0aGlzLnRvZ2dsZX0gaWNvblN0eWxlPXt7Zm9udFNpemU6IDI4fX0gLz47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZG9yaWMtc2NyZWVuPlxyXG4gICAgICAgICAgICAgICAgPGRvcmljLXNjcmVlbi10aXRsZT5cclxuICAgICAgICAgICAgICAgICAgICB7dGl0bGV9XHJcbiAgICAgICAgICAgICAgICAgICAge2JhY2tCdXR0b259XHJcbiAgICAgICAgICAgICAgICAgICAge21lbnVCdXR0b259XHJcbiAgICAgICAgICAgICAgICA8L2RvcmljLXNjcmVlbi10aXRsZT5cclxuICAgICAgICAgICAgICAgIDxkb3JpYy1zY3JlZW4tbWVudSB2aXNpYmxlPXtleHBhbmRlZH0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17e2JhY2tncm91bmRDb2xvcjogJyM0Mjg1ZjQnLCBwb3NpdGlvbjogJ2Fic29sdXRlJywgd2lkdGg6ICcxMDAlJ319PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7bWVudX1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvZG9yaWMtc2NyZWVuLW1lbnU+XHJcbiAgICAgICAgICAgICAgICA8ZG9yaWMtc2NyZWVuLWNvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICA8L2RvcmljLXNjcmVlbi1jb250ZW50PlxyXG4gICAgICAgICAgICA8L2RvcmljLXNjcmVlbj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTY3JlZW47XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgY29tcG9uZW50U3R5bGVTaGVldCBmcm9tICdzb3VyY2UvdXRpbC9hcHAnO1xyXG5pbXBvcnQgY29uc3RzIGZyb20gJ3NvdXJjZS91dGlsL2NvbnN0cyc7XHJcblxyXG5pbXBvcnQgQ3VzdG9tRXZlbnRzIGZyb20gXCJzb3VyY2UvY29tcG9uZW50L0N1c3RvbUV2ZW50c1wiO1xyXG5cclxuY29uc3QgZmluZCA9IEFycmF5LnByb3RvdHlwZS5maW5kO1xyXG5jb21wb25lbnRTdHlsZVNoZWV0LmFkZFN0eWxlcyh7XHJcbiAgICBcImRvcmljLXNsaWRlclwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICBtYXJnaW46IDNcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXNsaWRlci1jb250ZW50XCI6IHtcclxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGhlaWdodDogMzAsXHJcbiAgICAgICAgbWFyZ2luOiAyXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy1zbGlkZXItdHJhY2tcIjoge1xyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogMTMsXHJcbiAgICAgICAgbGVmdDogMTIsXHJcbiAgICAgICAgcmlnaHQ6IDEyLFxyXG4gICAgICAgIGhlaWdodDogNCxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbnN0cy50aGVtZS5ncmF5QkcsXHJcbiAgICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtc2xpZGVyLXRyYWNrLWZpbGxcIjoge1xyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb25zdHMudGhlbWUuYmx1aXNoLFxyXG4gICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ2xlZnQgY2VudGVyJyxcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXNsaWRlci10aHVtYlwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAyLFxyXG4gICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnLFxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtc2xpZGVyLXRyYWNrLWNpcmNsZVwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICB3aWR0aDogMjAsXHJcbiAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgICBib3JkZXJSYWRpdXM6IDE1LFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29uc3RzLnRoZW1lLmJsdWlzaCxcclxuICAgICAgICBib3hTaGFkb3c6ICcxcHggMXB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMjUpJyxcclxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknLFxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtc2xpZGVyLXZhbHVlXCI6IHtcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICB3aWR0aDogMzAsXHJcbiAgICAgICAgaGVpZ2h0OiAyMCxcclxuICAgICAgICBmb250U2l6ZTogMTAsXHJcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICBsaW5lSGVpZ2h0OiAnMjBweCcsXHJcbiAgICAgICAgdG9wOiAtMzUsXHJcbiAgICAgICAgbGVmdDogLTE1LFxyXG4gICAgICAgIGRpc3BsYXk6ICdub25lJyxcclxuICAgICAgICBib3JkZXJSYWRpdXM6IDMsXHJcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29uc3RzLnRoZW1lLmJsdWlzaCxcclxuICAgICAgICBjb2xvcjogJ3doaXRlJyxcclxuICAgICAgICB6SW5kZXg6ICcrMTAwMCdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXNsaWRlci10aHVtYltwcmVzc2VkXSA+IGRvcmljLXNsaWRlci12YWx1ZVwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xyXG4gICAgfVxyXG59KTtcclxuY29uc3QgY2xhbXBOb3JtYWwgPSB2YWx1ZSA9PiBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCB2YWx1ZSkpO1xyXG5jbGFzcyBTbGlkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgICAgdGhpcy50b3VjaElEID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0b3VjaFN0YXJ0ID0gKGV2dCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLnRvdWNoSUQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBbdG91Y2hdID0gZXZ0LmNoYW5nZWRUb3VjaGVzO1xyXG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy5yZWZzLnRyYWNrLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGNvbnN0IHRodW1iID0gdGhpcy5yZWZzLnRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSB0cmFjay53aWR0aDtcclxuICAgICAgICB0aGlzLnN0YXJ0UG9zID0gdHJhY2subGVmdDtcclxuICAgICAgICB0aGlzLnN0YXJ0VmFsdWUgPSB0aHVtYi5sZWZ0IC0gdHJhY2subGVmdDtcclxuICAgICAgICB0aGlzLnRvdWNoU3RhcnRQb3MgPSB0b3VjaC5jbGllbnRYO1xyXG4gICAgICAgIHRoaXMudG91Y2hJRCA9IHRvdWNoLmlkZW50aWZpZXI7XHJcbiAgICB9XHJcbiAgICB0b3VjaE1vdmUgPSAoZXZ0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdG91Y2ggPSBldnQuY2hhbmdlZFRvdWNoZXM6OmZpbmQodG91Y2ggPT4gdG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy50b3VjaElEKTtcclxuICAgICAgICBpZiAodG91Y2ggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB7bWluID0gMCwgbWF4ID0gMTAsIHN0ZXAgPSAxLCBvbkNoYW5nZSA9ICgpID0+IHt9LCB2YWx1ZX0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRvdWNoLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRQb3M7XHJcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5zdGFydFZhbHVlICsgb2Zmc2V0O1xyXG5cclxuICAgICAgICBjb25zdCByYW5nZSA9IG1heCAtIG1pbjtcclxuICAgICAgICBsZXQgbmV3VmFsdWUgPSByYW5nZSAqIGNsYW1wTm9ybWFsKHBvcyAvIHRoaXMucmFuZ2UpICsgbWluO1xyXG5cclxuICAgICAgICBuZXdWYWx1ZSA9IE1hdGgucm91bmQobmV3VmFsdWUgLyBzdGVwKSAqIHN0ZXA7XHJcblxyXG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgb25DaGFuZ2UobmV3VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLnJlZnMudGh1bWIuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAgICAgJ3RvdWNobW92ZScsXHJcbiAgICAgICAgICAgIGV2dCA9PiB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge3Bhc3NpdmU6IGZhbHNlLCBjYXB0dXJlOiB0cnVlfVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHttaW4gPSAwLCBtYXggPSAxMCwgdmFsdWUgPSBtaW4sIGNvbG9yLCBkaXNwbGF5RnVuYyA9IGkgPT4gaSwgbGFiZWwgPSBudWxsfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgY29uc3QgcG9zID0gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xyXG4gICAgICAgIGNvbnN0IHRodW1iU3R5bGUgPSB7XHJcbiAgICAgICAgICAgIGxlZnQ6IGAke3BvcyAqIDEwMH0lYFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZmlsbFN0eWxlID0ge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGBzY2FsZVgoJHtwb3N9KWAsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGxhYmVsRWxlbSA9IGxhYmVsICE9PSBudWxsXHJcbiAgICAgICAgICAgID8gPGRpdj57bGFiZWx9PC9kaXY+XHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuXHJcbiAgICAgICAgY29uc3QgZXZlbnRzID0ge1xyXG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ6IHRoaXMudG91Y2hTdGFydCxcclxuICAgICAgICAgICAgb25Ub3VjaE1vdmU6IHRoaXMudG91Y2hNb3ZlLFxyXG4gICAgICAgICAgICBvblRvdWNoRW5kOiAoKSA9PiB0aGlzLnRvdWNoSUQgPSBudWxsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0aHVtYiA9IDxkb3JpYy1zbGlkZXItdHJhY2stY2lyY2xlIGRhdGEtbm8tcHJlc3Mgc3R5bGU9e3tiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yfX0gLz47XHJcbiAgICAgICAgY29uc3QgdmFsdWVEaXNwbGF5ID0gPGRvcmljLXNsaWRlci12YWx1ZSBzdHlsZT17e2JhY2tncm91bmRDb2xvcjogY29sb3J9fT57ZGlzcGxheUZ1bmModmFsdWUpfTwvZG9yaWMtc2xpZGVyLXZhbHVlPjtcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRvcmljLXNsaWRlcj5cclxuICAgICAgICAgICAgICAgIHtsYWJlbEVsZW19XHJcbiAgICAgICAgICAgICAgICA8ZG9yaWMtc2xpZGVyLWNvbnRlbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRvcmljLXNsaWRlci10cmFjayByZWY9XCJ0cmFja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZG9yaWMtc2xpZGVyLXRyYWNrLWZpbGwgc3R5bGU9e2ZpbGxTdHlsZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRvcmljLXNsaWRlci10aHVtYiByZWY9XCJ0aHVtYlwiIHN0eWxlPXt0aHVtYlN0eWxlfSB7Li4uZXZlbnRzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aHVtYn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt2YWx1ZURpc3BsYXl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZG9yaWMtc2xpZGVyLXRodW1iPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZG9yaWMtc2xpZGVyLXRyYWNrPlxyXG4gICAgICAgICAgICAgICAgPC9kb3JpYy1zbGlkZXItY29udGVudD5cclxuICAgICAgICAgICAgPC9kb3JpYy1zbGlkZXI+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2xpZGVyO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuaW1wb3J0IGNvbnN0cyBmcm9tICdzb3VyY2UvdXRpbC9jb25zdHMnO1xyXG5pbXBvcnQge0NlbnRlckNvbnRlbnR9IGZyb20gJ3NvdXJjZS9jb21wb25lbnQvQ29udGVudEFsaWduZXJzJztcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiQGtleWZyYW1lcyBzcGlubmVyLXJvdGF0ZVwiOiB7XHJcbiAgICAgICAgZnJvbToge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoMCknXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0bzoge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICdyb3RhdGUoMzYwZGVnKSdcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXCJkaXYuc3Bpbm5lclwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICB9LFxyXG4gICAgXCJkaXYuc3Bpbm5lciAuaGV4XCI6IHtcclxuICAgICAgICB3aWR0aDogMjIsXHJcbiAgICAgICAgaGVpZ2h0OiAzOCxcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICBsZWZ0OiAtMTEsXHJcbiAgICAgICAgdG9wOiAtMTksXHJcbiAgICB9LFxyXG4gICAgXCJkaXYuc3Bpbm5lciA+IGRpdlwiOiB7XHJcbiAgICAgICAgYW5pbWF0aW9uTmFtZTogJ3NwaW5uZXItcm90YXRlJyxcclxuICAgICAgICBhbmltYXRpb25UaW1pbmdGdW5jdGlvbjogJ2Vhc2UtaW4tb3V0JyxcclxuICAgICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogJ2luZmluaXRlJyxcclxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogJzIwMDBtcycsXHJcbiAgICB9LFxyXG4gICAgXCJkaXYuc3Bpbm5lciA+IC5vdXRlclwiOiB7XHJcbiAgICAgICAgYW5pbWF0aW9uRGlyZWN0aW9uOiAncmV2ZXJzZSdcclxuICAgIH0sXHJcbiAgICBcImRpdi5zcGlubmVyID4gLmlubmVyID4gLmhleFwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnXHJcbiAgICB9LFxyXG4gICAgXCJkaXYuc3Bpbm5lciA+IC5vdXRlciA+IC5oZXhcIjoge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29uc3RzLnRoZW1lLmJsdWlzaFxyXG4gICAgfVxyXG59KTtcclxuY29uc3QgU3Bpbm5lciA9ICgpID0+IChcclxuICAgIDxkb3JpYy1zcGlubmVyPlxyXG4gICAgICAgIDxDZW50ZXJDb250ZW50IHdpZHRoPXs0NX0gaGVpZ2h0PXs0NX0+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3Bpbm5lclwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJvdXRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGV4XCIgc3R5bGU9e3t0cmFuc2Zvcm06IFwicm90YXRlKDMwZGVnKVwifX0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhleFwiIHN0eWxlPXt7dHJhbnNmb3JtOiBcInJvdGF0ZSg5MGRlZylcIn19IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZXhcIiBzdHlsZT17e3RyYW5zZm9ybTogXCJyb3RhdGUoMTUwZGVnKVwifX0gLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbm5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGV4XCIgc3R5bGU9e3t0cmFuc2Zvcm06IFwicm90YXRlKDMwZGVnKSBzY2FsZSgwLjUpXCJ9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGV4XCIgc3R5bGU9e3t0cmFuc2Zvcm06IFwicm90YXRlKDkwZGVnKSBzY2FsZSgwLjUpXCJ9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGV4XCIgc3R5bGU9e3t0cmFuc2Zvcm06IFwicm90YXRlKDE1MGRlZykgc2NhbGUoMC41KVwifX0gLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L0NlbnRlckNvbnRlbnQ+XHJcbiAgICA8L2RvcmljLXNwaW5uZXI+XHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTcGlubmVyO1xyXG4iLCJpbXBvcnQgQ3VzdG9tRXZlbnRzIGZyb20gXCJzb3VyY2UvY29tcG9uZW50L0N1c3RvbUV2ZW50c1wiO1xyXG5pbXBvcnQgSW1hZ2UgZnJvbSAnc291cmNlL2NvbXBvbmVudC9JbWFnZSc7XHJcblxyXG5pbXBvcnQgY29tcG9uZW50U3R5bGVTaGVldCBmcm9tICdzb3VyY2UvdXRpbC9hcHAnO1xyXG5cclxuY29tcG9uZW50U3R5bGVTaGVldC5hZGRTdHlsZXMoe1xyXG4gICAgXCJkb3JpYy10YWJzXCI6IHtcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy10YWJzLWJhclwiOiB7XHJcbiAgICAgICAgaGVpZ2h0OiAzNSxcclxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM0Mjg1ZjQnXHJcbiAgICB9LFxyXG4gICAgXCJkb3JpYy10YWJzLXRhYlwiOiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxyXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcclxuICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcclxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICBvcGFjaXR5OiAwLjYsXHJcbiAgICAgICAgY29sb3I6ICd3aGl0ZSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRhYnMtdGFiW3NlbGVjdGVkXVwiOiB7XHJcbiAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtdGFicy10YWJbc2VsZWN0ZWRdOjphZnRlclwiOiB7XHJcbiAgICAgICAgY29udGVudDogYFwiXCJgLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIGhlaWdodDogMyxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZhZTIyJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtdGFicy1jb250ZW50XCI6IHtcclxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogMzUsXHJcbiAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgcmlnaHQ6IDBcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRhYnMtY29udGVudC13cmFwcGVyXCI6IHtcclxuICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXHJcbiAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJ1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmNvbnN0IFRhYnMgPSBwcm9wcyA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAga2VlcEFsaXZlID0gZmFsc2UsXHJcbiAgICAgICAgc2VsZWN0ZWRJbmRleCA9IDAsXHJcbiAgICAgICAgaGVpZ2h0ID0gMTAwLFxyXG4gICAgICAgIHVubW91bnRPbkNoYW5nZSA9IGZhbHNlXHJcbiAgICB9ID0gcHJvcHM7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkocHJvcHMuY2hpbGRyZW4pO1xyXG4gICAgY29uc3Qgb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSB8fCAoKCkgPT4ge30pO1xyXG4gICAgY29uc3Qgc2l6ZSA9IDEwMCAvIGNoaWxkcmVuLmxlbmd0aDtcclxuXHJcbiAgICBjb25zdCB0YWJzID0gY2hpbGRyZW4ubWFwKFxyXG4gICAgICAgICh0YWIsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0ge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IChpbmRleCA9PT0gc2VsZWN0ZWRJbmRleCkgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGAke3NpemV9JWAsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogYCR7c2l6ZSAqIGluZGV4fSVgXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25UYXAgKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgdGFiVGl0bGUgPSB0YWIucHJvcHMudGFiVGl0bGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhYkljb24gPSB0YWIucHJvcHMudGFiSWNvbiB8fCBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCB0YWJJbWFnZSA9IHRhYi5wcm9wcy50YWJJbWFnZSB8fCBudWxsO1xyXG5cclxuICAgICAgICAgICAgbGV0IHRhYkNvbnRlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodGFiSW1hZ2UgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRhYkNvbnRlbnQgPSA8SW1hZ2Ugc291cmNlPXt0YWJJbWFnZX0gd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIC8+O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGFiQ29udGVudCA9IFs8ZGl2Pnt0YWJUaXRsZX08L2Rpdj5dO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhYkljb24gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YWJDb250ZW50LnVuc2hpZnQoPGRpdiBzdHlsZT17e3BhZGRpbmc6IDN9fT48RG9yaWMuSWNvbiBpY29uPXt0YWJJY29ufSAvPjwvZGl2Pik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiA8RG9yaWMuQ3VzdG9tRXZlbnRzIGNvbXBvbmVudD1cImRvcmljLXRhYnMtdGFiXCIgey4uLnByb3BzfT57dGFiQ29udGVudH08L0RvcmljLkN1c3RvbUV2ZW50cz47XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgZGlzcGxheUNoaWRyZW4gPSBudWxsO1xyXG4gICAgaWYgKHVubW91bnRPbkNoYW5nZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICBkaXNwbGF5Q2hpZHJlbiA9IGNoaWxkcmVuLm1hcChcclxuICAgICAgICAgICAgKGNoaWxkLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzcGxheSA9IChpbmRleCA9PT0gc2VsZWN0ZWRJbmRleCkgPyBudWxsIDogJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxkb3JpYy10YWJzLWNvbnRlbnQtd3JhcHBlciBzdHlsZT17e2Rpc3BsYXl9fSBrZXk9e2luZGV4fT57Y2hpbGR9PC9kb3JpYy10YWJzLWNvbnRlbnQtd3JhcHBlcj47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkaXNwbGF5Q2hpZHJlbiA9IDxkb3JpYy10YWJzLWNvbnRlbnQtd3JhcHBlciBrZXk9e3NlbGVjdGVkSW5kZXh9PntjaGlsZHJlbltzZWxlY3RlZEluZGV4XX08L2RvcmljLXRhYnMtY29udGVudC13cmFwcGVyPjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkb3JpYy10YWJzIHN0eWxlPXt7aGVpZ2h0fX0+XHJcbiAgICAgICAgICAgIDxkb3JpYy10YWJzLWJhcj57dGFic308L2RvcmljLXRhYnMtYmFyPlxyXG4gICAgICAgICAgICA8ZG9yaWMtdGFicy1jb250ZW50PlxyXG4gICAgICAgICAgICAgICAge2Rpc3BsYXlDaGlkcmVufVxyXG4gICAgICAgICAgICA8L2RvcmljLXRhYnMtY29udGVudD5cclxuICAgICAgICA8L2RvcmljLXRhYnM+XHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGFicztcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBjb21wb25lbnRTdHlsZVNoZWV0IGZyb20gJ3NvdXJjZS91dGlsL2FwcCc7XHJcbmltcG9ydCBjb25zdHMgZnJvbSAnc291cmNlL3V0aWwvY29uc3RzJztcclxuaW1wb3J0IHtDU1N9IGZyb20gJ3NvdXJjZS91dGlsL3N0eWxlc2hlZXQnO1xyXG5cclxuaW1wb3J0IEN1c3RvbUV2ZW50cyBmcm9tIFwic291cmNlL2NvbXBvbmVudC9DdXN0b21FdmVudHNcIjtcclxuaW1wb3J0IHtDZW50ZXJDb250ZW50fSBmcm9tICdzb3VyY2UvY29tcG9uZW50L0NvbnRlbnRBbGlnbmVycyc7XHJcblxyXG5jb21wb25lbnRTdHlsZVNoZWV0LmFkZFN0eWxlcyh7XHJcbiAgICBcImRvcmljLXRvZ2dsZVwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZVtkaXNhYmxlZD0ndHJ1ZSddXCI6IHtcclxuICAgICAgICBjb2xvcjogJ2dyYXknLFxyXG4gICAgICAgIG9wYWNpdHk6IDAuNlxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtdG9nZ2xlOmFmdGVyXCI6IHtcclxuICAgICAgICBjb250ZW50OiBcIicnXCIsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIHRyYW5zaXRpb246IGNvbnN0cy5jc3MuYmFja2dyb3VuZFRyYW5zaXRpb25cclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZVtwcmVzc2VkXTpub3QoW2Rpc2FibGVkPSd0cnVlJ10pOmFmdGVyXCI6IHtcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IENTUy5yZ2JhKDAsIDAsIDAsIDAuMjUpLFxyXG4gICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtdG9nZ2xlLXN3aXRjaFwiOiB7XHJcbiAgICAgICAgd2lkdGg6IDM2LFxyXG4gICAgICAgIGhlaWdodDogMTQsXHJcbiAgICAgICAgYm9yZGVyUmFkaXVzOiA3LFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogY29uc3RzLnRoZW1lLmdyYXlCRyxcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICB0cmFuc2l0aW9uOiAnYmFja2dyb3VuZC1jb2xvciA1MG1zIGxpbmVhcidcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZTpub3QoW2Rpc2FibGVkPSd0cnVlJ10pIGRvcmljLXRvZ2dsZS1zd2l0Y2hbb249J3RydWUnXVwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2IzY2VmYidcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZS1zd2l0Y2g6YWZ0ZXJcIjoge1xyXG4gICAgICAgIGNvbnRlbnQ6IFwiJydcIixcclxuICAgICAgICBib3hTaGFkb3c6ICcycHggMnB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMjUpJyxcclxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICB0b3A6IC0zLFxyXG4gICAgICAgIGxlZnQ6IC0xLFxyXG4gICAgICAgIHdpZHRoOiAyMCxcclxuICAgICAgICBoZWlnaHQ6IDIwLFxyXG4gICAgICAgIGJvcmRlclJhZGl1czogMTEsXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnZ3JheScsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSA1MG1zIGxpbmVhciwgYmFja2dyb3VuZC1jb2xvciA1MG1zIGxpbmVhcidcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZS1zd2l0Y2hbb249J3RydWUnXTphZnRlclwiOiB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgxOHB4KSdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLXRvZ2dsZTpub3QoW2Rpc2FibGVkPSd0cnVlJ10pIGRvcmljLXRvZ2dsZS1zd2l0Y2hbb249J3RydWUnXTphZnRlclwiOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb25zdHMudGhlbWUuYmx1aXNoXHJcbiAgICB9XHJcbn0pO1xyXG5jb25zdCBUb2dnbGUgPSBwcm9wcyA9PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgb24gPSBmYWxzZSxcclxuICAgICAgICBsYWJlbCxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBzaWRlID0gJ2xlZnQnLFxyXG4gICAgICAgIHN0eWxlID0ge30sXHJcbiAgICAgICAgY2xhc3NOYW1lID0gXCJcIixcclxuICAgICAgICBvbkNoYW5nZSA9IHdhcm5pbmdGdW5jKFwiVG9nZ2xlIGhhcyBubyBjaGFuZ2UgZnVuY3Rpb25cIiksXHJcbiAgICAgICAgLi4ucGFzc1Rocm91Z2hcclxuICAgIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IGNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAocHJvcHMuZGlzYWJsZWQgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgb25DaGFuZ2Uob24gPT09IGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYWRkaW5nID0ge1xyXG4gICAgICAgIHBhZGRpbmc6IDUsXHJcbiAgICAgICAgW2BwYWRkaW5nJHtzaWRlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7c2lkZS5zbGljZSgxKX1gXTogNDVcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8Q3VzdG9tRXZlbnRzIGNvbXBvbmVudD1cImRvcmljLXRvZ2dsZVwiIG9uPXtvbn0gc3R5bGU9e3suLi5zdHlsZSwgLi4ucGFkZGluZ319IG9uVGFwPXtjaGFuZ2V9IGNsYXNzPXtjbGFzc05hbWV9IHsuLi5wYXNzVGhyb3VnaH0+XHJcbiAgICAgICAgICAgIDxDZW50ZXJDb250ZW50IGRhdGEtbm8tcHJlc3Mgc3R5bGU9e3tbc2lkZV06IDAsIHRvcDogMCwgcG9zaXRpb246ICdhYnNvbHV0ZSd9fSB3aWR0aD17NDV9IGhlaWdodD1cIjEwMCVcIj5cclxuICAgICAgICAgICAgICAgIDxkb3JpYy10b2dnbGUtc3dpdGNoIG9uPXtvbn0gZGF0YS1uby1wcmVzcyAvPlxyXG4gICAgICAgICAgICA8L0NlbnRlckNvbnRlbnQ+XHJcbiAgICAgICAgICAgIHtsYWJlbH17Y2hpbGRyZW59XHJcbiAgICAgICAgPC9DdXN0b21FdmVudHM+XHJcbiAgICApO1xyXG59O1xyXG5Ub2dnbGUuZm9ybVZhbHVlID0gXCJvblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9nZ2xlO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IGNvbXBvbmVudFN0eWxlU2hlZXQgZnJvbSAnc291cmNlL3V0aWwvYXBwJztcclxuaW1wb3J0IHRoZW1lIGZyb20gJ3NvdXJjZS91dGlsL3RoZW1lJztcclxuXHJcbmltcG9ydCBDdXN0b21FdmVudHMgZnJvbSBcInNvdXJjZS9jb21wb25lbnQvQ3VzdG9tRXZlbnRzXCI7XHJcblxyXG5jb21wb25lbnRTdHlsZVNoZWV0LmFkZFN0eWxlcyh7XHJcbiAgICBcImRvcmljLWJ1dHRvblwiOiB7XHJcbiAgICAgICAgZGlzcGxheTogWyctd2Via2l0LWlubGluZS1mbGV4JywgJ2lubGluZS1mbGV4J10sXHJcbiAgICAgICAgY29sb3I6IHRoZW1lLmJ1dHRvbi50ZXh0LmNvbG9yLFxyXG4gICAgICAgIHBhZGRpbmc6ICcwLjdlbSAwLjVlbScsXHJcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXHJcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcclxuICAgICAgICBib3JkZXJSYWRpdXM6IDMsXHJcbiAgICAgICAgYm9yZGVyV2lkdGg6IDAsXHJcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxyXG4gICAgICAgIG1hcmdpbjogNVxyXG4gICAgfSxcclxuICAgIFwiZG9yaWMtYnV0dG9uOmFmdGVyXCI6IHtcclxuICAgICAgICBjb250ZW50OiAnXCJcIicsXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDI1MG1zIGxpbmVhcidcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWJ1dHRvbltwcmVzc2VkXTpub3QoW2Rpc2FibGVkXSk6YWZ0ZXJcIjoge1xyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4yNSknLFxyXG4gICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xyXG4gICAgfSxcclxuXHJcbiAgICBcImRvcmljLWJ1dHRvbltkaXNhYmxlZF1cIjoge1xyXG4gICAgICAgIGJveFNoYWRvdzogJ25vbmUnLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNlNmU2ZTYnLFxyXG4gICAgICAgIGNvbG9yOiAnIzgwODA4MCdcclxuICAgIH0sXHJcbiAgICBcImRvcmljLWJ1dHRvbltyYWlzZWRdXCI6IHtcclxuICAgICAgICBib3hTaGFkb3c6IHRoZW1lLmdlbmVyYWwuYm94U2hhZG93XHJcbiAgICB9LFxyXG59KTtcclxuY29uc3QgQnV0dG9uID0gcHJvcHMgPT4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHRleHQgPSBudWxsLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGNsYXNzTmFtZSA9IFwiXCIsXHJcbiAgICAgICAgLi4ucGFzc1Rocm91Z2hcclxuICAgIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IHBhc3NlZE9uVGFwID0gcGFzc1Rocm91Z2gub25UYXAgfHwgKCgpID0+IHt9KTtcclxuXHJcbiAgICBwYXNzVGhyb3VnaC5vblRhcCA9IGV2dCA9PiB7XHJcbiAgICAgICAgaWYgKHBhc3NUaHJvdWdoLmRpc2FibGVkICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHBhc3NlZE9uVGFwKGV2dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gPEN1c3RvbUV2ZW50cyBjb21wb25lbnQ9XCJkb3JpYy1idXR0b25cIiB7Li4ucGFzc1Rocm91Z2h9IGNsYXNzPXtjbGFzc05hbWV9Pnt0ZXh0fXtjaGlsZHJlbn08L0N1c3RvbUV2ZW50cz47XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCdXR0b247XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQVFsQUFBMEFBQUFCMXVRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBRUpKQUFBQUJzQUFBQWNiWW9KOWs5VEx6SUFBQUdnQUFBQVNnQUFBR0JCT1dIVFkyMWhjQUFBQkZ3QUFBRE9BQUFCK20wQ2JoOWpkblFnQUFBRkxBQUFBQVFBQUFBRUFCRUJSR2RoYzNBQUFRa2NBQUFBQ0FBQUFBai8vd0FEWjJ4NVpnQUFDdlFBQVBHQkFBR2ljUGtpSmhCb1pXRmtBQUFCTUFBQUFDNEFBQUEyQW11bnBXaG9aV0VBQUFGZ0FBQUFIUUFBQUNRRDhBU2dhRzEwZUFBQUFld0FBQUp2QUFBTGZrRUtBRWxzYjJOaEFBQUZNQUFBQmNJQUFBWENsTGdwMW0xaGVIQUFBQUdBQUFBQUlBQUFBQ0FEUEFHamJtRnRaUUFBL0hnQUFBRmJBQUFDaGFJUDNHNXdiM04wQUFEOTFBQUFDMFlBQUJ6S21jTFYybmphWTJCa1lHQUFZaE5WT2ZkNGZwdXZETnhNRENCd1labnhGQVQ5L3dBVEErTUJJSmVEQVN3TkFQYkhDWE1BQUhqYVkyQmtZR0E4OFA4QWd4NFRBd2dBU1VZR0ZNQjBId0JSY3dPV0FBQUFBQUVBQUFMZ0FYSUFHZ0FBQUFBQUFnQUFBQUVBQVFBQUFFQUFMZ0FBQUFCNDJtTmdZYXhoL01MQXlzREE2TU9ZeHNEQTRBNmx2ekpJTXJRd01EQXhzREV6d0lFQWdza1FrT2Fhd25EZ0k4T1g3NHdIL2g5ZzBHTTh3T0FBRkdaRVVxTEF3QWdBZlJRTnBBQUFlTnFOVmp0eUZERVFiWTMzQUxBUjRjU2NRaEVoUmJRaHBRTTQ0Z0xvQUFRRURvaEFSVUJSTG01QU1wd0FRb2RiWkpRREg4SFdweVU5OWJTTVhYNmxYa2t0OWVkMWErZ25QYWYwZDAxa05qTGs4MGdtalRiaVdHUktjMjR2dHozYkk0ai9lUXo4TzB5d0RmSkYxRXU2RjFsMllCZmFtTWExWUNHMko3UjEwMlFMdWg1c3h6MEVaekp5UEVJNVAvbE5aNzduVzdRcHhlS09kVjVIK1h1M2h3SXQrVHpOWnJpZkF0KzdDWitzb2l0ajZDZG5PNGFOdmlYSU0wUWNzbDlhM21TOGZqSGtQREZ1R0xOemJFR0szMExLSFE3eWhQb3B2Ky9HdUVSN1RZdVJoSlpyMy9URytHNUs3SjA0aTNsQkh2VFMrSXBqbCtTM0NuOW1Ndkxyck56WmMyMXF6SFo2SEM5Qzd0SStEZ3ZNWmZrOTFNaEo4Q2ZOdllUZjFiYlBrY3RleENSQW5BUGJtdVFybUN0M21tYkRhWXpId0FNTGZRTDVEVEZkNnJxSGRTZjRieUZuNjU1N0tsL1NXVC9BcHhQTFZNYmFBMW92b0xLSGJvZThtbnhmeldVUWRpSnc3UXp3U3IxZ0h1VjZBSnZSRjlmWG1oN1d4Q2Z1UFc5NFB1Mi9GTEhjaEUzckx0L2pYVi9Bcnl1R0UvVjREVFYrN2oyMTJmVnM5SGVSZkM3MmRDN1dlN2JkMjlGcjNmYit4bGdxRjZwTTl6M1hLbVMvL0Z2UTVyNHlMTlFHNnEyQ2l4b2ZZRC85bnR0Q2lwL1RmbnZzNy9jT0g1VDcxMG5OT0wyWE5xNG5mR1NRZ0ovMHZwa1BzN2RLdnNkQnJQM2hQaHllRVA4VitGeHI2eC9Yd0NYb3Z4QytoTEZtNmFZQStLVG5YOFpUdnB1ZURobllYKzI4WjZVM0k3OGJtbTB5cm1nemZDc05QY2VMTTdROFNOc25ienYwWC9Nb056dTNEaG4xN3FQNG5wVCt6RGhhQWJWSStHMkRPY0czN1g4MU5QTjdHL3R4NU5DaHhWVGFySHovNUR6U0EvWldoQ01BZU5wallHQmdab0JnR1FaR0JoRDRBdVF4Z3Zrc0REZUF0QkdEQXBBbDlOSDhvOVZIbDQvZW4yby83ZnAwOU5QeFQ2YytYZmwwODlQZFR3OCtQZm4wOHRPYlR4OCsvZmowOXpQYlo1N1AvSjlsdjN6Ly81K0I0U1BEUjh1UHRoL2RQLzc4TlBYVFBxQ2VrNTh1ZnJvTzF2TVlxT2MxVU0rWFQzOCtzMzdtQXVvUi9tei8vejgvTXo4VFB3UGZQNzVBUGlzK2N6NHpQbE0rZlQ1ZFBpMCtEVDQxUGlVK1JUNDVQbWsrQ1Q1QlBqNCtIajVPM2hkUU41TUlHTmtZNEJvWm1ZQUVFN29DaG1FUEFBTm5WcjRBQUFBUkFVUUFBQUFxQUNvQUtnQlNBR1FBbUFDb0FNZ0E4QUVBQVNBQlNBRllBWFlCbmdHdUFjNEI5Z0tzQXZZREhBTklBMllEa2dPOEJDUUVjZ1MwQlBnRk9nVmFCWm9GNGdZS0Jsb0dsQWE4QnVvSERBY3VCMUFIY2dmY0NDUUlVZ2lPQ0xZSThna21DWVlKdWduVUNmd0tXQXFVQ3M0TENndDBDNFFMdWd2U0RDUU1iZ3p3RFdZTmhBM1dEaUlPTmc1OER2d1BMZzlLRDV3UHloQUFFRUlRWmhDcUVRSVJLQkZnRWF3UjZoSzBFdndUWkJPYUU3SVR5aFBXRkE0VU5oUnlGS29VeEJVTUZUQVZpaFljRm1nV3JCYktGdW9YRWhjbUYxWVhuaGV3R0FRWUtCaENHSEFZb2hqMEdTZ1pXaG9lR3BvYkhodGNHL1FjV0J5MkhPUWRUaDIrSGdnZU5oNTJIcFFmYUIvQ0lESWdwaURJSU9JaE9DRitJa0FpMGlNa0kwb2tIQ1MySlJ3bFVpWHVKakFtOGlkS0o0QW5uaWdjS0tvbzRpa0FLVzRwbmltMEtjb3FEaXBTS3FBcTdDc2lLMUlybEN2SUsrUXNEQ3hhTEpZczRDMG1MVll0YkMyQ0xaZ3RyaTNTTGVvdUJpNGtMbGd1ZWk3T0w5UXY3akFzTUpZeEZqRitNY1F4K2pKaU1xNHl5akxtTkdBMGREU2dOTlkxR0RWc05jUTJCall5TnBRMnREY01ONUEzeWpoVU9RUTVzRG5tT2hvNmVqcWtPdVk2OWpzd08xZzdtanZRUENvOGZEeTBQUnc5bUQ0K1B4dy9rai84UUZwQTZFRkVRWFJCa0VHK1FneENta004UTNoRUxrUlVSTFpGK2tiQ1J0NUgwa25VU2VoS0hFb3lTbUpLa0VyQ1N1NUxDRXMwUzRoTHNrdlFUQ1pNVEV5SVRLNU0yRTBDVFE1Tk9rMUtUYkpOeGszY1RnNU9YazY0VDA1UDBGQXFVRDVRamxDd1VXSlNKbExFVXlKVFpsT1dVOGhVTUZTVVZPeFZVbFdxVmdCV2FGWitWdDVYR2xjK1Y0Slh3bGd5V0w1Wk1GbUtXZXhhVWxxaVd2cGNMbHk4WE9oZEpGMkFYYXBkNEY0QVhqWmVWRjZLWHFCZXVGN0VYdHhlNkY4QVh3eGZKRjh3WDBSZmVsK1lYL0JnU0dCZVlLeGcvbUVrWVdoaHFtSEdZZXBpRW1JNlltWmlvR0xLWXZSakxtTk9ZNXhqd0dQa1pBQmtJR1JLWkdoa2lHU2FaTHhrN21VVVpWcGxmR1c4WmVabUFHYTZadUpuSG1jeVoyeG5tbWZVYUFSb0htaHNhSlJvdkdqT2FSQnBSbWx1YVpwcDhHb3NhbFpxY21xVWFyWnEzR3IrYXlSclFtdHFhNUpycW12WWJCUnNUR3gwYktoczZHMDZiV3B0a20yNGJlWnVIRzVHYm1CdWNHNnlidDV2RG04bWIwcHZybkFBY0lSd3BIRGdjV3h4d0hKRWNyaHpNbk9HYzZoenhIUmlkTloxYUhYU2RlUjE5bllJZGhwMktuWk9kbkoybG5hOGRzNTNySGlNZU1KNDdIbnFlc2g3Vkh2U2ZCNThWbno2ZlZKOWNIMkFmZGgrRG41d2ZyUis3SDhLZjBwL2hIK29mNzZBUG9DS2dMeUE0SUZVZ2FTQjlJSXlnbHFDZElMT2d3Q0RGSU5BZzJDRGlJT21nOHlENW9RQWhES0VXSVMyaFBDRlFvV2doZHFHQklhQWhzNkhGb2MyaUM2SXhJbGNpZlNLTm9weWlxYUswSXNvaTNxTHBvdktpKzZNRW93MmpGYU1jSXlZakxpTkdvMVlqWGFOaUkzQWplNk9RSTZNanRLUEFJOWNqNHlQL0pCV2tuS1RmSlBJay9xVWhKVGNsVkNWc0paa2x0cVhzcGdPbUdLWW9KakttUHlaWEptSW1iYVovSm80bW1xYWlwcldteUNiT0p0bW00NmNBcHphblU2ZHNwMzBuaXllV3A2YW5yNmUrcDh3bjRDZjBxQU1vQ3lnZUtDOG9RaWhTcUY4b1lxaHJxSEdvZVNpQ0tJK29tS2lyS0xVb3ZxaktxTk9vMmFrSEtSc3BLeWszcVQ0cFFxbGlxWGtwZ2FtR0tjc3A3cXBTcW8ycXZ5clNLd2NySGFzbXF5eXJRYXRMSzJTcmN5dDRLM3VyZ0t1THE1T3JuaXVtcTdZcndhdlNxOThyN2l2OExCbXNMYXhHckZvc1ppeHRMSFNzZ2l5TXJKZXN1S3pPck5hczJ5MEhMUnd0SnkweExUNnRYYTE0clpPdG5DMmdyYW10cmkzaXJnY3VNUzQ1TGtLdVNDNWRybSt1ZzY2VXJyY3V5aTdnTHZVdkNhOFdyenN2WTY5ekw0T3ZvSysxcjhrdjJTL2tyK3V2K2pBSE1CQXdGN0Ftc0M4d1BEQkFNRk13WURDTXNMMHc4ekVETVEweExERTNzVUF4VXJGcnNaT3h1TEhGTWMreDdiSDZzZ2F5RUxJME1rUXlVYkowc3BzeXVETC9NMDh6Z0xPTHM1T3pzN1BNczk0ejU3UUlOQ1EwT0xSSE5FNEFBQjQycXk5Q1pSa1IzVW0vQ0xlRW0vZmw5enpaV1psWnUxTHJ0VkxWV1czdXFYZTFLcVdXbzEybFZxdEhVRkxJSkRGVmlBZEkyTTROTmdDR1F0VFp3eEdXSUFiYklNd1kxTTJ4Z1pzejhneUdQQmF3RG0vUGZ4alc4TjRQSXpIay9wdnhNdXN5bXFFREdmK3FzeDQ4YlpZYmtUYys5MGJOeUk1ekRrY3gvMEN1cGJqT2NMTmZncHhjL3MvVFFUdUh4cWZrc1MvMnY5cEhrT1UreFJQTDR2MDhxZUpoUDV0LzZjUnZkNTBtazY5NlZTY3gxOS81NTNvMnY0ekRtcENhanlIT0E1OUFhMXpCcVFlY0Z3MUpGS2xWSzdYdWw2bkVYbnRTdENGTC9wdFNSQ1YvaTJLS0VqL1dYUkZ0OWZyWlRRaXkwUkROeXRLLzNQejg2c1hMa0I2bU9OZTNPTFcwUVlySXhkVjJzMTZoVyt1cjYvYmEvWjZ2TlpETVgyR2k5RW1XdU1rTHVhNGJyM1piZ2JOS0xRUXpYa08xVlpRa3pRYlJkVHNkdmFoZW5OcmZYVnQ5WlRMSzN5Ni80NDBISndqazhzTkFidFB1NWh2TGsrKzg3VnJhL2VvNFdXK2YxbW9kcGY1bVJsK0diS2dOWU5nSGVvbWNWd3p5V1Z6OC96RytjM056ZUg5TlVSTEJIVDFhdTFXcDFscWhJRnZZUWxLd2ZNcVFRV2k4dmh4eFZjZVI0U1hpS0lRa2VlZlVwU25odS9ieUVYbnVSVFFEY2hHeTk3cVFNRWhxVWFZUjEwSWZhVGNvNWlHY3EvaTVwU0dsL0VhU3M1OTB6bEZPYWVrWFdYK1c0YnJHdCthVjl6MEplVnRkNE5tVUFrMjZSOFVlWmhmekZHNjBmSjJtbEJXeDZlNTRscHJCWDAwS1ovRVkxbytkRE1Vdi8rZDdlSVAzKytpTlhTVWx0ZWpaYk1RSk9KTFV5aUNrSmErM2VyZXIyUmNaV0duWEZCUUJmVkdTdzkxTVV6bGt2SldTUnZhdW8zV2QwcThxN3hkS0dpdDdRQ05HMFZNYzA3dm9tZGxON1V2S1d0RVd3VkpaVnBQU0taRnV3V2w5SCsvaEk0TGlwdEJ2UittOXlWbDlhSktVR2xYV0RGWmdTL3BDMVhJam5aRklNY0twdTJKbG5aVDg2ZGV2aTk0WFZwTGxOQVVraXJYbGhDaHBYK0pyb0Q0bDZqRFlCekJHTm5nYnVQV29VUW0xTHRlby8vUXQ3b2Rta0VCQno2UjZEK2xiQ1Y1QWhwd2NEc0tvMmEzU1c4SGZ0aHNkRHZ0VnBKQXBaeThGZmp3Q1B6VGU5MzY2TVVDWXRjNk8rK2dYeGs3dTlpWW1Tb1ViV2NzenM5TXpVMmUzRCttYXJZTHo2Y0t2RkxMVGtTUm9saG1Lc3I0cmkwaXNaUENDTXRheXJKMUxRcUtoY3A0b1JpbE5NTXdvM1JjcXMvVjR0SUhiY1dRSkZGQVNCUnN6VEpVUmNFOFFwSkk1SW5xbUdNWGl1TlRjL05YRjNLZWs1by9zbERMNUIxUFVWT09sY25tcGpLcHRPY2F1cXFhcVFkMFlvcWFtY2xPak9YU29hOG9ocEhPRk1xVnlVSWNScnB1RzRYUHlwcW11b2FqU2pLUlZGbXlUTjNTRFltb1JCU0JVdzFwYlhBUkIxd1JlU1d2MmFhOWpJN2llZ0R4MmhRcVMzeUpyd1FoYTFDZ2MzdFhIRzNFL1Y3Y085cVVtMGUzTmpzMXVkYTVDVDJjcnRodXpyVTNXVmhCY1g4VDlZVG0wYU5OQWY1cW5VNy9NNGdiVTEzVGhZODZ0aE5qUExJSFplcHhIZ2Vzb1Z0ZVFpM2dUbmxvbVR6eXA2QlhWZXFrU2JvVlZWWFJtOVNxQ3A5Zk9iZVVQYmZVVS8rcnFuYlVWOEozNjlXblhwM3c1TzIwaWxDNzdSUksyNmxHN1NtMGhFcEJhUWsxMFdkb1l2MUhXY0tXRmZkL0RaMktFY2RTWkdtdjllSjRNNDVabngrbSs1S3A3a3BwTklXZm9FeVZxUGtTWlRvVkw3eGtrUzVOOXlYcHhwTGNoeUQ1OWdqMXdqK05QeFZEMHFQMGd5UjdNWldSSU5QK0QvU1BPVzR2ZDVqeXppSmFLS0F1VFp1T015cTVBaGp2VklDVmwzQk5JZ0dSNmlER09tMDZlTHBCMklGNEMvZ3JsQ0dKelNMZDVnL3hJdFpGNFNGUkpxY0Y0VFNSSHhGRUhZdHczVGI1R3dUaGVzUi9BRTRMUEY5UVZScnlJcHEzaFFNQzVwL0NxdkNBUU1ncFFaQlBFZktRb09LbmVKNkgzbVdid2hsZWxLOUZRdTBxZUxEQXkvRDJIMTRscVN3R0dJRVR0dnU3QnYyOXhTMXluRXRaVkNLMC9IQWszbTJBaUlFMkFjYTlEMmdYTmpyUUdJeWZRTVJ6U3M2YmN5NTA3Zi9Fd2lPeTNGK1Y1Y1Y4TGI5ZThOeTgzZDlBUGRlTWFaOGVEV2JsL25sWlJoZmtDVHVLN0lrazdGOUEzSXVzYklBTk5rQm1wRUIyakhIVHRHL1FrakIrVE11MUQxRlUwSWdXSXFuUmFkWEtrdDlwdE1vU2xXUEFZZEdiVGQ4Myt4K200ZUc2WXA4MjFJbjNuT2gwVG5UK0paZjc3TjZKaWIwVGFNWXp2MHJ2ZjlYMHhqVjE0aSs3SjdyZEU2L09GU2ZvYmNoZjJzWW5Eb3k5RWxmbEpyZ1pWZzRtYjZsY1dIQVdRSkpGWlJLVTJyV0swK2kyUzBIWTdBTENJQlJsd0JkOVdMZHR2Zjh3RFIwTm8zV3NhYmdQb2JlNXViYlJRMnR3OHdmMEpwSjFPOVo5WDMrUjAxLzdXcjFuMjdGdHo4OXpTVHU5QUxTNHdQbGNMcUZGTjZFQnhTbVVKdENmWjFHbEF6UUlCN1FZUFo2SXA2ZGpKTk5RdU1vMHIyZU45T0JJT0Q5UitOUEM1Q1FFRTcyTytwekxMbzU4RXJtMlhZYVh6djJTWEhhbnllUlk4bjZLbTRVVUloTUJKN1ZRdXpKc1RlaE4wSnplZHBKMXltcHJTeGp5K1pjTVgvQnVJRkxiOW5OWkQ5Y3lEeW12eVZTckdlZTRZTnlScVJZeVY3dVd3OC9NUis1YnZjd2Q2VExhVTBrL25hNzA5Z3VWOU5uTE0rVmROS1Q5YVp3RHVrWVVRRkNjUjB3VVNFSEVKR0xacjBnL2lvN1BuWG5ra1k4L1VrSllDRThMTWk4alZEMzRRN1JFRC8zSzYxNTN6YjRGaEpGTXJpdGlqS3h2dndSQjBVaDVmblJKWGlMSGwwaWZHK0R0SkwwTTF3WDYxaGJhVkI0TlpENndvM29GRXJWUXQrVTFFaEExekFpaUNYSm9kWmRSR3FVV2hEdVBSTUhNNWRraUVnUmVXdFQvL01pZE9ZUjQ1N0FFcDFpMmcraklIYnkrdGdmaHltUnZNdFFQM3k2MWRZekRGUkhkZFB2aHVTa0VrbHM2bG9HUzhZSjA5ckRyN0RreGltTUk5R0RPSFF4VEVaQUZzRU5hQ29aSUFISUhQbkRRS0d4MEgvMnRSK0dEcmtHb2lIaU1YajBOVUJ6eGFVZ2VuNFNrZWJUQm5uQVJZSVVVUXUrZWhQdHdGeDVGeHlHYVlERUVOSGtMbFV0Y0FaQzdpZXF6aUlIenNJaThEbm8wSTZuL1dTMGE4cUZDVVV2RjJ1Mi9vYUszK1NXei83d2hxZExSY2xrdnA1QnhIeUxHamg2eEFkZ3hDOGZRQjAyQWdXNUFoNmlUUUQyS3hpUDBTeGovTDRrWHhYZnhHT09jTFdGQld2MHlGbmdCWFEzaXZyOHBpWS96QWtZQ0x0aVNkQkxxZ3lGdEh1VFZiNk1saHBFWHVwMUVqQ1JhVUNmYStxUXNGMlg1Njd6S2Y1M0YzdmRSV1M3SThoL3ovQit6eUtCOEwzNFg1Tk1IV1JwTUd0RzZ3dnNzc1RNN3J4QUZJaC9kSEVtVTBGdWZwR253TDM0WGNZTTBGcGp3b2dnMlNhdjdxelFOaFd4blM1TW95R1NuWEVrNWVPNHlxRXVQcFVHa3BBNk5wRVp6NklmcThzbnZYVktaajNKVVo0VCtzZ2I5eFFIWnRNd2Q1Qzduam5FbnFjeUZ0TGJsVXRRTW8zclpielphQXkxb0NpZmFCZVVud0VYS2NBM1lGRnhoekFTUkFXZXVENzZyMEdPQ2JDMGI0QlMvQnBEMDdacHRhMC84dk9ZNDJsRk5ydW9hVWpTOUt1dWZQMzkrWStPdGIzME94U1dDUkN2d3Nsa3ZzRVZTV3N2bGdJRS95Umo0M1lBd1pjM29mMDdYMFJXR0poc2JESXowMkdjd1J2OFd4c0NIb0hZekkyT2czdTBNeHNCZ1BCWkJTNkNqb0xHQ0tDeW4rS0UxR0EwbmpwK1FwSkRuTVgvaUJBUjhJRWtuVG1BY1lCa2ZUeTd3NkVQczJhZVBINWVrZ09lUEhXTlBIVCtCWkJ4aWZPSTRuRUpmM0tVWFo2bXV3N1FVa2loWDlVUi83U2JLSVhxZDZoZTBSeC9WY3FIMnRyZHBZWTdHQzc3NjZCSUxIeDNjM1ltUHBsMWxhVE5JUkpOUGxHT2FBMVNyeWZKb0psMER2Ukdnc0NCS3dxT1AwckFtQ0k4OUJvQk1FdWdWR2dJOGUyeEowSVdxUUIrQmd5NDgralpWaFFmZjlqWjRWVlhlbHVRN0R6UmVaYnA0WTBlQjZ3QjNnN0ZKZ3pCQXJ5clB6NWY3LzdYYUxtZUZVcWliNXA3eS9HWGZXS2lVRnpyVndwd1M1a21oZW5pQjJVVm9QZDZBM2dCdHB0TzYwSkpDZzBVa3N0QUtIaWJQZWh5cERMc2Jlb05oeE4yaW9SL3NmcXBuUGg4YmF2OC9xWWFoZmlWK1FsT1JvYUNiZEtQWWpRMWpvdnNKRXpySFYraE4xRkNOV08zL3M2cHlvOWlNY0JhTWdPSk9meG1LcE5vbDU4K3U3dG16dXVlcXNVeG1MTFBBZXNzbjdqeHk1TTRqcUxTSDNqbWRvWGUrei9yR040L1FPOXdBNDNBb2huYnlRUzVPQXdZOHhCMmx0VXlrOExCcWdHNmhVd1kreEdEc3dYVzR2UjJQMmp0WHVpUHhlck1lK0tpQURlVy9LNmFwYkVqQXRFLy92L3dWUFAyOEFlTTM4QnY0RjNuK0YzR01QOC96bjhkeis2OUFrU1Q4RDlVMFZiU3FtaGp6TjlrcUQzemlVUlplT1JJL2VmS2d6bTIzRHkxL0FDMWUraEVsRDBGM0k4MEVhMVJBbk9oUUlzdWlKWkxRTmZ6TmUvOXk2ekxOZVN1S2VPbWZWZHRXMFZXS0NVTGxKcjZ6OHYzbkhlM3FRVDZyd0tibm1UMUw0emdIa0o0NCtHS3V6eVZmWk1meEd2c005SzBZQWNRRGZSSjB0eXJBNTlhQUVZS29wM3JJUU10QmMvM3ZPUHc3RkY5NUI2L3JlditidXI1dUM4SVhGT1YzUUNHTzlYRWRQa09kQnJBMDUzSkwxRkpWcjNYMjRVYVlhT3pVVk5kSktvOFpwb29LT0NKU1JIVU9Kazg3WFZEb2dkTXNZMC9sc2FoODRRdUtpSG4xSTRLY2tZVXRnaXp5dWMvSnRzSlBIL0N2QVNFcW9MT0JCTGVrNEN4SUt2NXF2emVOcGtSSkVnUlExVy9BZ29EUGdMNytKOFEweVo4b0FzNVBHemRUMFl1dU1YbkFEU2FJYlN6Y2JFem5FOW9sdWhqdHlYVW9lU015aFVwNUZ0ZVgwYkQzZGhsUVlYbzBiVFpwNjFVUFpxMjlZL3Z5WS92M2w4c0g3Z2lPdGR2SDJqZTRKbWhBMDRWQ0NJcEQ3NjFaYzk3MTNlbGk1Y0RLWDNhT2RUckhEcHN1SVdHeE9GMVVFNXRtak40QzlGY0JBWXhSNUY1QWVWU2lCcjR1Y0lGS0M3akJpTGtSQ0FVd0hpMFJJdmEzRk8wcm1yd3BFdm5mWE40Ui9QN1hmTUhCa21haEEyZ0ZLV291WjBvbHlWQmtmRXdyUEJzRW4vTk1vc2FKVFRQQkNCbWFZM1dYenRLdFVSbGFwUUtWaUZHOUM2cDdKU0pkZElFYWtmcnJSREY0cFBBMmV0QVVGTUh1LytwWC9PYXk3NjAwdmNZTGl2UzhwRUJnWUN6T21NSXh3WjQxaFVPL3QzZHNMM3pHdUJIYlJZYnJnYXprb2xscWZhUnFhWU5aY2lpbmdpNUNqVWM4UllWVVhXME16RDcxYmdRU2hobDR5Z1BMRVBDM2JxVkxtcTlwclR4NmM2V0VlT1RaN1dFMHBSWGloUWtiMEJpQ1B1dDJabHBqM2JneG9VdURDOTJaOWxpMWR1M1AxcTRWOHZjczMveW9Cb2hRR2Naa0NZM1BkT1pYUTBDekFPTnczQjd2ekhRV1RnVVNUczViRTcvK3dDOCtNTUF6V3pCK05qaVI0OW9lYWZMZHJlYlBiVFUzRUxmNUlyYzVHRi9yMEw0V0cva05hRW9UVTFvRG1adlZxQVNJRmxQYkRWUWZEdWhWT2tFNndxcmMvNkl1SXdQNzZEcmNmMW9DL0tzZDl5Vk4wOTEzVzRpVDFkOGlSRkxWWi8yRmt0NVVDT0oxUXhqSWxYV1FLenJWZnlTeUxEVGJFZG02N3ZZcUpxV1phMXNiRysrcjllVDhGZDJaMVFzL3pRMzZBWlYvVTlTU05PWkhFcW5CYUlTd1RHcjFUbzBHN1ZhOTB3MjdIUm8ydW1FRWc1V0dneEdCYnF5S1dqbVhWa0k3UEJHNmdUSmZVNlZxbFNqbFhFb0ozT1JhS2xmV3hMOWYzYnQzZGU5M0RzR0RjaTVkMWNScVZWSnI4L1NoV2prTWJUbVhZcS9DeFZST0R1MFA3S1V2akpTeHpzMUJYNjFJME94MWlRU1ZkcTFPNnQxYXZkSnVkbGp2b0JwdEdIVWpFa2JON2ZLdFQwdGEzQ21acVJNWnZkU0pOV2w2Q3VCYkorK2tUNlNkZktlZ2lWTi9QaDNIMC9FSFBEL3V4REtablpVSlJIenZSTmFFNTFReU1VRlVlTkFQYm9ycGcxQWNaWnRuVXB0RUJjcTFqN3VDdTRhN2xic1ArSVlQZkIzR0VUUm1FUDJJdVBqLzB6TTkwaUR3V2Q5MWVKSDc4YStpT2traU81OVAveGhYV0w5SDBPL2ZBdjMrSk1WT0VxRW0zVVRqYmtCVGRFQ0hxZE11dm1QRXBUcWNDZUFLT25xUm9xcUU2WlJyOEdSaXZ3VWdseGg1MFZ1d1RNdzRreW9YdzV5dFlVRVJNNklnZ0VEd3pXeXBuTlZDRUFtQ0FCY1ZBVWs4YitmQ1lqbVZpVTBpWTZIbGlZWmR1NjRHd3R4dVBWKy9QVFVmVjFMM3Bzc3BZcFdLamdXeVFlV1JJeG1HNkNKSVJaSXNKNDZKaG5FS0hrdFY0dm5VN2ZYckYzMWVsWDJmYU1SZUhOV3BMS1pUVVF6YzZnNndKM3B6dWZ6SlQ1YkxoVmNVc3JuQ0diUld1YVB5bTc4SlFSem5jdkVJenlNZ0ViczdDQ25xQUYwa1pwMUtUTmVVU2tHVHBoc09iZVdFSWhScUpRZUpuR0RyZjBhT29idTJicmdMZWpwVnkzbTVCVUVwMnpLV004RG1oVG9JUzhYMEJscm43eHV1blhHc2R6bGV5WE1OYnlHUXJGQ1hkVUd5TENNbkNKcXN5SW81d1B6L0RScjAzZHc0QjNqU1kva3psVHVnbmExTllTblRIcmVMV1dsUlJNd1hrSWxtMFRMNlZ0MVRpb0VsOG1TWllJUGtORTBUZE0zS3BDMXk1WFIrZHVsZ2tNRzU4UXpPb3RjVTJzV01saloxVy9FbGNkWlhVNFFva21PRnBwdlM0cXZ5ZnY4TEtET1p4dW5KekNnK1YrbklwOU1nOU50RjYvTnJhMnZ6bXhzYjYrc2JXME44dFFuUEVSaVBzOERKRWx1RjN4MnhndEhaSERGeVduQkNuRzR5czlOZzhCNmRHOC9seG5Oak96WXdWTHJkNkg5QXcyK1dGVTNxQ0pKS1hDTEpXem42M0dQdzBMUHNvU082L1FmM0lnR3cwTDg5S1pOOTBDRnRrZGtFazdLa3VRbEFxZGZBMlVDcnI4NENGWWxFUjBVSEJDeEFQcEhLZG1CZ3RZb0ljRFRxaW9CTUszTzRUQUlMQllucWdSUGRpcW9mZFZvck5nZUdmbFUxZ1BTbTJ2OE1STENsR0NoQW1vTEdJU0wyWDBDRytwZDBQcVAvdjFYYlJkZXEydDc4SDZ1WUo5S2RrcXlJVTd3QWtOSVJKWm5QT3BZZm1QQkZMV1FxL2YrbDZzaEd1anFMa0NiL1Y5bEFLVGgyVk1YUWlrZ09GZlRwOUoxL2dHQVVLZ3BhV1Nma2Zva3NBRnJXQmJGMHdBZittQXU0VVJtdkFaN0pKN3hCb2lnUWdOL1FTT1cxYVZQU0tVTjQ4cTAzMy93WVp1Rnp6UEtraHdmRDhJdkRheERPTTNOVS8zOXFIOWMzdEcwN0VyZU9MZ0FuQnUwZDFHZzZtd2ZmMnFEZDErSjF3TGM2YTFiYmZzR2VaeTNIeXBiWW54em81MjA2bGdkWWp2SXNxblA1R0lwSnA1RUd4aVlLTmhqVDhvRnJVWHhhYXpWODlQRDRJeDkvNUpFemh6dXlhbmdyTGN1eVZFMG1oaWM0d2RqSnNRcTlZTFVxRUgxbUUrM3JIR2Iyc1hIUkF3WHJMOW5sd0JFOGc4aWFPbnlPdlhLS1RmVHU2QW9hOElzQ1lIZzZKVEF3YkhlQUdjQUE1QjNHRjVpOVFJR0dVL3JmVjk2V1UwVHpyUFJuaFB5WmhGNFBsOTRMcldSS01xcjAvMEdTa0VkNXRralQ1allaSDR0QW55NkM3T0s4Z1UxaW9JdzBRNW8ycER5Si9JYmJhSlc3VHNWNW1tbzdGMml3S0tRRUlhWExzZ3dFQm80SVhmRGlVQldLNFdyLzJkamV0bzF6M05aZ1RCWUJZWENkQWVlN05FZDNpSzVCb2xla1JDMDd5N3JDYTZtTjQya2FkUFpQVHU2ZmZCS3JqK3ZtbzhiUGVCblB5eUIxZENqMk55YnBNei8zT21EbHhvUFdVTytLUWQ5Wlk5b1FuZmR4U295Y0JQUWgraldoQ0dpcjMxUFJ4OVc0djk3RFhQZmNWOCtoTS8xL1JaTDZ3blBQdFVYUjFqVG9iOVJROXl2b0xZQmJ4NkZIRjVCVWgzL29HRXk4Z2FJTldnd004cEIwMnJQOEhDb0k2Q2xaVUVrd2FVZHU1L3F4WTFrVGhsLzFyanZ5RTlPeU9LM09YTHRuV2xNRnU5bSs2akFLWElRTVQ1UGxNTDdzUTJkOGdhOW43VlRwVlF1eXJwclcxR1JWMXlTL1BUcy9yTThhOE1PWXpWVWY0TGdWTkxSRUF5Uk9KanVBZHRUeVZKdEMxSWdZd2UzS1lFS1F6cGJzUTFUNGJwdXpHK0htK2RMY1hPbDhNeVR6cm5tZVRubll2QTNJVXRwMU9zOGVTazI4TUQ5WGlrdHo4NDRWRCtkSXpKUW96bE1ST25MT0hzb084Q1gzVDlBSFRDNWtrZytHbTRWbWhmYTJQZUR5czFmc0x4UkVlNktZV1pzdGwyZExhUDN5UnZPeGlYRXBYRmxhalJ1dkxOR3JRMThOdE01MGgwbG1qV1pWd0ZSL1dLQlVHQUlLRk5DTGRlQ3BDOEJIcFZBeERJWDN6aXd2bjJIUi92OTBmdEhOWmNmSHM3bllVTDZtR01YRE45MTB1TWlpcUZnc1V1MHJqd3FEL0U1Q2ZoRzF3M2VEWmNUbWx3SDdRajZVSlpCZ0RuVkJPUVRnMGk0aUMzVk54Q2FrQ1ZWUzJzOVdGMVFaV2dDWDBOSkNaSi9JVEw4WnJTejREa1QySWJnbjhYTVlsWDUrcjdTbkhrUVdua0w4OUtMUVB1M0lhTTlsVWYzMnptbUhzRmh6cjdTM0ZrWUdQdzE2eTJ5SGxlczczTk1NVDB5eHVUREc4WUtrOXRSMEFFT3JWbS9UMlVNSnhsY2xZRmRwYTUrTGd5QU8vS3h0aTBHQW9Mc0NIckN6ZmhWZEc5STdoYnozb0tvbzZqMzk3eGk2YW4za0k2YW1tYWh3RDczMm9BZWNuRXBoSnR2ZURIeTlCQnJERWU0MFlONDd1UHU1MTNPUE1tN3ErR1JnUXFQZk9oM2Z6RFlMUTRSdms2QWJ0UWtqWWJzT1NKMEFtSWk2Y0JsZ1BKQVI3Z1hOcUV3ZFBPQjJwd0ZBSG1nTXc2eE9zU0ZvSEJFTlNUMm90MmtFVWlHMGk0TnVVcWZ3SHg2SEZOSG5DS0V6QUxmZEpwUGJicU0rUC9kQTVLeE12bmZGWFVjRjBRSVdkVlRES21oMTl4eEZraTVoQVl0SENZOGxoQzVlZ1VVa2lDTCtBU0dhREltSUNIM1V3SnFzL1lrbGlBWi9xeWhwV01hOGpyNm1xYXFtYWpUVVVGZFUrbituQ2hnZlBDZ0k5Q3NxS0sySVZ5UW4vVzkvdi9IOXhzSmJOYVFZSW4vL3doMFNNaEQ2K01MOW9HMXFFaUpZZlAzQ2VRczkrUDJGNnhESVhvUis1akVzUXJFd2huRWlZMTBXMDBoRXVxeFFnNGFPRmN4clNOUlZWUWROa0lhRGZocERmNmhUSGE0OW5CZHQ3TmlmSlZLaGxFeGNPd0I5VkVEcjdnN3ZBUS9XYlczNXpMSm02MHR6R0N1OGJ1dThndkhjMG1VenZkblozc3p6c3FiSjVzVHk4b1RKWWd2SGRRRE9lMlZkbC9jQ2xOYVBMMXlJcDJlS0Y0clQwMFhLby9DTFc5d3ZRWGxpN2lCM2pJMzZLTEgrME1raVFnMC9NSXpLcmNxUWR6YnlnOG1kT2RRQ3BhRU5tazBFZzdsSmxmNEduVUVsN1JZMTFnSEhtSlJsaWRjRUFzUVRmQTlCRnhlZzRZaWc4WklzMzZjRG9NOGJOc0pFd2FEREl5UWdKZlFWT0NDVTgzMjBFV2RUUmNPU2VJU1JLRUxBUzVaUlRHVi9Sc2N2NklZazhPS3RiOHhoblU1MUlIU3FwR2tsYmFqZkEvcW5vNDFOL0NYQUpmbXlTY0JLWXJOakNHVHdCYWIwbFNqZXgvN2lxSENtRU1WUHNyODRRaHVGTUZlZGd2L0pzSERsbFlWd2twM2t3c0t1K1NkdHhQWU9rbXBnV1Y5N2tSdGcrL3NIUGcxVUs5bWlUMWZwMHhUcFF0N29OdXFkMC84ZEdtNHhXZWtONTRhUzUwR1NVQThLdEw3UjY0M2ladzJRUVlWYUtiWm4wcHNJY284cTVXNXJHYmU3K3loaW9raUlvTi9VdFA0WjZQOVA5TmYvOGFZS2toMEZ6Y3dneFJIMENLMXIvWCtCVzZyMklyZTF0VTR3QUdoK1prTGdpUW85SzhudkF1VDJ3c0J1ekhVR1hDeTg1SGpGWkQ0L21YOWdKTHpBa056b1o5c0dzODdHd0dEbW16QjRRYmtlY0JVMlpibHp4V0hhRExwWE1YU2pVQTJLeFdEL2M0Q2lzUlZWZzBJaFdFS1c5aGM4MnRDVi9wL1c3U0E3bWQycy9YMEVmUXRoRjA1UVFmWDRFdHJHRjh5Mms5Z0JkclhCcnZiNEVXMkREcjUwZk5CbTY4bmhSVzdRaERTL3ExQVB6UTN0dTdRTnF3UDdMdXBSZngzNi9UVm0yMlVlSmdNZENscjlZYTVGK3krTUl6YldxS0d2RTRVQjhhVnR0UjN1VVZjcU9LblhpTFROUko3UVVsRXBuczhYc25uazJxWXZDNXJHQzZMak9rNTV0b3lxK2hmcnFXaHU0bnMxMjNIY3NXLzdxU2o0aENEcm53Z0VvbjQ3cmFpcWt2NWVzUlFYdnpqRTdzeDRzTTVveG5XWmd1a3dhd2J6MzBoT20ydjZFUjArUDA4RCtvZnVwbUgvU1JiYlNTZnBzL3VwZHNoR1hwT09TektGRXNjeUtyS3B5WkNhSWpwdHFvTXdPN1FmVWtnL2tOYjBINzFyc3RtRWo3RzVpWVVyZFNlU1hSR0RCQkNCRFUvZk5BMmh5QXN5RmwwSnoySCtTdUZoK3ZEa014blR6d3VnVVlVQzFxTzhxcnVLalcwbmFyY2pCeUtLcTZ2NVNDOEkyRUVvNys4dWM0czdSelVqZ0dLdCtpeW1CVnptOTZPZHNyWnFiVlpZbjFwQmQwbzdxTmt5ZXJsYTVSQWRvUFEvUUQvVHhQZ3NRbndtelJ1ZzlnbEk1NUhJWXg2ajNQNDhnaU12SXQ0UThkZ3Yvd2NzSEJoWGJRRlVWWG9iVjAvV0lCUXdMeVBCbG5TRHR3OEkrQTJlZWNNVmtxeUdLZ2dsRENLU1Y1RGllWktxaXlBVFRORWVxMXFpQ1FvaTBWWEo4K1ZBUUk4ZjBOMjBwZVZWTHkzcnRteGdVRGZuNWozTHhMcGk2M0xhVTIzWkJHNHNwVjI5c211K0QxQlg2U2R1eWZVZnN3bC80cmFqUE9ZNWFMdUx6TE1GQmxFWUZIR2QxRWtYRUU2clE1MFpheFVMdDlnOEtEWGgwQWtVMFBUL1ZVSlNrMGVIZFAwUXdpMDRBYVN3dks1OFZuUjhSL3lzc3I0c1AzNHNod1ZVa2wwN2ptMG9Yd2tKT0hlTTU1R3hrSlllWFdrRWUvWUVEendxcFJjTXZFMmZYbUtMcW9ZK0VYZDhWU1BVQnFiOFBVbWtzbGtTdjZIa2xGL2hkUmxkSitzOHgrMzJiL0JHNVFzenJBVFVGMmdvWjg3SDU4L0gyNkxtUEQyOWRDNDJjY1lkd0lxQm8rc0FmaVE4N3EzQXM5NDZqR3lObmlTUmtmU28vQXFZY1ljTllpcVhOalo2V3pUWTJCZ3BkNWI1eWNGRDdOc2s3QXNqbm40clhmaDZjT25tbSs4d2JyOHY3SVgzaGl2aHpYZnFFRjhKNFh1dmZxKysxam5kV1llLzVJRFUwNmU1NFR6K0pxc1gxWW5ySU92bm1HL2x0cVBQbExEakJBVE1sZ2VDVVhkeklGMHduSzZuWC9SNFZDcUg0N0s4cFluallia1VqU1BPM3RyYVFyYnpUOHpYR1BYeW1VZWo0dm56bGV3YnNybGVyMy94NGtXME9qL2ZzKzBMdGozUFBpTitOMUF5WVNBTFVlM2oxSTVnVTlQRHg0ZHRRY3NNZW1DMTNweEZBMnZpQ29vWWg2KzM2bERjaFRyakpVdFNDeERmRXVvdThaMzJNZ0tOS2RwSEo5eWlKbHE3KzVoNHZORStmcnc5V1pLbVNHZmxzbnNzbEdBZ1pOMXptVzFoZlAyMHp4OVlPei9mTzM3djhaUTRLMDJjUGdEb2lmN0RSeWNVTkFQZjBPazU4Qm9hSERqTjI2dVZ5UUhQbTRlNjBEa0psODF1NFNLb3BwV2czaFc3QVlsQUVabnFGVjJFeHc3dWVmTEovb3NYcnI0YWNWTkxTMEY0b0hyVFQxKzQ4UGllcXc3dDViamRjeHZWSklFQUVvTWhYNzM5dW8yTjFyV3pSWEcrVjROM1Z1bnJPL3oyVFVBakwvRWVHRXp3UzVWdFg2YWhSUXE5aVpBcFhoVDQwN1hKQTdmYzhyYWJnOXZvZlBUaUVpSFRQSDhtdXZteG0yOCtPRG4yYTJ5V210dWVONld5MzZQckFxcnRMdk1IclRITHZBbnFZQ1dnTXpDdFpaNU93YUM0NXZXM1pNMTcyQWhFWWU5ZkxCMG84Mjd4d05UNit1WDdpdmVEOXY4WG51eUowbTk4WUh5UmhJdlRsZjFyYTl3b0xzdHg0OVIyak1vbUppWS9oZHJOeGpMdUx2UFFHU05DZFNvWURvMklXaVFpZXFGU3JsT2UyUTJiNkdxdldISzlNRFhUek0vTmVjVXhJd3pTMDQxQy90U3BmNm5VNSthV202cUx5VCtmT3BYdnRjVXNjUFd4U2FRWmNaREo1NmU4RmFQcTVIUDVDYmR6NnZSOHRZSlc1dlVVcno0NGQvcFVweTJPZ2M1VUgvak5NenBVQVY5UUVORk5iUHYwUUZGazRsV2VIQkxocnN2NjUzbFJVbCtISmN2aXhkZUJMaXgrSGk2aU5mMkJSM2lWckp6RURwMXJQdGtEdlBqSUF5RHl4L1dSZkliNGxFMkQwSzZlaEJRMXNOVU1neEM5VnFjWmliejFldmhhRW42OUpmS2ZwNW5RcVd2SXlPbWQ1QjFVY1BESkZZZG1NOVJ2MTREZVJjQVVoN2hWN2pxUTB3OXc3K0Irbm51S1lvdzgyb2VvSnJLRTkrSEVzV2NmV3FCbm9GQU5QSGFIdHBqS05tTmN3akZUWDBEM0dxcGMwRW1FbDdqV1pYNXVUV29ncml6VW14SHpESUJHakFqMDg4b3lUOVhjZ1EwNDhCdmxOdk1uUXZabXlyYWRCWXVuWTVZNG9hM21EUlhKUkZrd2ZUT25JOXUyWGQrRWVQK0ZZZXpYN0ZDdEtMK2xWRlEzdUFKNVVSYWwwejRNWmkvTUVyU0ZCQzNsZURnU0ZSQWk4dG1NSWNvdjdML2Vhc2x5eTdKYVBJL2hlUDJKRXpkWVRkVVVpZDVzVWdOZzA3cmhoTHdteTJzcFUxMmpGOVpVZk1uNW1pUllFK08ySUJVaVJZa1FINnExakM1N3VUUUo4VEZaVlJUUk1FeEZIUHA3ckEzNmZZdFowVzhDdnQ5dS9rZ2l0enNqZEJ3YnBTa2xYYWRiQjhGTVRieFJGM29IU2N5b3llUUxqUVYrYjB2TG1Tb2lDZFh5V2oraDJOK3d3OTh4c2dndDBBRzhkQ1loMVJzTVdRVDhjSmRJaS8wYlFBMnp4YWpSYXRIS3RzelBiRmQ3SjdoRHJXZjBYaFFDZzJRVXdFY01lRjJWb2U2bXdmeHAwRUMyMTduTG9mZGREeU9xVE5pVWVES0ZSakVPOVYraEUyVnMxY05BaDRaakl6S0JvVXVKbGxNcE13ck5KbU1SS2xsUDFrdFFLQlhTUitDZGY3UkMzekpTb2U3YW51NktRakVYSXNuMDUzMVREQXVLN0drT0FvaG1oZW1KUXNITkZUVmpMSSswaXVOV05GUW94MnBRbUxkbU5IVmFjalJaeEs2cStVSVlsWkFZcFZFb3d4OWN5RGFhOHpPU3FrcnpwcU01Nld3aGNuWGZyanU5L1hyR1g3VHRkdU44RWNUZDViS3BHaExvNG1ZOUxoVHlSYW9IRCtsUUdIcGl2RXpkZG1yMDhpVlZ0d3RZKzZFeTNEREllZGozMWhtK1NuTUwzQkozTFhjYjlXTVplc1d3dFQzMUxvbm83Rkc5Vm82U0s5UmhqRUpWNmhGSGp4SHAxZ2x6Vm1NdURQLytNNFNRajBtKzlMSGtRSjU2Q3B2NHFhY0U5WGZnZ216TGNEMHJTZVFOY08rbkJGRjQxMVBlRzlTTStnWVBudmlON1Rlek1GNUhuNUFMTW5zQzVYaUZ2NXFIRHp0OCtQaHhoSTRmeDAvektuOUtFRTdCQWJRRFlUL1A3d09nZk82NHNrOFU5eW5Ic2JYemxzbnp3ajZlM3d2M2J6K3U3SWVINGY2T2IxTkNyenEzOHNPVStoRjFIOTcvWVpyc29zTlhYckwybFplczhTVzF4QzladTRkZXNrNmpmdlRVMmg5Q3krL2pEa0xOZ2pxcFJrR2xEaDJOZWdGSFFiTWVnVVJ2MTl0NVBJWHBoU204aE5qd21rSlJIYmpUWVBsU2c0cTdOdUlQL0I2YWVQOFB2cnhTbWJUNDZnUmVHWHY3NjYycUlwU1FQV0VEdjNDZHdQN1F6eUZlMENRcHFvOTdhTFo5MTRjLy9QcXZQRFZUTFFSOC9yNnpaMDl2ZmZvbU5IZU5JemNtYlR1dkVwT1FOLzdySG9sWWVYdG0rdm9kTzBSUzlvQ2pqdHNSU0k4ZktqVHhHWEFBbU5hN2M3dEU0N2czOW9mam5qZU81dHAzdnU2ckh4eGtlL3Z0MTJDV09ObHUzOFJXVTJEK2Q3MGQ3YUVxa1REcVJMVjZtUjY3TmFBRVVLQkdRQ2ZyTU00a2tYSXRhakJXUmNrVTBvdndhSGgrNHp4ZDByWTN2VjhpaXgzK2cwNVlpRHZwbWJmMnZQU0J4ZndqNDdYVG9pSUorMDhLL2xQRmpLZ0t1aTRlajZmZmVaRHNHOWVRZ3RiWis2bHExbkJGdnIwbUZ2YUVwYXBidXR4cG5aT1hacTZvWUd6TEhrWlBxNU5WSitiNWNxK2NtVG9xQ0VWUzRlUkw2bFFFN0RMTDdhR3JaUzcxWDRSaUE0T0p5bEIwaURVYmhQS2hEbnlaSnhMbHF5QmtPb2xiRFB4TERIbDFrcXE5K2JGYmJubnNsdWVKTkI2bCtXa3hLbm1lcUU3ZDdJWHQvYzdmUytNRUkyM3NsdDU0NXNSZVFWSjhSZUpKT2p0YktlMFJCblY3NFJhYXdISFhjSU80Y3AxbmxOTklEY2R0dFBqcVpveGpoUlI1SzlzY215VFlrMjJjU3FmMHNwYWZ5ZUNrelF5bzMydVluU2pOclBWMFhRam5SYVJlUk4wNmRaTWs5VGJBQ1ZJUHFBbWVzcUJ1TXdLQVFTaHI2OVlmdU9yQms5bldtZmJ2blR6NTRJUHd2Y283ZTlhNzZvSFd0ZTFPKzlyV1ZYQ2hkYVoxTFhyTndTdFc4R1I3OXFHVlp2M3dJUkN5Vnh6VS9YMzdmUDFnZTdvN1BiMDR0UXBYRHJZbUY5bmM0MDZadE1UdVI4c1RRQ0dvempMSW1aWXJvcmxERmhBKzhBQTlycFlmZkxETU1udlQ4dVVIRDE2K2ZPd1BJZDIvUGhpbUR4MUtoNE41cGsyRzg2bi9RcE1NVlVubVl3MFNBeXBKMTJlMTZHcWNOcFdsTUhoUlFNRWNYYkMxM3BNWHI1bVptVnhZTEh2YXBERGpLRnJHSForMkxhdFFzSm9PNG5xYm03MnB5YW1lYnA2Sm5hcXY2ckZyVjZiczJMNTQwZDYyc1NYNXYyVHV1eklZVFc3VWgzWUZaUDRwN2hlSDgyUUVRRTJMTWhJMjhkU3BRNm1wVjlZVWtpTG1HaWNsd0tCZXBwNXptTGtsMGptL2Rzc3IxOE1JVkwxYWZiQmVzaFdOTEk0Y1hUcEpMMVRhTlVxVUJUaWo4OTBydUpGTWhpOGtNK0pONmdaSUZhVXdqNmtMeXBuTEJFQ1VzM3NpVlJlamNyNlRMMGVpcmthTHN4cXZtMm5Ub01zMlZDUmxQVlBXaEVQWHZ0ZDN2YlJZOGpTc1dwS0V2cER4eG0yem1Ca2Z2M3A4UEJNYjlyamxLNEtzWUY4VWZlUVoxWURvUEVFU255bG5zbGtJZUFrUlhpZkJUV0lPYmJ6OTF1TVBSenFhY3ZPbU5MZC9MSk9QVTdLY2l2T1pzZjF6a3VaTDZSQ2Jja2JRWEZ6WG90ZWZ1TFgvZDRxcFNQSlIyZFpFQnlOeHI1L1pjM2kyTmhablhjZHhzNlZLYmZid25zQlJkVjlFdW0waHZYU2dsaXNXWll4Q1NRb1JKc1U0Vjd2SE41eW1wQTFzekVrNy9kKzIwRTlPeDUrODhoekhqZmlpMUVGN3ZKeTdldWpiUTVldkZKaGZlRGxaaEV2RDh2QnNIMml2NWNUUGh5RmthbmpyTU1ROFhKNDdhcXZaSEp1eVROY3l6YVBMN1QzaitjTzJ5R3U0UGh1WDk5NWJPb1FKbndkMWMyS3NIcmxHcFJBWldya1FBSmc3NmE2dXV1aFZoVnE5WkNtR1l1cFd6cTd0bVN6VVVvNFVHS0tGNW92MVhNN2RRckk5bHEwVVUyNzY5VVlxM204YnFlSSs4NUI3NnBSNzh1Um8vU2FBZXg4RnBNWjFmNmhhdzRYRzFQVWRLbThDNjZPOXYrNUgyd3VOYWNVaXFPUm9wYnZOblRvK2IxbldzUU9MK3llTEhSa0prK2xVcGJybnAvY2JrVzJabW5xZmFhY2RUYldjeUZPVm4vSUxTTVRwZEcxNnJGajU4TW1UNWRYVjhzZDFzK0NNNzVzdGpxYzl3ZFFKbjBtVkp2UDVVcmJvRlVIbDBDUWlQNUpKWnpYVnoyUnpodllETS9TUmJPYWlYT3BmeXFkT2xVK09ZaXpLTzRIam9KSlRvZ3Nhb3liMWd3UlpqOWFvNFQvdXIvK1htZDc0d2JseGRyN1doMWR1ZmZqSWtZZFBqL3A2OHRTQ0FpK1hWbENGMUNzQUR0QjZmLzNQZXpPMThibUQ0elQrc1lkUG4zNzR5TUJmWlBDT3haVzVCcmVjV04vcUMyeTFBaHNGVVNQeE1XQmNGU0pOMERJdWNidGl2aXB3UmhjZXZMN2J6UmkyazdHZDkrY3EzWnd2NDI3WGZ6T2IrdGcwZk05RVN4ajNmeC96dldjeWptNDRqcUU3WWExNjdwYXFMNmkzUFpQS3ZjY3grbDh3Zk45QUJ3eW52NEhSZm5qK1MveWdMeVE0bFBvZHplOWVBMG1MUVExMkhkYWRnU1g3WXRLanFSOVNtM216RGMyV1NUbk9kTzJNQXgvRVZYSUZ2OXZGc3A5RDY3c3kzM3ptbVM4Tnl2am41NnExWE9xWjIxVEJyOTR5d0JlL0MyVVJRZEl0Y2llNEc3aUh1RGR6ajNOY3RRVzRzRnhuWWRVbjRYWm5aZlFFUnQzc1JvbVBGNzFjcDVBcVdiVzdzK1k5MGZ4b05VUUtzYWhDUktqbFIrd3NNWCtVV2J5OVlvNkNzRUV2cDNVTkNRTW9YYmlFK0Y3dnNWNFBIY3lpMTE1OXpXdFJ0akJ1ZEkrUi9Cazk3Mll5cnBjNW5EclJObjNWMUNWeVRKUjRVUUE4cFVHS3ZHRDNMNWhhUmxHSkpBbDBoZGlwQmhLVUFFc2libDk1c20wRmlnRHRmZkxLMTVpdW9TbVpoNHpDM0h6QlNFMk1ieFNMY1F6ZncwVlRWUGF1cnU1UlJiUG9GNHdhZjliSlpXcVFxM2tsWHpPSXBKdS9CTnlhTHEvUmJKNG5zcVRaSDdPMVFpVFIxV21TOUVSNVFaSDB0SXNrQVZXcnVwdldKV1doWEgxU2NVMVhpbDZsRndwNmFvaGJmNWY1TnJlNC9ZejczY1RkQVMyUVVIMmI2TTBoMWZlaHhLSk5KNklUdW9kaVF0N0FIeHVzc1NUMHlEb1FJTnA2TW1sTndwMU90VTFwOUx0WjlOQ0hLVjE5MStvZXc4VWJ6RFR5MG1rUE9SbDBXWGhpd2ZMOGZQODJPU0N5YXRHbEhLcHF2dUJsUERmbjNnYmtTbys3TVNGRzRRNTI1U25OMUdRU2ZJa1NicytwaEhCQkhnaDNsNXNDd2tXT2VVeXNHUG1KeUJVdDFmcGxtcGI2KzlRZkI3cnptNEFhdWlUcGhWVjJhcGdGVUxjdDBlVjI2Ym9KRHE0d1dtMzdhUTB4Y0owdFE2aFZvbVQrcFI0VVVNUVByNFZSRXk0R1lXbTJCSi94T0pXS1UvWTk3MTlkVzMyQnQ5MURrOVh4WTJlRnpROTllL1hpK25kZkljMUxmL1R1TjUxbno2Nms2TFBmZlA4OXEyc2JFMk9UaDF5TG54UE9Ia1Budi8yaDlZc25YdkdtZC84UlBEM0srNFp6eFlQU3RRY2xHQjZUQXJDY1dXNUpMcCtpNlQ5SGs5eWxxNDZCQnZOK2FsMWhvbkF3cXBLRmJFeGpHc29GNnVsYkgvb0dEa1pyZldURWVrTVpYMHQ0U0RMek5ycUJ4ZkRlWUpjTE9pdm5EOThaT05QNkNUNUlackRvSW9oN2kxT3FoUG5yVmt4VFUyeS9PQ1dMUEQ4OTFYTmxYZldDUWtZTlQ5d25hTXZUdWRCMklXWXRmMGZMUkpWNnh0TjBtZWdxQkVUV3JkQ2lQb1pDSVJPR3FxWWJrVi9PV3I2bTB3MHJOSVVRUVNGcTRCcTZBQU1YUHFLZnRrSlZ0OUhhVk1GMU5kMnlscTZqQzNDbUNyYXRhcGF6TkQyRk1kRmlHOTl6UExMRDFQU1N6dDk3WEU5bE05TkwvYjhIQVdocWx1MG9rTCtyeUlKSW5VWWxtWWVVRmRVQWlXYmJpZ3daSzVxaXF3Uml4SlNva1FpR002YUxZVVVSTHNrNTF4K1JVMW51L3VIdUpydG92dTJyU1liclFRYU81b09sSkVrTFhMS0R5UFlNSVd1QUlmM3BwTW53SG0wMDlOQW9WYWVMR1RVNGNkLzFPalNEYjJaOTBlS0pFQWFSVEJTQkVFVzFKYUxwcnBVcitaR2hhMm9ZWmdvQ2pOTk15dElWdWxNSXRBUzBnK1psUU1obTNyK2JaSXlNSzNiS3k5Q21rRVFFUUJmNG5Va2tVTzlGVzFFMVRWRWtVVlpzMnc5TlExVkU2QkRBQ1UxWEZHajdRY3FLWTF1YXFXckRkZFVjdWdBaitBcVEwSUEwcFowK3RnUkNPZkd2WjdQakEwcTBCL2NUdjVWSzRtNU9QVnAyOWxuNTNWS2hiRVpoUGtpWkFON25nOERTWkdsNWJVM2dOZjFnT2dTMlE0UzF0VmhRRGNkMTV3WGVNaDB2NjRWMnl6OWc4U0pSZ0c1Vy9wMTdpYU5IOXRUNTNoMDFSWlhrU2w1VkZWc2ZmeWcrbncvU2xpVVhuOHJvaWdFc1N1UzU3VFg4U1YxK3JKcThYQ2xmdGlSRFRQUk42R3VUM0NzaHhweWtJRE5hZTJCcXlXRUpoVTNhOVppQ3hFUzBSRHBrR1hYSkpLclVPeXZJcERBcUVSTkZ4QXFhOUNoSWlEcGJRdkdwQlorWlBvWTcxU3loT3ZxbVczai9tMVlQMmVTeWRyR2g2SkpxbDJiQ2NNcTQ4aEc4ZUhXK0VLdWxZZ2twU0lET0VaZ0NLRkJZbGxKMEtiY1lMdTJwVmZGWXlWalVkYWtjTGkycFdybytVOG1XUWpJNXVkU2NyUlI4QjZHcmM2Rit6elBUZUJKVjgxZ0FuSVAwWERzZDNTb1JhMkt4S0hvVmowOURyME9pSVdnSVl5a3pYNUwwQVBGNXI2cVRxWFFrOFVGUlVBTytqSEtCVHBDWkN1cWw1dXlzTGcvbkhoTzYvU1JVKzNIcS9PT1VlMmR1NzdlaERFdUo3K0ZneGNSMlowbkdQbHNIMngyeWhTamMyU3VvUnZXMUFWc21uVzFPUVQxa0k1OGtTMVcyMlFROVROSDFLNWhFeTJpSGw0OG1pWDViamJ5NFVTbkh1cFgyWE5XS1JKVlhBRG1KdWVEcWdpdG5MVjF5aUVna1dZQ2hIdHU4cVJITE1jZnpOY01zKzc0aXBoVURWRVZia3AwUUNYWUZ5YnhpMk5DWmlZNTRKS21hSXhsWkZKVjFEQXFXS2l1S0xtaGlSbGR0MDFHMVZMWFVLS0tUczgzSm1jTnhTUk96cVhyM0t0TVRGWjUzczFla2NlalZia3ZiaGlvS1VtMUtnY0loMGluNGd2N0cyWW0wd2p0T0VVVk9xRTlPSWVobXJ1RkZSMFJQckpvV0RwQmZVSGxNa0VnMDRyblh6WXhGdmlDWENvY25CbllQRWRyZ0xSUTE3TFRBRHYwVDZuZUdsTm9oZlkzUStja28zS0haZEhaSU1hSXllc1d1TGdHelV6UnpRQ3czTU1lRFBYWjVwNVoyYlZoTFVXUzFGTE5lN1I1SGR4eDl1NXBJN2hRc2tFcTB1OGpiT3Z6UUJ1VU4vT0RwNnBLb0c5VGJaSENzQWkvc2dtNWxvZVNJTG43em0vWVA0aWVmdEo4ZGlYNzBpZmhMM3hqN2Rmdmg4SmMrbFgzZk40cFBmdVZibnduQ04venlyLy9DaUYxbm1CZFhoWFFyTkcxSWorcHRhUE1Ia0JvTlBndUpRQUwvNVZ1ZjRlSFZFYjNMZ0JJV0VzM1dIZXk5d1NiM1c1RWZSblVKaGhXQUZRdlJQaGdsbUlNWm5XaFhib1IwL2FoVWtTcFJkdzVBYmFjNXZEQXdCN0VkTnM1dm5NZktUVDFiV1QzdmRhYXZzYjZZMGxDNzVBVTUyVjUyREJNb2lSc0hiMjVpR2MwS2dMNVZkYVdXZFNFaTVKeFpRWVFMN2FNYURwRlJSK3ZuVjFXN2Q1T016MitzTms0SDM0Ny9WQkFRZnM5YWwvUi9hMitjaWxJWlMzZG5ya1FBNk5Ibkh6aUdaRUt4UGZwL0pxK3g1ZW02cE9kTEQreWVUN0NoNW1mcEhoRitWQjZPYk5EUXV3QkhtMUU1R1pYdFZuVklsVEpoZXk3TTBoWHVqQUhUNnRXN2pVNE5TRkF2UzlTaE5DS0RDMU5vQ01nb1l2dGlXd0ZPNk91MmtrbkJVRXUvaDVlRm0wR1BuMThSRVhxVmk4bWVLYmdjMWcza3VCaDZsMms0eTc0QUl6dm56bENxS0VxMnR1SXpxcmhsVWQ5emM2WGNxTUFiOHFmZWkxd01TV01KSC8wOGVoRWovOXEyWkZTbjY1T3FQWCtWajlDQkIwcDV6OGtpVjdjeVFLSjQ3MjhONlhMc2djOER3OGVLZmNUd1pwR0l0RzJlbC9qK3NGbndMZ2xBSjJuWFE5cjhJYUcyRGd2TklhaGVFZEc1NmlXRVNxNnhyazZyOUx1MnBsNzNhbVFwTjVqbTlZcU5YbzF0RzcxUitQb3pndkRNMXdWaFkwUDQ4clA0ZlZIMFB2eXNJTDcvL2VJbHZrYVg1blpKeXJ0VEdyUWo1cGl2MjJudUZmQSthRmFFclVQQVVyRGdSM1QrUE55SDZRdzY5RjQycTdtRU8rMEY1clpTbThJVWQwT1hwODBMNG9XNURRTUVwRElGWUI3MGNiNGRJVVZSRHAxRHlFbnp2QW5RRmQyOXJHbjc3MFhJMWsyZVQ0TVFQSHJyYTdyRktaNmZLaDY5VmROdVBRcHhZYko0elN1VWhmZWdOU0VQTGREc3RKdlFMclloQ0lidEk5eHNkNW9JKzNrKzV1ZktuVTY3VTU0VEJJaTFLMGZLODN6L2I3NTArNkFkV04yeWRJVU8zV1dGRm5GM0FURXR2dGl0by85RHM3L3lqNjlNOGo1Nm02TGNCdVhvUC8rZTk2Q3B6cjJqNmRQWVA1MjlmY1RXcU5DOUNxTTY2ZFpCUTBXYlA5dDk1enU3UC92eFZ2c0hkMTg4Zi83aTNVOC92ZHVIYXBmZjdrT2ExbitmcGxGblhIcTRsL21LY3dKN2RwTHRielJBMU4xa216NG9MclhuVmRvTUx0TTFXM1JwWDVzQjc3R3kzMGk1dnVTTHR0YytxbmExOCtmejJyaWdqa2s4eHNKZHBvL1c0dmlMaWgvS3NnWmZ3SE1BSzBqOGdvMzF5WU1GUWMwRWVzYkpTTDZaK1hDOFk0dDZZMUtPNmtDM1l2b1ZpQThZNUVGaVIrcFF6WW1PVVpOT3E4RnRvZEVxbzd0ZnJpRDlqVGorN1IreklPSzJuMEdKN1pxVnJBa0RFa2dXcGw0MjVWazh4eHptMjhNTjlnSm1MWUk3ZkJOQVBiVWRkU3NnRzI5VWdCVjZJR3NNNDh1R0lTUGtJVjVXYnZTc095ei9pWFh2UmxmMjFlQ1c4TFRxYTZnWEkxNzViNERvTVFiVjZQc1N6OGQ1dWdvdm43ZjZYMk0rWXBzNytHYVorYUpRV3hZell3R0hvK3N3bHdVb1M0Rm5tMFlBZUVtV2xDZUdDMkR6YUZuZys4L0wxRC9UYmhQUTRURHdxTHZvZmdjaTVrbmI1bkZKbDZDRW1KRG5OQUY3U05MUlBnMHJoa3hON3lJZ2NWRDBnR29Ta25oWmJJbnE5NG5JUTZoSTNLVysxcGVzd3FHZ3Q3YTk4aWFQQmx0dlZYYlc0RXpsMWJac3M5VTNpTzU4cUd5dndaa3R0QW9PVzNyVFNCYmpjS1A3cEJTSCs2VFFHY3c2ZGZmN0VkdWx2R3ArZFhYK3prdTNUQ2xYRmxaUG4xNjlaTnNVUm1NYjBqOFBvN2hCNTNxN2RBTkZ0dUVGMzZMT2pEVTJZY29XRjVHQk1TU3FEUGJhMm9mUlZRODhvUFMvcUNqUEVmN2lwN08xbG5LL0ZRU0ZRRHVrUVJoWStxMklIS3hjZjEzbEFHQzE3ak5LalNmenRVejhrYURnK3dWTks5Qm5SMnpZSWtqN2dLNlk3Rkp2cm01VTc3VHEzZEFmSG5uNEVvai80YTEzMzMzcm9wL04rcVZ5TURVVnpJdit5b3EvZC95Njlldit6YTdkVkxOblgzbVR2ZWU5ZSt5REd3aFpyM2orRmRaVnZ6K282emlLMFhVc24wdnlHS1NaeS9tbEpKM3g2OFlobmFFOEhrY1BEdDRMZmxUcFJsSklTaldhenJBODNLNzFvV0t5ZitVS0NpREZibUhvSlRiY0VzSWJhdmQwbzRkS2ZiZ2RCTjBKb3IwMU4zZmdFM1NuaHoxTlJQZCsyTk1vbHBvVEpsK0lPek5IVDR5eGZSOEt4ZTZNLzNmTjMyaWUvQ0RiMVNHTDJDSFgvOVpzZStGVVFKQVdINnNNOW5qUVl2L0tiZi9ZSGx0ak5zWnhYb0ZQekxPSjdzbkFLM1Z0aUhobVhRRFFFZjZhUDk2T2J6azRlVVZBTnhkZThldXVnR1JkTmlmMnljYXhoUkQ5UXRBNGVjdE03L3BxYk5qWm5IRDY5dUtzTHlCSjZyOTUzMFRnTFZ6QnR0RVptYituVnZaWml2V0t5TUwxR3FndmM3Z3JSanR4MEdVV0dvUkdxSnViaGM3OTRBWlZqVlhsOEg4OHJNQlJSYmRyYWtsUng4K05xMHBKMWZZY1YwNmRVbHVhWGl4VXNwcmFSbXVuVlFVZTcvWGdhVVU5QWU4cWNxVWl3elcxeWYrNTJsSlYzMWZWRmhOdkwzNmIrd0xRb2tyM2dmSkE2MmxTZFRhazY1Y3IwV0JaMmZBQVhOQ2tMampKYWxyZ1RhRXpiNGRDbnRkc1BxUE1UdG1XYXR1VE15VEwyeHIvV0ZnSXd3S2Ewa0tFQXYxdXpSRFV0WSs5UlZNVTdTMUorTEUxVlRDMEw3UGxhc041ckdTL0JRbjZvRTk5T1ZkUXZSa0EyQUVrRWdBa2hCN1NqbFlRcVpOMmszeTYxMWh2OUhJNWVqZzNFdjlIRnUvbGtzTk9mR1J2VUlXdXFZZ2dVVWdwV25yMHZpZWV1TytXNWQ3RzBydk9yLy9SZldlWEJ6eHArOWtxNUZ5bmp3Y29YcjZGUHYzb1VtLzU3SDEvdEg3K1hVc2J1NS8xQ0R4SUhjYmJHOE5IMFk5NkZtUVFjeTJQdWlqZUdCUURiUmRqQkI5RXlWN0dVWlBVbTIzbUVndUhia1NsRk5wY3V4K2RXRnM3OGNxMXRWZXk0K1pJbkI0SFBwWEpQaGFjeCtpWjBIRnp2YUY4RmlpekR2ZTJvNk8rbmk0OEh6UjNkZ2VpcytwQmZmMEhzdHgvVHBaL3NBblA5T1FYWkhsZVh1K3Q3WDRQc1NtWFhhK2k5ZlhONGF1SVcrdXR3M3Z3ZG05bkRqUFpDM25ROW9pMWR0ZExXaHNnRnFVV24vUUV0SDQxRlBicVhJNGUrcytQbktCejdLVC9GRHU3bWdYb0hEdlprYmZKWGdNQlhVZVh1TlpXeXUwcWRUbWtsRzBFOGcvV29ZNW9QVGsrTFBmV29KcWJ5U0ZaWHoyUWpZVHBsdE4wWlFyUWxmbTlkZ2VyMkdwMFRYVmp1STNpempyb1dwMXVVTkJxbHNxRVRsdXhoYnp0MVJmczUreHYydlR2RHVwWWJkUXl6MlZxU2xTb3dOanYveE9QQk5kODNuQVF0MlhiUitZcHZWZnRMZWFCalRKbS8yS21Wc3VnWmtybHpjeThqYVJhLzAvb3JNQ0lIanpGZGJoRDNCcjNMUGQ3M0I5d1h4MzFlRSthaDI1dU9iRGdOTGUvREtjRmhPNnNWV1l3bnEyWkg2aGR3S0NaT1RFeDJsSXdSMEVkQVJuYWFnQmNHazRrazhyQVBwTll3NEhyRHl3dzVVRktBUDJwanRCY3dnUDd5dERTUXRXMllOdkszdG5ITnlJbXFhR0JPbU90aHQrZ1MvVFhhZFZqKzBYTzluTjJyZVU3R2MvMW9xeEhKMHg4ZlZHMkJhUWluazRvQ1JCNHZpajdsZkZBVVJ3THNlV0IrcXE5WGtTdWFhaWlKbXZBeG5RRGNKNGtnaTZIQkVsVmJERWxtcmJwSWw2M0xZQnlraFRLUk9jRkdVbUNSbFBRbzBDVEJRQmM4L29oMTZUTG8vdGI5Z1VieGJYTVdxYTJhdHQvbS9jNmlCWEhOMDNicm1XY0hHOWZvRDEvWHNUb0JHamNTS1lyY1k3RXBwSXU4YXBBalVBeXNHdjVGYnhrdXFxSU1LOHBCRUdwYUpFRnlaWWsyelZCVmJTa2NzWE9STEdHQlJXQmNvb3hqU0FDV2c3d1dtRnJ6WFEzM0YraWZXclk3N2xrN3d3OVdTRldhYmVhUE4yQi8xbm8yL0ltNEdONWNWSHVyNlA1L25OckhMZDd2V0NKN3NwRGQ5NUora3N6NkxJVUtJS25RMmdac2IyTmd2cHdFVHJmYkwvd0hOMTY5N20vbDUrTG41TWZScm53aGpDSFlwM2NRUFQxaS9KRkdUN3J6SFZZTGdhNVhGRE1JYUxyVU5Gc2x1SzFiUms5YXIvWldiUFI1Zlp4Szl4bDFBNCtxZzFGd0JISjRCc05maWRnK1AzM3p0RzhiVVBqMlRIN2c4SE9qa200ZmR4Q0czWi9EVFRxRGZ2aWNEdkZ0V0drTjdMSElvMnZyYTJ6eU9ycTZtNU1SS0RjWjNhODBJVEJ4a1owYXd1NjJkRXNTclk4WWtwYVJDZ0VZWnNoQVI1bUd4OFZVTEw5RVZPZTZvd2pEaVpPMk5aSWc4VTkxOFZxVnM2Q3lJcFJBQkUxZG16VEhwK3dKOGJoNkx6Y3pZbUhWTWQwN1ppSWc2VkIvK1BIZi9lU201K0tMYnA1K0tGRGdzTDYweUxVL3doWGcvWTdBakxORXFZUW1VTDFLYm9SNmtLNVRaMmNkLzFVUVJSS2d6MGFrOTBmbzJUUjZQYW1rR3hIeUttVndTSVZqTmxTRllSWE5FMDB4WXBpS2hVNGFoLzJ5WGtDSDk4a3Q5NUsva055TUpPTEgxNUIyMzhydWlhSzVkY1JWU1d2SzR1aTlqQjlCNzd3S0x4QWZjU1RZM0taNlpWSmZSTGJYNDRpcU02QU5kSHZ2MS8yOWZrVS9IL3laY3IzOUR6N08vL3lSV0hqT3ltTFRmY2Y2L3k3T2IvM1pmSmNmUG5NZG1Ub0V0MmZzVW94L2NDSW5qaHZEMzRTWUY4QzhydWdSY0VEVGVEaWcvTWd1ZEFvWUo4a2ZrZHMyZ1N0NUtwQlZETjBRVk5Eb3QrcGs0a2dKNmwzNElxajhYVzBpSE81cksvczBVOUlnb2pjS0JzNnhCUmsrUXZpVEw2UXlvQ1FOSHhDeGhxWFRadVNsTGIwUU5EZFdKZUFwVnBoMWcvR3hKaTMycjRkZ001dVAwYk5jWHhjVm14aDFEZlBBWTJBSVhNdkdaa2pVNUZrNklUQkRSUkRqODRkV0lndHdObTZtWTY0YkJaa2tkOTh1K0ZsVkNvemJPb2RldjVpeDVYM1p6SXNUSVlUcUROK25LbGxzejFielhpRzIzL3Z3RWUyOTdaUWJRWEJZNzdTQ3JieDhCcmdxVzNiTXVXOHpjRnUzdlRYVTNyeDRMKzN2cjYxUmRjRlg3TCt6OWpoTXJUZ0ZXZkFIT2JQbjE4ZERPNytkeUh2L2pyekV4aTg1d0xIcGZ0N2Z3T2h4T0pQRzdSZWtkcWRMaUFBYXBBWUcyN3lzbTN5QnpLd0R5Vll2U1dCcUplbzdPL1NCVXpzVmdkRWVWUkFRRXNRL2RTcVMrZ0VERHpSWEJZaCthR2x0OWxvMG4xNWdMbzhYUUFLdkNFazVScjlRQ2NKMldwbTMwVDE4aXdhek41QW41Um02ZkxRcUlDSkJKMnhnTmhjQkhCSmF2VWRQRlJtSzBqcDJvbzZkWW1Fb1ZFYlRoMTNPd0RLSUt5ei9DU29YZEJrcjZQREVvOFZ1aFdnUkhjWEVPVDB2djRMakg3dmtpWEJTODNVc2paUHhiSXNZcm9kTmNLYWdmV0FGK2plQk5RTUE0RWpFSXVITTBIaVJTVVVpWUFNT2tVT21FUUNUTUsySFNSME53cWNqZ1dCQU1LQUV4NkxTT0tKSlNnQ0p0aEFXSlZNVFVTQ2dDQk5uSlVjckNFNmFTK3BMbzhNbmxDbVowcWlVcGV3SnFBQTBoR3hqckdKQkVBTXFoaUpmQWtUT3cxbjFMOUg0V1ZYQkZJZ3VrUVljb3lWT29Mc01GdzRhTEFWdER5UEpjcEtBUVh0eVh3azZTVC9Bb1Vsdkdnb0d2YXhWSklsMVJCNVg2SnJpNEh4Qm56RWh4cEdDdU8vdkVheEtTU2RCdHlsSXdIckNrL1pNdys1QTR5aDA1RUdzV1VkdUxZaThLSWt1UUpkR3d6QVIxSUE5TWlDS2tpRXJqQ0VNaEVndTRtUXBpSGtxSmdITWtzYUlqSVFLWkJ3Q2dQcEpVTkFHVWliN3ZWZzhuWk9qN0NrcHRzcHFCc1VBU3V5azVGRGFCK2U3Z1VoZUh6N2pYT0F1ZWhlSUx2MmRWU0cvcDUwMkwvcTNLdGU4ZDVYb0kyUDNuRGp1WE0zM2pBY1UzUi9pTVIyRSt6NERjNmlvWTljYldBODJ1alJ2OG5POFh1UGQrNDdPRGQzY083RGgraVZROXJoYWJvQ2MvcHdhWTVlM3JYZlRjRDJqZXgwcWNZQVk2TzhBR01qTWRpRzlaRVY4K2hlWFZXeXQzZVBUaU5zYVo1NSs4SVU2RlMyTENNVkM2NjdzSlNwYU5ETVg5SjkzcjNwMUVmWXJ4K2dpekszNjNlUU9NYmpJcHBWSGlXZUtndlVmN0xMWnBaZ3hBTE9vd0MvQzRBS1JpMXduZkJrb3lwS3RpSmJwcXphV3BWdGtxTElRRjBWK3JxY1FsUE9oQU5kSG4zWnNBQzdxdWJYSmRHWnNHclpHZVVoVFVVUFBZUlU3YUg3UnVtOWIvc1hOZ0JQc3NFZFJHeExreUpLZHFNRHRXTUZzVWxFT203cmcvbFk5anN3ZE4zZlhrbHFTYnJxNnBKTWYvUkdPaTFwaENoR05HNVdvRnlvVm1vMVFsdTBSVVdSMEFiY2xVeVZGMzExRWJyTTVaTjM1UE9TZE8rdGw5UHVYd0JKQWJoVWN1eW1HZkxJVVNScGxCZFNUMHk2bSs4a3RXSnRyNldtRUkydEJCaHVnQXhBamFvdmRRYk9LRnNKNFlTS3RTRWNlNi9kcW51QjQ4a2ZYRjFjWEYwMFcvYVM0bmllZCsvdytuZUhWd1o4T2FnTkxqeXhTTi80NnVDeHBYOGRYcjkvZUdXWFRRdFRGTkl0RVkvWlVmbkJEd1oxMndOQlJ0aXVHSWxqRGR2ZVBrYmMrczhacmk3OEc4aExrK29QZURwV1RJRnloOExjK0tJSUdzcm1GbXJLbG00N21na2pYQ1JJMHVOcG9RamlWNmd0amxzV0RGeVFGTFJ0TjlIbGFKUHVkOTJsa0pYK0EwbVlNUnV5RFl2ODMrQzJlOHoxanJwdGZEZi9ZQVpUQm1DSXVRZjVWV052VnVsMmxleGVvOUsrNnhPZW14VkZhM3p6cnZhdzN5WSsyZFR2WmR1dnI4TVdPN2ZvRHpPc29EWjhPdENEMjYwNXZzYjZEdHZpb2cxQWlLMElhRFpHMit2Q1BCQjFub2dhWlo3QUdBWDRCeFlpQUkvbEZjVzBMV0JmWGJZNTJjL2xPK09MaStPTE9UdU5DZThEdDVWbHhyamhTV0J2bEN0RFRDUWl2STFUZ3pQWEUzamJQN1g4RDZPL1diRkZkMHhtYXdjYXpHRTE4YTd0dGxoVmxqSDE1N05RM0JHZ3UvYlA2YTZyaTJlejVwai94QUZoYUIrNWhjM1JGVUVEb2l1d1FwODRQakNGR3VCK1VMb0I1VUdMMHNIMDB1ZnV6cWtEcDg2czY4YW1HYTlaVnV3NDhScjdqWS80UEF2UnpmS2szUDhIVUhOQ05WWkQyLzY2V2xhdnRlM1Q4cmo4TmR1K1JoMVR2MDR2anFuWGdNNzAzVEUxc08wQXpwQUhwLyt3c3djQjVaZDVPcnM3bk5WbVcyb0ZEQ08yMlNaQURDbDZ6RldielFIdXhLaS9heVhaUzdvT2NHR0svUkJZdThQMi9OcUpMYUg5cU1PMnF3Rm1DMDBwemNpOGM0UER5ek4wQzkvZkFVa0dNZ09yaURkNExFdXlyNGlnYlJzOG9xS0UzUkw0QnduYU9OcFVSRjdsY1hCakYrazY2dDRZMEdWbG90THMveldpRXl2UXFCZ0MxdDVZcG50THl5cnJPcnlNYWNjQjJVSi9SQUU2QTJZeHpEYlZTSHdSR0ZZZStnZnNhTEtjQ3hxQ0FGK3FNZFFTdHRLaDU5TGdTL2NndkxEZWYySHRtL2FmRlFxVEJVQTI4U3ZtUDlaN2RoWEY2K3NYMXRhZXRPMTk5UHBrNGRmaitLZm01N3U5M2pqVk5PVmR2NlV6dW04dE4xd3VTK1VWSGwwK08vU0pCUjVSR1lsWGt5MzRxUm9CNEd2Nzk4NDZ3OTltb3hhaitrZ2NjY25QaXN5eWNJdWFvZFpvc0xrZFF4a2w2eXFIYVBDMXdmRXk1UVhGelVJY2dyZlQzeUc3ak1aUXZQM09pOXdnc21ZK09QcmpKY2IydzArNFdmV3lKSkVydDlOLyszYU1HN0dsdm9iNUJqUHZsVzNmVFdxeUdQNEUyY0NOMEE5M3U3T00vTGM2N1hEbjJVdWRZZGhDM2M3SUw1NGw3cDZRdDJ5SkZGVFpmall6RnNjQ0FCQlpkL3hpSnVXNkVsVmdaVC9JRmlwajQ5VXgwN1YwUVJZa1haVHB6M1lBeUlMT1JTUk5zWlYwdFZ5djF1SlNQZ0J4SjRHZ2swaEFyVUMxTWRVelU1VlNuSTRNUWY4YmliY1ZnSzRLbjgrWHcwQlhhRS9WbzZCWXFtcVJKc0lJcU9WalA5UlVubmNrZzVybVJkWFhiSVVIYVE2d1FoZEUxZFk5elpVREN5Q2hvVVpCM3JZY08xM01GY3JsVENvMEFYZ0t4SE1MdVlKS3Qwcm05QjlhYXpjQjhuSUordDBwN2tidUR1N1ZkR2FQeXZWV3M4d09NR2FwOUFkK1pBK09ESlN6TGRBSkRZWS85OEYrc3dQQWVUU012ZFJ6T3pjcCtkbGJkWFRldGxkdCt5SU5WbGVwOGVaYTJUeHNFUnE4Wnp2MmpuSFp0QWdOM3JvZCt5bFRIaWNXRFc3ZGpuM0RsSWwxbUFiL2V6djJIRE1Nc2ZSUnpBNlBKd2xBY0hBN3RqRElpY2gvdlIyN1o1RENZZk50MnpFanlRaUNWMjdIUm5TNWlPNC80UTJXRE5TcEczSGlxZzVjY2hsNWJMbEdOeUpVRTczNWlnZFRaVE85U0pYS3hiUlpUajBZdHI3NzNWWjQ0NDBNV2F6Mml1bEZVUGtXMDhYZWF2K3ZXbkVydXZIRzNmdkd5R3l2aTJHYVViZHBKanUvVUJsYXFRL1gxS09yQnNsaWVhSjQyeUxOZWZHMjRvUzhlTlVxYUpkWHZURkplVWFlcGl1aFd0UHk0dUEzSS9sdHpOdms5dEo5VFliU3dVSlVOSUQ0WnZ5OU81aUpEWms4c0lRS3lJeEVYTlFvOXFJR003cEIrRDJmdk1jaXZpUUpkRGU5QnJEZm5HSmNkdll5UThrQjUyNWdxbEdsYlBQK2pEcXBSMVBQWmRRcExZVTI3cit4MTh2dk1RMnFpdmlnM29HdWNXQ3NlKy9ody9kMnh3NGdkc0duZXNyY3dmMkhidXovYVhkS1grZzZ6dEtVUHRkRUkzU2l5SkNqU0hCbmY5bHV2WWtIRmdLMHVYSjQ3SzczM25YWDBUMExoMWMyL3VyRWlidFBuRURjeXVHRlBVZnZndXRqaDFmNjUrbTF1MCtNMkZwRHJrcFhONkxSWHptajlsWE03S3RCRThCT2JRclRmVDZqa1ExOTBMUEpENTFSTyt2TVRKaERHK3M2bVpraGVxS0xvSG01dndXS1FEeXd0V2F6V1pTWVcvK1kzZS90elBrbnZtd2M0cDBTMnR5a0c5SDFlOG5LUjVINTdHNmlDMHlXT1NESHlvbTlxd3pmYnJLWGRiM1RycGRKblNITkd2SHAzbzN0aTJ0cmF4Y3RLNTJOcnlyMVhHdTFzMjkvKzVSMXFuUlZhM2w5amU3d1BGNnJad3Z1NDI2dHA3eWpXUGhacFZkekh5K2NXOTdkSjNYMm00T3RCTWFHelR5aUN4V2E3YUdqTjBLUG5BR2w5d3N6RThMZjlob25Iemx6K3lhY25ua0V4Vjk0YjZQM3Q4TEV5dTFuSGhuaXNDMUliMmFBSktjUXFkUVQ2Mm1EVHZ6U2RRR1YydEFSeEtlYkt1YVp1LzkvSEpPVVU3cXNuMUtrTVl3MTNsVVIwbVgxSmxYV0VRSk5YTU4vNVZZTitlSkZSYSs2V0RKZUo4b2lFbldURUZPSGlDeSt6cER3cGZzekZVZnRNOTE2bTlsK0s4emlHekJWb2puVUg3cG5wWlVWNmV3Vm9PdGRzUk1kMm5DK2Qra05GaDNPVmRIZkxsSTVsMW0zOWpLTERvOHBvMncycEV0K1c2d3pYQkNkL0RCWEpabThHZndNSzkxRWU1OGwvZnk3UmNsYU9ubmlBMHdJWHowUy9yUUsrcmdpSGJycXhCVVNJQzJrWG5uOWRXaFpNdnVmUVQzTmtISTNNTG45RWJiUDNScUx2NU5LT0UvQmhRSldQTXdyWW1tVVBuUlZGZDAxY09lMy93cG9BUDZaZEUxMlVQZlpJaWhXaFoybEdIRDNIMW1aYnB5akMxbzdjN0pDbmVwQmt0cGs3cGJIYnBrak5zWHZvbXNxbS84ZmEyOENKOWRWM29uV3VmdSszN3ExcjExTDc5VlZYVlZxTGExeVM1WmxMYVl0V1MzWmx1MzJnbXhzTU0xbWpBTjJFOXNRYkREQ2dDSEFRQ2REQXNFa0NQS0lDV0hwSlBNU0VnaVl6U0hKNzgwb3l4Q0drSXp6TWlRa1ljcnpmZWZlcXE1dWlZUmYzcE82YnQyNnk3bjNiTi81MXYvbkdCdklYV3dZdjVLL2JUZVNzZDIzNWZHRWhEd2swY1JaRE5DZVJlUWpSc0JpdHZVaHRtbVlWY2hBMGxWcjEyaG1sVDBrYU9hWnNVRitnbWRrK1pla3BNeCtGWlpzVVovVFhPNE9SMk8rMGY4bENtLzRXM0pTL29oRUpQYnJ2R0l3dDNHZVBnZUxPUFBOS3dmUWg1Um0vbldFamJXSGFsM3hpVkRoT1J5dE9JREZMbjFtME1vVEVjKzFUVVlJM3dlRklUWjhJVEtTZVJWNkZxbEdWcEsrUUlpaDM4QlpTa1l6dVJ1QUtwSXZURW5TUzFPTWJudnNaM2taeEwwcFFsUjZqbG4zazA1Z2lDbEgrYm9Vd04yQjlFV2lzVXBhNDFUeXhVa3BJYjJNcE9GR2kvMGNyMmpNR1JDb3RXbENaRllsYzBiZ0pIMFEyVk9oNzJ2b0M4RUNKY2xEUHg4UGFVa1ZHQyt4U29IM3U0RVFudytoZUQxS1dpb1VkNWQyY0lnWEYwVGNGemVBN0EwR21QcTFUbmRqL1VMS0MweTJVbUhOd1B1OWtmMys5MjJ6RUdoODBqSk5LOGxyZ1daSW1zVHpaSDMwT0tjSEJYTjlmZjJHK1lhZUJJYnAxVlVXdnUvWTl1dEl2VkpLSmhRaFZhdGNWNm1sQkNXaDJFcmNDT0s3bHdjbnF1TVRjSVpYRThsU0NJbEljd3c4RkxzMzhxVXUwYnljNVNxcTZTazdVNlBxMWlndEZkVnlDa0c4WEJybVR3Q0d0RDFnam1nU3N4SkZqS0U2VCtDVDV1azU5S2VEQWVEbCtYaHpQME9ldEJnbUlFeXRpd0wzMkQwYzErVFlxYm16YWxGVnRWczFFRnpkdUpuMmdaeXdQQytMaXBQVE5NNWpVUnpPczNBdGJpV2RFem0yeUNPNllKVW54QjVqRWxrcHdUWVlDaU0yemxKOUlVTTZTaW9mRUZLeFliTFVWbG11eGJMZCtkczBvbW9sNVNhTjUza1B4bGZhbXhBRXBWR2V6cUZxa09WVmptUHpYUGdrVmxaTVJ5bkM1R1MwQ2lkelpLR0dpajVaYk9BallFR2ZvSlp2TnRMUm9FeDlMUFpvN0MyeHQ4V2VpbjBZZUtSeWxpQllCMzZodFRpZ1VNNG9Xb3JvRVN4R2NBQUk3WVNvQUJHckhvWVhiZTNqcjNiWGoyU0FNSzVqdUVmemtvUkpDa0pqTlFYVHJGRS9NcXFkUjl0b0FPZTdneEhwand6T1V2a3pFb2paMU9kWGtEa1dhZ3pyaE00ZWdFTUZTekx6aWNCUW9mVkVRelJtSmdVQm01eVJWTTlLd3FqMGtqcWM0M2xWa21UTGwwU0dNYXhzb2x3dmpKK1dNcnlBb2luSXRHYm05RGd5cDRjRlNjQU1Nb3dtU29xbW9oYjdQS0xQd1lmbFpNSDRsQ01RaFdQREk0MDVpNkJwUEIzb3BzUnhxc3NLbkthcUtSV1dNRUxNL2Z1SkpEdG16dEowQllpMnBMcDJPdTk1cWtLdUFBWUNoZ0hQbXAraWNuVURmdDkzNU1nRE45eHdINlBJbWk3SmJBY0VHRmt4YkZubFNHem9RNEY5MTQ0dGdKeHdKVWF0ajEybWRSZkp6clp0N2VnVXpJV01DYlc2ZmdqcUh3eGl3bndNOVdwYUl5MGtwMlFFWm96YXB3NGtBUnNheENGc3pBK0dEUWJOSlNjVVNkUlppZVgwejFXVFJRZnIyS04xMU5SZk5iaW9ocjFCYzJncU5zZnRSNDU4NjRiN2xsaFpTc2pxYjBJektyRDhNeWNZZnR0NmYyUzdQU2JrYitlQjdZajRHaHE1TGtUaCtKR3JCWFVocVEwdm9QeC9HR2UwWmN3QmR0N0pNU1FycFJ6REVsV0c4NTE4Zlc1cWJoL0tuQndyemF3Y1dWdyswSEh5Z3NieVRKQVl0ZjJBbE9CWXJNSStZUHJKb21mSXFaTGlKSzlzVm1mM1Q2VWNRV0FNRUNQZEErM1R4K2NQckZqYXZHSnl3Z2l2dUJUVkNDRlI5cFB0Yjk2ZHA3TnA5TTI3aTh6Z2ZEeVA2M1lRUVNVOGZGTXA1L0NXV2VzY1dGNDhzaklqc3l4aGVIUGYzRlN6bm5maUhLT0tsdUVrT1lZa2dkWGZlNFRXUUM1WWk1bVZBL1BIVDdjUHVKd0NyeW9JVG1wcS8yeTFlV1hTVVVvcDJmQ0tTUmtXL3J1Y1JEcDk3OEdidHRuaC9kZ0t4Z3E3WGxDQ2RiU0VWcWtTelQySzJINlZrQVZDQVl2Nks0YmdXZ0hhTHFuT2VwRkZSTkJ1SnpSYmRicDdnT28yTzYxUTZQY3dTY0Q4VnVSbnM5WkUrelJKVlhsTjVXZHlVcnBFSGpOTlZqWmRrMVUweFQwU1Z4Q2RuQ1B5Y2FBR29zaXk4TXVJODdQRjFJUzdjaHhkVFRUWHNTUW1icHF3dXVxbWFlU0lzanNEMDcyV3NReW1NS20yOWxXYnJZcnNHUzdoZWNram5wSXVsV2NKVDJUZ2thWktHVmtoUGtabmNwbmR1WmJLelRDQ1pibEUrRlJsdmxYSlppdXQrVW94d2p2Y3BMNWl3SUJYQW5HWUJxMGFzc00vMlUyQmFydUhmZ3JJUTVOZFVnL1pQSU83OWJNUHg4ZVNBNjhBSStHUHVBejRHbkFlVW9iNkRDVEg0cHZTZFp4QjFVY1AzOVNjbVpxQ2kwemQ4aFBHcUYrQm9WbllDRkRFMU5STTg2YUlyMGVaTWdmOUdRNHc2c2ZvaDk1S2M4anlJRHJjSW1tdmoyWFNGZUtiUkxFVWRFNkdMMkpCeWMxcnJtbTZWWkdJN08rckZzTGhXOTlnNFZmRnU3d3R0bXUzN0hKN3l4NjcydHZvcmFNeEZzMndxNnNiR3hjdlJyYmwyQWE4bHdtakxVbHRSMFA5dFUzMWNOVFh2RFR3Um5rSVRVUEZkRDI5bU12bExjdGFDOFl4SzhNRUxLbVk2TFBaTk5CRmhRcHNXK01ZK1lvdVJqZDFNYWtjeFFqMXFmOVZhSml2b3ZvM1NwQzlkVklRY2RUaUtYTG0rWjg3L1RvMjU4Wnp1WGlEYzl4MHFsSndkTU1oZVE4UGVUbm1kYWNMRy85VGVPUjZ6U3VnVitmMG05T09XMDFabHU0NnhwdWNEQjRyZU02Wmh3UkMzWTBpK2g2ajczWmo3SmJZN2JFNzBac1RRVWxDZ3l4MUtBdmkva0FCdVNPU09zcU9oQkVrYVBIQk5hRGMzanFPZHFKdW1KTWh1bHBvenBjdzZYWWNQdGJ6QnN1SXltNVJWUmpKeUU1a0U3SWlKdk15U1BVc1pyM1hPQkdFVTRrbEp2d3dHSlpYYW1qR3hWUFBEM0ltL3RWWlN5VkMwVTdWRGJlVTBBUWlXWTZmemZva2JZcXFiaWlXbnpRVEVxczRLRG5Zd043Q1hrNzdMNFFsNkRzRFIyV0dmYXNJSzBCQmR1TkVvTmZkREFXdkZrYmFaaTUyUmV4MDdMYllHb3dLZzRtYUJCb0Y1Szc1UVFqcGZCaVdPRUEzYVE2NGlGcVRzbm0xc2hDcEtjTmtUcVhaUWJhU2JpdnV4eU5RZlhTam96bmVxZ042OUJGSmxEVmVtZVk1NDhRcXgwOUxnaXBLb2ljNFJsNFNFNTlLaUZMZWNJUTl0UXhDNUNpZmxCa1M1OWpNZlJ5djhNRlNYRkI0aG1xNWY1NkJEbWNKSnhGVWpOUE56N09jb2Q1c3lSeWo4MmhNaG8zT2NKSjlzd3BMcDhpcDVsaHJKWk5NWms0M3gweVZjekpDWW54cGZHYXhuaENZMU8yMlpzSURvSHhUaktzVExxc3BmajBsU1NsWXhicXdialBVbVk4aDI3Q0NpeEVualhiVFVFTU5ReU5Vd3daaW5zUTZpSE5PZnMxajJLemZ5NmpLSCtxMWpQRTFpMDgxMDlXRXQ2QjArNzhWVitFZk9lNGx4cksrcVluS0h4dVptdjQ3bHJGM1Bzc3kzcTVkU3YrN2NjekZNS0tua1dPOTJQMDBMcGFhS0RwTkZOZDlYSm5SWHdKTmJvaVZKa1NJeVNDdGhqQ09ORFVtck9tdytNSDFpNFNQMXM1cUdYa1pkTTVCbHdnc3BnM2ptMTZDL1J6ZUpKUkRsZ2N1STZkbHQvTFNpaXZQbnY4RCs0cmF2a21GMVExcnpHSVp3WWRGMG1UaUNFYkphb1lLQ3djTGtpd0RYRXpnVWdPOWdQQzlSL0I4SEM3a2tqNGVnSHNOblZVbTk5V3VzRW5JeklQWTVnYUs2cUhZeTJyQXdoc2F1U0xoVmlwdVl2K0xTbFBNbjdNdFNUUXRwK0N3eExNbVo5bkE4RENNc3lpeGdzNG9nYWZDdlpnb0cxalNsOE9wZ0oyZHREekN3ZzJXS1VvdDlzK1pxUklES3pwY0FzME1Wd2NLb3d1c1ZDeHd3b0MrL1RiNUJkalRLUjZPV0FNT1E4QjR2MFVTa0VBa2IvaVhHLy8xM1RKUnBtK2NWbEp5LzcyblhrUFlmNzN4WDFRNVJROFJ1Zi81VTRYWU1JZHQ2RS9ZcHZ4bWpJeWdHNGt0R3BPRWxHbEluYmZJRFRDV2kwd0xOd05WQ1RPUTYzdU5YZ09aUVN2dWR4eExNNnZ6MVVJQk42ckZLenBia0FTZS9ka1Jrd2hadytzYmpRMitOT2s0NkkzaEJPakRPdVord3gwTGR6WjR6R1RCaUx6Zy9XNllFdXZKMElxSVdDY1dFeU5yTVRkV2liMDc5ckhZYjhlK0dmc3UwUDBzNHlGZERlMXFuYURaeFhqSmVLc1QrSkU3MWo2bTR0Rm9MeUF0VmJFRTR3Z1hBSXF5aWE2N2NLaEdUZjhSaGdYOEwxVkx3Z0JUQ1RNZmtReXNMTUVpczgyd2tXT0NiclV6QkZ2QVcwSm9qQXFtajBUM1BmU3RHY0NSVWJzNGxWVnp6RzVZaUJIV2N4RUhPUFg4Q1JOdzBleXc3V3JvV3BVbnpVNFR5RCt3OGY4YnZWWEVTWVVVUEozdEEyK29ld1dpVElySUpmMXZHRUQ0VzB3SnRzNHh5NTFyR1U2M2hhU0kxOExZRTlnQVNEeklKNHpBQnlDQXNna0pCQ3FaU0FwdjJ0eFVvekUzTzhYWkpxOUlCQTZDU01zckFTOHc2SGxyQnF6UVg5RlpSbTk4djZFemJFbzM2cTFyV25WREMxUTdYMC9Cc0FXV0V5UlZqdWZ5Q05ud3Q3b3RHMXEydkZUT2FvWnM2LzR2dmg5V2tBUVA1M3craitpVmxyRWdJUlVqRGtJWHd0UWlpb0ppcldReHJDMnk1SnpUQUZhWEhzSlh4dGVnRndGVDMzQzZNZytYQ2NBZGdtd3VpQngxWXNaSUxzS21FbkpLUUlRTm5nZ3BHZjNoUExSTWlnSnc5cXpBS0JZdjM1b0JrUVJhaEpkMnlTSUthcUw0ZnNhU05jWlNaU3lKeGVTNjF6QytZcUxrei9HbTRqUHMyVFNqY1RvSHJ5RlFTeWZOaXprUzgxeUt0V0lIWTFmRmpzWmVEUko0ckFLenFkaHVCZDF0YVY3TG94bGdXY1RVR1UzNzJyMGs0MnV0aGM2dHRSQnlpdHJuZ0NnT0ZIdCtDVk1CNUhFcHhOR0VhMkk1dkFpbGl4cGl4Y0FaZkJnNWJQVi9kRVBqbGUydHhMRmtLNG5zMmU3MDM0M2tqdjNBYU5yWXp2VHZUa3dVckxwbHdVTElKbVFSMnBWSnBUVkcxaXdIc3cwb0FtZXhoUTZjdG5Qb3lBVWR5aVNyUEN2WVNVTStqeTZiLyt2U2ZMTkMveTJGdjV2dWJpV2N2V3BidHRuL2F3SnV1MUZNRTJLRDZLblpjSTJhanNjdHh0QnNnWVVoYVVqQ2VFa3pKSTRSYmNHMmNxWVZOMGQxa1loREZXdFhXQXhYY2ZtZ0s1TE50YlZsNjR2TC9TK2MzRnkvOEh5L0I4TGVyZVRBcitiZmQyRkFYMStBK3g2Sm5ZLzlaMXhGUTU5R0wrNFpqQ2lFUzFTeFU1dGhLS01WNGlDMWdNbEhWbkkvY3YrQkNDUUIwek1oQWdOUUF5VE9RU2RjcTZqM1haZWlWYzJ3VkdPM244eFFaMENEZzd1b1ZaVDIvQ3lKODVnbUVkWnBJQUdkb0JPbjVjVERCQmhJRnNnL0dWcGN5OGt3NzJVSHhCc0ZlQVN1Lzd3WkJ5NFBLS1dyNSsyQ0pNMEk2Q2NtV1J5Zk1LMGFFQ3ljbHlEdDg4Q3RHQm5vWllheEJUVU9UQm13K0FKakNwSWNDQWtnQWJJY3NPaTFRWmpwT1FaZFFnVE9yRHN6YWNNeE14TEhqZlgvUWxBWnBxanl1UndST2x5ZVlUUlJGQzB6azdSa2x5ZkhNM3Q4ellhWjZxdWU0U3NPRGhwWE1CeVFyNEJiZ3JkekZVWGlZWnF5Ykp5cktLWkRPTU1DWXNJSlU0eGM4R1FibVNxRzAyUkZ4clZaNEhqZGtqUldsVFJCTDhHeU5nRkx1cHE5d21Pa3VCdEhHSDdDSmcyUms1S1lERlI4Qk9uUEhwNTFwak41VlJSdEt5TUtETWRWTTdreXkrU01LTy9CbjVNSDZmaTRKZlpHRUFHNndGT2NBemtKNFRybW9VeURIVml4WVNuQXJrZEdKUXdNcnMzRGFnYXJId0xSZDZxZGFzaDE0NlkyUDdDU0JKNFFSdGhUblV5Y2FpdzYwSzNZN2FMZ1VTVW56ZUhoZ3lUUm9zTUMrUmthOUl1S1d4eEFFVmRiM1JJRDRBbWxHUVp4SzNPNE1JUTZhMVFPVWZ3K3pEd3JDbm5FdjhTeWZCaFQxRklmcCs4UE5jREh3SHQzbTJJSUhEQ0xUbWJ4MEx5UCtqaDBJcTEyWVpTeXlMRjFZUFJHS3g4TVBncit3ZnJORGxLVmVCZklVQk9heHNXVkNvVW0yRGRZSkcxUU1LeXpPTktoUlQ3UE1Uenpxd0Ywb2FDUXZHSnJjVlZqeTFPQ29rRjNKeTJtS0tubzhvbHVqYkFNNktLTVBrUkFPREFITFJOd0NzUGswMGFtRE9TZWx5b0luQVJFQWFrMCtSWWpLQXFzQ2JwZ280YkF0V0dZaUNDZE1XSk5sUi9sQlY1anhVQ0dLcUp0UTBwekFnOVNLOXBWT0EwVlV3UVllMWFTZEViQVRDa2tyc0dpSXpMb2djcGF2Q1J4NkpFcEFmMlhCWkV3MXBnSExEeERaSlU0Q21ZSTR4bEhzSW5PRUpOSklZWVo4aWFFVVJrV3lDYk1xRUNXRkRhSXUwU0hacGNZMFpOVG5nQUxEaUVhVEViQ25LUEtZWWJ2b3VjcCsyWlBsaG1KNWZFOGk0RXZDcTlDbjBnOGpuc29PYXN3SlhJalRrV20vNmU2eklvd0oyMEpXRlFOSmh6aFplaFpCZHRFMVJ3UXlEZ1JIUTRKRC9VUVhGWXBpR21GU1lwT1JTcktxVkk5eTJianV0bFFnTDJDK3NOc2k2dUhIZHMwT1ZjeldObmdMQVpmeFJjd3NTa1V5ZWlFcktRbEVkb0lIZ1BjUWNuSmkwSnVBcGRvbHBPelNVUGhWTU5SYllPRnhaYzFlVkd5UkZnR09Ca21LNC9Zb2dhMHBXUmFBc2RDV3pPS1RnUjBDdk13eHh3bFJCam5BMHN0d3duUWZOQUZhR0VPaU1pQk1NcGF1a244SEMrb09oQ2Y4YnpPbWJiamlta0RoQzhPbGlUMHoyQlV4Y2VNeGpDMjBBa1dWbUlSWm0xL1U1WWxnajVIc0Y3RGFRNnVFL2tFSnlsQ3dNaGxHWWdjU2NSaTIyTUFLMXVNYjR2MEhwOTRIUDZleHMzakk3bFQzVmdxUkQwWUFWZEV6OEZpTTJDN1ZEOWJLOWFLNUNrbDdmWS81NmFWb21LUnVLWDgwa1BYbnIyMlFQYkYrMzlEemlwdS83K2gxb0lVWGFXbTYvMHZQRFF6ODR2QklGK1ZUMWJJUGVpdFZQR0xDTmtCL1B4Sy84ZXZ6VDM5ZFA3K2IwL2NEOSs1KzdkamhiQVJpZ3RxMWxzVUttQUUrSEVQd2ZxNG1DT3JzZHBySkt4RXd1by9pOXRFWStOdy85a0xxNnZQRnVEUTgzZ0lwTlpFb2RELzByZStOWnJ2SmtQano2T0UxVU1UTU5wbFF2c0t1VWZXTlBrOTM5TGtvN0ttYy9KczQ2WlowYWk5aHY3KzFudnc1UGlZSnMvZTFKaVZPVzE3REJWTHZXS29qYXU3ODhXN3JXQWdVZnpDZzYrakwzNGV0MmNLNjRVbnppNHRuVjE2eVlNUC90T09kLy9PRXA0WnhqU0dlYXR6UTY5YU1jcGswK0xEMzM0TjFlbjdDRGtqaXI5MXd3SUxLK2NUa3JSd3c4L1dQcDBrNjlKejh2WFhDK3h6MG40WjkycXBqNFR0Z2dsaVQxSE1pZENmazRZYmtZblh2alkzK0NQZGtSOGpmWVU1ZXdNYUhSSVVNVWRKazluQ0creVc0MFNkWGxUNjY4cmlkT25FNnIzSGo5OTcvTVdMVGZVejZyM0c3bXAxdCtHUjZuRTgrcjV5SmhNYjVMU041RzRzdDRRWUR0MWgyZFZ0WlFjVXpidUZhZXhyRk00N1VrOTNLZUxyMTRyVGN2OVA1ZWxpZHZISXl2NzlLL3V2YmRibGQ4bGZUNVZNM2ZmejJRUGVyK3JOd3NMay92MlRKaEJjMVVqVzVidVVQZVh5SHNWNmZ2SE00dUtaTjJUajhidnJ1aFpJbG5mc00zc3ljM0NVdDJRdUU0LzBweGRwREd3eWlvMEpPenFDTVlpTDVRQ25EM200MXRrejN2OXg4OURpdEh2VlpPZkVSdy9lY2NmQjNsOHpDL1h4UFllYU13ZjV5dFNWZDk1eHg3SEIzRVdkckkxZTI0TU1xTVVvb2R1bkp6OXRwMUoyL3luY2t0Vkd5djRzN24zZlR0RjV4Z0NQOXk1WSsxRS9HQS94ZGRBb1BOK3VWUmRKUE05MG9oM1NiSVh5YmhCSExTbXNhU1lSY0w5RDNwRk9yT2FtdStNOWplem1sTGpIbFFpSk0zcmNZNUxBcXNadGtHY0N4bEZWb0dFc2I5Z1RpVjlMSis1MFNvMEtyaFdmVitPU3FwNkJoZTRYVkk4ejFNYytpWWwrUDhHeGI0YnJHVmY5ZUI2a3NJbkV0dGhjTSthaGw5NFdwbXNSM29zWGl6V1JyRU5ObjZNMW5iQlQvUjhlSVJPclJ5WUh2MVAycDFmWFYzZkcydVVSdzJMb3VkM3l5K2lEV2tiL1U2Q0JNSHlBYkFCZkY4Mi9MMUovZldJV2krTHFnWWtEcStKZzV4OWZmL3IwNjA4VGkzcnVhNk5uNk03Zm5zYnpJMWdUcU8rOUJKdVdieU1TTzNuM1NJZTlHRk5EcmNIUGY2US9GVHQxNCtSclhqUDVtbEdmYmhYam9iZjVRYlE4SWF4RHU0VUtpYy90R2gvZk5UNWZXMTZZV1ZpdUhiN3Q4SG85KzFTMmpwdnk3dFBTaVJQUzZkM05wYVhZQ0gxSHpLazR2S0ZCOGdSNC9CYnRlMFEzYmMyejNSclprRVJDK2c4STdsMzdWdllkN3MxODRHZmYvblpTditVRCtkenFkeWIzN1p1OFpnWkkwUGRQWFJmUjhxZEpML2J0WWI3SjN0TVRFNlA5aVo0bmFFdW9oVUpFWkE0U2c5SkFqZUxjVzN5WldHL3ZPWGx5OTU2VEpmSDlKM2J2UHJIdzludUw5OXBDNmVSOTExMjNwMTNuRi9EZ01OY2hwWGRBRmViYTA2VE5rNG4rYzJUajNaT1Q3OTRNTVEyZUp4K0NPdTZKSGNEbmhtWnkxSTVPVWxlV0d1VUdNYmhnZm1oSzcxQ2ZEZFMvQmQzUXNvNkduc0dvSVBmT0N0d2tKM1dTcXNUSXA0QnpNUDJPeEUzeTRqUWhNOXRQaWFiZmxuaDY2b3VMVTFPTGswK1hCT2txWURWc3JpdEpYY0gwT2ZrcW1TK3hobVN3UCtrVVorNmVXSnlZV0l6RlJ1UHhKWW9EVUJKRUVNZkkrc2FMWGxJZmYrWkw3end6di9EMTFLbEJ1N3lMMHNoWVYrelc5aU11WWZDSGJ5amUrNDZGaFhmY1d6eDY5SWxWN1UxdjBsYWZpUFJob1YreUhka2xZQjUwUnozWmdvRWpHd3RuUHRwWXI2T3RjUG1LZHI1NC81a3pyejl6aGxsLzI4TVB2NlY5eFRLYUgrdTVZdi9iZVBUMVo4aTVSbU5yN2R1Z1BxRlpwTmNEVEZlUUY4VGFBRXVYdW9qaDRLdUdBZWNVWnAyZWlZZW52bGhLSmt2Smo1UXozdmpjd2JseEwxTysrcTZydi9ueEJ4Wm0vZXIwclkvZE9sMzFaeGYrTEZGS0pFcDJjY0VlQ3hxSUVOTUl4dXlGWXV2cXE5Ly91bE83YnM2TStjZW1EOTU2NjhIcG8vR3h6TTI3VG0xZm0rT3hjWXpoaDc0MzBNMlFXclVvNWt3MzRMMmdHN0lDK0s0MEFqQ2d1Q0FVNWpGVWNZaHhjbVoySWVGMWFydXp6WW5qd1ZXNXEzdm5kcy9NSEEvNjM3WFNmQzR1U2FRVlpDdnRHeXB0cThueWlwS0xHMG9tSUtYOGxTbHZOdTdGNFI3LytLRUR3VFhCcjZRVGFkbU01eFdWWjV0Mlo3MVR5U1JhUkJUamVTRnQ0enVUQ0pNS000UGZIdm95UjZocFlUNXc5QXkwYS9iUWZabVBFZ3ExcUhlYkw1UUZxbTdyUmpnbnZoQ1dZSkwyMFBjQlhiN2FJKzdMNUR3d3JZS21HSEZQRm9nb0wyZG05L3Vxb3ZGeS93OFVaT1I1V1RGRlZoM1B4Q2VuUGN5M3dncUtJemt2WHlSUDhJSmxhRStmSFZjRWpsNm4yN2RPeDZWZ3VzVExoaXI5TUs0Nmlpb0k4c01NUnQyeS9XK2x5RG5PY0RWUjBWVG50MERTWldpZVNrNmI0SWdoS3VqTndDR1NhbVhXWTJCZkVyazlqWnlCdU5XWTVMSXdaekFFWkJOZWpuQWFZa2VocmRveEpUWUo0KzhRWmxxS0RYaTdWak1jY0FocFFoVWJROHFVcC9FeHJTNWk1ZnVoWnh3ZmVyeDIwUWxuRVdaVk5TZ0paY3dGajBKa0xjd3ZSUzc2bGhtSHo5VHUrbmptQUpQMTNBejNYMVFUTTg4NnNLY2IwRlNUaDd4MHBwcE85ODlaOGJqRnM1WXFjM3lndXNvL0U0R3hOSVhuQWsyUmxRU2NqYjJRdzlMaWhmRk1kcnpocFJQMk5XSitJaDg0TDVMSVlzWkp1MTQ2WFUvSjhVSWNKSTFBVlJWTzlOYUl3Q1UwS0lablBUZ3hHdHVLL3BOVnlqVUpQbXAxQXpTUENyd256dGRRL2tiYmZhVXFkcHBCcUh5bFVaNllBU2tLM2JtbE9YMmNEV1kwclVvV3BwdE9UVkVuV3V6eC92OFl6Kzk2WWxkMlVrK0xVdXFOa3k2ejlJZEx4SjN5NWsxcjRVdFhIOXAzNU53QklwVjB2WGpneUw1RFY2ZG1GS1hwa0FOWHUzS3RKb0ZnS1FqeDM1L2Z4Ujg1d25jNnlWbFZyVndpRzhCNlF2T1hkQWtYU2daUER5VURhV1NOUjR5QUpNM3dNbzVJQlR0OExPSnVVTzd3WmFSdU5lcWNLclpFYUlPZzFoS2djT2o0VVVlS3RjU3VkNmFKZis1d2NkZmNOWmE0OTA5Zzd6dHc2Q0w5dGQxeFlvMnNyQ3grOEkwVFhmdnhHeDVrMW5Ibkl5dUxIT3h2ODZlMUtTcGt5RUNMN1NCTVkwNDJQM3ZYcnBXVlhYZDk5cmRldG5kbFplL0xMdmFVanhVdVhDaDhUT21KSDhFZDRNSFZJWjAyYU9SUElUWVZtNDd0aWwwWnV5RjJaK3pWaUpzNE1GalFzQzRNN3FZR0tjUUlBNTR1WHFNa2ZaYk1vWlpFbktNYUZ1b3dIMFErOUFLU0F0ZERIZEFNMTExa0VRWThjdWFnZWNRd2hKZlVNQmVPd1h6TkpHN0tKU2FuR1pYVE1QdDhnVEJ6dkNIM0NPc3U2cHF3Z0JpSWY3dGJVTFc5QWtNbUpVbms1d2pqbEd5VythdW1OSlhJQ0l6a2dselAxaWR6WFBJcWIyL0tOZ3VheHBkMDVSc0tRd29rYmZJQlorbTNYZzk4cE9NWVBITldkOHVDTDRIMHp5NUpoakRMZFhYaUNCTGpjTHpFbUE0amlnNWhHSW1YZ0JSSVM0UzFTdzRxV09aTGZOb3ArNFN6dkxJWE5NYzYyVjBmN2FVY1Z4QzRJSlhmTC9qeXBNMWwxSUREaEd3eXJxOUFKMVpwL29NYll1ZGlkOGZ1alQwWWUzUHM4VENEUXJjNjN5MERwZkNoYVVZTTFhamJMcmR6cEJVUFd2T1VxS0pZUEpwNUpWUnh0L3pRZmxzZWdDNzdyWFlUTFZodDZMWXk5QmZ3WG9ob1VvQlBMZklTTTVrU1FwN2pLdVRqSWlpQ1dNdkUrckhmTGhadnJhYTh6Sjl5QlAyWWdLZ0tGTjBYZ1MwNVZwTTQxbUV3ZkpZRmFzdnlySUJuYWVTcngzR0NKQXFNQTZSWitseXFlbXV4K0lwTS85VTlFdXQ5Z3FNeHZCSWEvSVF4SWpHODlIMXNqaGRpaGVxcnE2bnFjc2Jid3l0UUdNT2hsaHZJQnNQSjJPSU1nNmdqTE0ramxZdEhCRHBDeXFndUVlQWhGRVFGend2c01oVHk2cXFYc2RCcnlvY0xCQ3lJZzRJbUdTNUY0S1gvSDh4aXpRM3hGbG1ReEEraFZSeGJ2eEs2ZnpFakFOL1U1MDRFMW5jTEIzaGd1S0t3TWVWQkdoUHFQTkN1L2RSWFloT1Raem1oUFhaT0ZNK050UVdPWTNmVnYxSGZ4WEpuMjY0ejZkcUdDc1JWRkZRRVRhMTQ3cnlsQm1nS045WDBKd2NYcU56Z2dxbzdlZ0htM05pY0d1dEFvVUpuYk1wWUN2ZVdESzRPMGcybmEzNlF5U2JpcXM3eHZqZEJUQ2VuT2huZHlwSi81M3hzaDAvVE5NMW8xZ3lkSGtVL3l2eTluKzBnRnF4Z3NrSnBsb0w5N0djNnJVQ00xQjJ6cEIzbEI4OHo1TmQ1eWZnRUExTk1aei9PTUlyRU1jd3pqR0FJekRPNCsybFZzR2QwQ2JyN0U0YkV3NGg0bWlSRS9obGRKbWNKRWZuZk5DVG1la0xtV0FHTmM3ZWl3V21WRjNGQW51RDVpNUx4bTd6SW5DV3kvZ3dQRXNiMTIyS3dweUtVeUxsQlp3bEJGUjJ0dXZqcWlPSThTNXBVMFl5bzhGMHlIcVRtVHVXc1FMRjR5YjZTaWFlS0lqRE84Rnh0am9qcVZlZFVsdGVZYjlRbVo4Y1BpNHFaeUJReUV5ZTVkQ016cGlVU1dqcXJ1WWYzRWxhNzh5ckhqaWZUR1NvM2hINFpGbXFDdXRWT1Y4aXhQcklITTB5QTdtcWh0VUlnMHVwVm9sRW9Kc2d0QmJVMFdUcmhLY3E0cnlqMTllTWZiTmNYSjhiMzE0K2ZOUElIaVZkWGxMRXB1cjNVWnp5S2VoSFFlRXQ3Q0lmbXdBOGZmZHZZZ2wrR0Y2M09WOSt0dnUrdGQ5LzkxcnZKeG14UlU5aDZhcXBZU1V2Y1NUdVJzRStYZmtOWGk5ZG1xOWxzZFhTOUYrRXB6ZEZjWnlFTEdLV1VERDNUK1BDYk1rQlJmaHljQnAzQitaRmJ3aFh5S2s2UWVkRVRFWXJaVUt4c3lsRklBeHFkbFhsOWI2VzZWME5GcFNsYXgyWm5qaFNqQy9TdGU2TEY4d1lXMDBXeXNoNEUya0ZEWktSVUxwZVVnWmtxMVd0bjZWR0ZYckZOaHNqR0pqRHF0WXVRdnpYcTRoRUkwRGNpbmN3MFZzS2pqSzZJZG9scU45NktkOUVObm5yUDBIemlRTG1oTHAvbW1KOHZsWEluODZ3d0xxdEtVb1J4cVFQZHUxSE8zbVZ6NkNROTg0WlM2YUExS1pncEpJazJMRzI1MHhzbkU0ci9vZktMeTNrbUYwOXdTVVVVVVRVUExLK2tzZG91MTN1cEl5YUZ5ZHVKL0dHNDZKQ3hWN1JOTVNXSUhxZWwzY0xRL3dEWDhURVk1Zk0wbDMya2xvSS8vekpPQnpRSGFHZW53OEV3b0tBWE9nc29OeTBWQmo0SGNTTm85QlQzcTZQdUJtR2c1RVc4NU1pckJoNEdrYXRCemkyazJvV05VUitEZXdmeHlscytTa3dzRWN2QmVEMkVudFUwV1czbzBCeVNGV3JTN2JKb1NQSVIrNTFGQnpUMG1QUUZrWHBKVXZjalROeFpLODBqYXVoOHA3dE8rTmNDUld5TFlxcmNQZ29zL3Q3WDc5MEgzQ3VNSTBYc3pSOEdFc01VZ1crd0M2TEN0SXBvR3ozU0podS9RQzdzTG5JczBhK1l2VUNDb1A4L09aQXppSVNiVHpDOW1RQTYwdUNWRmNzNkpRSDNRQWdYekZ4QllwZHYrNUF5YnJWNmJjVFpJeGgwd2xqVTlrN1U1b052c2w1WXA0MGVibGRYOGF2LzFaRTRtQ2ZEeGw4ZGMyL3F0UWV0M3U3ZE5OeHROTUxEd21qams1bXc5YmZtc0JrcnhocGIxSnhHNVZJaUhVS2hsVVNnSFNHQ1hFQmxablNMMjhNMEVZUnUrMmx5WXFiWG0va3IzQlExS1hBWTJFamFBeUEwYTVMdmUzZHFVZ0tQSlNTTmJDek4vdGZaSmJyNXMzT1M3akV2SnBobi9ueldUaWJ0cktRNTd4dzVTdVhSQW5tQjZpWXlHTXZYamZJalZnZUxiRHlnNDRVdXZYdzhRb0dqd1FvQ0psRUx6WVpoeGxzNlZ6dXJpNGNQN1pwYzZKMFZDV2ZrY0lkVENTZXArL2VmSXR6MWtsQTkrYTZYUENhSmxYS1YwU3B4Z2ZDTW5kMTN5OUppWjR6dUovamZxT1p6VnZuMEl3S2ZTNVpQNzFmeUdZRW5uSk1lbSs2bTdkN01uYWs0eit1c0s0SEVaWHVURTFuYnhEM2JHTlVKRkNJL3o5aGNoTFNEeGhMczkvVk5PTm0vdUw0K2lnT0llY2ZMc2QyUkx6UU9vbTBUZXVjQTRyZk9vb3N3b2c0aXJNMFFTMkxnUTFSb2pnUTdrLzFGT0paWDlkcnFhcStRbnc0UHJ1TncrdFJnWE9GTy81ZkR3V1RRcno5MXFuaXE0bndncm1vSVlNamtNL1AvTUJ4bkVXMUZMTVFDeU1neEZ4bWlNSjFoSlVyNE5VbmFMdUsrVVV6ZVpwRmk4aUlNa2Rkb2pDVVBITlRJZkxMYzBBOHNOOHJKZ3dlMS9sY09Ia2lPTmNqQmd3ZmhjSGlzMGYvOEFUZzROd2ZYSDlBdXdXREU3RHpvU2d2RHVydTF1NzY0dExHYUsxME12OGo2MHVJTE1OUkt1ZDVnWjREUmdiRnRIUER3R0l0WmlOVXhLNm9JaXpTTXJscTNoZUJpTFdGSG9xT0JHb3BZeTczSzRzdE9MbFo2bnovUVRxZmJ5KzI3ang2OSsrZ1pDdEN4NTBpcmRhUkZObGJmTkN0ODhwUEM3SnRXMTlZMmorSUZJUjdIZWdzdmlGMkNCNGx4dWlQNjVwMVpscWpheUNTMWNpVW93eHQyM2s4ZlV4NTVzRDY1NUpxbFJtT1ZUSjljYmRTbkMrUisrcWdiUng3ZWFYSkg3bDUrOHNubE03ZnBPOWI4RmxMcTRacFBmVEZDdlE3VkE4RlA5T2NvaFZCSXVMcFRoVWZJRTh5UVVGVTBTT1VRcnZtdjRDVlpFV1NCVll4a1UrWXRWcFMrck11TU9idDcxbVJrbmVjazNtMzRKVUhnSmE1aDhYSXpZY0x5TFF1S0xQR3NKRVJyL2hzMWxoVjQ0UHQxMlhReUpuQ043QWxaNTB6UE16bTA5Q1kxUVJTdjVjeU1ZOEpoZE5wZ1dVMWttZGlnbjdGOXNYK25ZdDNZcWRoTlZITnRNcUhEeWpBOE9jK2cxOGgrTmg0Yjl2VjhDV2xQRjJWZkg3UFlEYUYrYS90SnF4dUJSQ0hVVGJjejZDTnlTdGlkVGhYeXJtUnpISjl6Z21JeGNFMk80V1hPNGF2MitVei90K08ySGJmZlZTZ1V6MmhCNWsyc3pUK05Gemw1WG5lMVJCWnQzaHpoWFJDVFlCMHlKWG8xT1dhdWxNY0tlazRmVTFVdkJaTVo2c2xiWWtYWkUyd20rNitqVVpGdks4ajNaL2NrUDhVRmhIOFpYSkx5eG5PT0RTSUFJeE81SWxsWW5yNUtMNlhqN2kvSUloMy9TWXByZmcyMkNpTzZUZG9xdUZ6UWlESnFlZ2c2VkRubzJ4NlZubkJaUUR0UFYyeUdWOExhZ2ViT01NTXgzb2UyUXpMRDYwQW41elNpc1drcGY1aGxYNlhhcGgvL1cxNk0vNjR2Q2FsclFCWmNkQlZ1TjZ1UlV3b2pNZkpSU2VweEloRUVWbHBVeEE1UlNTWnhhSndseG9MWXN0OVNaaC9WUldqaDE1dkpYaUJMWHYrUHEvbnJDYU42TDdOYm9xaE95YnFnUzl5WUkwdjdDZmxybGNvMVlSM2pRR1AzNFVxSURoNFVCMzJyYnU0aTB4V0g5WXVxUjROUHF0R1NpYjlKY2s3amZKc3d2R01NYS9JOVl2dGNDd2IrRndXWk9TVEpSazlqWlVJazRZU2tPS3M2UXpZVzdKZWQ0R1ZOMzNyei92L0xuM2laTGNFSUYvcmZZWmpyRkZWanBqbmdXQ1hkMWdaclNJem00K3dnQi83VFp1UDhONU54ZnJGeTJRU2N4ZExDM2NXRG5IUzUvSnYzNWl1WWVGUFJkaVRlVkpTZm1IZ3ptZDg5c2c0V2FNN05YWWpWK0IvSXVIblpoSnVZWlBQb0ZidjJUR1IzRFpKczduNTBSNUxOWE5KUm94eWJxV1FGYzJ5T0pOZTBlVVAvTjVKcnBqdmJjbXR1eHhZT3M5L3RnbC8yZHVPaUVMRjZYWXI2SDA0RkJMNHR4NGNSRk4weVZvQ3NaN3orUlFSQUp3VXY4eUZxTEZ5Mk1Iak9NczE1cmxDY25WbmkyNHBJbHZ2L3pjMWtYRktFYTYrak5zUDk5S3JuclF1Nk8xc29MczJZOWdWUjN2NSs2Q013am5FMzZDVlFBemFhQmwxVGZQMFFSemNZNEt2U3JCcVlURVBzNE9Jc1ltMW9saS9hK21zYkgvTEZVNGJsa29LYnVVNzA0YTIrS3ZGVklOQ3NVQlZZYnJtd2JPaFlEOE84dGxDY21WM2JnQnRTYTc1dVpMeTFsRi9rYXJ3azhUVWVQVmQrb3pCNzNyRU13M1RQdzJ2SGh2UzRSM1hLQVZEa2J1d05zVy9CS08vNlcrcVZvRDJpQll0aWN0SEdRQmVXWVlCZTZIQTFQSThXelZJb3JyV29lMmc3eXNrMDlFcUd1a2JzWXBrV2dOa1JxTnZaVm82NFdubVdhWWZYdElacDQ5cGxmd1RiSlR3N2wyTmFnVCs4SytKQ0VmeXZIVDd0RFc0ODBGMFZscmdBbGpWSjFKVW5UVjR3TkZkVUhFOXhiSUZUWklNTkJNblE1YXRoVk1iVGdlcjBtRlRPajZmSWxZWmgyT2xrUVpWNVR0UDhJQkNzWGlMaitacEtydVI5VStRc3hXVXQyd0lxbzBxU0FPMHIyb1R6ZFZseGxMaFU1VGpWZGhPV3FCY01Rd2djVjFaWVZ1SWRMUWxVaDlVa0xkQnRtZVBHT0VHMzdheXBHZ1ZUZEpPZVE2NW5IeFlrMVVxN21JSDIzRm1lNFJYSjlCWDVaak50cWJvcW82dndPM2hXRUsrV1ZUak1FL0VlMU9ZSkIyMHRGOFIxaTJlWWNsa1FMYXVaODFKdy9uNUI4SFRGMHF3MHpIQUQ3aTRXb2I1bTNFc1ZESW01bXlEZUVhK29xbjdhVGVweFZWWmtWTzBKN0ZzUUVrdlBHWktQaVowSWs4K2pGN09tbTFaQzFXUk4xRUIrQmdINlBRUTRCZDBXSEY5TnFEcTZaUmRCM3VNRVRSM3F0SENjWFJsYlJ2U2l5djhQSTZVMk1qQzNqME95NXovZWg4OUVBK1J0STBQaUhmOWZtL1JGVzkzM2dlMjlGZExuRUVkZXBOSkhiQURJT1lya05PUm5waWpLUUFPeEJ6ZHhFOUt0NXltNndFc3BXM24wMlJDUmtCdVdxMUovSmVCa0NZVjdRWDRCcHRobzZRUFlpQUU3M2R0RW9EUzZHVDdKbzArK05uU3FLRkRlZFZjaGZPSXlmZnplOExsYitzc0ppaHVFRW5yVTAxNk9CWUdrMkViY3Y4RnN4WFNHZTlpNDJPS2o5T2FZdzdXTWNiTEFjV3pHNCtQbGlTQWdxak9lMFYrSTZUZEtRVEJWSEk5N3pQTGJDWG1DWWE3dHZ5clZTcHVFYVRIa0hwdHBFZFpNdDhuMXg2ZW5jMGtsSVNKYXBxNFdDak5qWWtKTjVLWW51cXJmeTVaZjFVN09yVWpPN05qWUxHOXpLM09wb2M4SzJwQWw5S1p3QTJEdC9WcTd4Z2RvVDJGcjNlRGl4Yk9QYkJRSzVKekNUbzdQcU9yTStDUXJ2NW1zdjN6dnFYTy9aMzNaWHo3QjVIUEFFWTdsOHN5Sk03SElYL2R5K2N0aSswbUFxUkJFbE1mUUpJWStjeTU4YXBpZnU5Rm9QSCtoY2VGQzRZbnBZT2FmcCtQVGZ6a1RUQnU5WitINGVUaE8xbnM5Q1k0ZWdFLy83K0dTKzFIbEh1V1VSSDhRSEVkYlhqSWowRElQZlB3QitDTjdWaVpXVmliSWVmcnpIdHhmV1FsbG4rK1RqNU9uNkx0aTVwQWNqZE5CRWFjYjRGdTJSM3l6MnVGdy9Iam10c3dmM1pxNWRmMlU5ZUk5RzY5NHhjWXJIZzRkQnc0VVR4UUxKNHNuSDM1NU03M3ZvVk5ySDF4YisrQmZuVjdjZCtiTUE3RlIzNVVvQW5NbzVVU3hrK0diZmc5cUhMM21GK3IxTXlpcFJ6WWU2dis0TXlkY09SYXpzVDFwVHFTV1g0dWlPYnN0SHdWZWVseUV6M0o5K1V2THk3Q3RMeS9majV0bEVCK1huNGR2K0FuL3ZoVHV3TjkyKzZWclUrdGxZRytHWmt0eVQvL0g5K2RoNzdXRTI5SCt5a2lOdXVXd01zK3Via1oxZVdwMVlCdGRKNkVUUU13dWlnUi9yVjlTVGl5U1BjV2dUVGFpMjBsOFVPSWd2d1hjMjhNN1hidTJEcnN2UUVFN3l1RWlDVmJzMWtpVjN2Nzg2cXBGQzFSV1YzZVdZd2NpbHJQK2s5OG5xSW5SKzhEdDBRczlqd1Z0cTFlN0c2emp2NTIyNEc3WnBtNml0YzNJQnV3UGpNSlIvTy9maFBtS01CZURNT0l0SlVRYWkzaVR3a1dHZWpJWWpWOHVYSG5id2VhaFZuNG1WOUFjSGI3Z0Irbjl6ZHpCZzNQL1dHNDJ5LzhZeitlQ0wzOFovVHJwTGowNG9yOEk0NEJyN2FLUE9WV0JSTEd0YnZIcHA4bjYwL2U4RUx2bjZPWmsvL3RQZjJ4eThtTVAxK3VFbmRqS3hidzV4RW1iaURVUmtTYzIwQlRzMEJiTUlnNVF1VTNoUUtoMXQrVnpPeTRoQ3huUHk3am1zVzczMks0RG5XcTFVek56azdYQ1BsYytERXVyV3RyVC8rTmp1M1lkNnk1MWFyVk9sZXh6OGZwMzc4THI3Nnppc1E5T1R4ZldWcXA2UnI1U3R2WVdLaU9uVUwvM3d2ZklGOGw3WXlWbzJUMVkyMnFJa2hTNnJWSm5SRnhYVFJKbGdoREtydDhOMml4d1YvZ0wvaWFwcUJsdnpyZFlqbEdyS2J0bnJWbzlPMVZWR1k1dGtkbGFiV2EyV20xTXJxOVBpdkVGM3g5cjFtK29OOGY4ZU51eWFtZkxqMHV5d09tMzJhbDJPMlhmcG9PY0pUNCtPVGt4UWZ6cnhzZXY2ejh2K21NcDMwOFZMQ3M5OElFcVVOMFNvcVg1ZGsxRUh2OUhWdUw4K1lSRjFoTlcvNk85SGpsakpVYm9yQlh6WW9sWUpzb09CcjFCaFRXS0QwS0RVRERFUFE5VURWM1k0cUdDai9yZXpmUHdYY1FjajlMeXJvYlZzK0twb3hOUDU2cTUvcjlVYzlYMXU0NzExck5sc3RycmIvWklmRmQ5VjFweHJycktVYlNwZFAxM2VyME9YRmlGdi9peCtTT1ZPKyswOTVUbjh4TVRFeE5iTXNFcWxTRm5hYmFER0F6ZFJhYVp3ekJoa0lEOWdUYTRQTnliWWVNNzBKeTY4SExwTml5NTdUUXY2S3dtKzdMK01SMjJHcXNML0JKVklYNkRibUh5cjM0bFhjYmtFdVgwVndRVnVNd2FEdnQ0SExjMVZ1RlZlUVI2OFNWMzMvMlQxdzZFZksySmlCc1hSR3ZIcnFOSHM0Ty9pSno5d3NpaFlYdzkrcmdsb3l4dE1SSU1hMVljN2xISm50dFJ6VnF4VmlZbnArRnRaZTJGR1AyYUZoTGZUL1QvSHZVazd2K20yKytUaWNMM3lkSDdOckJDcW9yYmpmdjhpeU9WdXY1VXVNYjhBOVRwYlZBbnRCWU1mZGJZVm9CT3FCNVZsaUQvU0pXazFKbWlWbzVGRjcwRW5kQ1N5d2RkTWkvcHpGRTErWDZmNGYvdUg3d2tuejh5UWRyb3lKWTRsTUF2Y3N1RUpnbmNHK01GWVBicWNVK1RXdS9wL3lVOU5lS1BibDdxUVVwT1VkL1IwQVYybXpQc0NGMWlzVDlJMFM3YWw5emRmeTUwbEkzdXc5K250cFV5cXAvbEtaSXZPcXZVZUtvRDNuSlo5OHYyUzVhZXlYMTdsU2lUZy91Ly9lMy9RUTl0Zk94amcrSW0rODl0OCt1OWpFK3NTNGZMYUwzdTNzejk0ckhjRGxmZmI4UEI0N25ZdGpXVHA1aHc0ZnUxaG82TFlnaFEyT3o4VE8vWHM4L2VSQklUT09KVzZ0VkNQSEhscmJjK2R1djNlcCtDNDhvS2prMnJJTUNSVzdmakVpTEdkK1dTTjkxRFkxYURDUktPUE5lbVlSVDI2SnVmNXN0VFpiN3RhSnFqUFZ5L1dLZU92YjlINjdEYlR2bnB0QS9yak83MFAweDZody8zTjdmUG9kVElITUtSUFVsQ21JWVFiakdhU2pNSXlLRE9sVExUSXB1c1ZsTFJkUHFWM0ZTdTNDaW5xODNLTmgvMHhPVjkwTU1tMyttQy91dHZ5NzE4S3JmZEJmMzM0TmgwYmx1WjFjdVdHWVN2M0I1OTUwdWV3Q1hMNVdTdU4xUGRyUmdJYTdIOVdkOHNOOHZLVEcrNkRETEIwTzgxZk9ibG5uaEo2ZHRMRzhtdkcvYm5OSHEvdVZGK3dVSHkyTkRyVDlnQmY3ZVRrRzYrNkJYN3A2cTZLOG1Pc2J5MjFxUVU1U1Rkdm1Ga242emZjZFhVb3FzYmtxd1p6dHJHMmlZbExBZW92amI4dXl1MHZiQTdmTmVHZEdiQUxmUEFRVC9ubWFabkh2ak1JNDk4NWhGaW4zcm0xSitZZU9TNVIvREkyNTQ1OWN5bzdnaGpQMm5FQmJJNjVYME1zclBJd0paOW0zSzI2NjBXc29ySGo2KzNqcmZXajM4WHZ2dC9CUHNFamcvbS9BUGtBU2hSb3h5WVdFWTJIbDJoZjdEOGcyWHlBSEMraHRreVlQOEhaQUovR0Mxek5GY3R4bVhFY01FSlNUV1YySUJCS0pCWXlnWnlRQXI5emVYMDNlbkpILzRRcGdNNWhHQkwyM3dpRUIxbE1PTW1DUVhQS2crb0ZzYjBVSi81eHlZK052RVluVTUzOTU4aUd6QzV2bXVuR29WQ0E0NmtnRWhjL09FUEIzT3FSMzNjTFpUSi9HSDJyUTV3TExWTllBSm9JTTNQcmEyUjgrcy9vakUxeThBZ3JJVnk5VFFUSXlkaFQ4YnNHZGdJclFDRkdScWc5TWhiODI5OWZiNy9vd2R5WjM5VWVDQlA1aC9QUDU3di8vUFA1Ry9jbS8rWmZEaG1aNkEvVHVEb0Eza05ibnpndTRYK3Z6eFFlT2wzOC8xL2ZTQy9UV1kwNk1qMmg4RWNjQU9kbTJRekRBL3d2dklWNytMVFR6LzlqMS9HT244NXFiMzR4ZXI2MnFsVG96U2FZclh1SnhGV3E3dEZzbkFjd0JKQUxYcXQ5M1MvK3JWZHVYdnUyUmpRcWtsMG1RZksvYXBkRTNpY0RJbjRxVk5rNHRRcFhBZ3VNN1lxVkVweVVWQXFWNmk4eE5MQlJYQkk0WWo2YnZqZGdnOUpiUjBiaVZIeTZkcE9rYTRZRUJKbjJDakJDdHVKZE1ZbUdTWVp5ek5kTXROWTh2Zk16T2R5OHpONy9LWEdRcVdTdUNWVGI1UW1Nb2xFWnFMVXFHZHU0V1NackMvTlpkc0hweHJwZEdQcVlEczd0elExMVgvbVRLazVVVzRVczlsaW96elJMSjNoSkdsYi9BQ3NScTJ0TndqaHR4angyYTFITFlRUDN5b3plZ3JGWWdqSC9mYmNWREdDb0VEbEVNRE1qc0NCMkorUWRZb2s2dlg2UnAxdXZvUmY5ZWZwRmgzRkp1RWZ3ZTBMc2NuSmxZbUpVNU9UVHc5Mm9qRTBpQWxLRC8wREJqRkJld2dtVVNyRFhHd1ZtNlBSSm85TmJxcjl4ekZMTUJtSkUycjg5OCtxL3plMXRVUjVXQ1BiTnlyUmdQY3FCakQvTHF6Mm55ZWIvZDR5S2FCOFhXaThydG5jSVpQWFkyL1lXc0hjUldhZUt1aW84WEdHb1dvYitEVmZDNUhCT3QwUWdYdUdvai9BOHRGcFZXdCtJTTZ5Z3VoaitHMWdFSkdHWVBpZEZrYUVZNEN2S0dCQlpjUUVDak84UkRxaVRyZzRmcFlST2Q0U0dZbndMR3VKaHMwN2FEYmpXR1ppZnZMclpjMzFFYk1tWUZpZEl6eFJ1TUlVWjhpS1l2Z0oxdUlZZzNoRUpENlJVd3hSNHB3aE1BclBvTytrVURESHRURythTWh4WGllU3BrdWRhTlh0L3pNSHBKNHpSTVpsWkZOVE9NM2dkQ0hGNkZsTGRCb0hqOHhQVHBabm1ZUXZWeFc1d0lzWkVaNGZDSktzczRyR3M0cUlVYUVLc1ZtQ01hMnN6L2dpcXpxY0xQRWVoMTZVUkN5b09YUlpGVmhmOUZoYlVseDEyT2FyME9ZSzlINWlrTGRFYkVlcWtKYlk2b1pmZHo1NTU0dVBYbjNuTHkvbS9meWRpM21RYWM2LytLcURieDI3NnR3VEovYnRxOWZoTThUMURmc3d4TzZ1YlBYajBHZytZc3ZHN3ppQ1VBdGh1ei8rR0hKVlAwNDVUc3I1TU4xZWMzaEIvNVlldGRLUGtjRjY3QVk3WXcvKzNsc3JGa2ZuSWNocXJYS1kwUksrTm01YmZQYlp4ZHRXTVVmeWVtdzB4M2hBL1N4aWxWYkVDYlJHd3NPQTZoRmdlSWZJTEo4K2VrVyt2NW0vNG1pNFhNQzIveWk1K3d1VU5TdVl0bTJHd1ZaaDRCVnB3K2kyK3AvUjhmUk9tMUdrZmJ1RWJ4MmR5V2Uyb2syL3RIRVIvbEZKay80bURTdlJmN2JST0VQL292NzdPNkFkVHc0MXJOdTllL1lNRXFBSlF6RXVWRm9RR3ROS2x5NXZ6NGs5cnk0a0VvWEV1Ykg1TVNMQVkrbXpyUVJ3UUh2RzY3K1J3Sk1mcktmR3hsTDFiVHg5VkJlb2lvbVFkaVcwbmRQUVh2UVZZTnMxbjd4R0ZWKzMvaElXc3dmaDNwMjgrS3AxVEMvK0JZa1pueDRuREZISkV1N1dHYmIvZEgrcVA3QVhBalVrdlFIdFFLR3RBblNqQXZRRDZkbmcwNXVjdkdkaTR0MlRRNytzOThMYVh3VEtPWWY1VlNwQkRlWHNrZGcyRExvSVhjMXEzVHhiODhSYUZLV0lXWkxiUVkzczNiMTdkeWx4U3pGTEk5L204cW1Dcm1YRzM1eDQrVnQ1MlNKdkdkODFmamFkTmsrVWJvTHJpb2xiWE83RUNlbk1Rdk9BVWVUcjJleWJFdmZDZGNjbDdpMUpESmM3UDFQTlpESi9VS1QxZVMvVTVudlJuQmp5WjJNNytEVGF6Z2tpMGE5VnV2MWVlR3prTDhyOUcxc0dlaDJWNTBRemFmQTl5S203Zk1uTjVERGQ2ZjlvNUJIUjNPbUZNWEJwekloYjI5Z3czL0VPRTlyNDdXYXZaMjZqRThpelQ2SC9IcWJnZ0ZXM05ZdW9ta2lQY1ppaHkxNEE3Rm8zeElOenFXL1NKNWxFYVVxV25wZmtxWklkejlqVHdHbHZqTytaUHB3b0pjaGhYbHdZZTZXdVNKS2l2M0pzUWVRUE83cXBYajM3eWduZm4zamw3TldxcWZjL2dQNWkwVHU4bE1wcURuSXFjWnkySGt0QVpLTlA3TmE2dkYvRDUzYkNkL245VXVMRUw1T2FsaGpyUHpkdTdVK1F5ck9CYStNTFdFbmJKc2Y2ZndLbi9QRlhGWE85eEh0dS9wckJtYnBEbng3eGZhc0R1VEI4VW5la1p0RVQvTitHUjl3Y1ZtZFk4QjFicng0V043c3RmakVkOGo0N0pHQVhtUjlnRU12azFKQi9ldlRSVDI5TS9uSHVqMDlQUHZyb2lCUk1UbTJjaHFPUkxucEV2eDlTbHpDdjVaNXczbEJFcXBGTUhSV3FreTc2L01neFZEcnV2STVZcThzaHJMYlQzMWhlQllJV3FUYzJSczZFZVN5SHVUV1cvODJmbEE2R1BJRk03VXdvKzBWaFV0NHdZTW96NkRncXR1Y0hUbVBWV29mTUpjZkdra0IvUG9jMENQWVAzWEJIL3lLWmE5NjBiamppZDBEVUcvNU5WUXVkVGlHZHlYYzZQaXo3Vy80SEZ5TTlLZHEzdGpTazlFbnRyUVJjTFhLWTJwVStjUDhqUUY4d0dWNWhrMXFhN21wUE5ocVRqK0tCM2pZYWlHWEdPanRLL041V0lhTzNoL2VGYlVBbHRjcEk3RFdOU3k2MmkyUXpZZmVmUkhkc2NxK2Q2SjlIRjhIcjhlZFhjZlBONzBSeVRvSDZkTHFSWm5KRUtuSHRzdjFQSTllVGpVdkxHNGtITnREV0ZLNzZKcG5odHR6R2IzN2s1dVY2WGZTN0UrV2ZheFNMalNMWk9IdkYvSk96TTJMeThNR1Y0aFd2Szg0VWl6T1J6LzN6MEJibmFhUTFNRjUrVFlScElyWUgweVFnNnh1TjVlWEd4Z2FJclJ0cmpWZm04NWFWejcreVViL3JGVGhEWG5IWGlHKzJEbnlJSDYxalpaaHZWT1RBOWRHRkh3UVQ0YjRRVzY2bW50KzgrRUlNVStNK2Z1clU0Nm5xQzdIMWRiSWE1a1psdHZFZ2wzQWZvM3pHTnE0aXRvTUhEV25yVC9DOSs2V1ZmZnRXOWptalpkWDM0YkZmMmxZaW9USGNxMlNOYXIrYW5aSDBGelQ1ZEtoZXVqQnh3Sml4YnRwNzlaMTNYbjE0ZnY1OWg2cWQ3dkhqZTJlcXV3NEQyNFVINnNmdlBiNnpidW8yRzVzL3NLMDlON1NyRGVPbVB6alV2NkczZXo3Q1graGdWTUppQ05UMDZodVR5WjlmS1Q2VmUrcXAzSDl1YUhZcWY3eWg1Sk85ajE2ZnZETDVybmorSGJrbm44eDlxSkZZVE9iVXh0RWNVT05SWG8rbjFqcXE1K3BnV28vT3Y4ZnhmV0twWTM3RkpEK0I0OXNvWjdQRS9RbjhYamplZmdEajdWMnhzYUd0R29tL01HelkwT2M2aXFmMXhJREFXZ3VzRGZOZU41bXFWbEpKOXowTXJMcFZ1c1A4L0Yxd2Fpd2xTR2RzT0dpZlZ2aFVOZHhSbEROYmViN0RXR2djNFdKUW93SFJnUmpNa3Yxa2x2WEp1KzR0dmlFTWphN3Z0WGl6ZmNpVjBuKzMra1FVSlAzT3NZT3VOaU13VHUvek84dkxYcTQ4azgwVEUvWXVXMnhhY2crMVRkN2FhMS91QVQySEVXWTA5K0NZTXVnZlhNUENxR3lNWjhRUlE2VTd1cFJSeXVNTU9jT3lIeC9aUC92UnM1T0Y5QXV4ZEdFeTFPNnZyVVg2L1RWeXZ0UjZMaitadHF6MFpQNjVWdjhiZERsNGNIWDEvR0FIcTZpTTZLVkNLK2xvM21XMGpJUjVGclliUk1MeEhObENlQkRpY0hrUElyc0kwTkx0UnBGamR4MkxiQ0wzd29FK25QbURpY2czNERPOTN0VFFLb0pYVW9QSW8vQXpCMzlLbUtka2xBNW1JNDFlR0UrT3J0UTI1bk9uZ3l0QWw3T05wWnVUV2VPcU9iVFJocnZrOXRVRGpWb3VsVzhlM25maTJ2NHZ3MmJmNm9GbWhSN1p6dnRya1dWb1M3NFdNY2swQ2xmUkoyTDh2OWNybkt1K0N2NlRVTGZVSTJmcW42S3lmRDJrVDM5RFBrYmVUZW1UdjBVQmhyMUk3ZVJ2dVBBRytIdmlpZHR2ZitMMlQ2OWFhK1RkOUVpL2Y4ZGI3N2pqclJkZXZwQTY4TkFJVHhkRjdXOFpPUWZEb3pOaS9Ca1pEeHVVY2Z6b0M3RVhQOWNxYlEwRmh2S1k2OWo3ekZBdUdXaS9kMG9sR0paZjNpNmJqTWdrdndGenNqcVVTN2JKSk1nQ2pNZ2xzWjhHSjZWVkV4R2ZhS2VTOTY3TDRLUzhuT0traE5nYkJZS1ptYlZZekc1MTdWcTVnb0p4anB5NjU1NVRwSkJOSkxJa3R0YmZXT3RsRytvbnRibVExc2MyNlQzUkhmUlNldEcyc2FEQ2FLT2UzUlhnYnRvMDUzR3RVL05yTG9XOGJuZTZzQS9jQ1BLektLVGtDRm5aTzlzN2xTZ1lUN1crazBqVXgyYnkvaTMzbkRvbDM1Z2dQTk5LWkRkYko0eHA4NlZYZGlZS3VXL2MxZXIvQ0M0cUt0T0tjOHQ3MTlhVkd4T2ZOOFhXWG5qRkVVd2RyRmRpUjgxcU9lSlJzRmg0cmExYXRudW5UdlZtOSt5WjNWYmRENXN2ZmV5bDVyUng0dHdKWXpDUExEclhjekFxQjdiK1dtaHpGc3N1aW1IZHlPNzhHZHFyZGM5YnFEWVg2dGVPMTEvT3lhNDJmWmlFRXN2NTZ1THErdXJCRDVPZXRieFdKYzZWOVdpc1lyNGdKaVlnWmZIVHBCWUp6QmN2ZnFuUmFNQ3orNnU5Um1PWkVoOThuMmRoL0YyZ2VmSmlNUkJReTlUeTNRb0dtbmpTMitkdXVQdHc4MmVIN2poMDZBNml2Ni94cWxjMWNITVVmeCtLZU1jUUo3VVltOGVZbEVxWXVXNldpSU9NM0JUMEE2cEYwNDNIVGRJZGlQYTE2aXhEWFM1WmV4NStZbElPVktIOUo1YjFHWWs1ZGd3MlBzc2VPeTRJOGNIdnVDQWMvMFU5N2ZhZmMwMWRJZmZlNjFmSWhNc2IvZWM4YlhWVmQ4bUU4V3BXWU9NTWMvdzR3OFJoOTlneHZCM3Z4cHVQL2FMdXZSRHpzcktva3lmZmxlbC9uY1JNYTMzZENzY3pyWWNEOWRoQzRocStJK3Jub1Q1VVk0cmUwSmplQlZONk5sR1BqUERROCtRZkxubXh3NWU4L0xGdGxTTzNiWHVkSCs5NDJXUGJxaktpTTdSQmZsOEJib1ZHSEpqRVlFSllnUzZteUJhSG1BdnhQTUpCb3Njdyt0MkhtTFRkWVZZREVOSVFsU0QwOGVwU2oxRjAzbHdrbTVKV2xUMldaNFNrWVhtWXNxRmVuWGFWazBVL1gvQlNwMnpHVG1zK3p6azEwZUVJTWYvYUsrVDl4REdOZ3djWmh1L0dKWWE1MHZRazAyQkZZcC80QWMrSVZxa1ZKeGlVS3JHc2xqY1ZqaTh0bjE3WWRXWXBYNUI1RnIzc01TR3lSQlJlK05pWlhRdW45MXU4TGJNaWc2aHViRUl1TVNMTEM0ckJrZnpTOXB4TzFQYUsxbElFUXJXcGZHSzNVRTdCRkJJb24vUTJMenhmYURUV01mUWFWc0hOM2s2ZnIyMitTVWpGdTF1NXdLZ3RKT2kyUkRjb2Q5MVdVRVovcFFaWkxWaFdmOVd5eVBuK3VwWE5aejVrOSt5SDg5bkNSbUZ0Yy9ONTY0VVluSXJCMThXTDY4dkxaTFBSNko5ZkxxQXlpaDNTWVRZMmdWRVZHSWhlYVhtQkVlcFdqVERMZGpoOVFsMXRxTXZ0dEhqRTAvSkRjTVZKaG5vZnp3Y1JEcVJJa2FOeVRDdmU3RFlYQ1lKTmRHcGtkYjMvOXcrWnJNbFpvaUZ4Qml0Z3dBQXZwU1NPajZ0R1IxY0RGV0VET1ptdzZ1Rmtub0crRVpqZi9FMVpsR1FtSVpiVm1uR1NaVmoyTnNFUUNOeEY0UHMyaEt5OXVMN2VTL2xFWmlST1FoUnlWaUE4OUMzSE1wb2daaVZCRTRqSUNkd3J4TG5nL1VSZ0pjS0lrdkJIQ2s4c1BpR201SnN3RStoSlRrYk1XNWs3aVFsVW9EV2dSOG1EUUhObm9tak5lRlJMOUgxcE5iTmtDQ3VHUGdHdEtMc3VCVnlEazdCNHdaaXVSaFNWUE1oeHZQVEpUNGs4eDkxbm1LS3NXcFlxaTB6NWNDcnArQVl4ekpsMm5pMmlaVmozYWNJVzZmZWZNb3hsM29xYmZKN2g5aWhwTytreTdQc000NmtyTzZLUy9xQTIwRk51eFI3bFlQNHR4WlpqTjRkK3NqaGNNUEV2Nm5uYVZZcGtKM3FoMzNnSFU1eUZuaU1tQ2RNakZLTlVhS0ZEUXl0QVNKUDlaQWdYajFRR1hmaHBvQkI1cmJ5LzM5OHZ6ODM1RmhHMEJ6V2VtTzUrZzN0eDBFdmV6Z2tJeU1DeGt2Qy9lSm05OXM0VHB5a3lDMHRnQnM0SlhBQXpsNFJmODdvN1ArOFlWeDh2Vk0rcWVlZ1c2TFdzZHRONDlnOE5xUDlUbGViYVdxUDJsSVFKYkNvQ0k4aUlNZkQ2MXg5Q1BBSG9MNDdoOXJIU0dFZHdNMnlITUUvaUJNWDNQazc3TEFwdEhxYU9waUdKM1RBTXNWb0t2L0NRZU9taDZnNE1FWEs3SVRwSFptYVBXYUxKOEFxbjdhMVc5dXBReTV4aThQd3dMRnBYbkZUMjJVc1BLYU1RSXg4VWpWS3RYakpFSWlkenVaUzBvTXRoVExTaUJjSEkvb1Z0WUNOUlBmOEY1SkEzUVc4anV0WFIyTFdERElRMDl3Ym04VWI0SXBTdFJNcE1vVU5FZ0VsTGdjckdneTV3VTZnQzh5cmRLZ1ZrNVNJN3R4dUVMdlJpYU05Yjc4Z0xrMk5hZWY3UW9mbXlOamE1SUhlOG1SS2ZUWGJVaVlhaXlYTVRhaWVaNVVzei9aKzlVWGN6RlhMRHpaZ2tMYmhScUdUY2M5YmFLb25OeS9QWFhERTNyVXpPelUwcTAzTkx4K0ZBa0MwMmlET3Y1akZhUnVEeTZyeERHc1VzdVI1b2JUMWxmTzZSczJjZk9VdHV2OTR3VW5WQ3pweTNCclIxVU9lRi8xaHRSZXJOU3Q3WWhWcFY5SCsvVnArMUxxM0FGZGNNSzlCV3RsY2c5NmJ6c0Y1ekkxaVBrWWNxK3VDNGR0RkdLbzdhY0hLaHYwbzJySDZ2VHRiNkYwaUROUG9YNGJNSlhCUE52N3dOTDVKcUM4am8zWnRiTi9aR2J0b20xN3ZBdmMvR2RzWHVnSHR6TE9id0s5Vm1XT28rR09ZSnEwS3J1WEc2RjNsVFk2dzVRZ0ZRVEtzd1pmZjJEL1hsdXVSVDY1S2orYm9HMHpGVisrU3A0ZDUvRndTR1BEUXhsbHVZUGE2NVR3aHF2RFRZSWRjT3p0MlgwYkxCeUNlZVZRL3NQREk0U3Zia2I3enVhQkJ3cDZKdnU5TzJ4SWY0L3RkbVhaWjdvcGpiWFJyc3ZDSTg4M0JXeXdUYlB3ZFVMUEV5UjBNN3hLRHRBcGhUVjEybTVXQW91V0c5TDljK3RSMXRBNHhsVGJ4czQvd0YrNFJ6K045K29XMUgvWWZZSnk2cC96dWRKOWorRHkvWGFKZHZ5dUF0RHpsUGpHS0VvTjNwRnBUbTZlTHQwVFc3U1VHZFF4eWJnUmR5bEt3Q01hQVltZ1FBUFQwcExsQ3JtZVBDTkx2VkNFSUNVMVRSbXhGVXFDUVFkYVZhWGpRc3kxZ3NWN2QyZjQxU3dXT0JLNGk4WUx0S2h1RjQ0aWZzbktqNmdjY1FFbVFGWFpGRnpGb2xTaGhEWWpnZVlaUEZuQ1VtRk10VUNnN0RrZk03U2cxM0M1UlkvaWVYeDZKWnBvN29OMG1PeVRscGhpbkFLalJKRVhCWVJtS2hhRkV2UTBIakxGT3g0d3l4eldtV2JPZmpISXA0RUtXWURKY1JtaHFLeDZpUnJZUUZOTXRReXgrMlVYeG5FMTI4NldHV0ljNEQxOXo0TU1Nb0Q1SUtHWGw1d2VRNFlubURaaGh6VkQvcGJHc0ZtV3c4ZkpQcmFQeVIxZlViZWNtNTdwVS9rcXpKclpwUHlqWVdNYXd1UHcyMXpjTUtPUlhWVmd2OXFHTG9LeUJBalpCd3puVTNIM3Fvc0xHQnZ0cndGZmxFcklMc1JiUFRFT3F4VHFiZGpRMzNiYVRnUC8yMC85VEFIMnRRanQwTjV1QXF1THZ3RU9uaDEzcHMyelY4OUt6dTVsTlBRUW5rK052ZTV0SkhiYjhtZEkrbmp5REg2UU1Sc3pRNjd5R2VRSmd6TDhTem9vbnJ1NTB2TU14cEFyempHV0R0amxoSGhBZGgvMFdFWVpiaDl3R1NsYVQrWHg0UWhuWEswWEpvbGhicVJ3M1NTYkVKREZJUXYvbHk5OTIyby9BZDVRQURXQ3pOdDRxMU1QRUZsU3ovUWhBTzlQOVNra2oyQU54RVMyU2syd1I2dXlhRXBUSGI2K1VLczhUMmdLVVBBYmlvSE9wOVljY3RoTGxjd2JHZC9WV3BoZjFGVzNpVk52ZEFaN2tRZTRGY0ZYdE43SDNVbTJNUUEzYzVLS1RSUUQwOEhYMmhsek1tWTZad2lIR1VQSkJyQ0VNOHU1MHROS3p5RHR5cndYbkVFYU1ST2lNWGVUc3YrNEhMaXFacTY2NWpCYW5BaTJ1S3FyaFdPcDVQeEFOTDB5UVFBQXpaU29rY0kwdDZTbEpFUVFFbVdTMzVsaW1MZ2xORmJ3bE8xRVZOQWY1VGtRM1hTV1M4dUdrcWlxUTR0dStsYkIyajM2d1ZrZk01ZEt3Z0hLK3dobUZLSWt0NEZsaEtrREU0UmVMRWg0aWdHeFN1WHhKdEx4V1VNK25BdFRSWmtndzFZYWNEMjlGTVFSWlJkT0VRNWltaG1EN2pTR1pjNWxYN25DTEJoR05FVHRjMTIvSE51S1NMb2l5YlJwQU1DbmJDdGtTUjR3VkpzUXFTdHFDd1BNMk1JeXVhQ2dLUFlVa1NML0hJMjdKODFIY2tCbjEzWCt3RDBIYy9UZGNoT1NwSFhiZDFXUWpqMWhuMEh1Mmkxay9aZllQT215VHQ0VFVtOFh4aDIxVi9sV0ZWVGNXc1Y2TzlCK3RYUEJGWU92U2VFTmNkelFBSmdGTnNSWVhHQkVGSUlES25XYlp2VzBDdWt6VUdzNGh5a2lyS0VpOUFFeG0yN3laZDN6QmxXVkpOMC9NQ0ZjU2p4Q0ZPOEFpSDZicEJvb011TWFBa2dsam92TURKRWlMZnJ3dVdxaWd5aC8zblpJSnlMam5vUHkzaEpnUGJ5a2l5UkRDN0NjOUpvaWJEbUNOeDNvWmJXRkc3aTVjdzliZklhYXBtMm5ITmxVR0FoTEZuZW40aTdTWU5YUkpCdERGbmVhTUxOY0JVbTBTRVBnYVpsWGlXZ01EMk1HVlpMcFRuWXozZ0tYcVJmK2RRbm0rak42YmY4cW1mV0t0ZDVzTjhLVFRHQ1AzcDBPZHF1ZGNqc1dYWTlwOUhzWDNaMnJDNkZoeXlMc0pQa09VdlhzRG9tQUw2eDFoQVVvWGhzMFpqbTBMa3VoR1BzOEUzNnR5V29kRFQxdld3eGJDZkhpME1pckkyTnd0aHZOUVdUMVFDR2VOVnNVK2dueUlNc0hKSm1PUksxWDNjUEVpV3dERE1SVkMrTmVyMlcvYVEvNkc4WlNCdWJTamZnRDlhODUwS2hoSlcyeFJpZFpCQWNMQ2hJWno0elpReEEwTjErOW5SRGVacDJ2Nk1rUTM1a0hUMzFaak5CdjZrbFFlSWVPZlZrZ1hmMXRxTFVHNzBlS0FCTEcvTHJtSVptbW5CME5SWVRCUW5tb0tua1A3UHJyMklZK044d0dCS0FrLzJGY3RXYlMxdUdBYWpzTG9pbVNJbnErdzNsMjZSZEY4MkpjODNkU013WE5VMU5WK095MktTVDNGazZTWXhMc09sZ2FzYnVtOUNDUmFNSms4V0F6N0IvQXE1K2s2UlBMQWloZS9JWEgyM0JMOE13WHZSR2xFOXdSUU5VWkkwWGJjdFV6TU4xWkZ0UlBoblBkN0ZQQUl2V2tzUzBSSWxpNUZaSGRnakcxOFBYc1dEaTNnMndRY3dHbjlIdkdtSmNHaytLYWlCN0J2NGRyWnI2S2Fka0N3cHFVaTNMREZNd01kRjJaVWRIZC9POXVBOTNVQTBKV1hFbm1ySFRzYWVISEJCYzVRSlFpRnJydU0yb1JOUTVycnNSdkNiT2JTTWRhazJpSDRQTnFGMktPaDZYUXkvamE2SGZ0OVJRdlJWRXVQYmJ4OXVub1grbE85Ylhubmc3bXNrVCtVWkJ1b3RRdnU2R3ZhVzZROXFJOGNKcThvYzFrdUhUb1pPakd2WUdRcTJGNUFPYklYMytUcnhGR3gyaWNHTWFab1R0cnNyMjBDUE9aLzNHRWFGRGtqeFNSRTYyTmRNYUU3b2N0MzBQY2trNXg5WXNhUnI3bjVnWmZrK21mUmZBVVVOK3QzRHJqRjFCMXBaeEFIRjhDcjBEWXdBRm5vS2g1YU83Mkk3aHE2ek1tTkowS3ZrblJ6aFZZWnhlWTlGSjBWYmRsUUQzOGFGTlVXU1JCeWtxa2VVSlBSakFzbzJvRi9oWlF4ZkRsUWh5VlBma2kxYmVPajEzZ1daNWhyVXpRNHR6L00xbXFZRlNEck8xV2E4QlJKemt4N3JkS3RCOUYzcjBxVUU5bXNlVlFKUmowMmErNmNWWXZOMWFKNjZlR1RFZnZ1aW4vZXl1VnByQ2Rvd0Q2U3g2SkpIajdadlB1cG9WNVNkM0JRN08xNjhXbEt1dkQ0cm5OM3Zmb0pNN3A0UzgrVXhaOWUxbU9QS1VKeTViK3dSRG5ZOWRYZGtERjg1dWRDY3RuVDlYZlZxdXB6blptZElYZGd6Zm8xbjczMmRsK2dlRnJKSGxxQzQydmdzZDhpY2hJbHhvSjBxaVhuRGZPdHVVaTBtZ21xcGRaeWJTbWxMTzIzdzE0NjBCTTBVRU14M2FHUXgxc2RENUxJUTNsTW9VNHdxckNKcTF1bkFwZ2dCQWxLMERrVzZ3bm1BZTVFSEtqbWUzNjE2M1lPa25NdDZlVi9paUZ2azhrQmZHSTBScnRDY296Y1QrZm9yRmNsMzk1OGw1YkZ5WHB6YXpZak0vSnlqR0RERzJLbWMweWxxVWYyL2UzaEpTMDF4Y0N2TWMydTZLUUcxbUpubDh1VjBsWnplYTN2WGpCT3Rob1daaHpnWVdhYVJGMHNwUm1hQ2FwQW9Wc25oYnNKYlBDS1Ayby95TUJyUXk4N0xDVUZ4VWFZQVZOU2FGeWZGNmpBN0pLelgxTG1UTExLc3lqcE1rdlRYV1l2WGVlQ3VHT2FjNFJubituOUxKdXFWekpsTXhaYmVWODh4ZHpIL0ZiRUtWWmNGWVUzamRjblUvWGpXZnAzTllJSlZ4dXovVS8zY2xZVWd5Qjg2V3JadlNUcE9iSnMvRHZVNHZjeGJNZi9lZTl6OTB6ejdJOUh6dUcwNFRiM1lhOUhtdFQyR1BZamkyMUhWNlFkeGpHTkJKRjBNRnpFWk9ERkQ5cE4ydHhNbUc2T3B5RUFTYUhyMGptQXV6M2hSdHVBb1l6VmxtTElrVE15SG1tTWduVERwUXFpNGVSb2EveDFNdzNpSGhrbStDNHlxOERLdzE3ekc4QXJEK0t6TEt5cFRBTFpHME83QTYwQVFXSmFrYzY2S2ZHc0JXQTFHaEt0WlhsWVpWZVpad1dlQUVnSVBVdUJFa0tkSmFOa3YwVGo3NjZDNVRMM3FrNDhyTmxIbCsvT21KTjN2RVZ2NU9QR3J1Z2xuQzVhVjhPc3UrM0VlVTBUZXp3RnpyS3JBM3ZEay92L0QzSnVIU1hKVTk2SVp1VytWbFpXVlMrMlZ0V2IxVmwxTFYxWFAwdDAxaTBhakdVbFRra2FEMWxGTEdxRVZxU1V3R2tZZ0NvUVJZQUdEakxGWTFXeis3QWMyZzQyTjdBZTRiWHdGK0JvenorWmkrRDZ3Mi9MeWZQMXNNeXoydzF2cHhZbk1XcnBuUm95dS83aHZwaXZYeUlnVEp5SWpUOFE1NTNld1ZNdmlkTlBSMkhpTzdHUEg3OFE4WEdpWUFkLzRnRzkrTEtsNVpBM1owUEt2K0R5QWxTYmY3T1AwNmttbzFoMGFGb3ZaREkxbExTd0FJZ3RpZG5HMHlsdElFaFFBcmMxZ0ZyRGFIWkFXZFZkWGRVd3RLNnNWWEJsSWo1K1RUaUlKaS9BNWRCTFBCeUJXdklMSnJlRHBBRTdwOXpQcUJXSzdFWVpaS1dEdGRHWndVd3BOb1ZONDRzU2VLQk9CVFRXenVwNVpSYnVmaXQ3NFZQVEQ2NXZyZ1kweWVaYk1aeUg5dXArcVQrNlAzNjA4MWNCOWltak42WWcxUS90dVVCQnVWNWloV3hFZlc5VnBNMHMwQ2NFcldCRUlGZDFaZ3BWMWdHeUh1eWcxdThnclhLeWRxZkltWDgzc3NEaUZYNXk5M0RJU2FMNVltS2RSWWtmN1cyeXZOSjlwNzRxai9sUVpzWU4vajB5WGtzblN0SVJFQ1pXblptY0hueHlFNkd3Mm0wR0RmeXQrVjBPdFhCWU4vbVdtdVBXZE0rQ2RpemFjeUhZYXQ5QWZhWi9ZRmFkSHBQejFtRDc4T3ZhemcyZkhCWStKUWJkbngzWVVIOE5sWmFoWkg1ZHM1TitUVHlQd0ZSc2F3RUVNUHl4S01oRUNiNE9UQU41RTFJSUFCcTFvWkFHaTEwQThHOTZLRU9BcTlDWXRHdFhlSFJmRitMdmg2SDI2TE90NVhYcTNMZ21uSTBjY1NYSzZ1bHVyaFNXZE4wN2pMdEkzdE1FTG1vay9vbEZUUXhuTlVOWEJKMUZMQ091REZ3UUZkVTlvUEsrZEdQd0p5dWhQdU80VFlXSHczeFZsekMrb0F3LzJMd2pFOUhuVXVYZzE4QTJuNDl1SGRwd1dxamhkUitwdG81YkhYM0tWdDJzMWxBeS81alZoL3JidDFNbmM0UE04ajY3Z3BhZGQ5K2xoL0pzYW51LzNLSkV5cVJUbGdoMFY3c041UUNwYW1JVGw2RmkrQlI0S0ZvMDMwSXF1ZDNVZHpEbTdzTm5RQjNnZTRiNUlnWDNvV2RmVmZidlF0ZDdaczczQnVZMk5zME85b0Y4ZVEzeC9pQjdTODBzcmVEbXJrQ3ZnUE02UW5HRWhHbWRaMjloWWQ5MStid0pYMENiSW9WWGlGWk1qRUlwTkg0c0w5ekY4SmpRSjZ5eWYxRUpnUDRSbktHdTF3V3JOcmFYdjFJeWF1OW1QM0s0aENzekhYVXkxNnc3WHZqTzBhMmgwQmg4WXh1RFhOemZQMVhUOHJ4YjQvYTJQMXREejFEVHU2ZUNyaFBPSFdCWjFmOHFGS1JoVFl6VzlBUHVwNXZiUWVzK2RKR0VWS01BbERqYk9uWU45dCt1NlFlbjR3REF5VzJKVUNjQXZnbHlOTndpbWVjUUxDOVVHWjVFN09BY2hZR0ZpaDA5MTNBVDRuQnpVdWx2ZlQvQS9JN2xFUVl0Y2dPUTlWT3VlSTluMEIyZlBVZXJJMXgzS0JHU3JtWkZXNkRycVpvZ09BYlgyQU5Eb1BIdlRCZjg5dzdYM3dKUzUxVXlqclh1ckUreWRZQzlzdXorODdtNmUzU0M5YXhNMjUvQWtGZjl0dXJobkRIKzlyWnZSQVhLN1hYRGV3OTEvQTU1RnVIOE8xbjFHNnhzNHdWcnc2d2RQRGM5ZC9mUXFzVlVMNmgvZTVvVTFEMUlPMmxabko3RGFFc2JXVzF1T1BieEYxS2dpMzRZWW5yMWFiV0pYTzN1V2pDUWpZci9kUDF0YnEvWHhmMys3V3R1TzV3V1VaUUZYTTlmeVJ1OUF5NDlTTm5RVHd6OGRyZlpXQi8xVlBOUHZZUTZzd3BTL2gzcGQvR0xoTTlkMUI2ZHh6Nk82WUp6ZHZWQVplTDVmaitUaWFOaXhMV0p5UUk3QTZ3SXl4aE44c253QUpyZFFHZUtCeVpQM3ZJL2Y4MlRRYzQ3Z3ZuTytQeG5rdFl6Z1hRSFBzaG1hckF6T28rR1NVSUJKQnJZeTVXMW1wTENnd1dNUkFkMFJpa1JDbUhlbXFZWHlvWVFsM2lCYWlTdTFaWUZqQkQ3Q0NEZlFuR0JJZUxNYjVBN00zajg5MEd3ZWFPN1lPVFcxYytxWEl1L3BJamVpbmRHaVp1aE15Q0F2ZmVZYlo4SU1Gblh3VklubExTd21TL3daUWY3OXhvRkc0OEE5VXhBUzZYZ2tjZ2N4R3VRbTZsa0lNQlZlcXBZT1AyRlZ1YjFLRjY3S2s0VGNyMFRlUUFoZTlQRlp6eVA1cTRTNnV5SVJoaEM0MjRkeURIQkJmTnQwaGJSbkZjc1QxTmlDR2FMYmo0K2pBZ2Y0YjFiQmovUVF4THgxdUU3Sk9XWnFXT2pCQStHZkR3OE82b01mY0VMMDNMbUlJak16REN1bWN4cWVtVlNVd1ZtM3BrRXFURnV3UjI2L2xzbnJtaGI5ZTVVVmRFWFFucjR6ZTJaU3pnSFp1VHltYkxpL0NFVStOZjlFdGpkY2tBNmZBdjhQWmJhWHZ0VytXL0w5M2FKV00vaFdDRG53QXZBSzhLRnJPaTE5ZFEzaHNRRzV0VkQzNDBoL2tYcC9CL1UzOU0yMTFiVk4vQzV0YkhRNjIvQURRc000NEU2UUUvNm9yZldEREU2dnJXMzJON3Zka2I4bDRGT2tRY29qQ0NFTzJGcmg2UkpnVXZoR2NrUGd3OENneVN2QW1tbXprQTh6TTZoTUZsdnJEcXpKSXVucHU1TlliZzE1ZUU0bmlxeU1hTGQ4c05WNDhTTVBQOVNiY1dtZXhWOS9pR3pab0JsR29pTU1Zak9vZDgyT2NvRkd0S1R3VXhFV1MvbHl4ZXZzdVAybTdzb3JJSjRrYlNOYTNJRUE2cmhjN1c2Tkd6VkVtMzhwbWg1K3FiSlhMMVlLbFBFSTlRMFVKdmc4b0tZQk9JWkRyTXd1R3ZOdmlMeVdoZjNqeGtRYmlnU3BGM1JNZm1wNm16RXNLaHB2OVIrZkkxUHFOd0VJMUJvS0cwK1N2S2dYZmMvTC80ZUFRMjJaMSt1VCtFa0Vnc1J1K05QeU0yODEzakJ2TEdJKyt6UHI5U2VOeCtIOEpYd0hqRzFnd2FjbWlIa0RtRG9jSC9xQStwUjhuOWcvWE15UHdkaml4eEJVYWN2ejUva3hYTWhPbUt3UlQrYnh1NUdIdDJaenBQK2V5UGIxanRCV3BLeWgxOEZmUmxhRForOStUejh5MUNsUmdIMnRnTmY4T09EajU5U2pSNGQveUowNDJVNXpFdWNRREF2R0tQTE9PQjlVaG5KUC9kS0RENjQvK09BbkpqUDE2VGcxZUFUdXJEK0lNcE9GYk1PWkdaWVFuY0NaQ1hMK3JmRlQ0enkvTzNFeHNISGVRRS9qZnJnZnNFTkEwQUVOcEM5QnQzeVl1eUdNUmVDS0hxWkI1MlVQRVY4Q1pSaXhVcmJNK2tjN2VrYzlmT2c3K2ZsYS9xN2IyVlRaUzRaM1RhZnFJVjdEczVJNGd5UW5PWk85K2VaU0s1OWtjN2FtYWp2eXRjdjJ0WC80dzdaNnhSVi9VOXRmMDcxMnhaeGF6Q1EwUElqcUVpTVduY3lzdmxCS3owbFdoczhVOXRWR3V1a2g3WlVnWGhzbWZRVUZ0QmZ3ck8wQzlIMmJrS2Y4TWREM1ZyMWdIZGhLU09qKys0RU85VHVZa0NlZjNGN28yUGNwQWJpcEpYOFV5WjFmREM5Y25ISE5ISG9JU2gvOHc2am84Q0l1R3FHa1YwNWRnRmxJLzdOYUlkOW9sekV4TmlhbWRGa04wYzlNTFhyVzlBNFh1R1JITUpkS3Nld2N0UTJERDlxVVFJU0I1WElBOVJFMGFzRzcxRVpObzQ4cWh3NnJIZjBYTDk2bWRncmF0THd3eWNvdktJY1BLN2hkN1VZaFg5ZTl4V2xrQXIwaG50QXJWR0paM0tybHpEeXBVM0Yvalo2a25ZRTJCWGx0aUZEU2NvaGR5UVVhTlkyK3JUOUptcE8wYktlUTNiMlZrTlZWSkFJTlQ3Y0pSVTl2TFJSTnRPbEx0ZWhGR3UwQ1RUT2NMNEo4bGFicTFQVzRGVUFnaENocHZybzRhQUo4N2krdVlnbXJPWnkwQnM2WlhLTkRmUGtCWGpqUWNNS2FLNGszSG1nbW0yOUlsQkFqSXkwcUsrRVBtK2swck9GckRHdEU3TlEwTHliTDVlU0hyV3dxV2tXcW9QTml2c0d5S1RzZXo5dTJVQTVMa2p5YjBrV0JVd3ZGeG1ZcHJ1S3ZycVhwc3BLdVpCQ3RXWnFtRnhMbHRwZTFUUmVKYnZVT1ZwWTlYbEQ1S0ZMMVFtNDZaa1lyREoyY2tsZ2txckZVc3hERWRLSG1TYjJ6WkdYVnIwTmhIQ1NxdFlYK0M5VWIzU3ZvSXA5ck1rTE1ja1VMei83SFpQN3QxbXE5aXcySlpkN1E4akdiZGlJS3Y0V2EyOGZVQys1OFFOc3F3aklvYVJQQTJYK1pMWExKM05aL09qZEhOZ3RBais4QmVYNTUyN0oxdCtZd2xwRlhxRDcxTnVvOTFQdXBqMktlaDhGZVJRaCtZVlNZUnhPbVdmT290UUxvTFozZ3Q0S2FXVFJockFWZVRDdW9OWThtakxud3ZBWVBFZ0w0TWZuWmhwRUZEbmdUOWwzTkZUVEtjclI0Yk9MYy9RQ1JIV0pURjZqWEJkVFBNVWsxTDBhY3RNeWxMVTEwcFpDVlpwV01Zd2dGTlVVWENuUmFMUXBSMjFYWXRLMUtycVRhYVU3SjJCRzR6ZVJTQ2Q1MStRVGpSaU5jS3NYeHBpc0trbXNLWEVxeU9NUEFtZk81SEo5a2NrYUVTNmV3aUowVFJTR0g3eWRTbkI1MXYwWGdWblg2bnBRbVZ2ZXVUYm1INzVHTTNKdFRPZE5PZlViVXpBeW5wSjJJa0ZkeERqa21oUW1OT2xtRkcxS1M0V1RYam9xRlVCb0lUYWtGMFhBeU1wZXhRbExQekltQ21NT3lmekxGUjR3OG5mQUp5UnU4eW1XU25CQlF5clBKTkU4SUZiSlpBVmZFMFBFVDdGY0lFR3hMMUZMMzBIcy9ranljY294Y09UdFR4YVRmTzRyNTdNODVRR2E4QVVzblZOUzNkUUNBVWQvbVdpQUIvTHp5ZjdVYkRDZDhmMk9idWRUaEVKQlVGUis1NTdBN1ZjMFpLUGRmYThGL0prMkFwZ1V6VjUzSkhuNlYzeFR2U3gxTzVvelovMUlUdkp2d0VLUnZTc2U4QXAvVktXcUJXcUlPNEpuOExkUzlJOThxZ3M1STNyUmhxQnZQZEFMY0c4ZEhablVXQ0Y0ajZQcktSTW1IUCtxZ0ZJTkJ3Z1lsVndlUTNQa0dNYmdGSlR5QjFBU3pZWjZZNUtKcXNicTNDaXM2ZUZlazk5Nnk5eXppWkRpWE9iVFlXMXhEbk1raFhUZFlub2JRWjdUQnk1a0t6ZFA2VVptdjZmaWdzdDdMMlBTT2FLYnk3ZDVpSlJQZFFkdi9JTzh1Vi9mbTgzdXI1ZDJ5eGxmMzdxM3l1SGVoZkI1eGFtVng4WmZ4TVQ1S3gySkxDRlp4R1VQTm9HcEVOVUpWdEpISkZIbE5YeFNiT1VBbHpqWEZSVjNqaTM3c2tCRy85bU5PM1VEZFR0MzNFcndDbzJKNG0rSHI1T1VMclhLZTJNTVFtNWk4WU9YcnhPckJONThoZ09iQUlydEJ2bUN3cGk3azhRaFJnSENLRGFKVGJMVFBaOVlhWW5pb1BMR0ZBYytJZ0hYNEVPR1pGekNEWnlENk8yWmpUNi81dkxzYUptekF6YU9Wak0vRUN6SHN2OUdNNkxPQ2t5RW9OM0FQL3NtY3p4Q1JPVTVZbU1iTVBGSU5BUXVYRWJDem5pR01KUGk1NG1oOWN4dCtiaFFKQ0w5Tjh5aXdZK2tFTmkwZ2h4RUJGYitBZlVUbFg2UTZYMU8rVnRGMXZWZDVrYW9JYVRWVlNTdXBENlhVTkpwK2tjb2p5djJhOG9jbktwVS9xbFJlQTJ1NWQrQzdwMU5LNm1kVFlLY0w4VDRINkNuMDV2Tm9JQlIwSmtvbmdUWTdQbG95ZU1nOFJVb0g3SVBkM2Z5Y00vZEZCMi93MzQ0dXlnMWV4THpZMSszK1ViZDcwblh2bUxPcmpsTzFUK0g5TFFTaXpQY25DMkxhRzhUN3Q5VUJaQzJoRUFFSDRBS0FwWkZZWS9QZ1QrYWdtajdZQUdPZGozeEsrWno3T2VWVDMyWloxVkpVWHVUZHMvbzV1SDN1TGNHdDM4Y1g0UjdMYmlsSElNajYxQW9peFFBZmNTSGpFamI2VUVEL0Q5elB1Zjh3eXJ2ZngxbjN1MytOTDI2TWM1MmNPeTJPNTRIRnZLL1JIOGtwblZhYnhBUnVBcGcrajRkWVc5aUNreDZvdDdNZldadXJOQmlXWXlVT292eHladFF6dktqSjhReGlHRHh0NTNpNk1UTVh6TDN1WFR0eVdjdlFhRkVYRlZPMWRKV1dVNGxFbktFVGlVUUs5MFBaTUZWYjFpUVpoU090eTQ1c243YzJKOUNrUU04K3NubnpJTUFiMFNLU21EWVExMlZzdmhpWUk1eTlZZWRNZ3hFNFRCT0RhWnVrbEdVNENkZUFhVlIyakNiUGwwWEN0Q1Rvc3EyYUJsQ0c2VXpRVEJ6b3BGWGRVazBGVjRMV2pNdEdhNjh1MFFscWxBbitxLzZLVk1lSkVOU3ZWclJWaUJRaXBaWlhpR3gwZTZYRHRYTUF6STJvUGU5R3E3RDJmWGp3N3pYVXF3MU91MGdmbkszOTA5N0IyUzB4TndTU0wwVlc0Q1BOU05TSnpLQkl5eUdnM0s2K2NjNzl6Y08xamJOZDNYVlJiN0NKZWpnLzVOYlc5RzV2Kzlxd1JPSzhneDRnallpQm1VTXd2VEIxdWE1NzVxeDdyamJvbzY0TG1kUnE1OXl6WjNHVzFBRFdBQzZXVHdBbnlJM3owYytDWFJySkNOY0dNZ0lidFUxd09jTTUxU1l3QWhWaStVcld3WEhGOE5QQ2NQNE5YYnEvaHR5MTIvQnNXamwwaUdnNTRFMUIraTJkSC8yb294NDZOSkdQU25EOS9IdzgzeVlmUXBRL005aDRCaDVXT3JydVovQnhlRkR0Zkp5QVREQUVZM29WVWVkaEZNRnEvQ3FzdE1PdnIrdUw1Rzg3cmhFUEhBQ056QXJLQ2JtV3Y2NEI4Z1VKN1BueHdlK0UwT3FyOTlOSGFyVWo5UDVYZzJIZGExNi8rYTBicnFJUGxFb0g2S3RHdUFSK2ZpcXNENVZ5TFNKL0VLRUU1d1U1UFRITTRnbnh1ZWU2UHp3eGZQNkU5dFJUUkNicTRlZHJWSVJFUTZyQmFtVEo4UzFEcTJSOElPNU1lV0xnMDJ3UU03cnljS0YyQ0drcERNRlNMZjhDZWlNV2YxTHR0bmQ1dVlRSFVxOVdQMzU4OXVwYTI1NWVLRnp1SlVxbCtRaEI4TWNTRXNRbDA4R2l3RlROYUNLNmdSK01Gdk41L05oaVBLUFAxOXRhcXBCUFRNV3pad2l3LysyQTJiQ1FNTUhVUVRjU1pqVGc2YkFPY2VKUmZSNzlvOVYzQWdBVkVNdGZnTXczRXJvT1dab2lFcUw0clFSdEVDS1dOWXNuRklnVGNSTm84cFpSb0dSTzB4MzhuV29KRVVkL3JuSm1nOEIzbGY3d3JoTlhKMjg3MGUvM0gzc01VWThOc2M3SnN6eFpINE1ITmtuaTdpZ1JSOUtza2pTQW1HTlRPWUpraktmekhjNERYUndSbVpxdE1NS3ZFSjZLNWZFb1pqV1IyejF6cG90Q2MyZHJFS2poN053YzB1OGdXTEozcktQdTZ2cjY2dXIrL2IwZXhKM3BxZnRQOXdGSnRqL3VUMUNlREt1OGJVQXJJY0QxdGplRE9vRW15SmxoQ2Q3R0RQb0F6dkdSTTJjZTRUckNqaTZvMkJieHNGYkJSWHJTZXRJNmZkb3FyUUpRd2lvVUJPdUdWQXlkUnZkYzRKcy8wcklOclV5My8xQ3c1eTUwNy9SZzdlRGk4QitxQUFzcjQvTjdCbWYwV3EwNzhmY2lkZnIwT3Y3YmVoWHFyLzVVR2k5S0lYZXAxTDAwYld1NmZ2cDh1bng5QWNTVXpwQzVOMjZYTklRcEkxTVZMRFFDUXF0dmxOMXN0SjFXZm5ROXVIYU9rUm44bCtQVGxSMUMxdElaZXlaWjJTbElHWVF5a2xtcnhMS1c2Y283NXFNODZpR2tmeGdoUmdvSjczN1h4MmhHa1JUMncrOWtGVWw0T3grU1Jub0FuNWFmUXNuRmk3MVFLVVBNWk9yRklHYnVicHgvQmdrYUE5NHlDOHRNTkFpWWkrY0pEdmxnbTRKR0J5Ym14RFE5aU9TTC82OWV2aXB5K1ptODR0NkdZamxYaTFmOG9McXZFMnI1ZWowQ3ByQ09wQmxWUlptTEtwS3BoZEY2NnlOWHplL1BhdGRkVlZtWm1sNGVyQVdSZG1GNytzQTFpek83VjV4NE0xUE94RTFSZE9QVnFpVE56V2N5dkJoSnBuMGJwaEhkRjZmNlltUzlaT2xic0tSM1VKZkJlbGpKaGtEQ09TaGhCYjhiclYySWZKQ3Q0UzhNWnlRbVg0N29rT2JwSmFKb3Q0Uk9FMkpEenFBOHhLQVM2anhadEd5QXExWWQvWXlDQ2dEdlVVSXFDTXlnMUszVjZIQjk1eTJHSGs0Z0toWGlwZGN3K000M0Q3Ny9vRXpQdmxEOXF5ZjNTYXJ4Z2lZSjR0VjJMRmtxcHV6WWw5K29FMDlDVjJmWXVQNkJZdEt4WmQyS2ZKbDlRdGZmK05WSEg5VWpsWXArOGlGTlVWVkJzRU5qZjNVL0xuMmVLbFBUUkYrNVRMQVdoR0JOcDFNbnBHK3BObFFWREJLRTRJZXIzWElXNWxIQmgxUnZvTXRGUWRKZU1GUnAzNU1QVDFadVhWOGp0ZHNqN2Z5TWZQQURseXZWRjJiM2hHeEJVRlZGZStpT3lhcTg4U0hkajhnRmYxK042STgrR3RFQkF6RXg4dTI2amxxbDdxZGVTejFCdlpQNlJlb1QxR2VwMzZiK0cvVjE2anZVWDFML1NQMEVzU2lNbTZlTUZ0QVNPb3hlZ2U1Q0R3UHVtVzgxTzNLeXdIMDNUeWJDL05CcEdJNEwrUVdZVUhlR1hzZkVscmExMENBaGZRTkhESUdZMVRZYnBtZjVQaFRFdXdMbjQvaE9HWG1CWENFdmlnQmhiNGllbllUTzZuakU2NnpSSWQ5MzhFUmpRRWh2K3BJOEQzMFhpOFcrMkY0T3ZxSUJ6VzNjcWNHYUYxNURHMDgxQ2RBQ0lZaFVBcWV5Mnlzb3FBeE05akZCb05JczJVS1pEL3N1YlFLWi9nSTFEV0VaclNDTmRvWjFYeWhEYUtXb1RlQUNsbW1QcE1aWm1MYlZGc0JMcmtvTGdhKzE0NXNRRi9LRlVVVFllWlNoblVhekU5amQydWorMGlKTk54SzdvNnpvekNVeXRCaGVESXQwSmpIbmlHeDBkNkpCMDR1bDY2L1A3V2JRUWd3U3hXWW5FczNHSUZGc0FURzdjOWV2ejdnWm0xTVV6czZrTER0R2U3WWpDOFpuNkpqdEdZTHMyRzEzWmo0RktVSzAzWVA3czRvUU9ZTnZWeUtDTW5zTHA5QUtSM044aUJ3Z0hvc1NvTnAvWGRpa0dTTUtUaUF4RGM4dlpCUjZoRUUwU2xwd0kwSWpGYnlFWG1Ya1ZUVWZNU0pSVHRnaGNoRVIzMlBvRUhwTW5JWTdPVU9QbW5uL1dvaVZwUDlYU3dnOFRQWWRuYVVqTVZsRmdzcDlPcUtHRW9LQWNDb3p5Z29jQTVlL0s2WWttZFdtbENyTzFZaHpGaE5pVlU2SCtGNG5xaUtMWDM4cEtjbGNlQ29PRGtWd1Y1RFZUMmc4azBrc1JkbTVSSU93aHZDdmtaaGpvMHVKRE1OcndEM1gyVzJ5czFzVHpMTG1ic2NGOXFZWkdaaUJ1TnRzRDdQSWlZU1lWMktPZWt3bzR0ZzltU0VjQ3U3T1JrUE0zZmhtaFFsRlp4R0QyVC92TTFvWnZON093a25XeHZYK0dERkFlMXREUkFYQ3JTWEZZZVdJYUtFSGpMeWlGdlNtaUxyQU9NVVJmNC9HSEk3RmVFVVhaQTV6R0gwOEVvY1dpTWU0SWo1ak9lbC9LRWxKeEh4UlBTU0tRYjB0OUxOaVZVcEpFcWZQQ0Y3VmxQRjFqUlYyS2dsUkJHYkhvMG9FODFUbDJUY2tvaktuRW1iVFJVVFl6MHpnTlY2QlIvTGJxVmRScjZPZXBINkIramdlTjZoU3d5d0VBd04vM3Fod29TSGh2QUZoT0J5TXhwYTJiMEJCM2t6ZWRvWmVYeDE0TzRjRENMeVFrKzlmZFB6U09UWTN4RHVBZDI3TEc0YnV2Lzc2NEwwcUwwMjhMMHZsODk0b2M3ZmZJMGlYMlcwR2I5UGVXSHpVNzY4THVycUp1LzFpME1lbmNBdWVKYjJhSlQzOHYyL3AwTTlQOUdNNk12Zys2YnVob0Nlank3YjAyKy82SlJQS0pyc2lJWHlpcTVvanlvT0ttVUZYZlR4dkJGM3FMT2xEUmR5YmZwSDBIZHhsNkd0eGw1Rko1L255Ukk5QnQ0MjZDUkkvaVBzRkYvU1JHeVk2eG1TY2FNQVE5d2c2ei9aWUVlRFEyZlR5QUJTU2F6akV0aEJRTkFndWR6NndsVUsvSW9kQzhtQk5EbXZLbWl3NE5Qc1JpZUhRYVk0UmZraE9rU2NPMWtTZVFhY0Z0SXBUbmxXMHNJeDZjZ2pmMUlWRENFMEwrR2p3Szk4WHhlOHovQlpkYUlqTVBCb1RCazVOZ3M1WnhtZENhMFFoZWs3MEtSRFJSK1VRd3cxNkhETWtCdW5pOTZIQTc0dTlrRHlOMENGU0xzamNvelVhSDVFWnZ2NHRhb25hajkrUXE4RitiTHh1MDI1MnZCYWU1emRzK0pRd3ZBQmZtQ3pkYVRtZVlEbk5qbFAyNEdNSFlkYzVHeFlSYVFlV1dDRjhXRGt2TUhpczlod0FFZkpYZGY2Vlp1bVllWjhaQi84WncvcHRtNTY1ZGtmTzV1cVhYMzNnTXVNZTQzVTBMSk4zZGw3ZUhueVJUUit3VEZUL2l3TnB0dDB3OTgzYk5XY0dEL1htUjJiY1JYcTQ4SE9PN25ySTIwTnpLRm1wbDM3T251L1N6dTZkYjk2NUV4MDh5RFVxclFOMXM3SnpkMnk1T1lXOHE1RDljMmlxV1hXdTJuUjVmdkExVk5JYkRiMkVtQ0FtNXBnbldTd1JBVWRlaWcrRUJ4ZXErQVZyZXRTdjVTY3ZXTGZ6Sy9OSVVKSDBCY2tQL0JPdnhmMmtTdG9QN0VaM1UxZFNOd0RlSmU0eE04Z0NuNFlsVk1nVEM5a1dXTW1tVVJBOWVjR0RNWS9BTnZwN2I0VG5HT0QyRS9tMHRUVmM0TWM1RHNzbFhBSHZPSnY3UTRnZUgzV2lVYnkvbFd3TCtLY3JpUmU4eFZTNi9FSTVuVnIwcW52MlZGK0F6Vm44UkdIOHZLZm9Tbm02REZ2OG0xYkFSVGlhVzVpYVRpU1RpZW1wQlgzNWVMZDdmSGtZYjh1dnB4SlkvWFVobWkyYUlJeThtNEh0YjhHUC9VcEUwU1hRaFRjV0NOaW40K3RLL2ZnZ2hUeXVZM0FEWFRNaWNnZXBHS21meFJlNGs2UldEVkpQbjhKbGNnVlZmZXBlTjVHV0t6QkJUWlR5ZFpnTFViRUY1eFJaOHc1dy9uMzdKTCsxamdEU2ZuRmtEN2dWa1hxcnJXQ2dtclQ1NENzQWxwckJJUUY4YURic2h2K3hjSmFSRCtCQWRCb0JxZ1ArbTNEbUJqUDl3UEVYcWJoT3VycEl0di9EZFJ6WE1jdmx2NTY0ZUpQT1Jua2hQaE4xZDhWMnVkR1pPQllPV1QzaXVhR1Fzck85VXdtRlhJL2hSVmJSaXdrVnowa3FDeFVzOXF1Sm9xNndJayt6Y2tqWGJUdXlIRnVPMkxhdWgyVDJ4NlJNbDJ5dmRQS09reStXNXlhdTVmYmVLREVMTVVtS0xURFNqWHNQSEpEWWNKaVZEbnlYU1Y4MnQyOUZaRGhaNWhoeFpkL2NaV2tHcVpxWjRqbU9UNW1hU3Q0SG44OU0wRTlXcU1zeG55bjhldVc1UytBZWU1SElNZHNqeWh3dGw5SHhTK0RNNExjSVQvOW9ncUdUSFA5Um1iOUlaYThuakdGSTRrV2ZWUlBIVzllSG9VL2RSdjM4K1hpN0hWNndBN21EaURiK3lyb1RlSnVQSnpJZ3lnVGU1ZTNSQ2oyUmVJaFNZVHcxc2gwLzNEemVtNkFBSTZHaDhSNkNzN2Q5VlpyWEJ2V2FINGtlN3h2dko5Q2hLMlNCTHg0T1l6RTJIRTFLV1A0VklYYVh5QW1zbEl5R0dab09oemsxWWxxNnl2MjBWTHBsUnRUYjNMZ1cweXhWMUVYWHhSdlZ3cWR4Vjkydlh1eEdBRTU2a2l3bS9qRW5pTG9aanFKUmhyaFlGQTJiWUxNeExIU2NZa2pZbGhSSlVjL0dORFlvbE5WaVdiL0k4eTl1OVFrQTYzNnFlS2tNbkdUNjBMaHk5ZEpxUEhGamt6VEFDeitOME5IRngvMkFyb0dNZEFLL1U2bkFMNEVxNGRrLzcyTUIxZ21XYU4zMGUwcWgxU1NkQ1BjbjMvd0lqMWNCeFNQS1B4c09NNGxrb2R6V1RiMWRMaVFUREZ4SUZOMjZxT1pWc2U3aVN5ZTdjM1BkdWQ4bDI2OForVmk4WFJZMVRTeTM0N0c4a1V2RVNobFZ6WlRpc1pOekpBbjU4OWZIaG5TK0xCb3ZpYWFYb21PeWJZa2VFL21MUVlGYlFLdnA0NXY3eTdpQVlZWDZhMnRyZWw5ZkMzWjlDT2swT3NQL1R2ZjcyM3hSQ3NNNExwRWNhbzFDMHdUclRrSG0rSHEvL3lKRllqU3M5bkJXc0FoTWRuMG9BVitseHBkZ0YyQ3RBbTVxbkVUckhlSGtoRkZndkVWWXRZekdTc1poWkorUldwSDRnb1BOR2JxOHRYK3FzanMyTFltcHp1N0sxUDVXZGtjNHZPUE9xQ1NsdzRZUlgwNXFXbkk1YmhqaHRDUkZuV0o1Mm5XbnkwVzB0dHp1Tk9xZWJqR01VUFRxdU44dnArTHgxSi9heVpnOW45UTRZYzV4NWdST1M4N2JzYVNkY3VNcFJVbkYzYUZ0OUpEK2w2RCtJcFJkckdTL1BhK2wrbGplRUVCVFBNVFE3Z0Iwd2pEQUVlOFVGb2lGM1dGTmxqVTVvdk1vaXRMUm1CR0xvK2orUlA1YUdhN2ZHOWJ0Y2lKaUcxYk1YazdIazVPWUREQnVnMmYzK1JiQ2pRQUlaRXRoOWdWc21MOGNMeVMyRkx4RWlObHFUZnpGVER3UjAzVUwwMkVaTnFiamR3aHA1OWtxZXhmNGd2akZXODF5Z0JEQkM4MzJ3bklnM1g2ZEZOWk01QlA3b3lpT0NZaW1NU21zRkJUL0J6NEhZc2w0ZXRtTzRhSWppWEpJQ011VDN5NlJSRDdLa3ZoZWZyZm1XcDVBZWpUald4d1RlNENDdGJHK3RycUdhcWRQOS9yZERmVnpuMVBkcnU2aVh2OXN2MzkyNDduWHZPWTUzTVhYM3ErKzV6MXFmSFV1TkwxdlMyd3RZeUwvemloYmt1VjZrRm1RMVpsaEZvR2RHK2hRd1FzSjFrTUwrUUJBa1FEbmdORUFHVk1XZkd4ZE1tSXZCQzhJWEVJZlQ2Y3pGUy96dUozUDJZNWo1L0wyVEdnYXJ1RHJYZ1ZmeDFmd2RYelh2NDdZOU5YcFZPb3gyM2E2am0xUGExT3AxSGxYQ0YwM29MT29BaHFKUzZPcnZUQkIxV2V6MlV4MUx2TUdNNXN4TGN2TVpFMHY3c0VWZkgydWlxOW5zcFVLdnVkZlJYTDJXRGFUZWN3MHJVWExOTXZ4Y2lZVFhLbnNySkR6b1kwaTFVV0FGaHp5ZlltSktwMk1mR0lGM0F0cmlLcFVuaEhGaytJV1hCSW13Sy9mOWt4NTJ4dnhuSi9IS3ljTjc0ZjUvZkpXQS95dGZUbytFVWNna045OEJYeHpaRUgvVFNLS2tXWG1vT01hUk1qNmd0Z0hhc2VZZkdDOUZtQlNnc2ZJTUZBbGdSQWRDb2ZNY0tEMFRZOUFtdHFHeVlON0NiM2RFK2xVK1hXZmZ1eXhZM3Zic3FKWkNZSWdtb3JyNGJBUUVrVE5ZZzBqZjIwK24weUV3MkU5bmlnVXJ5NFczamNXcTZwb1Izc2ZpWUpaRnExVU1VUkNVMjdHUzhXeVZ6UU14dElBM0ViVHdrbjhwRmN1bHVLUVR4alJFOUlRdkNyRzZIMlJpRVkzZDU0ZjRxdW9uOEV6bHArbDNrMzlJckU0OW1lTDdXRXR0dnRYZVkwaGs0WlhpdHRTbEgvS2VTay9EQ2RRM3ViaFAvRkVFUHh4eE12RE51N2YyYXpnV3BaclB6YWJ6YzVtUzNCc3ZkTEpacXVaTE8vYXRtdWhZaldEazVYUFMvV0dLcVFxK1lsMlRUN3kvTFpVanAzMWs5MFBhV3duZTdNRnB3ZXlrUFB1NE5naDFQaDN6bVloaDEwVzVIRFpSWTd2MnZKRUNXcFNYYkw5VkxZek9nbGlvWS9iYXpqL2gvNTVaTEoxOGdISHhxMnhQZmJSY0QvQjdmR2RnTHREcnI2RDhPQ1l6eFprRVI3ZVQ2NjlpdkFOSGZadmZYNTBEVmRueUIvQ21HeFF3WGVRU2svK3JRUjM3aWVWRHA0WVlzSkN6SlVvdFFQWGJ3K3VJWVZNSDVPaDRBc2xoRzdCZi9NSStFVVc1cnY0SytJMUhmQ2JiZUl2Q3JFNnFpOElRWFI0K0NFM2syS05mbFIwTXRlLzl2bzZuNndVN3lsV2tuaFdaK2x1Sk90bUk2NXVpVHA2dk50YlhWMUYwYW5wc3BCdElsVFBhZG5wcVozWFhmZHpZcWxZcnhTTGxYcXhsQkMwb3JmVzdhN0JyMXpTYkVTL1FJQTlBMnhQZGxTUGNaVEJVUzA2QlFCcDl3cndrUnJYaURtUFZ0ZlZYU0RMRFdnK3M1V3lmcmZiaDkrWXdzSFBUOUlnYnBFcHQ5amVEVEZPbmNEK0RuNkFJczBIUDdRR1ZqWDZvTjhId0tvTjhPREcvOGpWTlhEcXZrZlhWOG5mYzY2N1N2NkM5YWtMbFVlMCtlM0dRbjRoK0UxcThFbDhNVCsrRWFKSVlYQ2w1M2J4LzI4UFM1bmtweHBFbXdZY0VGOWxObmJmQzZNcTNUb3ZoTXp6RHh3NmtJdkhjd2UrY1BMb3dXSlJyL1ZlUzJ4aVppdkpaQ1dKVGg5cTd6MjVJNS9mY1hKdis2YWp1eHZQTkp2MlpSOXY3R2FKR2N3VlNVZzFFUXRJQlhzb1k2SzQwU3JCTVBmWCsvbXVUK1IxdjUvTEVQTVY0cHo2SHFNRllrdERUQzk5cTFWd2JJYnN3TnU0UFF4YlhtNlJGU0lrTGc0MkZwZU9MVzJjYVI1cS90MWc4ODBwSTZiSGNDZlpQSGZ1NE16UzBzekJnNlZtYy9BYlo4K3VHMXBNeU9XRW1KWnh4OWhnZnJtT2J3RTZXYXJnR3hOamZsck5ZZVE2dTJHT1MxeU5HVkJXRDVkN2NGemNWM0QrQmlscEhRb3VIZXk1dzdKb0NwZGw0WDVmSlpLTEg0YmJHd3E0Y0xpTW9sZzZDd0NxaUJ3RGJrZU50dGNVU2gwSFVjZE9zU2lHMkFldXJCK0wweGFkdXYzYlpMczRjVjNvZHdmZGJoZmduSndveTdHeDBKVVBOR1laaGEzdkdIeUw3Q1p2dkJVbjdRYjAvUmo5VC9RVWlUbm1vK3NROU14T25jUWs4YkUrUEQ5Q3N1RDRPS0pMS0FoT2dpa3NFYUVTL2JteTBKSm5WS1FqOU9CVnpSdmlXbksxYy9SUlZJSDlkWS9TK1BwRCtQTGdOeGVVcVdsbFEybTFsS2twVFVDQ2R0V0RDN05pYmZIUjY0N2o3YzljeDZEaDFhOUNrZ2tNaXdmd3V4U0J0aUkrRFg3Y01pL3dmd1BiTS96KytNNTBZRENFSG5qdGE5M1hkdkdQN09SK1grKzdmZDNmSVhiLy9zWEwzdjcyeXhhRC9mT0hEcVVPdmZlOWVPUHZSekZXL1RJdlVPSzIvTS9MY1FMREFmem5aNmtGc0Y3dEZBQnV3eUttRTJBZDBRS3JLbXNjQ0t6amU5Z1RTQWNMcGdLd3FBc0F5cHV1WHF2cFpLTkR3M1hYK29QVlBtQTduQjZDUzV3TDdydCtBc0RxMzBCNE1BR01od3lnRWtBRUxtb0MyeUpLN084V2ZDdk5HVXhTWVFrUlh6T0l1M3RCU256eDBaOTJiNDRJY3J0YmFGa25aWjhaRWR5ZkpPT2NUOWtJN3p4R01IaGtFcVduaGkraUR2SkExZVB3SGVoOXpXR2NSRXlTRUlqSVZVSWZNYXR6ZUNRUEJocWluOGxWSDlhWHVMZlpsVnkxSHBNamtaKzU3S05YTkE1RTk4d2xiTWx4MFhQaTRPQ2p0Y0pyZjArOExoVCtlN2RlK05CVVBwSndlOTlZTVl3VjlvcEdyemZYVlhSMUhFTWRjNGlNRGZPajJFVkVBZVVFb3dFSVpCMElwcmVkcUVhN2RkdmVhblZ2OVYybGhSTCtxMFgyTlFKU2J0cUQxdXVGRHhUcXNQbmlCMUtWU2dvMjkvVWFWN0FUWkhUbmh2aEVQZzBGTWdjZkJjbTVXS2tmSmFXNms4VWRINVgyOEFYS2dQNzllYno1S3RTNEJCSGdBRm1CK256a3ZMbHg5RUordkRscmNpNitnb25kTXU4K0VJbThWTnl3NGRPbzkrTHd3ZHZ3RStPWU9nUjd2QVE5RFVibFFpVEhBUkxKNXBudTRNWHVaOURtb0lZMkFEdGNSNjcrSWpXS3R6ZCtObnIrMDFEcTFod0dQYlErbWN1NXpVMS9yTG1LK2pacTR2RTZEOXFrRGo4TS9qRjBnN09iUXFORFlHV0pBOG1YRlZuZzh1M2Evcm1pcUltTTBwMDdWRTdXOS9IeHpLNmZaUlJoYWwvTlcxSm9XdVh0K0Z5M0VtTVAxbTFEcmFlbmRoTENoMlZkcEtUek16OC9UNklqQXZUTXpWSDhXOUFBVU8xdE00ZnRNNG5pdHZOZkJoQWkyU1hHSVRkTUhLUEt4TW1meUhBU0l4WVA3RVdPaCsweFNkTjU4ZUdIc3ZqVEpOc0gvWko4Sko4ZzZPUEVuOTlmTldvRFBRS1JBNlA0VFpoSEpOWTFEeXYyelVnV05ad04vZ3BhZEl6bHB1M2NSTk0wdWdudEVlalFoaEhOYUlpWjlXaUVJbEdpNnlSNTRlLy9JMkJQV0NLU0tNNmxnYjl4TGNFeUo3SnRkVkJYVnBQTEMxSlVZWCtYRm0xalpjR3hOdnYxY0NUSWNkMzlLTTFFb3FrUVl1YncrVDhXcUF1OVA4T29ZOE02bC9ESENtVSs5TWdqSDNwazhQZittMUJieGJMaUkzRHB6ZVI5a0RmN0YzdC9uSTdRREh3RVZqZjd3ZnZ6cmMzVm9GeUlpVmpIODlXK0gwZERBRFJBUC9aRjBMMXc3L0kxWXZNQWdEbzg5SmRNQkJKYm8wVldWU0FHamdEUmhXaFlWR2tWdkRCeTZyNHhSdDNqQlkwaFNMeU5GZVFWeXAxNnUrRTBzZmpwWUdrR3l5OWhQSktYNVZDelUyWVlHckZjK3RXcXBCa3NtN05vbGtFTUY1V1d0Q0xEQU5oc0xpcEhOUGxxbGVlNHl6aE9FRGtPNFJ0eEZBb2hUTEVrSUNzMnEyb2FMNG1pSUNCV1lHbEU2NHg0bDRId1JVTkFxUnRlS1hKM1J5Nm5OV2JsNW0vSklWMHVWYklNWXZuQ1VkSFFGSUZ0UldqRVlOSGxEanZEMEF4ZlNldnlrU0lyQWZJdUxsQVVNWGwwQmtWd2NSeVBETytBRnRGNG5sTVJyL0tBemF0emgyeTRFdHV6cmpHN0k0K3hJdnRRSzJnYjRQVTB5SFFqVGsrd2VZRndkOGpsRVlzN0pCNEIvdEJKd0I1ZTVOS1BBRzg0S1NxYStNd0V6dUI5enBBTnpKYWI3azRkU0RYMmZVdkM5U3BYWEU3MHF5V0xTRXVISXZpVTFBdnZTYldPNzBxL1RyKyt2TVgzTUVFd3JNb0VReW8zc3ZBQS93Vml3dEZ1Z1IvRGxzbVBRRUx5OUl6UTRFc2h3OVVsSHUzbHBjRlp2ZGJ2bnp1M3NZR3JQWGdXUW1paXVqNzRDMTdDOTYrQmp6eVdUWHJEdjRueUo3MmNKc3JILzF0T1lFUTVSUGFkS0JTWHRWRTdkMjZpckFHZWN1QkpvTDVPWmtIclFhd0pGNy9IcThTM1FhS29Wb2toN3BHQ2c3cFA3d2hQdlpyK3lYWFBmMkN3OFdydXVuK2xYMWNjMnpYRE16VFEyQ29KSGNaRDNXOTk2K21GNXovdzFhOE9OdTRaNnF6N0pOL2gzSzFFN2FOZTRmdVBrSGswTkNIeDA4Zmw4VUlRUFllb3RmQkw4Zko5eDAvcjZ4MUZkcFgzS3E3eUZUbXJUUEc4TjUzTzJnb1Rqam51T3kvVmozbTYzYjVQMSsvSG1TRDgreU1scXlRNHdaeEpUOGM1SnBLelMxT1g1T2NzWEtEK0h1aS9MbGo3QzlUR2M4aVgwUklLdk5DeWZPWnNyK0hQYnlXZFJvNkhFTkpKdFM5UWo5dTNFSm1pMmZrWTRoQ1NJZ2hCL1loYzY5dUlqMktYUkFzUkVwZldDZllyOC9QNmtYT3dJVTVIZnRTUzRjRldtM2ZJZy9JN2FUTnk1STRqQVdUYllBUExxcmdrOUhyY3IzWGNvMnZVQ25VTmRUdjFHUFZCNmxQVS96bUsyT09yMTRtaFczdUlUazZzRGtxK0pwNVl4eEZsbkxBODBpbVJrUmpzRjhDTkRYUkxBc1NoOEhqUU00SHFEbXdiQ3J6dEt5TUtlUWhqbFNkRzM3Qm00Z1JLcXBGMnFnbnhNSnA0Vkc2UWdvazZHdzlFeEQ5T2d4RGxEbTQzTUFFQTFhQ0cwT3Zsa0pnS2kwSkVsb1YwV09URHFnektaOGJXQkU2bStkamdQMlU1SW9qaGxCaVMrVEF2aHZGNHd3bWF6WUNxV2c3RitNc3NsMkdpSVlNM2t3eG5oTUtJVFlVWk1DMlZoUkJEbXlGR1NhMzI3RWhjRFBGNG1vaWxMcFVQaWZHSS9ZSldOQXhqRnYrS21tN2dVWjhGTVFCdlF5RWpFdzRaSEpNMGhVZ295akN1bFdWQ2dzeG9jWnJSSlprTm1mK1J6RVJqakRpWHNPSU1mMW5NVkJtNkdNMnhxSnVZRTVsWU5KT004a3o4S1A3RUZHbEdOV1B1UGxSSkZXTzR6NVRTRmZ5TlFvOGFHVHVMYUZFdjJCbUVuajNleVdrcXc0aElsa2xZTlMzWGVZWGt6TTlhc3FMSTF1eThJOGtTWWxTVlFkTDNVTmlwcEV0WXBvZ1ZVeDY2cXFDTE5NcmE2YWlDVUlhTXYrTitrc096NnFzZ050bDV2WVBiM2gyYzg5ci9JdTNkMmRhZTU3ZmY0SyszTjFqenZCYVNMdGdpbjl2RzlTMWNMazJ5MXRqR3ovUUZPUGo2clp3S3hoY2Z2NE9pZGxPdnB6NU4vU0gxcndpOEVIRlh4MVBSaFMzUS9qd1d0Y3VPWDEwbllFdmJCbFduaHNBNm04ekg4QTE4ZVpkdkFBU2N3bU5PcXozMHRpVHZEbjdCekF3RWd2T2p3Rmo0R1RxTmhqSGl3TkJqaGlaU1lLZkZZeEdtVFNSQTNFWW12RTBrSmd3V0R2RXpqbDBBa0k5eUJ5YkhuWEk3ZUxzaDlKQ0Y4NklGRHFpZVJxUkpPeTNma0dTWkJoc1VNTVRDNUVPb3c0S2ZsZVhadTJnU2tHNmh1UzB6TUZQWnZOV0twLzR0S1hzeExQU3dMT0RLNHZjTnBCaWhhSms1bnNPWEdBZ21RQ044aUY5WFZVaCtXV0xZZitKalFncExUSGlzRjNGcUNFN0dJcHBqK0dVakRNRUhhQWJMeC9nY1A4c3lOQzhack1NcklWM2k2SGduaTNRVm1Tb1cwMFFsT2NYVEVLQ0FVMFhFMFlwSU0xeWtLaHFZQXBGVGNZNXNNczVob2d3UklZTXg4SHR4RTYxRkZDUnlpRmJDSUVCeExNdXdEUWQvc01DTGxVVXF4TWFUUTB6MkdvWFZVMHpJWU1NME1rUmNEUzZleEpJZHkrT1NHRUZDdmI4UUMzWXhLa2lNekVZWm1wVkZIWWtoWkNNMmJFZWlKa0oyVkl2akFyR0FTQXNDajJ3SmlVaVJaVnhSVjFMd2Q1UEZncVlpS0RaK05UaFZRNXlvQ3JSaUdFblYxTE0wQ1pYSHFwZ0R0R0J3bURqYU1uaVJSZmdoVjVLVmpJekoxV213ZElrV1ZhTWtGVmdsaE9uQ1RGTjR3ajJPam9RVUljUFJhbFYxNGxKRG90TTZEMTY2dXFDR29FMFlsdEVBYmt3U2JqQkRxc3ZhcXNIajd4VmlrSTR3YlVqT0pCV094N3cza21pVUI1Y1IrQkhXMy9EOVdLRmVTMzBTangzMS84Szc0VFVKdHJIZndXbmN2M0g2MWt2MzhJTFFiR09wdG5ESm5Sa3R2ZnkrK2hVOGhkSms2SFVaM090b0UvclVoYnVkaHBzUjMydG1lNWZXd3g3K1grNCtzcWlRRHNDSGNBZWdCVnFLbGk3U0JmRE1ScEV6bDliZzR6VUtrRDBwUEdkNEc2QjMyYVJKNFRPOEFwRkM4eVJjRFI3K0lVQmxBN2ZKMEJxQ3gzVWxnMXpUUitYSlZ4RzBUS3ZUV2tIKzA4c0FUTjFwdzZWbHByWGdEeVNXaVZ2VGdyYkZuem5USnJxaExMSkdjWExJLy9zKzJscGZiNGt1RTRHQlFoQncrK0Jhc2doVkRsUVFoK2RFMEphTVJQTVJ4cjN6N1N3ckdhckdjQnp0OE1Rd0hqTWR0NklJb0E4OHdXVFE5RlJhRDVGRE10RFFJa1NrWkRnYThid2o4MnJJd0svZnYzek1kRjBUNGdpd1U3TG9xcnpPc1J3S3BaTlRVOGxwSk5FSlhLNGpHaVhjMEp6SDA3d0FrVWxFUVl5WjBNNDhJeHQ0UjNPWWZobkk1U1ZWd0ZLdEhySUZWZUtoUFRoVzQzRVRZU2xaVnZDN0xzc3gvRFNta1JWd2JrT2ZRbWlMR3BtOXZieG1RTXFscyt6b3BWYzBXSi8xNlZJb2xWcWkzanZFZC9RTnFZVC9YL1FZMUkxcjhiajJ4ZjhkSFFkNVVIUThYdi9mMjRIb2lYYmF2YTJOWG5adjh0bVp1blJ1RHBud3B5K3JiMjJOelJnaDgzR0M4Y3dBRkNuQk5PZ1NFN3Exd1hvUDlmWEJ1a3ZpTk9xZ08wQnJOYnpWdCtMVkVkOGl5QVdBUGdvUi8rbnU0SXdmM3JGZkc1eURtUlU3OGo4eXFRdzFCWDRGS0kyL1VjTVFUTUFwOGtIenpmTWhjSWR2TjFJSFFDcEx3Q0pkYTJHWmJpSksvWnlrUnUzbWlsY3NMSVREaS9WWEhEdDE2dGorQjgzbjNWcXBHSytxbjlPL2ptV2VXUDJHSGVpaGI2anNYRFNTMEV2aDhFS2g2UFVXNjg2cFQ1L3FyZFRQMGJxZWFWOVJkcXYvOTQ4WHRMbHd1SGhncGJ3MWRwNEVLN0xSRVRuTW1JWnp3eExISmZYOWJCRTFtWnZ2Vjd5Sjgwcml1Zk1obkJ2RUlCa0hxUVhkSDN4L2lVVTYrQ2tHWVJxRUtMNjNBTnlBdTVDb1FJS1hrQmN3V0V6WWRQVlF0QjhONlc2VVQ1eEs4TkV2cWR5WE9KVm1sVk1LKzBFa1NGaVUveElXNkNVQjBhRSsvdW8xYnlsYmUwSlJSWTZxKzZ6eUxjMVhsRU9oY2piZWJNYnhTemE0RTMrazhLYzZWN0duWjZ0MUxzS3lFYTVlbloyMnBuSXNJNk9BTDZPNlhISk5YcExNbjBMVXhGeWNyTk5FSXgwdmhQUS9lWUdvS2ZZTi91Mko5WWxZZkVFNkN0YndDRUQwK0Y0WDMrdkM2bWxwL0lMaWpuUXk4dWlqa1pPZmg4M0o4ekZBejlOM1RPam9KdlVlWHprSitXeFZmWHpEejNvN0ZreDBVdjh4VnFNTjlTRGtvWkVxaEdRN2ZHL1dNZDlaWXVsaXdUaURQT1MwQ294ampDQXh6QVphZjVGYVI5VHB0NTE3MjYrUkZYTUFWbGxmSDJ5dUkvZVp0dzNPdlExVnlESjZ4ZzMwVyt0RTd3Wkl0aFMxMERDOUpzNjJPRFFqcXJrOWt0OUN6RFJqY09xdVFWYnJKcHhUVzJJVmd3MWpvRUZIVFlzQlJYQVRyZEJMZElFQlBIeGhHNVh1dWJpRDZjUzVxOHAzM3Y0RDlBSDllNkhIUndUM1R3L094V0tncUh5RnF2N2tYbDBmbkh2MGRXdi9xYUtwSWZIVTVGZ0MyRFUyK0VTVGtxTmVNMDJINlZFdGJERGNPS09mQy8zam1mWHZxYmpVUmxBT0tTYUU1Rjl4OWJYL1ZHTHI2eVJ6R293MnhycFJmNzF5Zm9Td1BRTzQ1SVVSeW5iT0t1RnpCdGV3TlBTR0kxZWJEZFFIRzREYWkxUU45aTZCeTZmMFRVQ0NXU2VXZ0RVZDFqaWYxWXhISGpHMFowTUdnVEVmckc5c3ZQblpjUGhaL2ZqeExUcGFmeTByQzdpYU9WeGlqa1FhY0lZMEFZSzBUMU96NTZ2dmNHbHVEcFpMYzRQTmJNaU1hZ1RkWXhWaUpJUStFckllZjl6Q095TjROM0RmM01SOXN4ellUQUcwY240K2lQWEN3SzdWSlBPREtBbnUyRnhHNkF6QWF1VFVwc3JvRFVaRklibzV4NFRXN2x4aVZZMWVtR05pVExyTXhUK1RyS1N6eXZ5dktpcGErQzNWL2VlUU5uaitnNHB5dlJZZGx2c1QzSDV2STFZWFc4cWRLSFd5MEhYZnFtSVBUenM3YUpYZTJhYjUxWnVXL1NPVnp1eWlEV2hDaHp2NFBCWk1idm91ci84N0x3dysvaVdPdTFuUmh2aXZMcDVMTFVJRXFXaGdxNEpMQlR1TGdyRGxZT0pDRlhNVlBNSjlRK3BHMi9IUllRVi9OWTlQMDZBZUNWWjM2OTlOVmVKbWgyVkZ1bHJJd2pjNlhtcmhIVk10dWl3ajBuRTdrekhSWE1tZDRXazgwOHhtTFQ3TThKRklMT214SEJjMkZWVjdQUXBOcCsyaTJNTjVzSHRuV1JHeGhTdFprWWREbXMyajNHd0ppMEowc2VhbDBXUFo2UndkVG9hMFNsS1ZzWVNVQ091S09oenZoblg5WDYvcHk2bk15NkE2V1BmcDRUNVhJL3IrY2JRSGlpTDlJT2VQRmZoREI5SG9oeDVIUTcra242Yk5SUHR2NlhhcmcvK29kcnUzZEZ0UHQzN2N1YnJkdmhxeFYzZnd3VU1rVk5FaFl1bjA2WWxqVk50emZBLzh6Uy9uY3N2elFxL1Q2WFcrMUlIZERTVHEwQ3l4ZTdJbmpvUDUrZlo2WExnT0FlM3NOaXp1aTlIOGF6NVI1Y0FpQytqOGE3SWQwOW5OWnJ2ekQva3B5TjhoUXB2L044STdoclY3RFd5TGw4aUNRY3NSV2lUTVFTZXZzV2tzK0RldGpsZHYzTHF4VVozeWl1YnpVM3U5bE1vWFhuSGd2ZSt0dWNjYUMyeXYzKytocUxFcmV6YWFMcGJTc3JTcnV1ZjIyOGQ5ek05L2UrN2pITGZsTXZFdGZnQ3NiWWxYUVJPZTh4dXgxVFIvODc3RGgxdXJxM01yS3pldG1OM0Q5eDJlN1M0dTR1T1Z1ZGJFOTluQTQzMGVyTFVDRStSeEZ0dk5wdEZ1OC9CRWxyOC84ZFhlYUIyZXlQOC90OXBRVDM2ekUxdThBa0FROHpHbk9wNDFna0wvNEgySFRVTG02bXJyOEZBWGU3aEZDbDFjN000ZXZtOW9TN1JCZEhIRVdzN1huUGhkdU5sb2QzeXpxb1cxOWJXT2RHQ2YxTHozdmZmZWUyalhyWVpxM3JuU1cwUDl0VjVMMnI5ZldqaDBENzZ6cjgzc3ZHSnRQZmhPK0pqRkd1WGlXY2h0Z0xnSHNQUmxyOUJ4Q2hrRW5sTk53V3VDRVZkZ0JOLzVhWUV4OG1RRmRSUWFBeGFOUnFFeC9vbFc2TmplQnBzcGUxbDJhaUh2K0VlVlpNS0VPN25DRy8yNEVpRnJXNGdNbnNGekdwbzNHT0VHeENsaENVK3IrR0dVakRmaFVkeXF1bzFHdlBSMnM5UnNKa3NSdUlLL1dHZEM1clpZR1hpMnlGc01tVWtHd1RLRzZ5ckQyQmpUWkRiMkVuRXhoSTVIT05UMGhDYm0wQXFaRlFON0hIOEJ2akFNanJHMUVqTzRndWJDRkp2MXlobTJzYmVLdDA2OGtJdkI1VVN5d21hUnU1M2dUK0ZxUkVyeFJzT3R6alZMcG1PUjh5UjFQb1lYRWh4UGNKWlF4K3BFUE10RFo1NTdidlBNR1ozQWVOMTExOWRPbkxndGVkOWpqNzFJUGZaWW56b1B4OHQveG9meEdpY1NpWnpVSlRMN0hPYkpRZXBhNmxicUJQVUFmaHpXdStGOUhabm1FKzlZZ0dKcGQ3VEF2dCszUXNIL1MrQkdSS1pvZm5oVEFoTXErRURYdkRBTXRRalhQSUoxN1UxY0tYdHRsS0lsdWwyUHhvVTV3NVlVcmZEYWdxWklpc0R6amJ5WU9QTG1JOVY1TDlSc1p3Zi9HYUVocnFuR3lqeWowc25lM25vc0ZGTTFQcE5Vdm1LSHZMZ3E3U3B5WElKZjJjbG9jV2V2OVQ1OGl4ZTFaQ0VkTnVaMEdZdkZOTklkS2N3bTR0bXFZemtoMXcwNVZyV1V6SGFhTTRldXR4Y1BIbHhjV0VuYWZFeVg1SHlkRFRHWU1BaW1qdlNwY0Nxa3E0TElScDBiRGpLc0NqNnBzcEp6blhDU2lZU1RXVnBOMFdHUmp4VDFpbUxhWEhZc2h3Si9JM2ljQlJ3NzRPdjV2QnN6YTRKRlE5NTB0N0xnenlicS9NZmptbjV3V01YdTlucVVKZ2kvY1V4dWZvSk9la0lQSDhjakp3SDlJNGJ0UG9TdS94bkZyWTlpN0FQNUI0VEt6TXFOTno1KzQ3N0NpUU1IVGhTSzd4TmVsWDhWRjcvcDhSdHZYSmw5VStIQWlRT0Y0aDFiOHcxQk5JeVM0STB6RFFlZU42QUtSMzNuNGFrT3lUUDNaOTZPeFY1dnJlYzREK2R1aEJ6YlU3U0h6M3VMT3dMc1VQQm5VNGdsTU5YS2dVV0pWY0JpWWE0RmVrd3NBT1Bqd3VSMWxKVGI4czAzNDgzZ2IyQ0xrb08vZ1N1VDF3L0dZbTRzOXNzVDJ3QnpiWU5ncmlrVFh1bGpudytLd3ZPVjBTZGw0cmc4Y1F3VTRibDZHVE1RelBGTURsTTFQTWV5dWhrTnpqM1R2NEo2cnBzaHM1RGE4T0QwOE9BSWlneStqOUJ0NkpwclVBYi84QkUranh5SHcrTUlqbTl3YTJTbU12aGhjUENPWU0vck5ORm1zTFJPdjNYaUdCazY0c2c2UE11aElSYmtpei9HYmZZVW5zVzNTRFM3dkVZTHZyYUFPRXUzR20yaVV3UWdmV1lYOGpYODBHTTZXRWp2WlBBQU9vL0ZSVDh3RGkvZ21oV3FDTTFsYWlVemdnam1MeXJrTXRPRlpnTE9HR1RZY3p0TDRRWHJ6anV0WmdadkZzTEhkeG1KcFpyV2ZDYlJMRXhuOGpsQjlSK3JSR2ZkTEZrRjVPZ1YwM0NMTlJwaW5OTzVZak0yRXo5NmJXejZYZGNlamMvY2xxczJwby9WaXE1aDdWWnMwUC96WXl3VDZJczVYSytERUU4ZUU2d3h3dFpxTGJOK2xSd1RBa0V2NUZ2a1EwZHFBeURxVU1kbEJIRDNVRkVQVGN2TDFlUjhvaVFadUNycFlxYmlkWkw0S0tLV3NzMU1kVmsrOXE4SWlNU1hraDJ2a2lsdUhEdUduN2hwRjRKRnUrUktvN3I4QTdWcEdnc1JGMy82MmxaRUw5UngrcXkxWUZzTDZzR2o4S1FDdGVmcGVrR1BXRDkzK1VGMTRUYW9rNGptbXMydCtnTEEwd1hzemlZWjdBdWRMSW9JWHFTNXhCejV3UStPOUlUdmZPZnllYlQ2cm5jTk50NzFyblcyajhUK1U0UE54OFhVNDVQcjNNTDRlWGhxbVA1QzVVUWh0cmNRd2QvS2VSVGhJb1UwODRNaitCbFJFTDZEWEZ3U1BJZTY3N0padGovNGlZcmN4MVBpNDlTMnNvWjVrQ2RIaitBMGVBNU12WWkvMWUrZ3FJNHQ4UE1JZ0x0NHI0eWxLdHMvOGl3enY0UUMrS0dXNE45dGU3QmJRVU1NSXJKR1NIVGxzTW1pdG45ZGNDQVNMaVJvTFRUU2FBaFBaSUdiUHdBRHd6bFplU1FGQ1NQOG92K0F3T2hwQm44VUJKcmx1bEVJYU1xcGtpNnBuTXFIb250QVV3aGlTMXBrV0NFdGhnU2FFU0toUFh1VXFFampkMGhJVHp6UGNIdWlJVjROSG9mZ3A5RXVmbDZuNlluSGFkRlV1dDJRQVkrSHhDY1lVV0FqcW9yUFJGc3JYc0VwVUw1TTUwUXhSOHVjeWluY0ZVVTlLdUhicWhwaEJaSFJSWTRXQlpyVGlxVVFGcTBnN3BnT21lQzVJR1JpR0pBSmZuQ1VCODRRTWpFTWtSWGxrRDZSaDZBV2l6Z1BRYVE1Y1l5dkFQSnFuTHJjajhObkRQMXlDYklUbGd6RE5FZ0RyUVd1M1FHblJlQWxGaGxKNEFzOEdNSVh6Nm1IRVZuSHhjTWdRWDVyT0czUEVZSW9UaEFGUFRDYUNpVDJKMzduaVVWYW9HV1VLWlNQbGJIMEt1T3pSVHo5cDEyWDF0UmtrdWRRTXAzTlRlbGVyaGpIWjhtazZ0OExtOTNmNlpwNzZNTlNDcUtBS3lyZWE2RXAzNlMwLzhTdFI3dTBTTXQwS3F6cjRSUStFT251MFZ0L0xWZlJLN2xNaG1RVTB1aHltZGIwR0p4bE1xU01uTlB0T24rRmpxcTZtWkpVUllXOWVIQm80TXFOZUZTbDlsTEhxRFhxTlJCaHZna1ZKcGdHWlErTG5lREZERmo5ZFlLN2J1RXJ0aE9FQU1lU3ByQkFvb1Q3bUROd3NVbm1NWUYyQU9kU0dQSjQ3TjFGRS9VTkZ0WnAzS1ZoamV0TkdUcWtta3UvdEdTcUlUcUYwa2pUckxpTTRtYlJ6V3VvbU0zWk1TVnVoaldVZVZoYW9hOElhYVEyRU53NzlVNmY0MDdyWXkySDhQcXhoYVhkbjk2OXRDQWpDY1VPWG5rd2h2ZWY3ZjVLT0o5Tk9qdDNPc2xzWHMrN3JoM0QyVWYxRUozUDB5RmNtQkszOG01ZTF0VXIwUjR4WmVxcUNpM3c0NER2M2E3UDd4ZDJIRG02dEh2MzB0RWpPMlFFK1djeWtEMTZxTnNkcjVWdWtCaHBZWWlCMCt6Z3FRc1dpNk9XZzRmbXA1NzZWS3YxcWFmYTczakhPKzZmZWVDSmQ5L3g3TE4zUEh2bm5laitIMTk1NnZEMjU2TkV6dkVFeUNTTGgveUNKeFRBNG5JRG5tOURUbTJjeDlUVUV3L00zUDhEeUFibjlleTNUaDErN0xIRHA2NGNyWTM1ZVkxemNpYWVIejAxWVhNTFhxTTdSdjZ4L2xJTGZHNnNkZ2NXbldGNlJUNm9CVHF3QnJUTWp1OEk1SnZOTmRIVmpZYy84bkFUR2FJejVVaU52YlM3cDhaSnpwUXRHZDg4ZmRkZEJ5OS81Vy9HWXFJWUMwczZtdXRjY2ZWREQxMTl1STFFcDRJVDFObHltWi9ob3BKZGNjVEJuNTU0MTRtN0RseCtveEJ6Qk1NUUhObGczalRpa1Uvci9LVlFDdGJBWHF0Z3dVSlhGcjBFZlcrSllXazBIQk5mbXE1ZkZaeVk4S1kzTVlhTXlhTDgrSmREKzgydFBubkVmdDJQZURwRzQ4L0M2QU9JL0FFdWZuc2JLUFF2R29aeDIrSmdZL2ZuOG1ydWszazEvOW1jbXY5Q1hzbjF1N096M2RtRldxRlFLd0FXN3VBbnUzZERZcU9GRTMwQkozS0NCOXhaU0hsekFWSUdmcVlYbysrU3Fmc3BWRjBDUGJqZFdDd2I5N0JzWEtOdThhM0lhQitnQnI1NUszN3NQdkpKODkwL1lTcHZCMjc1Qk84RHJLSjhVS1NDRDgzbmtZOWtZT1ZOVEE5OVZWd2I5VElaMVFsclhudW1NSmZQcUx5TkRDMktKOGRTV0ZkRENFdzdFRzFLU0dLNG1DQWJUVHBFeTBvMXpMSnBQWXp3cEJ3eERKaUQ1V3RJVnNVd3JYTnkwcDNOenJXeWhybVdLV29hWGNrVzUzY3ZGcU1hVWcyVWlXUnRYV0RDS0FubVNLYUl4RENYdWN3SXkycVNOa0poRFY5a2tpZ3FxYk03a0NvaFdjdlVkODI1YmxtRWQzVE1rNWZOa1pkYnkwc2xmWXQvZnhUUEtlWmdSQ2o1QS9vTS9tUDhUaUg0MXNBQmdzaEN1d1NJdUZYR2c1azJIdkp4NGd6Q2VZajNYY0VTUVZva1B1NlJ0U00wUHRlMGJpbFhRSU0zcngxaFVhcDdNUE9uZTIvRENiaTl0d3JYbjl3UThUZitib0dnVkJ3N3NvYmw4VkpYMDJBUjlzaGE1bUEzaFg1ZnVIVXZkK3FZZU50ZTdpUTE4c0VFZW1GOHlGRFRzSGJjY3BvTStRN1ZNU2wxbmlnWjZndWRPaWF2M203V2VVQTZCVUo1cXczQkZYelVMUzh2ZkJOeHgwNEIyYnlHOThMZFYvRHkrNkZRaGVOT1hvOCtmZXJZa0I2Ris0TnZvdlZUeDNTUkVIdU14VlRmSjZLdlEzWFE5U2M1VHJuekZONE02enBhMXpTdzNNaER6UGFPMENsMG1zSXc2bDF6MityOEZ1UHJZWHkwWUlYNzkyNUlMNFFQNm90Z2V5eUtZRTNOZ3kyMTdrd1lXU3NLTVVwMlU5UDhtZjVxcjNabnVlMUYwcFVNMkV1SEFPMkw5bTJvSTBPRDVFSmlDNDBDOFIxcTRvRUFVK2sxaFYxSUNFZ2svcFJwRklSdWUzL0YzZ3ZVWEgrL2JtUnlVVUlTUDUxeXE5RlUxdExPdUt1clBiMVc4OXJsUktIcWlzZzFiWmpVaDBjNk1HRUxsbmtIejE5WDhBejJjaElGZDNXOGVra0Z5enZFZ0JRQldnWjB2RWFIeGdJRS9OcjQ1d1o3STlpeitGZWUyRU02TEs4VDBSeUU5VEtXdVJ0WVpzTi82T2l5cHV2YU1wSGJ4b2MzNm1DbVB6aXRIOFE3aUNuaXUxcjE5QTM5dUtqcFBNZVZXSTBwUzJpZFpEUDR3ZllNeUNHNlJ5ZTZzelBncWZVTVBqNnI2K2ZJcWY5M3pyLzB5MkhobENpZTRrVnhSZVQ1RlZoVkcvRUlSbTZiU2xORndxZjltRHZYVWpkaS9weVlSTWd3RzN4aklRL293andFdnZMS0FtOTN5R0ZaSjJjT2VCM0RqUUtjNGRtcWs2R2JsdGxvT1g3aXFQOG9IbTBoYlhuOGpNK2t2OU54dmZVaUQwdGNqTXp5ZUNLZzdZQkpBNC8vd2F6Z0tLNmZKbkpTR1Y5aVN4eUg4TUNpSC9WVEtGaGF4Nm4yWVg3aEp3VU5MckkyWm83UHVwc3hJKzZHZEtMd2VjaEs1SytCQkl3MitCM3lBQlBYUHlDRXhTNitoTmtEVm15WVY0NmZCSFdBRW9iOWU1R1E4Vm1jQjA1MWk3NUZmMjJBajNuSHF6SnRHRVhyWnBQbzdUb0I4M3hmWUQrUUVoYit2NGg0b3h5bmx6SnBQSmZGWTdsS1JxOGxkZkdoOVlmdU9xU2ZvWVg0UW9HZXNTMkU1MERoLzBtV3pQSGRJNzJISHVvZGZwQy9iVzI3RDVVSmlBSERsdXJ3V1BZbDYwdnpFUElLWEtpdFpvdUVQU0plTjk1d1pmNlZhTWEya2FqSVlaRTV2cjYyMXRQMzN2TEswM2MzbGNWZ21kNUV1OU40bGhFMlJlYWJhMGQ2YTZ0WEN5ZjJIWHpsS3c5ZTBWUVgxNE0xVkY4TzlPMENmRnk5ZlFSVmI1djJxVVRBRk1HZEpnQ045RFZCemUwK2R0NDRXYUdVR3lkOHphUlNhdVhGM1B4OERsRzUrWm9MWVo5ZXBHQ0x6SWswdjV1citTbm1jNkQzSGFYcVQyaXEyZ1RnWkY0bmFDZUxaeTU2SjhEKzNBanNGR0F0akVTWEhtcXJTaFAxR1U3V2lvRjB3NUdyZmtXR1BMa3lVRm1OU1UvNDlUcEtiZ3pPa3RwTTNQQ0p2dEtuWnAxUStJZm5YeHJHbUhhSmZqNkxlK1FjVlNlMlJGYUJDWXhSbUFKeDR0OUZGQUJlNExhY1JJVW9BY1JzQVpwRVJ5aDBDazdCdzROcExLSytVNDNFckY1RVBhQkdIcjVETzZBOTZYekhDYjh6Zkt1MlE5SGtPeFZOUVVmQ2crK3BrWWlLQ21FVDlpYitwdzErRmVVSGY0NC9UOFlQL0gvQmZIQklXNEJ5QVN1QUZ5RE54elhBVjVtbVZ3RGZwMmFuSUp6dFhZZ2VWbE8weTdYZEZ5WkVHM3dwS0gycjNpOEpNa2VCU0VPVzF5R3JLZ3RWWEw3Z3RMRHMwNWZOb2pkVjNkaTRlYUd1STZONHplSjczM3ZnRlQwM3U4dUlJbERaNFJIL2lPRHNuQzN0dWYzMlBkWHRPcjl0T1cvSmJtc21XM0FXd2o2NnczWVVCMitNdTBBZ1RXRE5HTkFlbmg2Q09SejhpWSs1b1BzZ0Q1TlFEcjBBZUVFVUFXNWg4TzJ6WjBmalJwZmdLNUYxWk1DL3ZGQXB6Z1RLdyttdDVRVDREcWZkdFMwbGpBRWVSdXZmWGVLanZTMG0wRHdLNHJlT1l3TDVNWDBtWWdKTms3QStQL3JSUkQ3Q1JFeWdac3RIRzNBRUVoTklKeUdGRlAvNWovM29tbXRJVkNDeVR0TkZIME5kekYyL3o0M3RWUUs3RVBCWUg4YTJCemUwRllUYlRiQWNoT1djcVBZOXpiYkMveWdMM3hNVUZXK2srVHZ1dUtiYlJkMm85Z1hOc3ZBbStyMHZDSklrZkVGUWxIZTNObHF2eXUzTmpXSzIrT1ZHenkrVDYxamVSUDRvZGNjZGsxbGVqek9pQXRyeC84QS9PTzBqZWdFRUpObDBnaE84eHgzTks3U1FQVDJ0ZVY1RlM2YzE5d2pZdU5qdlBIQmdKK3J1ZkdxbjNPNjN2eVY3eHoxNTVqNUZ0cnUybkRwNDVlTEdZbThZRTdxUFhIaERvZmFGMWs3ODJOLzVkNGQyZWh0RVQ1WW5hQWlXSDMvR3Q3QUhEZmN1QlBXRGxXUmkzZVlWK0FCTmRna1ZBbWlyZXc3MmVnY3JxcHh3dTEwM0lhdVZKWlA3RUdlMk9KbVc3SkJncjl0Q3lKWis3b082L2tISGxlVGtMSXRGTzVlZFRjcVMrMDk3c3RrOWYwa3JoaXc2SlpZdE9hSnNLSUhOM1pDdVM2SHFZalM4UkttNC9wSFJkMVlodGx3cFhOb1VubE8xc1N5NUIwdVNWMVBYVXpkVHQxTjNVNjhhV2tUV2ZkUmhDK0lyZWtRcldBQTFvQVZncWMwQ2dVOFZuSUlQclFyYmxnVzNteVNTVXdzdUZKcSsydEFqRVJwdG9peHNFNXpXTm1NN0VNbUJaSElXVEMzaEp4NUdjcUpjY3VSY1JDL0dZa1V2SWFNcmI2R2xkS2JDM0h3elU4bkhKUTNKMlR6YzB5TTUyU201cm93TzMwTEx5ZHdvUmJuU2RQVFVoMXRsdlJqZVYybkd3K2xubTVWWWFnaDhkdXIxVjFiTHZFYnorUmxPdW9LbmRab3ZWMXNGTVZMYm8rK3BHVUtoVlMwTE5NNlR2MExpWnZJOEhVRml1VnIzeGdtdXFLaXhoclJIclVocWJmQ2RpcHFveVYyMUVwSWFZUEV3NG5FTXo3RUtWSVdnYS9zY3ZoSkxvemRRdDJGcDlIN3FFZXJrVmk1SGlLUlF6eE13Z0tqdEZGcHRYOWZhN2xobEVwd1JHQWJLUllqTjZGaEVzZGpDdjZiRmt4c09VVHd5Uk4rSWo1ditJN3pBOEJaNXdsZEZrbFRsRWNOQkV1czl0SFprcjBqdlR5UnlsdTFlYmhheW40ZzdtbDNIUWxzaVZXTCtuUlppaGFPMEdNc2ZGdWo5aFVMQmpHWHJ0cFl5aTIrMndoa2ovMm1SUHNxVVVuZTZ0cG0vVWJrT0g0Wng0blNKYVJpWnNOVVlCVGQvR0F1RkQvWHdURFdhbmR1UGJwZjNjTFRRVmE2bDB5Rmh6bGJmVjgyTDRibWQ5U1JQNzlmbnNuaDdaYksrbjE1VnVoeDl0VDBuS2tWMDBLcEtjdUdmODlXZGMyR1c1dmJJaUo4dDR1TjdxbmxCbjl2NWlDeFZyWkNQYjc2QnYyRWJSQThLbUVudm9YNWhZZzJzTTBRY2FqZDhsQTlqbTgwTzF3Ynp6d1d5Y0wxdFV5RFlLVHdveXJadndIRFVoUGlzOXZiTkVtcUNlc0tERnByY0VNU3BibmR0ZlEyc1lEYXJKNnBZQXNxODVmanh0eHcvY2ZMbzBaTkhFVXdHdURnYjUwV0ZWYkI0cTRSREdzdHpZVTAzRkpabnRWQllEb2NraFpVRkljYkZHWjVqWTJ4TUVDUld3b25sc0NFeEFxc1l1aWx4SkxFU2xoV2NXT0xqN0c5OERJVjNIT3RoV2ZuWWpucnI4T0ZXQXYrREJhcVR4NEdBUHprS0JOeHFLRUlvSXFpaUxvdThxSW1XYU1wc2lBNXhJWjRQMFl4S3E2eHNpcFlVRWpsUk1rUlZrRTFCTVhCNlF4STRnYVJYR0lWV0dIcnJBNkltOEtJYUZ0WE94ejdtajhzL1JMK04zazZwVkFsc0ZQRmtBd1k3M0kxeFN4VkJoeE5HZFI3R3dqWWUvUEt0OGdwcU94M3V0Vk03SmUzSzlGVnF2b3F1cWhvZllQZ0dPQjB0bE1Ha2Y1Y1kvc3pneFUvdW5PMkd1SWdUS25xTC8xSzFQNk5KT3dHSkFKVWJzSHhWNTVnUGZIMklBd00yeitCWkRsLzREZ0lUR3NjVHVMR1dmODFGMFowZmYvNlpEei80SURxMFZHd1VNbUhVZHdmL29LNXZQUFBNZ3crYWUzUHhRaUVlcmtjbWJHWU5nbnphd2lNcnJGdngvcUtWdisrMGJZL1VFaTc0Kzg0eUtvOW04YjdGVUNlSTRFT2dvM3gwNm1XNmtVSG9JVTZIeVI1bXU4eExQQ09IWTQzZjAyUUdIOHVTeURHaXdPaWMxSkQ4T1h0dERYZXh0VitWUWh3cmN0R2FsZWQ1VG1TNWtFU0g1M2ZPaHo4UlpoSE5DQ29EL1lkbVExTFlZS1FRUHVKNGhsSEJtWUlOcDR3LzltZnVmd1ZacmEvZEdNSmRLNjd5Z2dCSnc2WVozbXF2cStDNmcxMjlrRVVyeUhNWXdXTTRyeUFVa3NocmVwdGY4SDdoRjd3dmJGWi8vZGVyYURGNUtsbnA5LytQbzlPb2Y5bmY5bnAvZTFkdmNHNTFGZW5uRmhkUmJQQjNxemVPc1hvZ2J4clAxY0xFK2luSXRxbWdacWY1VzlQVDAwR0dPTGRLOHRUR2pUZHVEbk9DZkJZbjJrVWcySS9GQVBQSG4ydm1CUWZNaHFySUR1d05QUWdFUm1CSGVhZEJRaFdCUFB1VzU5NkMvelp2YUxYNXV2dEI1enJEVy9TOHhXL2NzTGR0S0kzazFiSGZPSFJ2NkFFM2hOWkp3bGZzdnpVN05WWDdCcVR4OXUyL1M3eVZuM3V5OGpmM0hpcGwwdVdZTmNremdYTHhsMklmbG1JRElEZlFHUEFCc0htOVJkd21tdkFGZ0NoTHdoQy8zTEc5VnVCT1RHN2liekdBZUgyWVVQV3Z6QjFYbWpKK2c4VlhodHdQTWVBTTh4MHRmUFZ5ZFo4aDYzY25Ic0h6dlhMN1ZoZUZWRFdFZFBucmJwMy9CS0gwWHNNOGNpckNnblBPWjYxWU9TMlpwaVQ5UFBka3FMcm50bHJGZG41OTloeWFNa0sxYVNPUk1HeDdLZ3ZyKzBFOTRtUk8yUWpza0s2bmJxWHVndDRQQWd4eHZvV2xxYVhBWndiY0ZTMS9oV29GK2VqdHZvY0l4SkZ0K2N0WVlVUVV3Y1IyZ2VpQ3l5UWZxNE0vZmR1d1Z0QUpRVFN2dFVUSnVzWVVSZk1hU3hLdDYwN1FZbGFrNmNyUExHZnhwNXdXWElHNU8zTUZJMlJGaHZZZXdKTjBQRmlJVE54ajFGdkxEQ3RrUk9hVkdaYjA4Y0Zma2Rmbng2eDRqY2lGRnZFUXByVTFUdXhKbk5hRzhXelJheU9hc3ptYVRpeFBXVFk0dGxvY3crUXE1ajB0eE9CamhCSjZ3bUhCS1plT0pOQlZ5d21HR1NiNVBmSWVuU1l2bGE5L0NQZ240L2NtUy9EajJsU1B1Z2w4eVRzUUNzWHoyUVdEUjRlc01uY0FQSXN3Rkg5KytIbEVEQi9hK0hqMEdRczRTUGlGK1UvNFRCSjU3U3dTV3FRTnZNNy94U3huUFpvUjhRYUxSTGN5Z3J1ZnZyVkNZN2FaRlk5aHZJaUkrY084T3BPeC9kSGtmc0c4RGpnNzV2RzFwbmlFWmNxM01tSm1LWk01emFEV2xKVkFpTE4yMGpSckx6ZWgxa2thdFZjU21FVzJuc1QzRWdwUDg0akJIZXVmQ1F2ZWVvM0lFaGFITUl1bG5vaFpyQUdMUTV6TE1Bay9DMlNhRTdIcWRNeW5CT2pzNWlFOGVuMEZGVHc4dC9hYXBSd2VGVXJSWE5SQmhUdnZFR3BzcTgydHNhOWpuMk4vTVBnSzZoYysvR0dVeWd5ZXo3enhtdit2dGF1SmtlTzR6bDNWZjlYLy85MHowL08zODlmN081eWQzcG1teEIrTmxUVkZXcUpFUTQ2MEFXVm1JY1Uyd2NRR0FZZTJwUVFSS1FrQkl1ZWcrR0FKaUJFd2dZTWNFZ1NFRDVZTkd6WVBCb0xjZUxDRElMRVJJZ2dRMzB3RE9lUVFMUE5lZGMvdVVnRjlpUnZUTXowMTFXL3E1M1hWZTFYdmZhL1pmSDdWY1JiVGZQdkZnODl2YmRYSTVZTy9IandTRHcvWHpHTm9mNUhUTFBwSnJzSUprOUVKMHU4UWhHeEVja0w4UzZEK3VuUWQ1QVpwb3I3NmVaSWp2ZDMvMmM2bkM4ZFpmYjY1WEY5RFhmVVVTTmhDMElNZW9TVStYUFZCU2lDSE1oN0JHWHFLRkJ0aytVRks3MTJRUWFhSldxNTZRMGtpUEN0ME5BeCtzc1JnMy9tbkZ3WXJicS9uNHJreWVHRTdrMmZwVGh5NW54T3Z1ZTZYNkZmY0tNbGJ1Wnh0RjdsV1pGdTlyN0szLzFDOXNUTE9DaTB2dmptRmc5eE1hMVBEYzUwSm5PbTBscksrR3Zqcmx1TjZFempwMEEvVVBuUE5qMm10bGppWlRNeGVDOFRoR3cyOHZISGtjNEQxSGVMcStHTUttaCt2enJ1OERNT1RlbFdHYnhhNWZuSzQxWHRYZmZ2T3hDci9JSVUvTUc3d3Y2VVQ0WkcrUXIrWk9tSnVMcnYvQktsNml6UElVK1I0My8rZWhWMTJ4MzcxTldVaXptY0t1WDNFQVI5K2ZacS8zMnhleklBM0tqK3hrbjVZVVNkRlJiYVBaUHRaU2RpVGZtbjlqVEtiaXhQbHRWZnRPMUpKa2pqVHJ3TVBaTStuemZmenl0Nml0SDF6UVA5NlJ2Z3NZcGVVb0ErWnl2ZXNadkIwb3drV3JudkNBOTQ3d2xSK05CdHFoOXVJdy9rUjFzQklrSlhoQmRMQWhWcVVYMjVQUEs5ajJGTHM1UFdXKzNxbnhweGF2WGFRZDVwUnROcTMvREJvZFRLMXMzYTZuWHBCVnE4bGdkdnFOUFJ1YjNzUWRQdEp2VEg0emQyUEZRTm50TEZUYjMvNjQyVHZSK3R4U050U1BYM3FKejk1bTUxVjJxTWZzMFk4YWlhUlk1cGUxTEJ0cDJ1bnRhd2RKclp1Tk56WXRveXU3cm9MTDdDZHdPNmVHNStPbm9wR2JtajBkamVmWE5vWmxtMWo4aFcxNCsxUS9PcmEzVG1zMEdPS2UvV3dqSTh2Z0hnWVY4VXBOZkdQeE1uS2cxbGZ4UWk0TXdTZUxMaG5WK215Y3NCZGdYNTZjbjM5Skp4L2VtNzk1RHJaOSsySEFpWVRlSDhvM04zZHZicy9uKy9EY2VSL2VKTjhBK2JKendsQ2pPRG11TTdRSWZFVXBGdDQ0aUVCUkQ0WUZpQnB6aU1ibGZHeE1DZDhoVXdkdml5QWx2NGpqdDRZdFVuWkl1am1BVHpCMTJsbVBBUVFiajlpcS8yanoyWk10UTFLTXlLU2IxQUtyejhYNmFvZndqeldTSng0emZQK29ueDF0eklwa21tdGVTSVk5QWRaNzFsSklxRXNiNjRGL2RYdStyQXJkMlVxcTVRbWhMeEM2ZmNrY29YU0swVDZua2hxekRBL2xPVVA2NmxSMDhNZmhQcHY2L0RDaXl0LzBLdkxrbWUzMFBzK21hWTVrYVFrMWtBN0NldHA5MUY3SkJ1ZWo0dkNOZFFHbHF3L09rUXhVQ3BrbEhueGlMZHlYK2xuMWRad0NTL01JNzZVc1dEbXVGa2NKMktGcDhEcDhkY1NSUWRhOEd1V3B1dWFaZnVhOXJlV3B2bVdvOEh4UnoxRk14MnZyZ1ZlUTI0T0ZuTERDNnpJYzB4TjZZR3FZVzN1eHF0clVhM1h0Q3hMZkhxOVlZYjIrcFNxTFlVMTVKb2FhUFcxNFV2MFUzOXBPVENXV2cwL05DM0xIalFzMjRPckw0NmVYRTlha09hTGpFcG9COGxrMXd6OVZySithbWpYczdaMFFsRThGMlR6ZG5id2kvRE1JREZGS25KM1ppMGVuZzM4cXMxVWJoTTVBc25ya3lBekNJVU44d29IbTZtTTR2dmNVSmxILzJsUkh2VTA3eFhBTFB5UmtzczRxS0RBaHFpSG5LR2xpK2M4UHdzekVBSVg5ZmpvUGR1NUZUV2R1S2VJby9UTmZiL1pDSHBSa0s0dytTcm9HNTZIQ0NTU0dtUnY3by96OFRZbXd3d1BOMFFydDN5ZGVmOGdkYU1OTVd0Yk5sa3QzRllVSVpwRHczK2kwOVBvNng3bTJMZFdrNW5iV0xIaFdKbXZkRFhRMFhyMWtkai9QdEQyUFk2ejQxR0JmRUY0WC9ncjRlK0Vid25meFRYcXlqYVFkMnFsVVZVaFFybE9SZmxQaUdDWDRTcUtncm9YejJlWDlvVUZRckp3bkl0bDJqeFAybUllbDNneUpaUk1nbVFLanZHVXhBcTNrcWVsTldFWkJiVzhTclpqZVo3WktHWHhWSlM4OERxSk1SV29RYUhtVktDV0xvSndaQ2hoYjZScVRnMFU0eFZON2lweUVOZFVTc3lRaXBRcHhOY0R6UWJ0eTFia1VJN2NscTZ3MUdoMUZOMjFUNnM3YmRVNzNiMTBaVFJVNU1TNzhLeUJOcWFpcXR0SzNONDExYmk0K2ltYVRoUXg5YVVvc1VSS05VV0pGUllSb2h1U3h5U3FXeTBaOURvb2llNmVIdm9IdjAra2VJTVExM0RqcThDRlVRanNHSDFTaVlqa1h3eFV1RS8rTXJNeHVwOWtoWlpxR0xIcHlaSVZOSzNhb0o1WWprUVZCUU1zU2s0a3JnZE5SWGUwc0tNcVJFbkhUdEpvZVNwVHJEZ08yM0luOVZhM0cwUGI5L3FkeEd1TExjVFprR0JzMFpMTm1wN09OamE5WmxjbWhpN1hpUzdiS2xOenhxYUVObU1peTFSTTYyc056RStrVGhvMXpDM0ZWb2UrRFkzbTdhT1lmVEtRcGJCR0l5YjVsaDY2RGlHSFBxeW8zMzlHK0xGd1gvZ1A0ZWN3dTJ6M2NBZTNDaDZHb0NaY3FIWklXR0lHSlpPb05KUEorVk1qVHMrV2thZW5PUHZ1eklxZCtjNVpxVGhiS2llekhhNjE4TUdrai9aL1kxSkd6cTFVczdneVQ4Wmhwa1A0aU5YallhMmpVcjJEWWFnYWlIckxxR1k5cFl4Nm5jMTZTenlITStRUURvWkRSNVc0VWh3U0p1NXhROWdwR3I3aUR2NFV6Z2ZGT1JVYU4vU3BaRkpHMjg0YTY1b21kVzNOTUlrb0VVUlFxYkhRbG1wbXJRYW5aRWRxRGRJUStFQ2tpbXpJdGt2STJGOXoybFNqcGt4ZHd4S0pldTcxZDdJaDVMRWxKcGtlb1NIVnFjSGtnVHR5RkNNVlpRVjBJaER6UFdBVmtkaWFZeGppY0hlSW1XemRoaVJSOFJCSENJRWV4TlJRbk13WlNLb0Z2d2VVZUNhVEZJTlFObnozNlVReGxXQWF3UHRYdW9zdW9wWHJmVmtscGdhc1l1bjFqT2tJOGdDTUp3S3hFTmxmbzc3Q21PSlRUU1JRUTRWeVEzV3NKenhDa3BmVmRVdERjQ0NpU0gxOS9nbDNhK1BKV0FQdWM0MVF3NExKRXZGN05oVGEwSDJNVFVzYzBTU0VLb3ltS1dHZ3d4Rmlpc0JTb0NiNXV1NFE2dlI4NEhoc1NSWVphUEpyZWFjMlB1QUZ4M0szUVZpZEhQcVBJUDk5UWZpUzhCWmFRdzkvL1N3dy94VWN0OXlhNWdZTFBXNjdNRjBHZXlQM2Y0M2RsajJXTnc3KzA5WTBXOXM3N05Ya2FWYW0vTDlhZSt0eG5mZ3ZkbWpiNFdMWkY4bU1mei9tWjE5NjJkYzVwb1hhVjBHYVE5eGdOSnZQY2U4WXczOTMwUjF2c2RnbjF3L3VYVnJzZHllM0p5RFZQN2krV0pESm5Yc0hEeGFMUzdmZ09OSkRTcnBXaGJkUlVlVzd2bkF1cWQwN1R1WjJSZUJvZlNzWHptTU05Z0FHcEpoN2JwWEMvM0s5SkZuMkxYQ0FYQW1OT0ZkWEFTRnd0U1E1VkJBcW4yc1Y3YSsvUlZVVkYwWnh0VEQwR3pBRk9GUm1ZcGZxQlBUN2hrYmFBeU1CU1FOMC9aaVFTR1c2OXRZSFR4UXBrNE16bHJreHVYaXlLTzUvKzlhdHkwWCt4bXFYak9UUWhRZEpBWHBLR0hpV0pGT1BBdlA0UktaS3FEa3d3amd3Z0xpdUtVdXRWajFTWHlpSzUzWTJMZnVKUU1KSjgrSnp4Y3R2ZnZ2Tk5Mc3hPMzM1T0I2SEtTeXFWYmxseWVWNXhlN2xBaElYN1hoMDRXd0hVeEYvUWtFcm5iWU03UVB0OUNkSHBiekFZSDZqWFpISlVGdUpnZkNGYTZRZ1BXRmpTSnJPY0dhTFJaR1pycGNZZ3piUkd1VDJZYkgrUGxTb0REV0NvY1NqTU50NVFhakEzVkJyNG9heW9VYjFWa3VTVFRUbWtSMUpKSTV3VEYrczhZaEthQkd2SG9PVXdOQnNXUTc2UTU5YjRvSUdDY3lSTE9PYlFaWWlCemFaWEhEMjlpN3Q3ZG1mbUZ5L2RQMzZLZXUxalRmZTJIak5PclViN3UxTjl2YWkzeUMzNzAwNjNtUi9mK0oxSnZkKzlyUDd0ZTg4ZVBDZG1yczVjUGYzM2VIR1VnZGZsdVh4SmZtL2YvZFIybFZNallmM1FKKy93L2R3VjRTNXNDdDhIUFRYMzhKNEZJL2E1aXJUZVJHcVVZbWpqcmpsb1R4VDFMNU4wRmQxbEVWVmpNNHpCRVlpK0lMK1h2bGM3ZWRGZ2hOd3J3UXU0alpHLzg2M1FuNzMyb1VMMXk3ODhKMVhDSHY1clpkaEFLaWxXMVN1ZCtzeTNVcWx4bkEySDdaMi9uaWVqa1Z6WVlyalozM3lQbVB1aTlkZWRCbDc2WjJYeUtTTVoxRWYxT3VEejQ0YUsrcURkRGhNSDRpaHhob0hseHdGRjY4VjV4TFRiZHY0OHVVZ3VPd29yWmJ5M1ltcjYyR3RGdXFncytJTjVUaGV0b0VvTklSQ2VCYlUxWjF1U0xHZVlmVm9WdHZGc3lqTXB2aU8vaWo0TnNaZ25Id0FIODFRblVlc2V6N1dIMVdYTEs2ODg1SmxqenZVdHRFR2RhdmQrdURwSzVUSXJmWlliSGFiNHJqZFlpZkcvOHFZdDdaK2RYM05xNnAzOCtiQlB3K2FOMEhyOWtIcU1VM0xWend2dXRuOHIwR1RTYlltNzBlZXB6aHg3R0R5UGtOczc1L1hzSEltSEZpOVduT3d4TXQ5ZUJmazY3dkNGTzB1Q1E2QzNJZmpPTnR3TUhUY0NzdjRFTm5ISGE0cTFtWlJtcnZqbkhMOXZkWFBXS2MzejUrZm5EKy9kY3FLQnl1RDhlcDc1emJnMHh2bDYxMUYrL1M1UCtPR1NlVHVlOC85VHJONTRobTJNMTRzeGp2c21SUE5KdWJmZXU2OTFYWE1QMGhrOXNyQmY1Y2huTENNditEMlN4alRRQWpVNUNrWTgzSXg2eER1SmRUZkhxRkZSckFTUUJIalpQcTFxMFkyb3ZaUGJUcktqS3ZNU25yNUYyOTNFUXZXWFhSdmg1c2I1RnFuSzhtamg4TERrU3gxT3daejZMbkpIanY0TjdMQzlpWWN3L0xJUjhERTUraUllRUh1SGljVmtYMjQ4VDdwOGh0WC94Y3BaK2ZoQUFBQWVOcDlqejFPdzBBUWhaL3pweUFobENOc1FSRUtiOWFXSzNkSlVFU0t0T2tkdkU0c0pYWmtieFNsb3dTdWdzUUpPQU9jZ1pZVDBNR3pzeUJCRWE5MjU1czM0emU3QUM3d0RBZkg3eHFQbGgxMDhXNjVnUTQrTFRkeDZVd3R0OUIxN2l5MzBYT2VMSGVvdjdMVGFaMHh1Ni8vcXRoQkQyK1dHempIaCtVbWJ2Qmx1VVdmekhJYndubXczS0grZ2pFS2FFUXdQR01JTEhEZ09TUkgySkJHckVmTTFxeFhsVDFTOXE1SUUrVEl5RlVzc0dSZHdJZUVZdXl6dzNCdEVXTEFsZGplNUxkWG9tUW1xV3JxVjhDNDBKSFJzVmdjeERDT05tSlVSUEZhSDhRK05Tc3h5VE16eVl1bEZyNVVvcjh5WmhzT0JnblZwRkpsbWNoTUc3cE02MEVwYnV0WVVzaXo5RGJQU0xQNmhTbDJmQmRtT2s1M2pLY2VFWEwvOXp1cUFWeDQ3SE81RlNtZzBaOGJodUpuTGpGd1BkLzFsUmVjdk42Y3N3dEthVjBTOUsyY1pSMnIyMkN1aXpMTk02R1VKNVZTNHBUYk54RDRjS0lBZU5wdGwyTzBuZWNXUnJQV2FwdmFTdDNVem43WHMxVnYxcmFORkNsVDIwaFMyN2J0MUxadDI4YTl0elAvYm43MEcrT003RytlblQ1anpyRUcrSUQvL2ZsNzlJQkJBLzdQSDMvblAvK3hBVzV1WVdQWjJEYU9EYlJ4YlR3YjN5YXdDVzBpbTlnbXNVbHRNcHZjcHJBcGJTcWIycWF4YVcyUVRXZlQyd3cybzgxa005c3NOcXNOdHRsc2RwdkQ1clM1Ykc2YngrYTErV3grVzhBV3RJVnNpRldzV0pxc2FqV3JXOE9hdHJBdFlvdmFZcmE0TFdGTFdzdmExckd1OWF4dlM5blN0b3d0YTh2WjhyYUNyV2dyMmNxMmlxMXFxOW5xdG9hdGFXdloycmFPcld2cjJmcTJnVzFvRzluR3RvbHRhcHZaNXJhRmJXbGIyZFkyMUxheGJXMDcyOTZHMlE2Mm8rMWtPOXN1dHFzTnQ5MXNkOXZEOXJTOWJHL2J4L2ExL1d4L084QU90SVBzWUR2RURyWEQ3SEE3d282MG8reG9HMkVqYlpRZFk4ZmFjWGE4bldBbjJrbDJzcDFpcDlwcGRycWRZV2ZhV1hhMm5XUG4ybmwydmwxZ0Y5cEZkckZkWXBmYVpYYTVYV0ZYMmxWMnRWMWoxOXAxZHIzZFlEZmFUWGF6M1dLMzJtMTJ1OTFoZDlwZGRyZmRZNlB0WHJ2UDdyY0g3RUY3eUI2MlIreFJlOHdldHlmc1NYdktuclpuN0ZsN3pwNjNGK3hGZThsZXRsZnNWWHZOWHJjMzdFMTd5OTYyZCt4ZGU4L2V0dy9zUS92SVByWlA3RlA3ekQ2M0wreEwrOHErdG0vc1cvdk92cmNmN0VmN3lYNjJYK3hYKzgxK3R6L3NUL3ZML3ZiLy91OTNEeC9MeC9aeGZLQ1A2K1A1K0Q2QlQrZ1QrY1EraVUvcWsvbmtQb1ZQNlZQNTFENk5UK3VEZkRxZjNtZndHWDBtbjlsbjhWbDlzTS9tcy9zY1BxZlA1WFA3UEQ2dnorZnord0srb0Mva1E3eml4ZFBsVmE5NTNSdmU5SVY5RVYvVUYvUEZmUWxmMGx2ZTlvNTN2ZWQ5WDhxWDltVjhXVi9PbC9jVmZFVmZ5VmYyVlh4Vlg4MVg5elY4VFYvTDEvWjFmRjFmejlmM0RYeEQzOGczOWsxOFU5L01OL2N0ZkV2ZnlyZjJvYjZOYit2YitmWSt6SGZ3SFgwbjM5bDM4VjE5dU8vbXUvc2V2cWZ2NVh2N1ByNnY3K2Y3K3dGK29CL2tCL3NoZnFnZjVvZjdFWDZrSCtWSCt3Z2Y2YVA4R0QvV2ovUGovUVEvMFUveWsvMFVQOVZQODlQOUREL1R6L0t6L1J3LzE4L3o4LzBDdjlBdjhvdjlFci9VTC9QTC9RcS8wcS95cS8wYXY5YXY4K3Y5QnIvUmIvS2IvUmEvMVcvejIvME92OVB2OHJ2OUhoL3Q5L3A5ZnI4LzRBLzZRLzZ3UCtLUCttUCt1RC9oVC9wVC9yUS80OC82Yy82OHYrQXYra3Yrc3IvaXIvcHIvcnEvNFcvNlcvNjJ2K1B2K252K3ZuL2dIL3BIL3JGLzRwLzZaLzY1ZitGZitsZit0WC9qMy9wMy9yMy80RC82VC82ei8rSy8rbS8rdS8vaGYvcGYvbmNNQ0F1UGlMRmk3QmduQnNhNE1WNk1IeFBFaERGUlRCeVR4S1F4V1V3ZVU4U1VNVlZNSGRQRXRERW9wb3ZwWTRhWU1XYUttV09XbURVR3gyd3hlOHdSYzhaY01YZk1FL1BHZkRGL0xCQUx4a0l4SkNwUklrTlJqVnJVb3hITldEZ1dpVVZqc1ZnOGxvZ2xveFh0NkVRM2V0R1BwV0xwV0NhV2plVmkrVmdoVm95Vll1VllKVmFOMVdMMVdDUFdqTFZpN1ZnbjFvMzFZdjNZSURhTWpXTGoyQ1EyamMxaTg5Z2l0b3l0WXVzWUd0dkV0ckZkYkIvRFlvZllNWGFLbldPWDJEV0d4MjZ4ZSt3UmU4WmVzWGZzRS92R2ZyRi9IQkFIeGtGeGNCd1NoOFpoY1hnY0VVZkdVWEYwaklpUk1TcU9pV1BqdURnK1RvZ1Q0NlE0T1U2SlUrTzBPRDNPaURQanJEZzd6b2x6NDd3NFB5NklDK09pdURndWlVdmpzcmc4cm9ncjQ2cTRPcTZKYStPNnVENXVpQnZqcHJnNWJvbGI0N2E0UGU2SU8rT3V1RHZ1aWRGeGI5d1g5OGNEOFdBOEZBL0hJL0ZvUEJhUHh4UHhaRHdWVDhjejhXdzhGOC9IQy9GaXZCUXZ4eXZ4YXJ3V3I4Y2I4V2E4TlhENHNLSDl5cEFoUENzOEM4L2tLWjVWbmpXZWRaNE5uazJlTFo1dG5oMmVYWjQ5bnYxL254WDRGZmdWK0JYNEZmZ1YrQlg0RmZnVitCWDRGZmdWK0JYNEZmZ1YrQlg0Qlg2QlgrQVgrQVYrZ1YvZ0YvZ0Zmb0ZmNEJmNEJYNkJYK0FYK0FrLzRTZjhoSi93RTM3Q1QvZ0pOK0VtbklTVGNBUkhjQVJIY0FSSHZGZDhML0YrOFg3eHZmcjh2TS9QKzJOK3p2ZnQ4M3YwK1QzNi8vNGVoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZoYjBWOWxiWVcyRnZKZUd6dThMdVNzSlArT3l3c01QQ0RnczdMT3l3c01QQ0RnczdMSUl2K095eXNNdkNMZ3U3TE95eUNMN2dDNzdnVitGWDRWZmhWK0ZYNFZmaFYrRlg0VmZoVitGWDRWZmhWK0ZYNFZmaFYrSFg0TmZnMStEWDROZmcxK0RYNE5mZzErRFg0TmZnMStEWDROZmcxK0RYNE5maDErSFg0ZGZoMStIWDRkZmgxK0hYNGRmaDErSFg0ZGZoMStFM2VVK1Q5elI1VDVQM05IbFBrL2MwZVUrVDl6VEh2SWZ2MGVSN3RQZ2VMYjVIaSsvUjRudTArQjR0K0MzNExmZ3QrQzM0TGZndCtDMzRMZmd0K0MzNGJmaHQrRzM0YmZodCtHMzRiZmh0K0czNGJmaHQrRzA0YlRnZE9CMDRIVGdkT0IwNEhUZ2QzdC9odlIzZTIrWHpYVDdmNWZOZFB0L2xjMTErcnk2ZjcvTDllL3dlUFQ3WDQzTTkvbDZQZjdjZS8yNTkvbjZmdjlmbjkrdno3OUNIMTRmWEgvTzVmM21KL3hQL0o1NVBQSjk0UHZGNjR1L0UzNG0vRTM4bi9rNzhuZmc3OFhmaTc4VGZpYjhUYnlYZVNyeVZlQ3Z4VnVLdHhGdUp0eEp2SmQ1S3ZKVjRLL0ZXNHEzRVc0bTNFbThsM2txOGxYZ3I4VmJpcmNSYmliY1NieVhlU3J5VmVDdnhWdUt0eEZ1SnR4SnZKZDVLdkpWNEsvRlc0cTNFVzRtM0VtOGwza3E4bFhncjhWYmlyY1JiaWJjU2J5WGVTcnlWZUN2eFZ1S3R4RnVKdHhKdkpkNUt2SlY0Sy9GVzRxM0VXMW1IWDRmZmdOK0EzNERmZ04rQTM0RGZnTitBMzREZmdOK0EzNERmZ04rQTM0RGZnTitFMzRUZmhOK0UzNFNQYnhQZkpyNU5mSnY0TnZGdDR0dkV0NGx2RTk4bXZrMThtL2cyOFczaTI4UzNpVzhUM3lhK1RYeWIrRGJ4YmVMYnhMZUpieFBmSnI1TmZKdjROdkZ0NHR2RXQ0bHZFOThtdmsxOG0vZzI4VzIyNGJmaHQrSGo0Y1REaVljVER5Y2VUanljZURqeGNIYmc0K1Bzd01mTGlaZXpBNzhEdndPL0E3OER2d3NmanljZVR6eWVlRHk3OEx2dzhYcmk5Y1RyMllYZmhkK0ZqKyt6Qzc4TEgvOW5EMzRQUGoxSWVwQTkrRDM0UGZnOStQUWllL0RwUnRLTjdNSHZ3ZS9CcHlmWmg5K0gzNGRQWjVMT0pKMUpPcE4wSnJsYmtyc2x1VnVTL3VTWS9uQzNKSGVMdUZ2RTNTTHVGbkczaUx0RmRFdDBTOXd0NG00UmQ0dm9tZWlaNkptNFc4VGRJdm9tN2haeHQ0aTdSWFJQZEU5MFQzUlBkRTkwVDNSUGRFOTBUM1JQZEUvY0xlSnVFWGVMdUZ2RTNTTHVGbkczaUx0RjNDM2liaEYzaTdoYnhOMGk3aFp4dDRpN1Jkd3Q0bTRSZDR1NFc4VGRJdTRXY2JlSXUwWGNMZUp1RVhlTHVGdkUzU0x1Rm5HM2lMdEYzQzJpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvNkwvb3YraS82TC9vditpLzZML292K2kvK3JYL3dIdWY5ZC9BQUFBQUFBQi8vOEFBbmphWTJCZ1lHUUFnak8yaTg2RDZBdkxqQ2RCNlNrQVMvMEc5QUE9XCI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFSVEFBQklBQUFBQ0ZzUUFBWWN0QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCbEFBQUFCd0FBQUFjWlFZRU1rZEVSVVlBQUFHd0FBQUFLZ0FBQUNvSEJBcm9SMUJQVXdBQUFkd0FBQ2MyQUFCTnR1MFlGVHBIVTFWQ0FBQXBGQUFBQXJJQUFBWk1iS3RDSlU5VEx6SUFBQ3ZJQUFBQVZnQUFBR0M1Y3dFV1kyMWhjQUFBTENBQUFBTWhBQUFFZGtFcVRqbGpkblFnQUFBdlJBQUFBREFBQUFBd0dCNEN2bVp3WjIwQUFDOTBBQUFCUEFBQUFid3Y1azZyWjJGemNBQUFNTEFBQUFBTUFBQUFEQUFJQUJObmJIbG1BQUF3dkFBQXZyUUFBWGVJZVZHUjUyaGxZV1FBQU85d0FBQUFNUUFBQURZSlp2U09hR2hsWVFBQTc2UUFBQUFoQUFBQUpBdWRDWlJvYlhSNEFBRHZ5QUFBQ0tvQUFCQkVFV3A4UVd4dlkyRUFBUGgwQUFBSCtRQUFDQ1FEYW1NVWJXRjRjQUFCQUhBQUFBQWdBQUFBSUFZK0FoTnVZVzFsQUFFQWtBQUFBb1FBQUFVMDhhYjNKWEJ2YzNRQUFRTVVBQUFRMHdBQUk2WmZlT0hnY0hKbGNBQUJFK2dBQUFEV0FBQUJNN1ZVUXpNQUFBQUJBQUFBQU5JQkp0b0FBQUFBeFBBUkxnQUFBQURPRk13cEFBRUFBQUFNQUFBQUlnQUFBQUlBQXdBQ0EyWUFBUU5uQTJjQUFnTm9CQkFBQVFBRUFBQUFBZ0FBQUFCNG5NMmNlM3hWeGJuM1oyWWw1SjZkaEl0NEtTQTNMV29GYXN0RnZMUUhQZEw2S3JXMENnZDVxWitLNTZnOTlGQ1BSNjAzRk1TcTlZNVNxNEFpdG1CVlZGUzhFQkNNUW5CRHdpWGNkb0FrTzJ2dm5henNhMkp0clpuM08ydGZzaE1pWWovbmozZXR6NDlaYTlaYU0vTTh6MitlNTVuWlVTR0ZFSVZpdERoZnFNa1hYenBObE43NGk1ditVNXdrY3FnWFdndnpQUHRhM25EdHZQOFUrZWJLUlk1UWxFb1VmdStJa0dQdk51L0tWZFpNem11c2RWWmx6dWljaVRtWDVzekx1VDl2RTZjL3J5Vi92TG5LdVRSL1R2NURCYVVGdCtUNUMyY1ZMaWhjWFZSY3RMUm9ZN0VxSGxJOHNmakNrdXRMWnhjUEtiMnY5TW5TdUtmTU00cC9SMXVWWFNldHprdWVicnR1aXdicGs1N2NzNmlZRnJ2T2ljbXpkSGJtak5OTDNLb3NWbW5RY3ZJMDdjd3JudGdUNmY2NjVFbWU2VkdVems2RDBYTVczR0xPOUhqTVdiaWdxTGcwN3NyTGFmb3N1TVV6RDQxVkpxWEp1YlNvMkdqTzQ1aWFvcVZKMmZKYXJFcnp0T3hWbzd2eUpRVzNGQlZYM0ZlNHV1OHY4ellWRmZkVHBmRisrZjBxQnV3ZStHcHAvTVFsUm5zblBYN1NrbE1lUDJYTG9CbURIbUpFNkdwd29jZEpqdnZVVXpoL21OZHk2cjY4VFZibDBLR210Mkg5Y3VZVnJoNXhoZWtyTFUzK25KeUpCYmVjdXE5d3Ria2ZhYjQ2NWJRM1RyL3AyMmp6MjdOSFRSeTFjVlIxOFVUUHFGSHRad3d5Zlo2NXdHalVNK3BzZGZhazBYTkd6eWtlTXZwK28vRlJHOGNVbXZ2UytLbW5qSjVqVlpiT0xweFZHamNZMWM3N3pxaU5IcWR3dFdjVVBTZlBUYWJmcEo3YytrM0pmODJac2RTOHBEWE5FMWZmOUgvcVBucEl3YlE2YXFONWF0Nm1oUVhtekxiMThhQTNEdlRrUTdiVmU2SjBkcEtIUnBJdTVGenF6cEhNT2VhY01SZVB1WEhNeldOdUgvUHdtSFZqdG84NU1pWStkdURZUVdQUEdYdisyRitPdlkyWk5rTVVpZjVpZ3Vnbkpvb0tNVWtNRU12RUFQbDlVU0hIVTA0RU40Sjd3UDFpZ0JvbStxa1JZQ2JYczhESG9rSnRBZFdpd2hva0JsaER3RkF3bkhha3FOQkR4Q2xpcU40c3J0UVJNVU1mbGhmcHNMeFhOOHVGdWxZdUVlWHllYjFGYmhaOTVVRmRKV082V2wydWw2azUraWZxT3YxYmRUMzNOK2g2ZForT3F6ZjBmNnUxM0grZ0wxZnI5VVBXWEYxdkxkSWQxaVBnQ2YySjlhU09XWXUxMTFxaVB4SktuU2lLZU5QR2F4VHo3NFc2WGN6V0VkcHFFd1hpZmtaeHUwN0l1M1ZVTHRFdGNqUDNCL1VSM2o5aXpkZHQxdE82UStTS0tUck1lRnZvcDQxMm83UWJGZHVGUnc4UTVXQzRyaEpuZFg0dXhxRzF5ZnFRdUZpM2luOEZsNEFmZ1N2QU5QQXplcjlLdDRqcE9paG1nbnY0N2w2d0FDd0U5NEZGNEFYYVdBRmVCQ3ZCUytCUFlCVnRyQVl2ZzcrQVY4QmE4Qlo0Rzd3RDFvSDM2ZU1Ec0I1VWdnMzA5U0hZUk51YmFlY2p5aXJLanlrL29kektOOXVBRit3QXRXQVAyQXYyZzRPZ0hod0dEYUFKTklQUE9qK1hIdDBxeTBGZjBCOE1GLzNrU0hBR3Vqd0xuQTNHZ08rQzc0RUpPaWduODk3RlhGK0NsYWZvUTNJcTc4L2hlaTZZQjI0RnYrT2QzL1BPdzVTUDhzMHo0Rm11bDRIbDRBV2UvUm1nRTdtYThuWGFlSWZ4dkVlNWdlOXJLUS9UdHAvbmJTQUs0clNSb05TNlZRbGdnUklkVlAxMWxScks5WEN1UjRMVHVUNFRqQWFYd2U0ckthZURHVnhmemZOcktPL2ttN3YwSVhVMzVYektoVHhmQkJpM1dneWVCbjhBei9IK012QThlSTM3TmVCMThEN0FIZ3A3cUU4cHZaVGJLWGRRMWxEV1V1NmszRVc1bTNJUFpSM2xYc3A5bFBzcEQxQWVwUFJSMWxNZW9rUm1kWVN5Z2JLUnNva1NXNmtBQ0lGV2dENVVCTVFBK2xCL0ExK0FMd0c2c1NSQU4xWXV5QU1Gb0FpVUFPeHRsVE1UK29MKzRBUndJamdaZkFzTTFrSHJWREFNakFBVDlBRHJQUEFEOEVNd1gyOFUrY3p4L3JKSjlHZHUrNW5iemN4dFAzTzZpVG5keU16ekM4bDdyYUl2Yys1RC9FTVZmbUd0UEtMMzRoUGVWV1g2RFRWSzcxVGYwVnZ3RDh2NXZncWY0RmR2NmsvVlcyQzkzcVlxZGNTNmw5NFhhUnVmRUxBZTFRSDgyZ3o5SWpQNE1XdSs2TXZUQkU5alBJM3pOSWJYT0JldmNZRFpQWTNaZlFHZTRVcFJpbmRZSmgvVEhYaUdRM0lwZm1xei9yTnN3dSs4cXBzWTRjZGlpQmluOTRnSmpIaWlkc1FrWFMrVzZYbzVYTytSSThIM3RTUEhjejhSVE9YK1JzcDd3UDNnZGU3ZkE3VjZqeHJHNkVlQXk3aWVBV2JpNVdhQmE3aitXRHRxQzZqV2pqVUlMemNFREFYRHdYeEdlQklqV01NSTJ1aTlodDVyNkgwTnZhK2g1eHA2cnFIbk5mUmNRODgxOUZ4RHoydm9lUTA5cjZIbk5ucHVvK2MxOUx5R25tdm91WWFlMTlCYkRiM1YwRnNOdmRVUUUzNm0zMEtIbjRoZmRhNFRkK2pUMGM3L0VYL1dENHYzOVBOWTZWVTB0VlUrcnUrVVQrbnI1SE42RVJxN0Zzc3RsU3YwOWZKRnZVcXUxTCtSTCtsWmFIR2xQQ2c4V05RdkcvUnlOSHFUdFBYZFdQY04rWGQ5aC93SDE1MzZWbFdxNzhEYWQySHRKVmo3Z0RwUHoxY1hjUDFqNmkvWGI2cWZ1ZGEvSGZZOGd6ZS9FUmJZV09ZR21QQTRUSGhGdlV2VStFQjRZTVJqTUNLTzdXTlk3VFZzL3k2MmZ4ZmJ2NHZ0MzdVZTF4OWcveGkrM2tTRVlyejRoYUljYVJ2RmJKZ3lYNi9saS8xOHNaOHY5dlBGZnZjdEQyOFY4MVlyYjVYeTFqYmVDdkZXSU1PNGdXaGxOMXFKeXNXNkxSWGZqcUNOQUpwb1JoTmg1a0VGV2dnaCtWNGsyb3MwdTVDbURta01wd1BxRFZHaTFvcGlKS2h6SmVqZVEwZ01Gd1dNMG95NFJPOWdQQlZFcWhiR3RJOEkyMkpHTDM2bFg4VldYbXkxSEZ0OWlLMDJNcW9hK1FnKzh6Rkc4TGorV0Q0aFNoaGhDTHZWWWJjZ2RudVBrWVlZNlRic0ZtUzBCeGp0SjlhRmVoYzZUQ0RyeTR6RXkwaTJNWkp0akdRYitrdWd2d2c1K3d4a3U1Y3ZWMm8vREMzaHpUYmViT1ZOaHpjZFVTYk9JcHFPQjM4RXo0TG53Rkx3R2VNWkJjNEUzd0dqd1Zod0RuaEhoNjB5VU1GN2VlZ3JDak5pc0NLQjNtSllQSUhGUStocGwrakQyRnZjY1RmeG5mRnhsek4vMXRPejVLNUQvSWg0WHNacXBDeGw2UXJpZFpCNEhTUmVCNG5YUVdKMTBOWGRLc3JWNEdYd0YvQUsyQXEyQVMvWUFXckJIckFYN0FjSFFUMDREQnBBRTJobUxQM2R1QmVVMDBRWnNTMUlYQXNTeTRMRXNpQXhLa2g4TXJFcFNHd0tFcHVDeENZVGg0TEVvU0J4S0VnTUNoS0Rnc1NaSUhFbVNKd0pFbU5NVEFrU1U0TEVsQ0F4SllpdkQrTHJnL2o2SUw0K2lLOFA0dXVEK1BvZ3ZqNklQdy9pejRQNDh5QytQR2lORTJYV2VEQVJuQXNtZ2NuZ0l2UnpIcHB4MEl5RFpodzA0NkFaQjYwNGFNVkJLdzVhY2RDS2cxWWN0T0tnRlFldE9HakZRU3NPV25IUWlvTldITFRpb0JVSHJUaG94VUVyRGxweDBJcURSaHcwNHFBUkI0MDRhTVJCSXc0YWNkQ0lnMFljTk9LZ0VRZU5PR2pFUVNNT0duSFFpSU5HSERUaW9CRUhqVGhveEVFakRocHgwSWlEUmh3MDRxQVJCNDA0YU1SQkl3NGFjZENJZzBZY05PS2dFVWNVcFBqVEFuL1d3WmdXbUJhRmFURjQxQXJUT2x3dVdXSUtIdUJLSXNBTWZNVUo1SGdPdVpoREx1YVFpem5rWWc2NW1FTis1SkFmT2VSSER2bUxRNzdpU0RPQ29XQXgrQVA0Ry9nQ2ZBbVFsdmpyRUg4ZDRxOUR6SFZFSG4yVnVISG9PVkhFN0d5Uno0dGlScmNGenhnVGZjaERGNUNITGlEV0xpRFdMaURXTGlEV0xoRFNmVzdtbThOOGM1aHZEdlBOWWI0NXpEZUgrZVl3M3h6bW04TjhjNWh2RHZQTlliNDV6RGVIK2VZdzN4d3hTT1RxdUNnRTAzV0N6RFZCUnBrZ28weVF6U1hrTkIwblEwdVFvU1hNL0NMTFNwQlZKY2ltRW1SVENUS21CRmxRZ2l3b1FSYVVJRU5Ja0NFa3lCQVNaQWdKYXh4K2JUeVlDTTRGazhCa2NCSDlqY2FYL1FxUDhwRDQxWmNieEIyZGQ0ajdPei9BajUyQkgvc3hYdVlYYU9VUmZKaEhQdFVaeEhjTmxrczdtN0hmeFhKRlp4czJuQzVYZG40cFgrcmNUOHk1Z3BpVGk3ZGRUOHlaSXBzNk80azVmUm54dnhOelNvazVmWWs1ZWNTY1V1eGRqdVltWWZPL0VIUDZFM01tRVhOS3NmLzF4SndwZU9saXZQUUY2b2JPR0Y1Nm8zcTFNd0l2eHVDQi9pOHhwNUNZa3d0SFJ1T3g5N0NLUWdkaUZCZ0x6Z0cvQTArQ3hlQXA4RFJZQXRDZjJBS3F3YWRnT3pnRWpvQkc0RWUvcGFBTVZJQis0Ri9BcGVBR2NETzRBeXlCSy9oRDZRVTE2TndEMExjNkRYd2JuQUhPQW1lRG40T3JBT05SakVVeER2VWUrQno4SGZ3RGRHSWpBUlRJQVgxQVBpZ0V4WUF4V1ViR2M1SFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RaSFVSbEliU1cwa3RiSC9KcVF0UTFvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXUmxvYmFXMmt0WkhXdG95YzQxajErY1c1ZWlkNTF5NVdjbjVXY241V2NuNVdjbjVXY241V2NuN3lzVjJzdXZ5c3VQeXN0dnprWkx2SXlYYXg4dkd6NHZHVGwrMWkxZU5uMWVObjFlTW5SOXNsRitpZDVHbTd5RGtiV2NuNFpSWDN1OGwzKzVNaFRxYWNTWTR3Qzh6bWVpNjRrL3E3d1FOY3J3YjB4NHJDejJyQ3owckN6eXJDendyQ3orckJ6OHJCejZyQno0ckJ6MnJCejByQnp5ckJUNjYzaTF4dkY3bmVMbks5WGVJMGZNb2dmTW9ncFBRaW5SZnB2RWpuUlRvdjBubVJ6b3RrWGlUeklwa1hpYnhJNUVVYUw5SjRrY2FMcDRvamdaZVJleG1sbDFGNkdaMlgwWGtablpmUmVSbWRsOUY1R1oyWDBYa1puWmZSZVJtZGw5RjVHWjBYdnpZSXZ6WUl2ellJdnphSU9MNkV6RmN4ejgwY2Q4UWE0cFNQT09ValR2bUlVejR4RlQ3K0JGeWg2OFJQS2FkUmR4WForWFRkZ1A5cUlJYjVpR0UrWXBpUEdPWWpodmtFY3dZUFhvY0hyOE9EMStIQjYvRGdkYXltNjFsTjE3T2FybWMxWFkvdmE4RDNOUkR6Zk1ROEh6SFBSOHp6RWZOOHhEd2ZNYzlIelBNUjgzekVQQjh4ejBmTTh4SHpmTVE4bjJUK1NPYVBaUDdJSXVBaDZ5b0hmVUYvbnAvQjZ1QXNjRFlZQTc0THZnY202QVppcFkrVmN6M3gwaWNmNU52ZmMvMHcxNC95TEpuTjJaSzVURGJYU2pZWHdpYzN5RCtTZno3clpuWUI0cXVQK09wRGMwMnNvT3ZKOExhVHArMG11enZJYXJxZTZGVEhhcnBlNG0rSXdUNFpvQXlDRUdnRkRtampuVEJsQkVSNUowNGZDY29PN3Y4SzhCM3lDL0FsME5wSDdQWXBmQWZ4MjZjS0tKRlpGYnN4b29Fb1dFZWNhQ0JPTkJEYmZjUjJIN0hkcDRncmFnckFoZ3I3RWV0OXhIb2ZzYVJCNGVmVUxlQjJzSkM2UlFCOXFNZTRKd3NscXRhUkIvaUlySFhFblFiaVRnTnhwMEd0NU5tZndDcndHcy9YZ05mQis2Q0tPbXhEbnVBalQvQ1JKL2pJRTN6a0NUN3lCQjk1Z284b1hVZVVyaU5LMXhHbDY0alNkVVRwT3FKMEhUbUVqeHpDUnc3aEkyTFhrVWY0V0NYWHMwcXVaNVZjenlxNW5sVnlQYXZrZWxiSjljVEFCbUpnQXpHd2dSallJRzRtd2g0Z3doNkF5VkdZSElYSlVaZ2NoYmxSbUJ1QnVUNlk2NE81VVpnYmhibFJtQnVGdVZFWUdvR2hFUmdhZ2FFUkdPcURvVDRZR29XaFVSZ2FoYUZSR0JxRm9WRVlHb1doVVJnYWhhRlJHQnFGb1ZFWUdvV2hVVmdZaFlVUldCaUJoUkZZR0lHRkVWZ1lnWVUrV0JpRmhSRWkvd0dZR0lXRkVWZ1loWVUrbU9jd096MHd6d2ZqV21CY0ZNWkZZWndQeGtYYzFjK2ZLVmNEUC9WUkVPZFpnbEtUWndsZ2dSSTBQaHlNQktkemZ5WVlEYTRFMDhIVjFDK2tYQVFZQXhhUFltMGYxdlpoYlI4V2ptTGhLQmFPWXVFbzFvMWkzU2pXaldMZEtOYU5ZdDJvTWlzSitzYUNVU3dZeFlKUnJCZkZlaEdzRjhGNkVhd1h3WG9SckJmQmVoR3M1OE42UHF6bnczbytNcGdEWkRBSHlHQU9rTUVjSUlNNVFBWnpnQXptQVBFL2w1VlhJWmpDZXUwcThySHB1Z3BMVm1HMUdGYUxZYlVZVm90aHRTcXNWb1htWTJnK2h1WmphRDZHNW1Ob1BvYm1xOUI2REswdlIrTXh0RjJGdHNOdUJIeUdhN0k2dEZ5SmxtTjR4UU5vT1lhV1kyaTNDbTFXb2MwcXRGbUY1cXJRVkJXYXFrSlRWVWdhUTlJWWtzYVFOSWFrTVNTTklXa01TYXVRdEFwSnE1QzBDa21YSStseUpGMk9wTXVSZERtU0xrZlM1ZUo4dUJ1QXV3RzRHNEM3QWJnYmdLOEIrQnFBcndINEdvQ3ZBWGdaZ0pjQmVCbUFsd0Y0R1lDWEFYZ1pnSmNCZUJtQWx3RjRHWUNYQVhnWmdKY0JlQm1BZXdFNEY0QnZBWmRueXlpWEF6K0lnZ1RRckp3RnNNRHA0RXd3R2x3SnBvT0ZnRlUwdkFuQW13QmNDY0NWQUZ3SndKVUFYQW5BbFFCY0NjQ1ZBRndKd0pVQVhBbkFsUUJjQ2NDVkFGd0p3SlVBOGVoNVVTVHVaRjFaekxxeXVOdDZjZ3IzWmsxNUJldHhzNjZjenBzelFXOXJ5N1c4OHhaNEc3d0QxcG05Vzk3OUVQeXo2MDRQYzdBYzlBVm1EVHFCRlVSeUhWcWNXWWMrU3QxanhOSm5LSi9sUGJQS1NLOU56VXBqRlhWbWpkcEdhZGFwY1o3M1hLdVdpQ0s4ZVlzYVRqa1M5TFoydlpyNjdQWHJZdDQzYTlnL1VOS25XZ2JRNURkZDArS1pXL0RNTFhqbUZqeHpDNTY1QmMvY2dtZHU2YmJlTGVIZXJIa0hpeUxyVkRBTWpBRGpSREZyNEdMV3dNV3NnWXRaQXhlekJpNW1EVnhzemRjYnJIdDEyR0tGYVQyaTI4d09odlc0K1pWQmxGcUxSWWxGdHMzNWI3cE5YSTBHSjRIendZVnVadElnbXluYmRadTZDUHdDL0JvOENGN20vVi9DbHlMNFV0VHQ5NElwM0NkL013aTV2eG4wdnVjZmdpY2hlQktDSnlGNEV2cG45L0RoUndoK2hPQkh5TjIvTjN2ejA3Q3YyWDgzZSsvSnJDSU9MMEtadmZjVnhzTXc5MTdDaDYraVBybkhIbkwzMkh2dXJ3L1ZvVzc3NmVtOTlPNzc1YUhVZm5ub3FEM3lyOSs3RG1IN0VMWVBZZnNRdGc5aCt4QzJEL1hZdXc2NWU5ZmpzUGQ0TUJHY0N5YUJ5ZUFpOUY2TUhlUFlNWTRkNDlneGpoM2oyRENPRGVQWU1JNE40OWd3amczajJEQXVCdVBOMjkydlpsSmU3YTZNMi9IaTdYanJkbHBKMEVxQ1ZoSjQ2M2E4ZEx2YldwelN0RmlpMi9ISzdYamxkcmYxcXltemUzaU8rMlhnZVVCdmVPTjJ2SEU3M3JnZGI5d3VGaEJicW9rdDFXSWM2NUFKZWpmcmtYWjNQVEpWMTVMLzFwTDcxakpDbXhGR0dLSHRya2ZlcEc0RDF4K1NLL2JSdGVTaXRlU2l0ZVNpdFhJNGE0MlJ3S3hUSnZEY3JGV21jajlOVjd0cmxlVDZwTjFkbnp6SSs0KzYrV1l0a3RueWRkNTdENnlIODFXOFU4djFUcTUzYzEzSFhEaEludG5JdTgyd0prQVpCQ0hRQ2h3UUJoRVEwMXZSa0kyR0l1U1V0ZVNVdGVTVXRlU1V0ZVNVdGVTU3RlU1J0ZVNSdGVTUnRXalJac1hlcklicDNXalRWaU1vV2FHeGVtOGlqNnhseldTMEd5R2ZyRldYc1Q2NlhIOUVYbGxMWGxtclpxVFdVMWZ6Zm5KTlpTd1FVZGRRLzB0eXhqbGdMblcvcHU1bTNyOEYzRXJkN1pRUFVQOGc5WTl4L1FSNGxubjlITzBzcFZ4R3VaenllY29YM055emx0eXpsdHl6bGpXYXNXWkV2Y0U0elc3U1dxTEtCL1MzWG04bEQ2MTExMktEV1dXYTlSZ3JXWGROTm95U2RSbFd0NG5CMWNUZ2FtSndOVEc0bWhoY1RReXVKZ1pYaXdLMHZCa043a0RLN1l3K29LN1hoK21wbGw0Y2VsbE9MN1ZpQkh5cGhCZUdFeVpiak1DRkNMYXZ4UGFWMkQyQ3pTdXhiUVM3UnJCckpYYXR4SjZWdEw2VjFnOWpud2g2ajZEM05uUWVRZDhSOU4yS2ZpdnArVEI2clVTblJvK1ZqQ0NFWGlMb0pJSStJcWtkdENQSUdFRytDTEpGa0NzaUt1Um0vYW84U05tZ2o4Z20vWXEwV1duOG5kNDYwVTZwUHFKR0lkTjV1bDVkb0J2Vmo3bi9HYmlPMW0vUUI5U3JlcjE2bDU0L0VPVmlFdkxaekljQTh5SE9mQWpBLzVnd21RTDhRRVliZmdmZ2RnQTViWGdkZ05jQmVCMkgxd0hrdFpIWGhzZGhlQnhIYmhzZWgrRnhIQjRIMFlFTmgyUG9vUWFPeHVCZEFNNEY0Sm54RVRGMFlMdmFuMEU1ay9wWllMYnJPMkxvdzRaWFFTd1RoRmRtcHNmZ1V4QXVtUmtmZzBOaCtCT0dPMkY0RTRRcnhzL0VzR0FBQzdhWlg3SFJYUTBjQ2NDUEFOd0l3SXVBZUVRTUYyVmlKREYvRkJnTHpnSGo5QkcwY0FRTkhCYjM4UHhlc0FBc0JQZUJSWUE0TEo0RWk4RlRnSGdzbG9CbndESysyOFE3SDRHUHdSYnFxc0duWURzNEJJNkFSbUR5ZzFKUUJpcEFQekFjTzQ0RTQ3SGhSUEF2MUYxQ3Rub3A1VlRxNTNCOUE5YzM4bXd1MS9QQXpkemZTbmtINVQzVW05L25YK2ZkTjdsZlIvMTdYRytnM0N6NnlXcEs4aUZaQTJxcFQzb1p1Q1A2eWhhZWZRWS84a1daOHBqZmVDbFBwUnhHM1Fod0d0ZmZCbWVBczhEWjRETHFmMDU1RlpqQjlVejROQXRjdzdYeEJ0ZFNHbzl3SGVVTmxMK2h6WnVBOFFpM1VYY24xM2VEKytBa09sWG9VNkZMMXdPczRQa2J0TFZXSDFKdjg4NTcxSC9BZlNVVzNzajlod0JkcTAvQmRsQURkb0xkb0E3c0F3ZUFEeHdDUjBBaitKeDIvZzcrQVRySmJjakhMQVZ5UUIrUUR3cEJNY0ErTU9jd3pEa01jdzdEbk1PVzRjeFljUkx6WkJ4emhLaVZpaUZSWVZadXcrSDVTRENlNjRsZ0t0YzNVdDREa25FZ2luVmljcDN1d0RJeDVrekM5ZjNWM05keXY1Tjc0LzhQdXZPa0hjMjN1Lzc0TXU1bmdKbXN2bVlCNDNldjRkNzQydC9nSDR4dmZaWTErVkt3SEJpZitRYWFXZ3ZlNXZrSFJtdGtZWU5ZcVEwQlE4Rnd4bnd0ODhDVG12MjJPRmVVSW9rTjl6MXczd1AzUFhEZkEvYzljTitEaERiODlzQnZEL3oyWkhrSEUvbHN1T3B4UGNRY3loc3A1MUxPQTdlQ2U3aGZJRXJSZ08xNmpIVmN1MTZEM0drRHo4MWZzVlJSVncxY0QwTDlicTdyZExQclFYeG9wUWxmMThLN3JDdmdhaEN1ZXVDcEIwMlpLR2FyeWFJMDVVMENLVzlpb3BTdFpsT2Y5Q1ROY05KNGsyWTRpVWVoL2pmZ0p0cTRsYnJicUx1VDY3dkJBOVEvUzI2OUZDd0hML0I4aGZFdzFMOUJXMnZCMjF3blBVd0FUcGJDU1ErYzlNQkpENXowd0VrUG5QVEFTUStjOU1CSkQ1ejB3RWtQblBUQVNRK2M5R0FWRTcxTTVESlJ5eGFqc1VnVHZHckdHbVpQMUkrbW05QjBFNXIybzJrL1dtNUN3MmIvMHcrdm10R3FINjAyd2F0bXROb0VyMEpFaDBhNDFReTNtdEZvRTl3S3dhMW0yVUxXbnc4bUk5Rmx4UHdaWUtiMm95ay92R3BHVTAzd3FobGVOYXViZU84QlNySlp1QldDV3lHNDFReW5tczNmSGNDcFp2VWhxNFJCMm84RWZpVHdXMmFmZHhnU05DS0JHWGtqSTI5a3hJMk0xSXl5a1ZINkdXVmphcFFOak5MUEtQMk1zakUxU2oveHpNOUlXeGxwS3lNMXYvVTNNdEpHUnVobmhJMk0wTThJL1l5d2xSSDZlNHpRendqTjZQeU1ybFdjd0doYTBXVUNYU1lZVVNzamFrV1hDWFNaWUdTdDZES0JMaFBvTWNFSVd4bGRLNk14OGJtVlhsdlJUd0w5Sk9pNUZWa1R5SnBBMWdTeUpzVDN5UjRqWkk4UnNzY0lrVE5LeGhnaFU0eVFLVWJJRkNOa2loR3l2d2laWDRTTUx1TCt6bXIyalFKY0IwRUl0QUlIaEVFRXhIaW5uWGM2dVA0citCeDhBYjRrSTFDZ0FOQXVHWjNKS3RyZDM5dklSSWlvVVRLM0NITWdRdFlXSVd1TEVFbWpSTTRvR1ZtRWpDeENOaFloZWtiSnhDSmtZaEd5clFqWlZvUnNLMEwwak1MbkNKbFZSSnlhOVR0V0I3bFBCN2xQQjdsUEJ6bFBSK3AzckE1eW5nNUcyMDZPMDBHTzA4Rm9Pc2h4T3NoeE9oaEZCM2xOQi9sTUIvbE1CL21NeVdVNnlHVTZ5R1U2eUdVNnlHVTZqdm1ibGtKZlc4bGx3cUlRRDlDUHZ0cVkvVzN5YjdEZ2NtTDh0ZUE2Y0J0WUFjaW5XU1htTXRKQ2Q1U205UTVhNzZEMURscnZvUFVPV3UrZzlRNHgvYWdkeE9SZm4wVjczVG5zN2EvSC90bGR3KzUvQ1JaMWR3bk43dUREN3Y1emEyWW4wUHpGbHRuNVMvNVZWdlNvblQvemwxaG14MitVdTJyc3Z1dVh2ZU9YL0N1cnFQdFhWdDl3dCs5ci91S3BheWN3K1JkUFVldGV5a1dzSUIraGZCUWRMV1B0WG9KVlNnUlNvdkV3R2crajhiRDVwUmF0aDkxZkhxWlJwdmQ3WHVDOUZlQkZzQks4QlA3a1dpV01WY0pZSll4VndsZ2wzT3V2RU9sOW9NMThVd1UrQVZ0NWR4dndnaDJnRnV3QmU4RitjQkRVZzhPZ0FUQlBzVlM0eHk4TzRkU2VVRmhPd1JMVFJBbFdDMk8xc0xzdmxOd1Rxc042WWF3WGRuOGh3UEp3ZURWV0RPUFRYbk4vRVloeW5kd1hDbVBOTU5ZTVk4MHcvdTYxMU41UVhkYmVVQmpyTm1MZHNQcU9LTWJDWVN3Y3hzSmhkNC9vSnI2NUN5dk5keTBleHVKaExCNU83ZXlIa3p2NzNmYUx3bGcvalBYRDZrM3Uzd0x2Yy8waDdhQXZCWk1WVEZZd1dlMENzRm5CWmdXYkZXeFdzRmtoazRMTnFzbGxUeGoyaEdGUEdQYUVZVThZOW9SaFR4ajJoTC9tbDRBdzdBbkRubkRxbDRCd0wvdE5KZFo0TUJHY0N5YUJ5ZUFpY0R6N1RhV3UzekFaTG56R2QwUmxKMW8wbWU3bGpQNWFjQjFSM0dTbXQzRzl3dldBVVpOaGloK0ppMFd4K0Zkd2lkbVhCTlBBS3JBYXZBeitBbDRCVzhFMjRBVTdRQzNZQS9hQy9lQWdxQWVIUVFOb0FzMmlXUFlIazgzZUluZ1lMQVBMelY4cmlJblNUOWtpQnNvb1pZd0lucUQ4VFA5VmFrWXZnT1ZLTVZDZFRubW00UVc0SEo1Y1NUa2RYS3YvaW1STlNEWVF5ZjZxRmxLM0NOQ1hlaHFzb080MXlqWGdkZkMrKzVkVFRVZytVREUyRlFBaDBBcmFRQVRFQU9PdzhrQUJLQUllWk1sbmhPL2grM2NRaVE0eWlxbjAvQnhyMTZoNmk5eHp2YjVVREVudC9VVGR2Wi9zZlovMFhrOFQ4YzE0eGhhaWNITFBKOHA4U1BUWTk0bW05bjJTTWUwbW5qL28vcGFSdmZlRDlkeS9uT2krLzJPaVFoMVJvWTZvVUVkVXFDTXExQkVWNm9nS2RVU0ZPcUpDSFZHaFR1UmsvUlZXMG9NVldIUDFQbXJqMU1aVGZ3VVp0NTdRRzYwbllkeGkvWW0xUkc4UWlyYzZ1QXU3ZjVHNTAyMm51eWNzNUkwOTFueFJ6cE1vVDhJOGlmQWtTbHZ2cDlwNmg3YldpbHhhU0ZBYnBzYjhyWjFEYlFzdHpuWC8rakpFYlNzMXpXNk4rU3Z1dVB2ZUV2b3VPSzVaWVVZWWNYdjVKQ1ZYbEhlalppeklNVi83ek50R2JuZVdiZXlwRVo1NmFLdU10c3BNSy9BZ0tWRlhLNmFIUFVMS1ZYaC9zMjlid1dwamhCZ3BUaE9uaTIrTE04U1o0aXp4SFhFMitlNFkxbFRmRmVlSTc0bHhZcnlZSUNheUZwa2t6aFBuaThuaUl1YmVGSEdadUVMOFZQeE1YRW1FbUNIK2pSZ3hpM1hLdmF4UkZySStXU1IrSng0UUQ0cUh4Ty9GdzZ6dUh4V1BpY2ZGRStKSnNWZzhKWjRXUzhRZnhiUGlPYkdVU1BTQ1dDRmVGQ3ZGUytKUHpPS1htY0d2aUxYaUxmRzJlRWVzSTI1c0pHNXNFcHRaNVZTeHl2bEViQkhWNGxPeFhkU0luV0kzYzdxT09iMlBPWDJBT2UxalR0dWlSVGdpTEtJaUxqNFRuNHN2eEpkQ1N5bHpaWjRza0tYU0k4dGt1YXlRZmVVSjhrUjVzaHd1UjhyVDVTaDVwdnlPSEMzSHluUGs5K1Y0T1VGT2xPZks4K1FGOGhJNVJVNlZQNVhUNUJ6NTcvSS81UFh5Qm5tam5DdC9MZjlMenBPL2tUZkovNVkzeS8rUnQ4aGI1VzN5dC9KMmVZZThTOTR0NTh0NzVMMXlnVndvRjhuNzVjUHlVZm1ZZkVJK0paZklaK1FmNWJOeXFWd3VuNWNyNUl0eXBYeEpycEt2eVRYeWRmbUdmRXUrTGQrUjYrUzc4ajM1dmx3dksrVUd1VkYrS0RmSnpmSWpXU1UvbHAvSXJiSmFicE9mU3EvY0lXdGtyZHdwZDhzOWNxL2NKL2ZMZzlJbjYrVWhlVmdla1EyeVVUWkp2MnlXdGd6Sk5ra2VLK015SWR0bGgveGMvazErSWY4aHY1UmFDYVdVcGZKVmdTcFI1YXBDOVZkRDFUQTFYSTFRSTlWb2RaNDZYMTJnTGxTVDFVWHFFdlVqZGFtNlRFMVZWNmtaYXFhNldzMVNzOVV2MUgrcXVlclg2bi9VYjlVZDZrNTFsN3BielZjTDFFSzFTUDFPUGFBZVZFK3F4ZW9QNm8vcVdmV2NXcXFXcWVYcWVmV2lXcWxXcWRYcVpiVkpiVllmcVkvVkZsV3RQbFZldFYzdFVEV3FWdTFVdTlSdXRVZlZxYjFxbjlxdkRxaUR5cWZxMVNGMVdCMVJEYXBSTlNtL2FsYTJDcWlnQ3FrVzFhb2MxYWFJZDRwc1NjVlZRcldyejlUbjZtL3E3K29MOVEvMXBlcFUyaEtXdEpSbFdUbFdybFZpbFZrVjFpQnJzRFhFT3RVYWFnMnpobHNqckpIV09HdThOZEU2MTVwa1RiWXVzdVphZDF2M1dndXRCNndIcllldFI2eEhyY2V0SjZ3bnJjWFcwOVlTNngyaCtybi9WVmZlQXlXZms2ZC9Td2k5V04rdnQrc3E3ZWpOZW8zNEJvZisrVGQ1dTl1WDkyZXUya0dIdmt0SDlDcjl2bjZCNisxRWhYSzlWVlRvUjQ2anBXWVFCRnQ3MUNlKzlzdW1iekRlMXFQNmJBRjdVdmNObVNmUDZCWWRPdXJydGlRNCttWHFJcXpYajMxVTlEWmExc2pKbzV5cmNqTVNjOTJqdjVhdmFmbVloN1oxeUpXd0lhc3VwUGRscmxka3JqWm1ybTRXZmJQZTN0RFpwcXYxVC9SLzZYSzlXLy8yYS9xN0dac25lcldZSjJsWHZkL2NkSDZnRzR6TzlQak1sNi9yUi9SeitnbndFTm9vbzZxTWI4cjA4M3FkL2todjQ0MDc5ZTM4TzlKOWU2QXUwMUg5cG52OWx0NnBkMVB1N042djlyT3l5eDdiWVBmZmcxazFlL1JobzVtVWRrb3o5VzA5cEZyby92dFJqMW83eVNVZDZQcGF0N3B0R1J1VzY5ck1tenV6dm5wQnY2TTM2SDNnWTNoUXJwZkRqWExteDM3bWJHUFdlMmNSbllYK1ZMUDZTN0d3Sk5WZmE3THZydEdtbVBNVmgxNS9qR2V4WTM1NWpGbUZuZDF2V1p2MzBtWjN6WCtUNCtqMnNwNGQwdytRYS95emZUckhlQlpMdG50MDY2NGZLWE92Mm5wdG8vdWNYOWpqcWNkdE8zRXNHK2k5N3IrTHYyck14eHIzVng5R2ttK3VLMzIrUGxOUDF0OEZwOEdvUEtyeXlPank5SS8xUEgyZmZwdzNQTHFZbVgyYmVidnpHdTVyOWZYWmZpVjVkTUlNdlFXOGttcTNJemwvWEZablJwV01BSHFsZmt5dnh3K3ZaNGFITXZwTWxib2F2Ry9tUnVldjNQdmY5Ump4TVRYVTVRTzcxZDU2REEzVVo2NzI5M2pTSVNSNThEbXAvKzc2ZUE0bExDSjNydWpqM3VWeDVvc0M4dU04VjZ0RnFiZFlVWm1WcS9HRFBlSkNCVDdheEovKzd0MkFUUDBBemhOYy96MHdWWE1pT0lsL1R6NnVjUjNmMkx0TzgxK2c5MG1kZWFrejEwWDZORWQrNml4TGpiM3JORkcwZityc09vd002VFA3T0JISlRxVFhpZ3h5K0Q0YnBqK0RQclRYRXoyUHZKVGU4bnBCY3RRQ201aWpzQWZTWDZlUmJDZVgwYWFSUEFabW9mdFJuSVg4cjRDSktHWElhMngvY2dZOWJkSE55N2p0SGU5aHJOY25aYkd5VkkwbFR1SGZQdlNVdEdNQmQzbXVSb3hXaTl3ZXpMdWVsQTZTMzNYeDc4UlUyVldUckRNYXljb3FzbzVzQy9keDU4TXBxYmJOblBpV3lXcGRLd3ppM296WWNwLzNjVWVRNXo1THM4Nk1MNGZ4RFhMSGw3Ymt0MUl3UjFKWEpnL296NXc0ZWh6Sk9XVlkxdlYwaUl2azJKTXNIWnoxMVJEM2ViYmszMHJWcUY2bFRmWlV3dHNsbVMrTzcraUwzSU5UdWpIeUpVZFkwQU41UGI0eWM4SndJc21qcnUrNmppNUw1UjMxTkMrcnpNdk1PWE1rNTFNU1I3Y3BzdVpBVXErRDZEOE5jNXlTMGVMZ1hyOC8xbUhHWUdhZG1SOXBaUHVFNDBGdi9pRWJhZlpreittZTZINGs3OU56dDdjamFZTXU1QjZYdFBLbzBweTUxZyt5SWszWDFRRGF6WjU3WDMyb3JKRW15eTRycEtVNDJZMUo1bSs4REdlN2V6RkxHSGJsdVA4SGtweXMrbHczcXVXNmRVYURwZTVNUGNXTllWOS9ITitjNkI2QmV0ZDNmdVkwMTRXcHN5UTE5cTR6TFVWT0R5bjZaRTdoU3BFOGpTd2UxMCtta2M5MzJlalNSczVST1ByZFl4OWZOeTl5TTBqSDJUNVo2TjcreVZnakcybVBZWTVDSk9zTnhuT1VJSyt4ZlZrR3laNXlSSHJtV2FrYWtXblhITWVUQjNYNXlQeVVaVlRtMzRFaWJWbVZlU2Q5bUhkUHlGem5wTFJRNmw1NXNuU1RQa3hkMG80NW1YR25qMUtlWk44bnRaTHU2eVEzNzBySzFGOTA5K3BkSHFBOGEzd21qK3VmZXRvOU5wdkR5b3d0eC9YbHlSeXBiMmJXNUtaa01FOXozWHdtTi9ORmJtYjg1cTIwYis2YllZQkhkSjhMWHhXQkREdUtlTnNneVVUUnJleDU5TzZuVHNqRW9xN25CZDNHS2pJOE4vVkpIaVcvSzNCMTAwOGNmYVJiTFhjamJyS2w1SnU1UW1UbVhQTG9tbGRkWStucVB6MEg4bE9XTjNFcWphNFdrK2o2dnJzZlNPZmMrZDNxK3FiR2tOc3RpOHYyQ2NlRDN2eERkNlQ3N25NTVpQdVQ1SDE2N29wZWtMUkJGNzRxVWhrL2ZLTHJpMDJzR1pDS09lbTRrc3gzM1RwNXY3dXI3MEVyWGJ2NlIrL3BkOS9QTjd2NUY0dEx4SS9GVlBHVDFJNytkSGMzLytyL2hkMzhWWm45L0RlL1prZC9xNmdXMjhTbndpdTJpeDNIMk5rUGZPWGVmaCtaSi9ObGdTeVVSZDl3ajMrU1BFK2VMeStRRjZaMitvOTNuOS9zOHBzOS9nWHUvdjZEOGxINXBIekczZGRQN3VWbjcrU245L0hOTHI3WncvL3FIWHl6ZjM5WU5ycDc5bWEvUHByYXIwL3UxU2QzNm52ZnAvK3FYZnJwM2ZicC8rTi9aYWUrNnYvRHZmb0pxZDM2ODZ3ZldEODBlL2IvRDVneWFjQUFBSGljN2RSSmJJeGhITWZ4My9QKzN1bFVNWlhXemtuRW9YR2djV3BDR3BwRzZRa1JEc0xFUVVpWG9YVld0VysxYTYxVklTSWhvYmFpU3UyVW92WWxxQzcycmRiYTZ2YytNeGNTaVlpamZ0TG5mZWFaK2M5TU10OFpHQUF4R0l5TmNGSlMwMGNna0JITXpVSXZ1RHBIU3d2OHVoZzRvRTU4aVBydHVUOFl6TWhGNzR5SkU0TG9sNUUxTlJOSklXOU56c2tjSDBKcVRrNmZ2a2pYbW9oaG1uVHN0UGRQdS9yczZrYWUwMXVqN09wSE5PTFFGVDJRZ0VRa1lTQ0dST2FTdzVOT2FmaTJVeEdlZHIrSGIvc0NrV3RDNURvc2NoMEp4elRpTlZkekRkZHlIZGR6QTRzWllnazNNWS9UbWM4Wm5NbFpuTTA1bk10NW5NOEZYTWhGTE9CK0x1WVNMdVV5THVjS3JtUTJDMW4wMDh5ZlRSeG1CWS93S0N0NWpDZDRrcWQ0bW1kNGx1ZFl4Zk04eEF1czVrVmU0bVhXOEFxdjhocXY4NGJiN2kvbjJ2Q20zSkxiY2tmdXlqMjVMd2ZsZ2RUS1E2bVRlbW1RUm5rc1QrU3BQSlBuOGtKZThwVzhsamZTSkcvbG5ieVhEL0pSUGttemZKWXY4bFcreVhkcFlZdXJqOHcxNGdoZHNwemxydmZua3lqeFM3UzBraGhwTFczY3RoS1FXRGVXeDZWTWZjU2pQVHFnSXpxaE03cWdHN3Fyb3M0NjdhN1B2Q2Y2cS9BVXBHazNGR05VVWo3bTZHd2VpakFJYTFHTTRTakJWb3pDTnBSaExBN2hDTEpSaVNya29ocTFtSVo2UE1KeVBFVVRDdkVCemZxdWZERU9OaHVmaWNGMkV6RHhLRFVkVFRMS3pHQ1RoanBUWUFyUW9LWkNhRlJueFhqazFZV1hLdENyTWhxTzZ0cWpuVkhOanFteGovcjNOZjdwelA4ZS8ybVBLaS8rbC9MR2FPYzFOOEEybDJLYkcyR2JHMjJiRzJlYkM5bm1wdHJtOG14eksyeHpSYmE1RXR2Y0Z0dmNEdHZjYnR2Y0FkdGN2VnFLczIzcFY1UVQ5QjdTYlY5cDJuVkZEQ2R6Q2pkeUZYZHlGMHU1bTN1NVQvZVl5UHUwai9uTnQ0aTJZOWlPamUzWWU0MG9Ub3IwcTczai9jWWFVL0FEQjdXazhBQUFlSnhqWUdhWnpxakR3TXJBd0RxTDFaaUJnVkVlUWpOZlpFaGpZbUJnQUdFSWVNREE5RCtBUVNFYXlGUUE4ZDN6ODlPQkZPLy92eHhKZjY4eU1IQWtNV2tyTURETzkyZGtZR0N4WXQwQVZzY0VBSlFGRHpZQUFIaWN6ZFRwYjFWRkdNZng3NXpudHJLMFZub3BXL0YwN3NHMktvallBcVdsRzZVV2tJSlZscTZVQXEwb1ZnTm8zS0lXRlNvaWdpc1NFZE42cXdWQldxT0NDNXFJaVVaalRQUUZ3WmhLN3puOUEweUlKb0xuSEVmYUVBMkpyNTFrNXBubnhTU2Z5Znd5Z0RBOHA2TE1pdFZ1T25XeGoxZzFwajdQTnBLNWlsUWVWeDNxUmRXdCt0V3ZLclF5clFLcjNqcHBmVzE5WXcxWTUwU0p5R2hKazJteVMzWkx0M3d2UDhycFNHZFMxRloybWIzRC9pTnJtUjZyTTdTdEhaMmpaK2w4WGFTTGRhVytYM2ZvSHQycmo4YVNZdEhZaEpnVHk0bk5qRFU3bHBQc3BEbnB6aFRIZHFZN2k1MFdweTM3MjkrL3ZCQUp3dEFQUXlOTFJkTmxSRjJxejRqT1c1TkdSRjhaMFJrajRwSm91eEh0a2JqOFlFUkVkdHJZcGZZMnU4dUkwRkU5VVd1ZGJVUjV1dkNTS0c1RVIvNGxhaHdSamZ1SHFQV2lTQm5SbjJFWS9oWjY0YW13UDR5SCs4TGFjSGs0Tjh3TXpnZjdnNzMrb2FBajJCUTBCMnVDdW1CRlVPNFArbWY5WC93Qi8yZi9qTi9uSHhzNk5kUTVWRFUwdy92SnkvVzBsK1haM2xRdjZxVjdxVjZLbCtTZWRyOXpEN3U5Ym85YjdaYTVKVzdlWUl1Ym03aVFxRHZibnFoT0xFMVVKaFlrNWlRbUo2ekJjT0JBU256VUhaRjIyVHo4bXYrcmtXeU4rYnNvTHJNcHJKR2R4WCtQNFpOQ2hDU1R5aXNZeFdqR01KWVVrNFlyU1RNNUhVYzZVY2FUd1FRbU1vbkpUQ0hUcFBscWJMSk1ZbUk0VE9NYXNza2hsMnU1anV1WnpneHVZQ1kzTW91YnlDT2YyY3hoTGdYTW81QWk1bE5NQ2FXVVVjNENLbGhJSlRkVHhTSVdzNFJiV0VvMXkxak9yZFJ3RzdlemdwV3NZalcxMUZGUEE0MDBzWVptMXRMQ091UHY1R21lNFZsZVlqOXZFT2ROZW5pYnQramxNRWQ0aDZPOFN4L0g2T2M5M3VkRFB1QTRIM0dDazN6S1ozd3VwV3lsbFRidWtuSWVvcHZOM0MwcmVZQk5zcDZkdkNacnVVODJTQ3NiZVZBYXBFa2ExVUZwb1oxSFZTZUgrSVFuMk1DOTBxd3FaSjNheWowOEpoV3M1MGwyOEtvYXJ6SWtYMmJMZkNtV0Fwbkh4OUxHRjZwSWxraU5WTWtpMlNoM1Noa1BTNkdVeUVLMnM1dW5lSTVkN0RVL3hRdnM0UlgybVJ1K3pPc2M1QURuMUNyVnlCWlZxK3BVUFkrb0p0V2dWdjhGdExmOUlBQUFBQUFxQUdZQVZ3Qm9BSXdBcWdFQkFOWUFBQUFWL21BQUZRUTZBQlFGc0FBVkJJMEFFQU1oQUFzR0dBQUNBQUFBQUhpY1haRE5TZ014RklVVFo5VFdIM0RWQ2tGSUdLcFFFdHk3bXNWTVFib1puUzV5WGZpRExkaXVmQUZoRmdwREZqN0xtZDEwMThmcFM0aW1VeTNxSmlmblhQSnhic0QwRU8zTVZweS9VODAvMy9CNlVyV0R1MXNEcnFWTXB3bjR2Y0dXQnU4cmcwRExBWUxlNE5wR0pKMTBsMk1uQi9McFlZeXcxNmdmVEJ5ZFM3RGNUdjA1c2dveGljMTFRblJoRUs0d1lZTng1QUd6YjhDc0FmajNId2JiZWlnUm5HYjJ5cUpJQk9LRWhGSXl4U0t6V0NSQ0VSbnNiRHA2ZlprZXI5dnVhdXowRFZwclFtNFJDekJ5YnUwaWhjSTU0ZndHUDM3eDE5ZWMvUS9pMzRIL2diVG1SZFpNaWtpSlZSQ3BTUG1HbEJpMDlUQzNxYStvZk1VOWpVNXFzSy9SOVhLZ3F6TmVTcGZiZWN4QzlsaTNXRG15YzlZSmxzOGtFSG00TE9zanRzbFdXeDVxeEdVdDJZMnR1aXdSYzlZTmxnbVpMN0VRaUswQUFRQUNBQWdBQXYvL0FBOTRuTnk5ZDN3VTFSWTRQdmRPMmZUc0p0bHNDdWtrZ1FUWWhDV0VEaUpOV2tCNkNUMEJxUWtDV1dyb1JYcVJUdWhGQWRrc0FVRVFSQUVGRkNJV1FBUVVVVVJBVkZDVTdONThiNW1aekN6Qjk5NzM4LzM5OC9NOVpuY21aKy9jY3U3cDUxd09ja1VjQjJxSURvN25ERndkenNHMTdPbUExc2hpR05Da0Y3MFI4STNnMWFTWGt4T2dLYWkrZzdNNkJLTkRjdmlrOXJ3YStXMnZ0SFNRWUxJRkoyVFlRR3hCZ2QrU0plQW1mL2xacDkwY3gwR3VVR2dJcmtoaG5NajVjZ21zYlJFM0o0Ymd0b0hTZ3NPcjFDRWFIVDZsYWVuQmZFSndoczFDcnovSHRlRnpIOFcxRVhMRVpxaU1LNzk1RlpVQmVKMjIrekxIQ1p0eG55TzVHQzZQdGV1UDIvVlgra3dIUVByc0xmR3BEc2xZTE5LM3hWMk5mSUpmWE9yd05oYjdhSjRFbERyOGpRNWpxU1BBNkFnaWYzWEVsRHJNcGZpSGppcWxqdEJTQnpBNndrc2QwT2lJeEowRWNiaC9DUmx4d1hING40MG4vMnptQkQ3T2pKL2p1emg0QzMzY1lVaUhjbURzZ3U2QjZsbERza0FEZlBueGFSZXVIRDNxTU9RNmFOQUZuUVhyVVM1WW53Mk9EZ0JiRVAwM0FMWE94cytlZ3FONGpJQWJWNTdHdTZYRlhFMXVKUnVoTng2VXR6SkNQM3pqcDl6RTRwdFlML2ttQWQ4a2tMSHpDZDVrdmZCb2ZKU3BkcHE4RTlpejRoRE4rSGxqY1lUbU5zSG9pRmQvVVkyMWttQXNUcTBBd1pOUUp5bTVGc2lvVXpjencyYU9Cb0Vnb1U1U1FyeGtEZ20xUkFOemlHUXdKMlRVQWsyQkxTVFVWcnN1UDJmWjRkSlBQdG1YZStBRHlPZHRXYlpxM2Z4VGx6NHVkZVFjZWlUd2VlZVhydG9QaG81ZTlGTHo5OTdhOW1uQStmUEduMDZMYTA5c21EQjJZYk9XNys3ZTlYSEFpZmQ5UC85Q0t0NjRBV1BTNlBMNzRtenhET2VQVjc4Nmw4azFKQmhReitwb1lLWEQ1L0h3ZVdWaWt2Qk5FcGtMbnlTZWpNTEhXbXlDdW5HSFZkdzZZeGhRak5XUlpDeXVxWUdMTVJiWGdackJCOWVwYTZzZEdnVkNwSVQ0cEF3MnhNYUFUUUQ0bDcrSnljQXlldFAwd2swYnA4MG9HakM0YjYrQmczcjNIZ3luNEVkRm0vQ2pnWVBZbzBFb3JpMzh1SzJ3dHZDZGR3bzdUTnUvZjFyUEtWTjZkdWc1YlZwUDE2ZlQzbmxuV2tmbFdjYytreWIzdnA4bWpFM0RPTU56ZmNydkMwZngzTVJ6YVZ4amJqYkRHd2xQZ3FUTWlBWGZXQlJVcVlKdnFwRHBTWkdxNEpFNzYxU1J5QWVYVW9kOCtOZEpJUjhCN0c4bTlyZHc5bUVPRDhBZnhRa1ZLT0ZNQ2dnbnM0YzNXME1kb2xBc3dWT0NrU0lRZ0NZQXo0bGtzQmdTa2dNQW1TR01RY0cxNjJaaXNHUkRBTWFjVUI2alVDWUdvMU1HWm5mdTZOeXc3SzNlM1RhRGplbDFSNy9TOGloY01LbmIrZkdmUDFtK1lHL2ZBNjNRSU5FQXJlT3k5c1kxZmFtNFFmcHIvWExIOEpGRGR2WW8ycmR0Y3UrWkwwMUNNYTBkUTZaZjZYRlZYTnl4NjlkTys2a2g3bVp0WGdhM1JZTlF0ZC9hWmxOMkN6V2JMK2swdSthZ2VsbkRacko5SnpUbmJsT2FGY0ZWRUVCQ3NXQUZ6V09FNm5aU0c2OWNzUnQ2Q0h3K3BiOWRoTkxoS0trWForSzhPWXlKbUNoaFVDT1hHUU1rYURJYmcvQ3drempUSWhDNlY0cFlmdlhxOGdocFAzb0EyNE1Sc05rZzhNcFE5eC9vVUFnNjVQNWpSS3Noc0E0WVI5c01RdW5nRDQ4MmdaSERFMWczeUpSaGhNbVp0bERPQlA1QUQvWkpFY3V1M1ZnVUliME5RbUZqdE1qOTZaQld1VEFJdEE4QnIwQnpicXRCN2cvUW03VE5LRGlWYjR2cFp3RFhYRE5HakNOTy8wQ0JyS0svMVFrRmYvSU5XcDErL3BDaUJmUWpEd3lsVG04L3lna3d6ZlFsOURBeFUrUnRmS0pGRERiNGdtVHdHaXFKQmUyRllWNmdSUnc2ZUt2YjE1OTI0MzhlbVRNWmpFVUxDM05lUjk4MEJlbm84OGFrSCsyNEZVSzZjQmh6aDBnTzB6Y0hSMG16cENWTmxPQ2E0MHdKSmt4dVRUWTRBUnhETFNlaWpzQTVFZDdKUTlIZ2RoNjRUTnJxZ2hBSTVJN2pkVE55ZUR3Vi9DVXRQWkd1RmdnYy9tckxnaUQwQUZoMlkvaDAyQUFhNFdhOGE0STRQTXBpb01OYS9ESm9SSEhnRm15UXc5RTV3eHdOcEhFN01MeU1GeHllTTg1TGp4ZHhoQSttTFZpd2cvMG11bndXL0lYeTFtQ09NRTR0YzAxTHR5UUEyOEpSY01ESXFWSk5qdksxZVhqL0pzaTByU0Y3aXc4RzkxRjJMeVZ1NUpVK3htS1Rub0NINmJwdmhBbnhNQndZZzJ5MWcwekpqUHFZS0MzS0VCS2VYTHY2OU1tMWEzL1pIYnQzdjFPOGE5Y0JtSUYrUXFVZ0hZU0RsdmhmYlhRUjNRMzU3dmZmdjBOdjN2enp5UzAybHVQbC84QmRZZ21lMzhZYVRxNzBUSjBNek1rRlpUNktlUTExaGJ5SWtTWXRYVXd3aVJtSmNKY2RMUUcvR01RR3FWMTcwdmFIWTU1dXdtT1A0TEpZK3liY3BNbXpmUjJqZ3FWTzNzUVJWRFFaaTcwMWZ6QVpIWDZsVGd0bm9tK3NEaktBUWxETUNjbEpNalV5QUV1Y1lITFp3WTNabzlZdDJyVnZEQlQvdW56ODlwcDVhQXlFdi9hRlVXK2U2enQveDVIMTBtSFgxY1AycDJ0UkE1SDBjM0Q1ZmY0SjdtY0tsOC82R1lpN0ZxajBNeExmUkZKcEtUS1FTVXZPL2h6SWRscnh4UkZvTERab2VobEloQjRIWnl4TzBaQlJjd29kVUtUUkVWdUtyMW9TaTllVkxPQno0NkFNTnlHK3FzSnRNVVFxQUNzWGJ0NnhmdTJpZzNsUS9QdkVSM2VuajVzL3Irek1TZlNyQ1BOT3Jkdnd6dUczRnZMaG02Zk8zN1p6bnZUMjdhOVBERDFVSS9ub3RBOXZYanNsTFhSc1hiMXVKY0hIbG5oTjJtSDg5ZUVDdVZjcWtVSlUyUkFJVkVvQTFtS29HYUJFSlNmZlVxY1g5SlZGRVgreW43RzRSUGN6c0lFNFU3S0JIM3JuVG9HN0c5dzh5ejBTUmtrMjhGVU9XZ2J5V3ZBdVZ5TGZCSTVpK1BjVzNodGV1Qzh4M0JEV0U0QmZEcFNlQk9DYkFJSi93RmpNYTZiVEt3Q1FOM3Rac1VqbkZHTzh5QTJXOG9LSnJGY2NxdW1ybDdHNGluYXFJd25WNFp1QXpMcEI1aEM4bTVJMHM0dm4zL0IrWi9pUmUzdmR6Tm41NzkyNWNiUGtOeEdPMkwxdzI5YXR5eGV0aklNcithZ3g3bit3M01PWGMxZHZvTC9QblpGV2Jqejkzdll6dlhyVGZiNFdqeVdHNG5veTExbERUWlRSaE9DYkVNcWxkUmpqREFpaHlCRmdMWTdVZEQzRVdCeXZ3NUxhb1JaRExjeGRwU2lNOTVnQzBBRnc0YUFPRjR4N2JsYUdBZWUxVzFFL3BuNWV4MjFmTlhvdi8vU2RQMCtmd3lKMjlGc1REOFY5c0hyRmdiZkZNL0d4ZzJLalhaL042TmdQL1hIdEN2b1oxQUFpR09NQ1RkenJwdzBlOGZrZlArNDg4RFZabXc0WVQ4amErSEZXTmhwZlBBQmZUeXh4K09wM0tVZHd3UWZ3aG9UTUlJNUkwNExYZzJjcHZuYmZGT0QxamVzVWYweHNpMzUybjBRTEprMENZMkVQWU1nbE1zNFFQSGYrZU80c1dLT3djcSt4OTVueEs4eksreWlLRXF5czZXMG0wMVVUNzhHYVpBL2lpM2Jpbkh4a1RjTFlBbXRHeWtKeG5LWjNabU54c201VzVaMG00SjFHcEJaRnJ1RVZ3WmZJdWRydmQ5NTRmYzVXOU96aVplUXVtdlA2dklmdkgvODk2NVBWYTA5L3VISHQ2ZXJGcytmdDJ6OS96anRDL1FuRjFhcWZuSDc2aTh0blpweXNYczB4NFhqcDU2N0ZiK3pmLzhiU2JkdjUxdE4yYjVrelk4TUdqRE85TU4zNVVjYVpqcFhvUEFyT0ZIT2FFUnBDS0JNMzZCSEczd05oRW9tSVNzUXhtRkdIdy9nU0RrSTRqUEhKbWRHQXlHWVp5cWhBK2E3VEdRZEhmL3lZS3ovK0JVSlB2dW00cVhWb2l6bERaeDVJUExSaDhidjdPdDI4dEtMdkVCQnkvUVpJUVEvUk05VEZqZTVGeHd5SnJRTHV6Qm0wL3RMMUovdjMzT2JLeTduMUdHa1NoSHBHTEF3OTVrd0d6bFQrbUY5RitMWXFyL29SQnNrUjJPR1lyeWNMRFl6SkdPb3B2OW9rY1lFV1RvR2x6RlNHcFhnNGlaL1BsMkpKS1pzN2FBQ1NrT29jSTRGOHAxWEN5MytMWFByVGl3RmZ4aGp3SDI2UmIxWnk4U1lYSUJtWURPc1FTeDFDYVVtQ1lCTmd2c05nSkRxcWQybEpEZTlHM2pBZjQ0TEJiQUZtekZiTUlIN2tTSmpyT3NNM2hNMnJTRlhRazJsZzhrQXdhUnJqNTIrQ1hmd1ZmaS9WclJ0eHVIayt0Y1FJWWdITWRob0J5Q2ZFU2tNdm5VYlNWM3pKOWxCWm1UeENCQ0QraXVzRTM1ejg0MThhN2k0YmpzYzhCWS81bkRKbUNIZ3lab2piNlEvSjBNamxGcmw0NHd2UllMSDJ5K0dCNE81QURNT1RpZURKREpGdnQvQUZ5eEo0NUhqOEpRbWlUY1F3Qmg1U0xocWNRVWVjbVpFOGhlL2dPZ2p0STBmeTNTYWp1UVBSbkNrZ0tGS0t3dVB0aURkb0c0cWowVnlQU3JpNHloMGpJZ2xyZGtSWU1RT1BlREVEanpESnZEQktZMjdBTkZuaDVnWU5GOFRLQTdWQ1RBUXAyU01IejU4MkFiTVF5SCs5NitDRk9aT2FSQm9YTGdTclpnM3RscmRtM1BSRkM4WkxPMCtjM3pmdjg3RVpmUWVna2V2cFdnMUZEYVdmeFVXY2pYdVpHODlocnU1SXR6cFNyVHFLb2hQQ25KSTNZZkZhRmRLUmJpeU8xdHltR291cmFtNHhoY25VOGYvaWw3UnFKVllTeUs2amVoRm1PelpDeG0yOFJJZ0pKcEJ4c1J3UHVUajgzWUloWXJsZytnaXdQemNDbWNHVTRrdFhmTDYrMlBFMVU4YkczRm56Z3kwUDl2UWIyeEx5dFgwNlpTN1o2UnVFSEdnMWVoLzFOUVdEVWFCeno1SW1NYzB1OWtlejBZRGdJUEFWS0FEendJS3lJOGF1QTdvdnJnT3NzUjNUNWpvZ3VJbyt6TzB6WU9Cdlp4Q3daV1JDOTRlekIvenpNWmdERHFEcWFEcWFnMnJXU0doWFBRMDhCZzZ3QjBvb3l2MTB3NUh1WTdGK0JXTXRFYit5ZlJDTCtjTXR6QjhNV05KdnBkYzRkUGFhaXYxUGhRb295RUtGbDJiV0JHWXFJbFlZTEQ4a2dEaVF3SC9temxrOUJWYlBoNGxUWEU5aGUzUlRBcXZSY05IeHJCUGVFQ0VjMVkxUDRqN01venFQQmZjbnV4SVpRcEV4bldFY0ZSckNyRTVyR0dZWmdWcDVJakNNaW5YR1lxUFdwR1FzanRGdVY1c3BUaXVhQVh4TDVZWkUrVFB1SkhqckIzZmhxRG03M0YraTZXRDYxaU83TjZOUklLdG8veEVIdWlnNlRuNlF0eXMyN1B6c2p5N0RFKzdkbTVmTzJwT3pjTjRiQ3ltTm00MzUzejY4eDZLNDF2L09hNGxCQzNQY1lOM2M2ZVJuUEpWUlpDb3RFbVpxSEZZbU1mRVhzSTVLTUFsR2daQWdnbHJDMnpBWS9mclRZL1ExU0huOE16QUd3N3l3YzBkTzNyMTc4c2g1Qy9oWXVsNEcrZ1BMUXhBS0J2NTFTenIwQWJwNjk5RXY2TnJ4WTNqZHlaeC9odWZjRytzL0RmOWx4c2tFYWcxeWVIcDlQZVl6bHNNS05CZEhwcEpyakNXWmhKTmdOL0FGZmRFTzlDZldYZEt1QWd2NitZcm9RQnZSdldQb1oxUWt0aTJMQkxYdW5yZ0RhdEY1STMzcGhmdml5M1d2eEM2aVNySStnc1FzUlU2ckQxNTdvSjg5blhScjFPSWx3VWdUVVZUcFAvNngrMlUrd1pYTHYrbTZEZCtIcDl3N2NrUkhydnVHM0k4QmRFNkcvTXRPd0NLendBUlhaMzh2a0YwUzQyWDF3c1E0eXd2a2x4UjZMZlhDSE1TS256c0w4UVBQVGtvZXZVcVErL1RNM2FpQTMrcjZHcDZHYjd1N2svNThqUHV6QXVQVFJZeFBzVnkvZjljNEhZR2xSTzhNMHV1ZDRack5FY1A3TUFOYVNXQk1UQXpNTG83V1NSa1V5N0JTcXNVeXJKVlNMQ1BNVGJpWWp0eG5FRG9HTXY2NkQ3ek5jRXpFaDhkUFAwS2ZMYitRaUthQ3N2MnRKNFBlSUJpdmVnRG9ldis0dE9JUXVuTVRQYjZEdnUyY0JxYmt5bk43ajY3eG1FcldXRGN3RmZWMHErL0ZWbCtaOVFOZUo4bE0zeUxmdGJOT2xrR3JaaERGMzBRbUdpT3F5U2JjSzNDZExpamdHeFhBSXZjZzBlSHVDdmN4SGVZYXZuU205b0NvU2l6dFNwZG9hemJRMlc3SG9FeXV3YkpmTWI0eEt2SzFUbHVnaWpoZEkySklML2JYYTR3bWFvbFV0UmUrdnYzaDhjK0lGcmhuNDV4OW9xUHM0Y2Yzdi94VUt0cCthQzJuN3BOZktaM01xUVEvdmZDTlY2VmtXOUhBbkJMRFhNbktoQzBpZTVVVVNrc2xxTnROVGw4Z1Via0NKTkI1c3dHYnhSc1lFZ0Q2cEtEZ1k5aDRIblR2Z25QZ0VyamYzUVZQNFNCWUpMcnJ1K05FdFk4RzNFZVJxLzR2ZTBnckNXUDBJNXZBQmpKaHFldUlQUWR2UjlhT2xJYS9tYmd1bGN5cnpwU3NUcktLU2NvTjFmL2xMVUtrS3lLNllHRXhMZDBiOHljYkhseHdNbVpUaG1EOERmU0ZGZ21HRnhYNFNPNGZ1cmp2U0w0Rm1Fa2hFV0pHTlF0T2hjK1E0QUx1K2U2cGRPSFpPQjlSZkg3NS93cWZpU1FMYVplOFNnbFdBUU9aYTVDSmNmUlJnZXVNWkxmekRhVUM0UTRvaThLWUVBMkU3eG0vbm9KcHdrLy9UK3hRUkVZaGpJVjhKTmVCS2w4SnloQitRaGVRcTV4RGwwQWE0SUFBNmhZOCtyTDA1M3VsWHoyRUE5RlBhQWZvQ3lJZWduRFFEMjFEZCtFREVJdStlL0RvVi9RZGlIbkV5YnhsRmJWTkJDdFdUTjJDVVVaRExUR0FaNVlZTFU4aFhRM1NkWldRU2NxMEs3ZzA3aEw0ODhleXNoL1JUREN0NUZESklUUVRacnUzaTQ1N0gzejRjKzY3Q3hjZHBYTlZRd3pBY3hYTXhTbjlNT0pYRzUvVFJubHZJK21IMFZoc0FUcVpVRWNsUVFnMFdBeUpWTVI3MGNTTnlubldCZjNkY0ZhYkY4emVEdlJQbHdmdC9vbUsrdGNweEgwL2p1ZXdWRHlBNWZVRWhTdFdPb2YwSmdqZkJPa25WS3RNKzNCVWkrWTlqUkhxdkdKaENBOGgxR0xHbEo5NlJDcm0yVllBSHY3eWJPNmtlUVd4aVpNU28vZHZRTVBBMERPSEQ3Mkwzb0FyM0tQRkE1K2RHZmR1U3Z5QjJRdGFqSXdQcXpxejFaeTVHM0kzejF1MkFlK1IvaGhYN1hqK2t4V1pUbWVoaXNJM1VYVDJveFJ2V0FBMU1udWdyWFpKb295TytGSjhMVTZzek9OVkZYTXZUM2VYb0xHK0Naenp4cU8vUVBEVjcwR0l3SSsrVkh6Z3pPRmI5LzlFUDl6NEJoMFQ0V2kwYi85WElLZGdUWU5HSDJ6ZmZmbFppYlRpK01aeG8xZldhL1RwN25jdVhyOHN2YjFqTGQzN05mSGFMS1V5czdXU3ZhL3V3T2VjbXdyTHgveDBLZksxSTE5aGtOajIyV0d4YmE1c3g2WStJa0x6NmxaQzgzVDBYU0VqSGl6RnhHd2dtR2d6bG1JU2pxSWJ2OXhGdCszZkZwZmNGaDJ1eEY5ZDdvZjhkVmZpZXhmT0grT3ZzL2NTSGVBU2xYdHEvaWUrb21nQWREU0pGbHNtRmZSdHNHZVVGQVVPelhSL24rLytmdVpmQXdjSzd6M3JST2w0ZlV6SGlaM2RyTkJ4WGRzNjBrWE5KRG92cWlkK08veU1Ea01wSWVVQ2tYbndnR01BNllHbEthRDlTRTR3a042QTkydEltYUJPUHFpVElWbUJZUko2SXg4ZFRaSVMwZUd4NkkzSllPTXQ4SjBRVXZiZ2UvTHhySk9Rdlc1ZDJYYUZuemZFYytHZ2RMMVRKVkt4cnI4cUtTYzNCbnhqb0g1dGc0K016ZFJsNHVEcFZXSk14eHNrMFAvYjREaXdZVG1xQXA0c1JkMVE5K1hnQ1lwY3pqZUhvOTIxM2RGd3Buc2F2QTB2MHY3RTRmNjhoL3ZqeGFWWDBoLzYxa3JDQVF5VWZ4TXVSMWliRFk0RUh5MTBQeXh3Lzc0UXp1T3J1NGE0SDhCSS9rM1Nmbi9jL2dpNjlyTDJwMnV5TW43dEZDQTFkUnAwNk8zMEZ0bExNekV6enlCR0VmT3YvTlN5SjN4djF5bis4NXljdnNLdnVUM3crN2FqVDhCRGFUcmVPOGtjZmhkeEIrR0dPTDJZckpQZlNCQURFWkxCdzh1WDBXSFFWb3I0SnlUWGNBUzNsVlkraXhjVkh3NjA2clpNV25vd3hvaTA4WERBZU5IeHp4ZDBMam44N25iMDNWV3B6NGUzRmd0NjFjYWdmYkdKMkhXd2xBRGFvVU5mZkNGTi83dE5ydlNBeW56d0duVFJPVXZ3bEJYVnlBbVJCaVVZU09RRVZZWjVqSnVueG9IVTNpQmwzT2xvS1JvM2NjVmRIZHdaUHB6aEhTamZ3SStsMm5BVlRrZEc5S0tTU0N4TlkxMUwrZnljSFBxN2JPRTk4SkY0bWhPNGFnNUtqcXpPUXVMUVVEMDlKWnVGQXdMTVBod294QWhXZ2M4bUU4cG4yc0JINDMrSDYvR1BSWkhaV0xBYys0blFFZE9DVkc0RzYwRTQ3a0c0WDJWQ2pHb0g0S1Z3Nm84T2wyVFhwTlVmaTVTeC9tbitNTjhScmlQbHpoQi94UXNkcHlQd2pxb2t4a05QMGVNd09aZWQwRlViS3Y0aEsyQVdKVXpiTEluRStNbklQTi9PejZmUkoxT0xEZ0QrMjBkdnpwMjZjelNVN3BVYy9NWS8wUDFzeHRrYXYyLy9hR0ptcCtyZDh2WXNYbDB5ZDl6c2FYMkFOUEhrNGJmZEQrcVB6T2cyc2QvdGhVTjdqbUd5MVNaTWZ5VXBETlBmR0c2d2htT0ZhT1ZvUDQ4TjcyRjQ0b24zM2VrYndETjNSckZaejh5cWVBZ1V4S3BrSUVJMjlRYVlFb2c0SVJsTTBkU2RKRWpmbmlyWWwrRS8xRjUzejdpUHZwMjRaZFBVZFluVk5rL1lWQVRLSDZOYi9YdHRsOExjOWo2RDBUbmt2Z1Q0S1FPUnBkK1luMDlUdkJpSTEvTXp2SjVSWEF1Tkw4eFBTOU05a012aFJZbFZvTkVSUXE1YXZrdnQwQmsyU3lqV1Z5QVdFSWdCVEdHMFJIQ0Exb0xEdzZINGJNZU4zLys0N253b3dCRUhDdC9admF2VC9JblM2dlBBK212S0E1QjJlYTgwYzhNLzc2ZDg4RGVkNnpHNGYxL0ljejFBUTNsQ3REUHE1eUdvZVdnejJybisxNGtPTmxLVEhaNW1GdHNBNWVpUFRCUFRkTWRjUDUyL0s3Tmd1RS9kdDEvLzhMcDlVOUc0RGFuVlYwOHMyZ3hEQUE4eUIvU0VNLy81ZVZQM3ZpRHU4ZW1maC9VRnJuN2o4WXpUY2ZURjR5akY4eHlLeDlGVk13N1BmZVAwNWFnQjI5ZnFhYUV5NkVVY1g0KytpL0hVcUVJalYrS1kvNEtZR1htTUpwWTQ0aXFxY3dFOUJyNG5QcjdqRmo0c3lpdXFaMnQ4Yk5tY2trQUlKKzB5Z3hvL1pmNE1hcnN1NTBhOSsxZVRCcTgyYThlN0w2d1RveGVmSURqU0hBL2dvRlNUczNEek9lS0hlMjdlZy9GTjhITVVJTmlvTTJ2QVV1Y0Fvbm4vUmk1NVdQMG1sby9zRXF0WFU2S1VwNUVIVzhnRGg5Y0h4RTdDZVlHeHhLVVhxRzNDU0dLNlFrdUpPU2todzhhOE42cWpqR2lIZng0OHVIMWxYSXVFd0RCYi9LQmhBQ0xFWHgxVXROM3A0ejFZTWt6Skt4cmtxc2IyOEJqVWp2K2E0bjBxTjYyUzlkQ05qd29aUHZKTkJMNkpZSGhGN2Q1K09nT2QweEpCdDNTRW5ueFpLUG5DdWx4aUtjRzZhcFZnWGFhczV4T2ZqYTNDbmVPQmdUZk92TDRuTXlEbjdzV09qdVl4elpaMEx0cWF1U2Z2b3h2MkxSZ1hVNUxYVEN6YXhuQXhwKy8rc2k4Ly95TXBMaWMyN3ZDMithLzJBdkYvZkhSdmVEYjRxNThkdVpqTVVJVFp5RGQ0YndWekhiZ0srYW5TbmFXallsUTVvZ0lFYjVRVkJqOGR2U0pFQ3RQZkJCTXo4Vk9OTmJSdWlYM3Z1L2FGa3lidlRNWks2NHlCSTcrODVjNkJteHpyWm94d0Uyb0t1ZjI0VTFYeE4rWnJxZUFnSVZvcDR6azBJNjRlTmRadG1RaXltZkdGSUFpb1dvRC9FeHFBdW52d21wY3ZSdTFBS200L0VJKzRUU1VqcGszNmFhVWt2T1k2bFRQSTZEQlZ2TXRFM2dWMHE1WmhvaDZNMUMxTG9qT2kvSTMxekwyRzVKTWVsSTNhZmNqSE8wZjBtV3dYVm9JR08rajhiOGJ6VCtLVUFoU0tvTVlwcWJUWHowUEE4clRUZURFN3pYOWxsdG42aHQwK0RheFlCRkVXdU1rdmdJSHUzNlV3Vno5d1drUmg3aU1pa3k4cTFrQnIzd3J4bUhUWnZvV25GNFBTMzJHTlJ5ckUreWxSaWFsNGZqS1ZHeW9jKzNtTVJiZTE2STBhQlFraWlEWEthUkRvZHZQUjI4TmpxUFdiSXB6RkErMUM5Q2dJZU44NisrMVRkbGROUHpSei8zSDc0bWtMMXdhQmlVdW5GcjRaUFZGb2NMRC9NUHZrc1ROKyt0MjlBRTc4Wk9jNzh3MFJrcnNBVGp6OTFveFJiaStoZ2JKZnJ1RXhxdnZseFdOVUdHZUZBNDNGV0ZCdm1PQnA0ZlBzT2VtdGwyK2Q0b21PSS9hRjA2ZHRUckFMRGQ0Zk11cktIZmNvdU9LOTlYTkd1LzFKandnZEkvR0NZYmhQeE01VGozdCs0eXAycm44MThnUVR2c0ZGVVo4eGh5a09NVkpnWmtKTUZtWXNCbDI5QmlSVWR2VWI5TXgrNHUzZEp6L1lzK2NFclBtSUJCazlpdnNOWFFMcHZ4MHZKK0ZGY1VjSndUM0taQ1EwUUJCeHZ6eGxKTjI2NjZpTGo1YnUvTi9LU0FUakxaWEtTT0szcDhidXJXdlBDYXk3Rjh0STloMUZFOWNrVmQ4d2J0TjJLaU4xNytTK0pINnpwL2NnSWlOZEJNTHJmZDEvOThwOThKSE1Ld2J3RitXeERQaFB2SUtPMHVlNW5mcS95aUNaeE96NEFobGt6TzY2ZnNNS01uZU5wakpJM3JvYTFkZThyc2dnMmQwM1AwdUN0Yks2RWhua2ZrNFBHTlFySDVWZFV1ZzkzSUxIWWVTYVZUSUtHb3FnM0tpMlVuOGRFM2Y2K0xNUU1KQXMwM1dMbWUwOXVLeFgvdklZKzJ1QjFxSlJsdFFBTExNVmpuR2JoUVlsZmtQeURBS2pFY093RExRSnZ6K1pHMWtKUmxScTUzRkdCV0Jwd1E5Zi9odUxqek00SGdPK3lPeFRWeU9OcWxIT3pMQk9jWVJQbXJyOXc2T2Y3M3YzYXhHT1dUTjkxcXo4dDA1OWNMM2t6UGNTSEcwb3RzOWNEWUxiajYyYThzYTBLWHNQelpkNnpjNXYzMjVRWXVxYjArZnRQajVUR2o5OExCMWpVdmw5bUM5bVlWbXBuMFlQVjhaSWcxeVVHOVhxREl3YWhWQWYvVVFFYkMrOUdoUmNpZ1Z2d25kSURKWXE1eEVkaUxBOEUrajk2NjhkbWtWbFZnMks3cDQ2dHZEWU1URUwzUi9rYmpxOGx5ajE4ZzlZdGhHZUdnVE10Sy9yOFhwY3dZUWttR3RiQ1Q1UUxxL2NxSllWM1E1bC9GL1AvQlBsdnNpbXBVekNpZm5CZFJ6MnZSL2E1MDJadnkzV1ByeTQvOUNmbjhEWDNRdlA3cHMwZ29kbFozRmZhbURhK2hIdWk5NjI1RmNaTDlUWmxvQnFXd0tYRTZRa2tEUUY1UXhBUTZhQXdNSkNQclhzTEtPVGdIdUo0OFRUK0Vadlg2cVVKVkg3a2s3MCs4LzJKZHlMWUZzd3ZUSWRucnEyNTFXWGJEOE4vYW1PVlBQTUZIUW05emVybFBaZ0tEbzdCZlEvZFFwZWR5ZWVQUXV2bDUyRmQ0NGRjMWVoSFFWY2JUd1BKZmk3cjlKUEhmN28rbG01WFlueklmcURVNkxtSmF4NEV4dU0wNXVURkV1UGFsb0NmNERFSldnNW1MWUlmWW8rWFFJSzBmTEZjRHA0ei8zUWZRMThobXd3R1FhenVVdkFzdko1T25lTksrRXd1dW1pQytWRFdKMVhDRUdOUUQyZnc3SUlGV3NWY1luYTR6NVBra0RydVNnbFplNE1jNk9BQUw4TXY0Nzk0dXFqZm5OQTRneCtkVm40NlBYZTRoQW9qdW14UXFoQis5TWJ6OUYraWl1dEtzSGJ5bTFSSFB6dmJGSHdwR3MvWE9TZXp3Zm01UFRrSncvdGhkL1hBbzJFNjZYR1hEU1hSS05LT0t2VGl3dGtYa1pkY0ovRjRNV29vMndlejZDSkEzUi9Sb0VLOHptYyt1NkcvQWtUOGplOEcxRTR2azkyZHArQzZXaGs1c08zYjA5YU1HenU1RHQ3SDJWbVZUKy85TTdvYlluSjIwZmRYbm9tQmZmQmlmNEFsaGZHSVJQYkY3RGs1S0EvcEJOc3pieHhuL3RyK2h4dGRZWkcwejZIV3JXRTAybXdoTExnb0NhQTlwVjFuYXdQNmF2TlREVjN5ZUJkYU84M2VIQy84WVVSaHpmbUZSVGtiWGdYSFU4NXMvUjIzcmFxQ2R2eTd5dzdWejByODlIZU81UG1EVnN3NmZiYkR6TkpINWFDM2NJOVBwZ0x4MWp0OUE3bFV4MmhldUxtVjRyM0Z5SHNXajAzdk5RUmJxWEJlZ1JQcUc1blRtYWFuc3pLNzIyYjJITjV6MmFqNm1XOU5yQm9jbytWdlpxT3FOOWhKTHd6NDNqcnJMb1pFNGNFempyY3RuMTkyL1JCbUhjdlIyK0FHSXdyUktkSVVXZE9DVkJ6OG5SamtLQjhTUlAxck1tSUNySGJmWmNzUVcvd2wwRVNzU1ZPS3ZmbGZ4S1R1QVJ1T1BjOFNhZUJISjcyRWw5cUwvR2xFV2krbWxRZWg1bm1LdUZyaVBaUkJIbFVIRldaVllXazVDUlJ3NG8rWjRmYVZ0b1VIQjRCaFMvZnRKLzQ3T0w3OXFJTFBGOWhYVm53WWRBUGR5d2crWHJLTlpBYzl1MTEwNmViVkNzTG9MbFlhVFRuUkpiZGRSWjJoZHpxYktCZXBjNDRpZXh3UjV6VmFZMGpFWGx4eEVrY3R6UU9abXZkUnc3L1VrY2NEV1FKb1JsWUlaNXltd1VqRjlsK3RpWWdJeG5QT0svbjA4RnhackRBWUt2RkExY1huMWF0REpjdStIN3BQSGFjNS9NVzJLY3U5d1Vmd3BtT0VSODJ5OGtKL01udXlBWFZQcjEzNlIxcDFRTEhablExbDhodW84cC9GUHNMdjlOSTB5VE95WnN4RnZLNnVGQXkyeldmNTJESmhtUVdJSnFabkNuckY1a1dGZzFrc0Jpd3FJd2w1b3c2UkdBV1JuUTZOM3JNdWF3TjNUWTNhdGF5Mlo1dXV6dCtPR0w0aDFsdmQ5L2JwRVd6QnR1N2wvME5Jajg1Q3lMUmoyYy9RVC9PYVp1VjlVcFI5NjJkVDQvTysvVFZ2VDNlZnZtVmRpL3Y3M25nMVhOalJwN3V0S01Ibkh3RlhRYTFybndGYXFJdlZEL1NDcnozUTdteGJIMUM4WktFNmp4OG51NFFaMkF3bityay9NamVMZ2tNamdtRzJZNWdpb2ZCK3ZnUHFkUVpHMGdEMndsSHc5SkdnT2FQUHJJTEhLK1BXYzNnSVA4RE50Z2Y3Rm1JNm9QWFVSK3dFL1VwWUFsd1lDeXF2eERlZ0YrNFRia0hjdEY3b0JYK2dJL3dPbXhXNlplQkM5UHZRNUswQWtRK0ZkTWdreTJjN0x6TmRyc2QvY0h6TGpmL0NmeExqdTB6Q2YweGp0cTRsdHdDbG1taTZJams5eGFhRlhjNHlWTFgwc3JDWnpzc3h1TEcyakJoUytNWHVRNmQ2VFE5N25EMTlQcnByNlRqbjZZYmkrdG8vaHhWSjUxbHp6bXFsVDZmUTZlTjNZZEtWTGFjVmllN0dqMWt6c1JhSUpsbVNlSHZGaG9GS2ZTZk5McGZ2L0t2djBJM1JaaDN1Mmo3MGZWWEh2OHlmbmp2bm9DN2N2TWZBZVlkMzduZnVlcjdwN2ZkZjFackhaTTN0dWhKZkpPbzEyZThEUTRNV2h4WGUvR0lYU2MrKzFhQys0c1dqeGx1Yjl5NGVQZWdKZkhwaTEvYmV2cldlV254OFNXangwNW8rdEx1T2Q1bXY0QUozY2ROYU9FVDVPMC92dXZJcVV4LzNDWUc4NG55dW1UU3BCc3JoNlYvSXR1SW1oelJadDRrL21PemRFQVNzcHQ1WjBuOXBURlNvU1RrT3lDUmZ2QzJGY25XVGR5L0g2Vys4NDRZdkduVEp0emlpUEw3NGwvaWFTNktxODVsa0loTXNtUTE4WkxWVk5EVmhtOXNoTGJFYVdJc2ErTHRxY2s2RWVLU3FkSnNkZm9teHpIVHFOUG9TMHdDeGNHYVg1SEFPTTJ2b2dSZnhvcXBNVHFwTWRDUkZjcmE4Rm9sTXU4OHZmS2E3MEl2S094Y3VlYnc0VFVyZHdtd3oramhvNmRNSGpOaXBPdERNQW9JQUlBeGFBVkN5SVZXZGdORm9CcElCa1ZvSVBvR1hVV0RZRmRwZGRGWDd4VHN1MUwwcHBRL2V2Y00rK3lkSThmTlFmZFFJWmdCU01oeElacUI3b09Hd0lFNm9UUG9OTW1ESW5sRHNBVCtUV080VWptN3hxOUNrRnVxRVM2SDQ4U1N5R0t1bEVnZ3NrdkZqMzdnZlg5NHBOOFV2MFYrZkxhenZSOTQzcW5pVjVsVHhjOVluT1NSNmFmbTlQMG5kd3BjNE8wTEV5ZDNLWmhadFByd3ExbDljd1pEY2NlOHlTdjlBdERHVnJOQ0RnMTRMUXQrR0o1WkphUGxwT0d2ald2Y0xidGRhMjlwME15bGM5RFp0RjQxT3JlM3J1eFFyM2xyR2g4K21kdkdOK1AzR3BQNFZvR2MwY0MzQWkwbzNac0Nadko3ZUM5T0pMNHVVWitZQW5TOG1uaTc5dGpkN2ZrYVlDYW9NaHkzS2VlR0JVbFkyOFhrazh2RnVQZ0h4a1ZmckpuVjVocHliMVFTSzZHNEQ0b0Q5Um1tWmcxZWhYdFRhMFM0MVJuSlV6VTEwbHJDUlJvalliWXpMRHhTamptTkpUR25OczJ2NG0wMDVqVGM2RWlsS1VFTmRibW9Hc1RUZnYrWHVJdGtKVWNvVjhhL3pSai9yaEg4NndaR0F4NUFNSnBpcUJ1dEFKY0dBYml5NkpVV0xScDVlZWY2Q08xN0hUK1VOYUx2NjF2Z05UMFNna1llU09wRUcvbFhwMDFxTVRnNmZIaTdldFdhbTQzbXppbDF1N2J0MDdsTnQ3WTAzMHZNNHIwbzdUQnltRzVvcytpSU1NMTcwWml2cklHRXppemx2NFFUTUg2VCtjL3dtUHRBNVhmRjNpK2NlQ1ZsbDZuc21abzhucVhMY2dZdlhUSWtaMW52WHMxZjZ0SGpwZWE5aEF1NXExYmxEbHU2YkdpTG5qMWJ0T2pURjcrL0c1Y21DTUpqL1A1QXJnSHRMWlk4OWNIN1pEdG9BNFdGUUJwRERJMXlGcFMzUnlJanpUQWNDT1lqKzJnMENCU05CdHRkNy9Ndjg0MXowQ3ZnM1J4d3VLd3hpZGZBdURnQmJvQUh4STlOUEw4RFQ4VUdKZk5CaWF0UFM4Y3dyOE9sOEl4NEZzUHN4RERyRlpocUdLWWFoYUY1cmNmQk5mRXM5ZUVLVnBJaTZTd1VDRUdvOE9GeUJ6aml3K1Zpc0xoRGZiZ2tGUis4dkpML1o2UjRWa0l1dXErMm9RSDhGMVNmNjFlSkhWT25hMVBQam85VysvU01tZE9LaFU2L1FLSUFPWU84QWhueDFkZ0FHR0VoQmpvUXZtVGlndFZWN0VOOTB6YU82dmxHelFLaGdYdmVwVzBGWTNpaDdPeUdibjBhTlhjL0ZiL0IvWHdWNjNteE5ENnNLbGZSdGVkaXZRSEh0QzY4TVBGRUpHc0lUSERQOEh2SURmaDd0NkVYNEQrL0JNUm5uWmhldEF2bWdaZjRxZ3hub1ZWUFI3QzgvOUtHRFRDdmhNRU9RaDBBeVN3STVKcDY1SXVxdjNKNHFiaHIwT0F1UnF3QUxlN2FaQ2tobWNrSG1YLzVaUTBzV21ub1BibkxzQ2pNVHJ2MEdkV3hjY1A2TmIwS0tiNzBnT3RBVC9FTXhvWHQ1ZVZ3bllJTFNyWW14Z1hLTC9nQU9iNnZnWDQvT1gycXlLbnl6bGdTQVAzdmx0OFg1N3JQTzdCcWxlUEF5amNkSTBlTkhEb21iOWl3TWNLRVZjZU9yUnIzNXRHamI0NllQV2Y0dUdGejV3N0QvWjJKNlhjSFNyOWJSeEg2M1JyMHBPUFl3bkhpZStKcFl6Sy9uV3NEMStMUFY0QVhYaXdEdndzZTRMam54eVgvNWh6OXpTdFl4dlpTZm90L3M0T1BxUGlORWlGR2Y3T0k0NlNGNHNmME4xZm9iM2J4MHprTy8yWW5GMTZ4M3hyaDN6UlM1bThrbXNEbkNBMXBua3NIRHU5RkNrS3pXNGhleUpraTVkelAvNXllNnBuZEVnQllHanpCZk9ZTHB6bnlXTllqVlNaZ0k1amFkOVNnZVlYamw4RThDTC9lV1hKKzl1VEdWWXdMRjhKZHM0WjF6Vjh6VnMxdW1mUDU2M1d5QjRBM04rQXgwdndMUTBKUUV0NExKTi9xWlV5ayszUGUzRUUvWGhTdzZNeXBNREVxekFUd0JlaEZZSXk4b0lleEtUQ2dHM2NUWkJPWUFNR2puZG9xVEIvdUN3eUhZUUk5WVNUMVhjTzVnNkE3M2lrSC9VVU13NHB4MEpRdUZYYVkybDR2MEFpc0pyQm0waStpODBZeVdMd3VKbzR6eE9BOUg4aUZjTHNxaVpxclBPaWJGMlExM3ZtSUIvbUhZM2dyMzVUbjh6MEMvSjArbkM0elFHTzNKTTcyQVAwKzBkb2t2SWltN293S0F2bk94dmhTY2lIb2VoRG0rS240TzBsTzVra21DK1lNd2ZRZmlPT1REWVlZMXlXVGUrK1BLL2g4Zm9DN3JRVjJjTDhiQVU4ODJ3Y0RFcVJBTUFkTkp0SDd0M0xkMjhCeXZHRnFrSG1halZxU3ZCQThUMGtZMFEzY0pIQzcvRy84bk9ZOTBMV3Z4dGFlKzBOWmUwbFpEd1lUbzhKTUFBNWw3VDFnYkFvTVh0TmpiTzJOZ2dlTXBMWXpuRnZHMXRVb1loaUhrZVgvMG5VdGY0cUpaRGJ0VnczV3IvTDFyRjhDRDVYMnp1TkZ0ZEorTVpnSlhIZldMNjhLR0I3RDFLTDlxc0g2VlQ2WTlVc1NlQm1tL0JzTWswMzd4ZG9aWGw2UDljdEx4TzJRQlJKVkhNTFNvM0FmNHhDaGphLzlTNmE3VStCRVdiWG9MNUE0ZDNMSkVqelNNUUpLUFNNeFJCMFJKVGJnQ0NVa1FjMXlDWTVUMDF6d3R4dnIxbFhrdWxSRis1UmtGMVFLdXNMaVhMaE96WG1CeGU0U09lZkYvWm04SG8vb1hreG5leEdFS1h0UlhUTWE2MjJvaDJGcXk3UWhIWXdqTUZWNEh6MU1IUlZtQW5nRVJoT1lXRStZTmdvTWZzOHpNSmJBUkFzZU1LMVZtRDdjSXpDY3dNUjR3a1NxN3hyT1hRSWp5RnJGaWhqR0VjdHlsaGlQemVZZThXZUZYbGd1QytXY2dnK2Y2Z1Erc3J2WGg5a2x2VUdtTnlBZWJHK1FEWExSVzFtZ08raVJoZDRDdVZsb1Bkb0FtbUNkckY4bnRJMWUwTW9zTUJLdFl2bGlVOHIzQ1QrSjMzUGhYQ0tldmE2VlJIYXJ3WE8xTk90cDFNVS9PNk5yeFpQK3hNVFhJaDhwN0NPVlBtVGg4VFEwaTlwTjhRMTEzUkZ1TDRhRXhnREFmSFp4bU9jbkFHSzlWSUxtKzI1K2FjQ3dXZDE3azlEdlVVZGZHVEJzL3N0dFhBRU42MG53OVFZYitwZit6RTlPVFpiY0syMnpPaWl4OU5hYUc3N3MrblExalFWdjNtVGp6YTYzWmo2Y2NLb1o0TjMxRzZQdkhnemMzZGdWV0swNkN3dkhhMEJqaE9uZXJDZmpSQ08yTjRONEwyV2RHRXlNQ2pNQlBHTjdNOVFUeHFiQWdHNUFaSHN6VlBDQWtkUjJoblBmc0wwWkttSVlSeWp4V1NtOGdNYXBHc0l3YkNQNW5mdkJxNlE5Zjk1QTI4UDc5MTBNMDRibW9wdVZTaEs2Q0dkRkRzV1NudzlMTDNSNisxQXU3VTFsZW8xem5SaDdBblFxcnBJaVFNVDRZQ1dyRDFoQml4dC8vMzBESGJmYlFZdjlEc2QrMFlGSzc3NTc5RWQwSEg4YjRWNXlwSERtVVlLdmEvQlkyNGcvYzhta21vSm9mWjRucWM1K2I1TkljMHUxdGlTUnlndVlmbFQxeUR4U2RCdHpDR2ZXeFpQVXdSS3RVakFDQk5vLzI3dm95R1NROSszRzdvZVM0NnV2YkRWMU9WbzJ6ZDVoNG5LaHdhZTNOeThkOVZYSDd1ak84blhiclhFNU1lbjIvb05CNUx6c2E2LzJmWDF2RVo1N0dyc3Azc1p6MzBMbUk5dXc5SVBudm9ZUXJxd2xnN21wd2t3QUE3Z3dBcFBtQ2ZPSERDT0JiaU9xRUloYUlvUGdLbUIrVjJINkRBZ2hNTmJuWWM0b01OendabWFDTldrR0RPTklNenBxbG1yZUp5VXJmY0k0ZWc3cmN4Z3lnL1RKa1dGME5KVHBDVS95cktSSlFrZXVGbGVmYTg0ZHJpUkNOUWJmeFB4MzRhck10cUlQVjNYK2hyOVhIclBxckVMalc1MEpYQXcxR2RJUVBrMm9sOE5LSTFodGVqbXlBVFVyTnRYSDhpV3BkaGhibk40T3cyelJ1aGkvUkpwOXgvTDdsWEEvNGZjM0xqWkt2N0g1N2FPM3Z3TFN0Q256Tm8yRzRxMzNwaFJYYTN4eTdDZTMzQUVIRHcvZDFNemFxTmpWTnZka1ZlVGFzR3NtditpTmZmNFE1bTh3ajhudE1lMnQ1VVdIZXM1ZE1UZkhUM3JqME1paGcvUCt2am9rNnVTdkw5WHRrZGx4eUlnbUlIYkphd1B6K1hVWE5vb3hLNDZ4OVJ5SVdwSllVcnhPcldUNXBUZVZYMmpzSThXN05qTGVIV0o0RnlzWUZKeGlNRGRWbUFuZ2RZWjNWVDFoL3BCaE1ONU5vM2dYTHhvcWNJckJuRkZndU9GZEtFNVZOV0FZUjFXakk0N2hWUGxaV2pQdlV3ejNXSlpkWHVPOHFPeWl5aHpjT2d5RHhFOWtHSW1ia0FpcDVDSkE5WDNscEhDUlcveFdhUWZMTHJVNWljb3VvaXE3dklXSldnM1JvYjVyZUxtQmFwVUh2UXpQeVM2RE1YMnBLVDdFTW5NYU41SERDb25ldSt0dmlKUlIwdXhQdnBYVU1EY3lZMGswSnBMVXlYQ0dtQW5tT2FOajZCMFhFazAralA3VUkyeUpEcEdWbFFpS2hsb1hpTUhEQlFKQ2c1Um9JQnBTYXNIc0xWbE1KclpyVEpjc2lSYStUbElHYzgwUkxBeks0QnVOR1lkK3ZWU0svZ1RDTjhPY2RZV2dJZTNScDdWQlRNM0JkWk03ekswUGdHMHVTQ3BadVAvb2h6dUxQaGFEN2VqQTlaNS9vbk1nNlB4OUVOenBaWEhXeFN4SDJ4MXg5U3pEb3R0YlY3WjFmZW1kNk5OKzJFK09ONy9qeXMvaXRhQ3hWK0p2ZUE0N3kzTEhMQzZZekxORlZIVWJHZ3NsZm85aFhwWHg3QndYUmVXZ2lqVmxNRGRVbUFsZ0htZGh1T2dCODdzQ2crV2dGVmlTSkhLUTZBSHptd3JUaDV2SCtoUGpDWE5haHNHNE9EU0VTa0VHWGlzRjhSaFR2eFJxQ1N1b0RkNlh5K1FPOG9BVFVta1pCOVhPWUZDL2NVYUg3L1BtQjJaeVN5UWlLUDRuMUhKRjhEK2gza3Z3ZjNEMnVHZGJYTTIzTVByWXAzeWNFQ2FjME10RU9uKytFdDJwazRuME9XSE9LSjFNVkYwdkV3WExLR05qWmtzdVFSR1FpSDNCWXF0RUppSXhabzFHcG1WbDUvVEpRV1ZYTXdmWDdKZzllTWdvZTZ1WEpEQ2phamZybmhQd1lyUDZFcG9lMXlGMTkwa2FleFlldHZWU20xK1drZmd6YzhpVzg2MStYNU4zUEpNUE5sc1FPcHBiVXQvMWg4a0VTSEljclZWQzRsem9YdThwNDhYSGJLK0hWTkFXQnZPSkNqTUJ6T0hvYmcvemhQbFdnY0Y0c1l6dDlURFJBOFlodytBMXo2RTdQWXpTbnpBU3Y4emdhRXdGZlY5ZitYMHZzL2RGQ0NHS0hMUVZEUkM4OVhrR1ZQUjVjWjdCLzdNWXVzcnpETHhaREoyOTdsdGpLdytoTXh4eFQrL1IvN2tZT25XOERubThlRjRTNkx4RUdQQm9IUkZHaDZWVVkxZVFucWwyaFh6dUNtaExkVjFSMU1zZlIxVzVJWCtJTjVWaUpJMXN3V3dPVFZTYlF3L3VMbGpDZEYyUGR0eXFqTkpqWEFjcTZXaGxsRmhrRjgyMDMxVUpUd085K1hGTWRrRjJIbEZlMTRJOWg5bjBPYTN0UVBXc0pIbGQ3ekk5SzQ3M1ZkNUxjeTRvRFdvbHcvUm5OQ2hlQ0ZSZ1dEdHRsSFl3cnYzQmRMRll3YU9kMytWMk1EOGNUcWxVckJoWTBYL1dUcnphVGs5d1hOYnBSSTkyTGlqOXdUQjFGSHJuMForMmFqdmRnY0IwekhqUC9qeFcrOU45U2hUano1ciswSG9TaGd3TWs4emE0WTR5dlNSY0FFbzdZL0M3SGtoaHhpU3VOYlhpNWZKbnhLR0tGYThxUnUycUlYSzlvUDlCMStlWnJzOWJXY2tjV2kwbmk4ZTZ2dFlERUZpWnJoK3UyekwvWCtuNkxOZEZtSTMzZXppZW0za2FUMytsKzEwWEVhN0tCeUdoWkw4N1Fxek93QkNRcll1VUJxVk93VUNwZ1NtQXBwaUVHQjFocFlUMVIybXRIUjY2Q1FraVo3a3dqWUdjSFVNaUFHeG1HOUNGcFFxemkrVzBHSm9qZzA2RFJnWEZyc0VWS1RMQ3ZUSUxTNDB4czF3WjBDWDMzRG1YUTVzb285aWY2UDZ2SnUvL0VyYi8vVVZKTHdjZVZXVzgvQUs2LytNa2d4N1BldEg5WDAzZS82ZVYvZS9Samx1Uk9USE1QSTVTZ0tvVjlKeTE0NisyMHhQTVlmcnZjLzM1VkcybkoyakRWV0U3c2FJZFpDZTFTMWc3aEY2QVRreGVSU1VrTDRqOWxqNy9pMnVrdmpkRGZXOTM3ak8yVDB5ZS9YK2l2cmM3NWtmUkh2Mm50VUVvSFVtUjZVZ1oyLzhKRmZZYW1ndEQ2VWhiR1dZRzIvKzFLbVFaMWs0WHRaMGVlUDl2SnpDSm51MjQxSFo2Y0c5dzdSbEY5V2duWG0ybkp6akQraE1uZXJSelFXMm5KMmpIK2xORDB3NnFTV3Flc0hhTW1FYUFzK2dUNWJkU1orVzNmQ0dldFFZZWZhQTFScWhOSTFXMmFVUW9kbEIxM21odURMVzd0WlBuSkFQMHhWVEdHVVlDYTVxR2tkUVBRbi9DT1U0Y2h1bFBNS2JnbFZXVFZCSUJuRWJxR3NQU1ZVbWdNY1lJcVJ2Zm81QUFYOHAwQVdjSTlaL2hYYXdyTm1taHhTYXBCWmFFNndScDZqRGlmNFFnMGRvbFJBNFVMcTllVFNxWUxGMUthcGk0T3ZDTlhLZUZ3UVBMRUNsbklzQ0JvQU02Q0RxNHV5SWxkNWovRzlPZFNLSnhrRTZINFU2SEtWU0hrdE5LTSt6VWNnS1JZU0p6aFRzREl3bFpqY1JrVlJ0OUNjVWcyZTRSb0RPNWt3eENySStFc296MzU1TWdTSTZYelJ3SDU2QUQydXloRFJ2c29MTndENjNWNXhBSjl6QkJJZnJXQ2J3d1BlamFNWHR5bi9LZXpHWnFFQldiYy9saURKTkVlZkJqR1Fiekl3OFlyQ1BDSVpRV01adHpmbmxmUm91RUNwZzNNWXhOM0tucWR2bmxxZVYvRWhoUlVtR2VZcGk2bEJheC92UW9IOGxva2FKSnl1OFN4YnRxZjNxVU44U2FnTGRzMzJZNCtUS3lnd1dVaHVCMmpCTG8vVE9qZGFINGVWK0oyTlRhcytleVB2NEpYdHorbEhheDkvYmtVaG1laTNLYmVPMzM0RXNzalkvVTV2dDRta2ZrZko5WXU1MkdLZU8ycjVYZkY2K0xEaVByaTRHckNWUG84LzJvSFhSUjN0MmVQdThBUHFmUE8rQjlQOThRaGZ0U1U5NXo3NFBXcEMvQkt0OHZYNFIvSzRubmc1S0FySGVWTnl4L1FtMldJbGRCUit1VDJqYTRuVnJ5dnArS3ZzVFBONk9HSkpjS1ArOG9QNDlEWHhOZk45N3JrYmpUQVVybWhzNjlyY1B0RitSWWlaQUYzNVNRbUNmSXF1SDhWL2xXT3haTW5EZ1hIRnNJVVZVWXdDOER2eUdqMEFERmd1OUU5OS91YXhLYngySlNCMGY2RHZmYkt2dEhHb01JTW1hZkNwL2Rab3diZ3FFdmhzbVNZVkxCYWc4ZnlrblVrTlRUWWUzUThVOUdYeFBmTEdwSThyblliOG56OGovcGM3bitqdkplREg5QVZMMnJTdmtDdVg3amZ2eitWK2lhWnNtdzhSWHlHSjNQRUJYV28xMU11ejl5NzhGYUVvYWp2bHJTVm9lS3R2RGZ3OTJIeU44bEs0MXhzR0JhVkVibE9ia1dpSzVNZmtWaE9jbVBXWDRKR2ZVSTQrQkpvcVV1V3BXWHF6OVMzYm1VRlo5TE5JdTBxSlloSXhNdldTcW9qejRtZFlVMmJyVHoxaUdqaHJpMzU4Q042YVBTNFc3bXA0akFsMzh3amZURi9PQjVUVXhUUmRmblgvdFZTcUlzT1JKTFF1djVnRXd6b1hPc0Q2MmR6b0xEaHd2NHZxMUd0WEtiNEtuV28xckRYNVE1ZlVUdDlPbHMvV0hZYzc0OVpoKzVvZGhIc0U0eGkra1VZWUtneFpGSGRHM1NaUno1anVKQ0VkNDcxNmdNMGxsKzNrN0ZrVWRVQmttWFpmNk01MlFROXQ3SHFsMm1PN2VGMlZ6Q1ZMdE0rVzhFUmpJck1CZ0hCNHM1Q3Y0b3ZFYXUvM2tZdFJQdTR2VVB3M3JpODVaL1hXQ3ltai96WElKS3BibWJJVFFLT1ZCbU54NjV0bXBaSmVIdTFxVXhkYUlDQXB1WWV3eHluU2IxbFJwSm91T2ZweVIvYzdEa00zTmNMK0VHS0tzcU9zcmlnWENEOW5rVGxqbStFanBpTGIzWGY4b0xWSktjS3FMRmFiS0VFRVZjQlVFNnA2Slc3OURrQ09xelRUWDVnajRaQndvY1I3WXVqVzhRRzJCc0dkNXp3TUxwVXpkV3hRVDd5TUFSVis2NFE4Z0Fob28rVThmQisrK3RuempVOVV4b29QcnFBbFZmWFQ3M21LMXhsUXA1ak5teGpxZzJzM3h1SWJPZlJFbXFUTVhhNmFMNkJYdGdJWDg3MDFjOTJuR3BOck1lM0FZbUg4YUtIdTBNVU52cEMvcGgrVENRT3hoRC9KU09HSkpCcmNqNHREM0pXMjJ2TC9jWGxtRUlMTEhsYVdCSnZFZjVmVU1zclRtY3lDMnBwT3FpVG1qVFpkYW9Mb0pBbldib0RHWXBJTUZXcHpVWWM0UVFuV1NqaytzRXZiL1kxNlBVWkhXYUVpT1gxUXUxcUJVSXhRcnR5aFFTWkloMWJScTQrSlZINkN0US9WRzc5VjM1ZnFRdUlhbFJXSmJiZkZiRFJqTmJmUERkRHo2K29EM3dCbW5BQzNUdzg4NTEzOGgxN3dneGVBbS9HYnpRM3oraWkzZlFuNWpUOThOekVZUHhsWnd4VVorYldZa05VSmVZUjcwbnlteFE3d216TE1Xd2toN2V6Q0JOWENJYUJIWldpYUVtcHlTYTc2NHhManZTcWZXNTduUDVwNVY1TnBSaXFwNUpxYXFib3grUXJxNjQzckRoMTRWeVhZTk45ZW8wUGpaajRmV0dEYjVaSmllc25qaTVaODhKb1lqV09waTRrMW9QbHhkT1hha3BkckIwMnJTbG5sbXM0QmdyZ0lEeGpOYllvdlEzUTZhdE94bjlyY2J6R2pvSTM2WDB0NXZNbzI4eSttc1cvQldZNDVqK2xvb0hXRHVVem82aWRIWWlha3J5TXRsdktZOStnTDVSMzV1aHZCZlQxZy9aM3F4ZVlhdWVROS83V0g2dkJMcTdLZlVORmYwcmRHRmFYNHZhcE9ySy9YK0gyYVJxOE41S096UTNrL2EvdXd6ekN1dC9EVUdGWWUyMFVkckJNdlZScHJ1bENCN3QvQzYzSTRGdVhhbm1saUo2YS9xRFdwSjZYNndkNmlkNmkvcUpocUUySkQrVS9aWStiMUZlcHI2M3JmcmU3dHdGWm51cTRmbmV4K3A3dStkR01ZMVI4OTZhS0lQVTQ4SXdtZkw4RDBPbCtIa1NTaWM1bS9oNUQvYWMreEo5U3VCSi9TNURHb09uN3owT2VsUGR2NEwva1h6UGVWS0VrZjZXeWtZRHhPRUtiNk9uczFUd05xVWVXS0JTL2J2U2lueDRaL25JV2YwZVp4NzU2R1BRL0dsQmlZQlNXZktVNjB1VEVvbjhuUHQyVkE0QXFSeUdmTyt6Y3RPNVlGdHVMdXFIK3hHQysyd1hzekMvbWw1SmppRmxVYnI0ei8rUW8rcVVnb0hjWWEyNkdxeXJDa0VxY0Z0b2g4TUpSWEJFbGpxcXFGbXNwTlBQWjdJcTJhd2dHdDNXWkxSKzlwbWMwNHFlNXFKMzFMUlc4R291OEI0RXpHbzhRbTAxWnFFUDk0enBmMlpSeFJkbXA3K2gydkw3a0ozRS9FbjZ1QWFxLzlXVCtSNWkrbCt3WnpzN1ZiOUJQcmVBNlg5bXlhQnJoK3AvOVdUZUdNRDBQMDBNQld2bnJ0cWZIdHc2cHY5cGZBdXNuV0ZxTzczQVlCWkhGMG5pTllnbUhhZnlSdG9lMWt1VTlucHh2M0pOQ1d3VXNYR1FkT2tFRlphMTIwNXR0eTk0RGV1SjJuYk4ybllGSDJwejZpbnozQ2RZZXRlMmE2bG9GOWxKblRyV0xyVnRGYk0yOEhNL29RRnJnOXJPUjlEbnRBWWN0Y3Mwa0hYRUcweGZqUkRNeWh6UVBGN3FnK2t0dzNSbVBwZ0lVWVZoTVNZMWxCZ1R2UFpIOE42bCsxYWRiK2FQK0ZieFI0QnVIWFd0Vk1TcVNPVnFyTXB3YmpISVlqR09YaXpHMFVjZEs2MlBSbmxFWTVsK2JtTThJb0JYMTQvbXJWS2ZUN1lNMDRINWZBSXE3RTZzSFgrbEhhd2ZGYkE1OEJVOTJqbXN0SU5oNHRrY2FHQllPeGxxTzkyNWs0eDNCQW9lN2R5VTI4RTBjemlWNmdKVmZ6bzdNd2ZtU0RYeHFMdlFNM2wwTnZYZlNNQmNuZ0R5blp3QXhwWlloYVlDVnBCSlRIcUpRL2hBZ1BuT05QTEhMUVJzQUlsVUY1NnJDcTB0NFdNMjdhYkZlNHpoYWJHRFJncFhTZG1lQVpLaE1LK01GTzBCNVdkUU8vZzI3a3NDdDRweldLd1ZjcjlDcmVMeFRieE90eWNPc1hoOTNUalI2Qkg0U2RRQ1U2a3p6NEs3T3NCQ0toU1JTNkdGRkNleU5MWGdFVzBoRDlMdzMwc2NsZzhzcERpUkJZd2xPV2JSSHFaeXZYRCtmSWtpRyt6NVpPdlM2Tm94QVlHTlFuc01MQ2xoeFlyQ2E4Y1BHdmFFdjFwMmFmY2hiNS9Cb3UrTThVSzZ0bXdSazJFWGx0OFhYVkp2S3NOMjVSeEc2Nzh3RVgvR1JQeXRPc0VVYzVCSW5WN3NVZW16b3RnckZjZm9RVi9Sd094UnZmUlBiZG5YQlRmYUwxaGlkMnl0bXZTaTRxL0QrbmtmM0h6aVRuaWJ2ZjJlcndGTFpQaHJ3bFZsVE42VlZKZFNqc1Z3U2lHOHpHZjhkWHJkdjQ1SmxTM2x3Ynk0eXNuUS9VMUg1ZVV0bVZNdHBiSmlKKzFhK0M2ZnV2cG9XSXNkZlNzdmVrTHJja28ycVM3V1FWN1Z4NFlGYUpWVXovTnVuQ0NBWXpZRC9ZbUdIcFhWZ0ptT2dXUUJWMUs5VTVvOEt4L3lwdy9ycW5oZWhBSEZhOFFQN3BqZDJSN2xQR250QjhFbEhNTzZlcTZhamFuekw5Rmo1cDRyQjZJTHY0dXdVQnlMMEpWSGRCcDhBcDZ2MDhNUzhReEtHb2kyUEFRZGwvQVU4cXVXRC9mUjFvbVErdlVWam9scjl3VzRObnBVakpnQ3ZXYU9aL0UzeEdab0lMNFgyV2JZdmJ4RCtWL1V0MS9odTZTK1lDODFkcDUvQjdRQjh6a3pwdlkwL2p5QzFrV1BJTWMxYWVQTjFEZzUvaDN1SzY0MWdXL0FrM2l6QmtZU3lJV3Z6V1I0R3JOT2FmOTgyVDVUeG1oL2VJVjloc2FsVVZxN1I0Ylp5T0tiV2xmRTFkRjRWVU0yaGxrdncvQmdEWUdweXhzcmRPaHhXSWNtZk9zOW1ZZTA1MElwVElWTzBCOGxhK1ZyTEpOT1FCOVMrVHBGSzEvajV5WjBoc3JGbmJWeU1aYTdOM0FDbFlzN3dLMFZjakYrYnFCMEdNODVTQkVhWUo1US9VWDJEZy9qeS9ObHNrREtsaVhSZGFMOWpVM01QUVlvOWJFdzVaczVUbGpKNnVVOVVPdmw5YW5rTGFySDA4L0FzUVJJRDg4dDFzOE5jc2tIclM3dTV4bnpvTlE5U21vTTVFZzdRM0lUZW1oT01sRkV3ZDhYZ0Q5NmN2eVRPOUI5ZWxQK3BreGJvL2RXekNveFF2ZThuVUpIOU9WUG1mZFE2Yk12Y3FNTy9kMjBRWmVtN1YzOHVmVmkxSkwzNlZvSnRZRkpDZ3VXK0hvVm1TdEtqUzlaSjlnaTNJRVh4Szg1TDY0aHBucVV4VUphVmtRTitDazVhYmhrZ05uTnZBTXhrbGtOVFExQ3RqUExBUElkZkdsSks3NDdUMCt6TVNja0d4SXlNbTN3UXQ3dVhhTi9HQ1Q4RmJSbmova0c0K0h6OFR2ZWs5L0JzWGR3cFNXdmNMMDRtRTllQlNwZUJTNEIraW9RQTZ5Z0tTQ3ZJcWZjTUZ1bHpXeElTTTZ3Z2EyN1hyODM4T2V4WXMyM1ROOS9iMkx2V0NpOEE4OVQzU2FJdktEWUQzcnNmVzBGZTNnYUN1dm56Tmtnd242OUIvYkxGaDFTM3FMRlk2UU8vUWEwby9ZMDBRdlVvWG1GNGZxOHdzT0ZjQ25jREZseFV0eVJPbXZXaUY1N0tHL2NLeXdBejhUTE5MOHdtZklSczZxdThPbzNiMk5Gc3VHTE13cjNEbTdWWXREQWxxMEhkY3hJU3JUWkVwTXl4Qm90QitJSGZmdTJUcTVqcTFZdG95NGRjeDlrQjFzeDN3b20rYW5CMW9wc2FYMTVyemcxRzhpaUhwZ0orclJwbjJTTFRROExpMzRsdmYyZzNPeEdBK3JGMUEwSzZCSWMzcXRUNi9rWnRQMWM0UkVzRjIvZzloTXcwZVd3WWtpTEZ4RGpzVVM5Z0R5VlhmeFpmRFhMNGFxb2xrRW51bnowcTIzWDE3VTI2elN5eTBzN01tbzFGOC8xSERlNlZkMmc3dU5IdDhrazh6Wlh1TU9IaXIvUzgzMlRuYnczbjBxUHFGUjFQVFdYa05pdWVUa0owbVlCQ2NrOFNTMU1ock9XUTNRMUg4Yk00Zi9NNWNWZkplU1NnSUN2SXBOWmpxQ040R3I1RHJvdWpUbEhtRlc3R21wMnVZWHpObnJIZXFkNU4vUHU1RDNBTzg5N3V2Y3k3eTNldnRtRU12Tk0vN0M4WUxXT2RHL1VvR3VYaG8yN3RVbU5pYTVlUFRvbTlYYjlEaDNxWjdacmx4bWVXRFVpcW1wVkVxSVpJSnhBb2FJTDQ1U1oxZlJWM3UwTTVBRXJkbXREb2YzZm1pYWNBRTB3L0JiaEpOb2h1aG04ZGtLY2dSeUZ0L0VKcUlaOVgwL1JUV2lyNjREd3FMeU5lQU5yTTMxY3IzQjBUN2hIQ1pmUmVxa1gzaE9zOG9pNnBZdTlOTG5CTEgzUkdTQm5NWUlNZGpSU3BuemVxbnRwN3c3anVobm1GdzNxQ0lUTFU2V1VXdW0xT3ZUTGF0dk8wQVRQcnl0RHVJUE9xT3ZueFpIMTg2STB4RXNUSjNnNDBEZkcxK3FMVjVGRW1oTG5WS1lOWC9sTW03c1U1cU9yY0Rsdzg3bC84bk9FWCtqcWxZbjRTc2Z3R2pxRHVQSlJlQjRTS09Hb1dMMEtGTW5qcG5QTE9HVlhJbTdOR25SbUQ4YmZEL0ErM2kxMS90YzVCQUhydHJTV09xTjNNZFIyTVl5M1NodmtPTWk2N0F4UVBURnM1bHRvV0dyWWJEaGdPR2tRczhrd0RkU2w0MnNsSGg3aVkxS0tFV1RhOFBpc216ZWprQzFiTnIwenFhY1l0bmJ0MnZ2WEsyTE1Pc3N4WFJJWUlqSWRUczRORFphNGlmaUJSUEpEaWMrcS9BbUdmMS9xWWt6aXFnMGgrdXFROGpvY1pIeGY3RUNmcDhyUE85UG5XRzhFaDZUT3hEY3FQeDlJMjIrSVphNW45SG50RVBaOE1pZjdrTVZvK3J3UmcwZGZVZmlleFA1SG5vTzVJYlNmYTVuTTR5aS9EeHRKWGJETXM1cktQRG5sL3VWSGlId1NRdUxIaUtQRFJNdXRSR3BqNmpCL2w4aDRaYi9PUEhxZlNPbk1NWHlmVE0vaXFQRnZKenNKUm4yTmFWYWtYa2gyK3hid0kybUJlZ2ZiOHpYeGVQcktOU1VxTysxRU9aUEFvNnEyWFB3OHpwc2VDQ1hCN3M4K2g4TlFFLzRIRkNHUmc2RHd2MFBDdTBwc0RPMS90UXJkbTk0M1ZzZDNqOTZueW5sQTdDd01ua1pTRm5JVndtNkFwelFCYVlRVU9US1hITDVXY2dDZWhFU2pKYWV4SFNDWExFaE83OEZjQ0xLVDJVb3V3VnNRZWlTTTZhTXNEWjRTUjF4R25QZ3ZwMnJ3WjkxZnd4U3NKNzN3YkkwZE9Ydis0K2thMUVmUHpxckI4MUJEblpkZjZUMDdUNG1jRGZvRFBaOGc3Yjg5MFl0c1Jucm9Zd0l0dVpZQVYwdW85bFFZT2hhR1RoSDVaMjZ5VHNxN3lMa3MrRjFwNnJzZjBmdDB1aVpZZkJmOFpCenh4U3Y0Zkg1M3BYVzhSRmJ4VkxRNnJTSXBPaVNTb2tQaVVoRm02ODRjOXRJZFJzVUtmSkhrVEhMRSszaCtqZXUxQWZDaXUzWTNmcXhyU1U0T2I4emxwVnpGOTRUbFpvbjRudVN6VzM2aDgxUC92ODFFSlo1bnFHUCtMRG9uVHZpbHdQVlJnWkNxN2hONVRsYlJPYkhSOXpYRjk3V283N3RKSmZPaDVxcHBjVTBzOVJnckxTWHZUWkpSTTd3QnNRWWJBRHlKUXZsZUxoTVUzQzcraU9zQkJEZmhYWGRoYmpaY0QvdG01NHJ1czRxdG0vWWxzOEwyUmU4YjBmWHFoZmQwZjNvK1F6U1dyL3BVVWlkS1ZRdURRcWhhR0VTa1RLZXZUNGhjenRwUTZnalNlYjRjb2ZSME0wMnRSbW83QkxaWXpoekN4U1dZRXpJU1lra0NRcHd0d3hZT2xKSVhOT2VnSVREeEZnZ0FhSW1Pb1hKb0J3aWg5OEhMQUFLNzhOWFR2NytjZXVYcFgxZUI4QVJkdXZzTHVuVHFGTEQrOGpPb2ZSemRkSzE5L05FSGZ6dytkZm8zZmhpbHlld2NCenpPaHF6bUNCNm5OeDVudUhLYWlrNW5wODVxM1hsQ3p4VmVDdlVMWWxYV1NBUkFxRDRaelVjdVZrdlZYNDY0YlpNNHBncGJzQ0lNbjBrSGI5clJqUWNUNzZFNzlxc0hwSW5nQXZSKzhDRk1jNWYraGI0THdEcytPeERFUGlIM3ArNzdRdjVIM0Y4Nzd2OXhUTnNTbEJxT1N0VVlmU3kvdGdZQVNXZ3RKZTQ2cmJYZVJJekhKTGlNbUlVVHlibmtNbEV5Qmxrd0xzV1JzbVBFUDhtWnpDR1FGT3lDRDVjZCsrSGtCOStmWEluU1FlcnNyYURhYjQ5QTZ0YVp3SXJTeDVGS01rTEJJeENQYmo0cVFHWG9jdHE0bk42ZzFlWHhJQktUcTYzb3AvR2ZvNk85Yy82WHZONy8wUjVMWW1rblNhbVlSeTZoUEhJSUdJZmZSV0lhaFRCRlR4NVIvaXYvbzVTQ1lWYklNQ25sMXhpTWF0OHZRZ1A1cjJnN3EyU1lscXlkMElxNGlzT1VINGZLL0JqejZXZG5XR1NUSnU1NVEvbDkvakhsMmRzb1RFNG55ckVqQkU2SmZ5ZlhPTlZmVGZ1UDlkOHFXSGJNclVUL3Baam9XWFpPbDRCSTlwYldMaE5nSWpWb25KSDBneHhOSGVaNVBLN3BPYityR3ZTYnFZLzI1UzlucFBsWkFrMld0TWhPZmYwejNoNUh3bjdIN3NrSWNFL1pWRFIrYldySzJuRkZtNFVHcnF2RHVnaEN0cjlQOXJEK3VVcms3NGhCUjkxblR0K2ZuZysyakZ2SlN0UGk4UmFqZktFNXh1TVFQTjVCcW0xVEp6YW9XeXpGajZyOEtkYmk2bG92VlBVVU1yNUFqa1lHY1hxcm9OL3pCeXhyenQybU9ROTE2Z2FyUjNQTENRK0UzR1RBVjQ5OC8xcS9OMWI5Zlg3QTBTYjJQL2VzV2JwbTRiUzlOUStPM3VvOHNIR3BlT2JLV3prN2F5YWZlK09UNzE5cWhrVHg4RHUvdWNjdW01VzMwem5YOWZFcjNmYXRXblNJbkd0WEErUFJSN1N1WjNvbHE2blVJNndnOUNRc3hKdVhBOHZrNDFsSWxWRys5UlNVYjBkNVUwQktncFFrTkNqN0VUVUhKNFJJMTFlRmhXbzlhRXEvVXJoaGxjaGVGRHM4aTBPVDJkSkd0QWswcjlZWnlwSnF3NmpuTVVwSExEd3dCN01aUWFrZlRjc1R5aWxqR2J4aVpXV1ZIREhtbExoLzVURjFhTWRzclA5YzhxdHBoQzB1alFzaHh0WUZYYUk3UiswNUlUcUdpUHZRcU91eW5UWHVXNURzTDRoU3N4V3RzMTE5WmF2cnNwc05ESDZ5M1pYdVk2RWRIbkZCSlhXRmFRa2RnalpoMWJ4WmZhYVNNV0dGWVRDL3BIL1ltREFpeDVGcVRkcERFUG13OEJkVmkzTlVNeGJINm00cHdRelduQ2F0S2ZmV0VKalZ3NlNKNlZiQXFEWmk3SmhCSTM4NGMraHZFWTQ2Tkh2TjJ1WHJqeDdkdlBudHRTdU9qSVlpZW5yNHpGK2crc0JaMGZHRkhWZHNmbXV1MUdmODJKNTljNGZrREI4d2Z0WkFhZU11b2xlOWd2TDRUWGlONldsbGdaWHNGSm8xUUUzTDBXUUZkUldFT1kvb0UyQUcxRDdSa0d5SkFFQ01YNHpOSm1YZ2RRVEpjUm44SmpSdTZtdkxGcmVhdVFDczZsT3p5Y2oyWFR1OWY2YmdEZENGZDdjUUhhOGdmc012azhZdkh6MTAwSWFFSHVIRFd0UnJkR25kT0JEekZ0Z3E1bEtlU21uby8xQTMzY2VEa3YydmRkTVBGQlMvYTE4NGZjcUdSTHZRNE4wQkl5N2ZLN3NvcEwrM2NXS3U2eW1yQjh4emMvRStNZEw2T2NUQ09PL2YvUEVCekpVU2dIV0NBS0lUQkp3TUlEcEJBTllFTGdYY0NvQllOUWdncWdGNVVCaXdsUHpSU3FwV0J3YUFzWjdsNmdQMG9VRFBaV0FaQ2RNTnAwUTN5Q1FxcWIraUhCS1RJUmdmZmZYbEg3OTkrZFh2cmwvaCtyM2J0NzBOMTd0ejkyM0RueGxZSlNnRjZWZ2ZhSW4vMVVZWDBkM1g1MzMzKysvZlBaeDI4ODhudDJoc0hlRlRRdjBYMkczVjJxWENpNWxDaGduVWF0OHlvbGFWOFBqV0taUHRRbjNYdGVIZHZMeDdCUVVzM3N6SEV6NG54OXRpZWVvWlhmdTY1WDhLN2NWZk1hNWlHZC9mcXRQLzZJMTZvRFFFOUtCemY5M3BwNlJZbXNhQjVZeGhXYThQWWx3eHhFN3BGMU1scGtaTW94Z2hQeTNkbGdCWXRWaUN3b1JuMGVSQ2xaM3hDWVpqYzhDbXhySGRXdnFrR01XQWVpRUZVNVBBYTlFZGJQNHhBWUp2allEY2dwcS9TL0ZDMU5iK0l3VFlYL0JlUDlyVnNOZHJQSjhqR0JaUGd2TmVaM3hjcnAyRngxZEE3K1c2MWZpK0Z4M3ZZRFNVdjQzM1ppMXVSQ1hVbDNKdEJiMWo4VTFzSmRUWE8xYXVaYUNUNjJQMUdlZEpQcFNZQVpZbHI5Q1poaFZmUEhaenhZSDNtUWtaL09MN0RzZmVJN05tblh2NC9RbmJrcFYwVzQ5NnRWZm1QWFI1MzhieE16cTJSYUlqZDBuK2FQdlFZc2VLQStORzluOHpycWRsNEV0Tm12OXdkdDNGbE1TVjJUMW5Wcyt0aU1FVE91THh2MHJIM3huZlg4Q2J6S0xFdUZCYTlGdzRpWmFmRXlsWnF6Q2JhR1Z0UDgvejB6MkxuYk9raHppaDl5WU5SaUtMZmFYZ3pYL2hicXJpSlR6dXFzbC9NUlR6eGlJMFFPRGxPdjVaR2l2QWY1TkMrVC9rVGliWENhckluVlJFQ1lILzVsVGUyL1hzQVB6NS9xVTc5cUpOUlJ0VDFyKythU3RObmV6VXp2ME4vOVQ3RnlCZ3BiL3NFaENmYkVGSGUrYmNQODFzNjJOUUR2ODVqZGZyV01tK3BRV0lsVjdUaUNPR1UwUTM1UFRWNDZzWVBRcHk2eXRpa29yNEtzNGtzMExEc0xIampnQkhiSnV4eTNINi9UV0x3WnQ5YWpZZDJTdm5ZZmsvUXNjTFRtbjJPblFreGZsTHNDbDNXUDlWOFQzQ0JqWnIyTkFuRElUOWtISVAyQlI1WkFUR0J5T2U4N2IvY3NJVWlhN1VIektsYzF3SDZzUTVZa1JSUGJrazd5NHpEcWlDUmlyaFo4SUk5UEdvaWVpZnI3R01BY1NyME9ZYXhyeTVZTS83L0JjdGYxZ1dkeHQ5UVdTTEgwRXljRitXaFFySFgrQ3ZBMnpPTytCOWZRNzNXMzkybzU4SGN2emIyWTM4T1ZSZ1IzUDRLZnlYcmhyOGwvTFpqVlFQb0xYMzZsYXlscnI2N2dyN3E0d2dCMlVrd1dRYkVWOEoyb1VERUx4dDRhN1ZzRW5HelBUNm45ODQvNTNRd0wzanMxTlk5VjhHVFBPbmx1LzlHNVgrQ1RqWW04cmErU2hlRE1COUNNTlV1U2M5WGUrNWp1aldTRFgrcUxJVjZWV29adHpoRk5WaTliaEZ0SGdSejBWVlNLaU9UWUxta0NDczV3WVRCVGdKQmdMNDVDZFFCejFDVCszb1NYbTdsMmEyNm5UOGM4a3VuZjhDL25oWUVocWcwNy9mUUJkTktBTmNDQUtaVDdZL21UZ1QvVFAvR1BySEgvSTNYYkhRRiswOUN2d0V5T2ExR2VvbTFCRmF2dUQ4R1YyQmVGMU5RNm91RTJFN0xKeFdTUkFNVkV2eUVxaVdwSTloYzBhR0NiSnVvUk9oZ2pHekNTYWw3WU05T0E1SUFMektrdGFQbnB5K1hBSTFwNkpGVjJ3TjAveGpBbm5mMU1DK281dThMYUdTUXZEbUNXdWJsLzFxK29vQm1VTExaYU5STVd6dXprQkJyM1VYNEZEUk1IRXBtTzJld1h1Qmd6bTlCVGhZOENKam5vaGFpajU0SGFPVXVIT2R6MTRYeDZmTGVxR0lwVXlBRWppdlU1Y2dzZFd3a3cxTWxycEJHVmlVSjhobXBPdVp4SVVEMldZQkgwblh6c0MyeldZMWJJbWVvZnNGajlFVCt5V25oT1dDZU9nSFFqK2VVVGJsOVhzYmtCc2REMFE5d1Z0Qm9BWklCUGVRK2ZGVFg4amZJR09ZWFg1ZjZvWEhVSTNyL1NMYTV2Y2NiVk5DZlVpM05jS0MwNGVMWi9YZGlIOHNzTlFaRTg4eEJVcUNCbnBJdVJKM29OOCs4bGx2Uk54ZDI2WUxYTEo4K3RxSmEyWXNXd3E3dEpuNWN0YUZNek9jMWFvWFR6OTd2bU1Mb2NGODlHalpxWEx1MUdlZ0t2b1c3ekR1MUZKZ1dvQjMyQlAwNll5Wk0yZUFPay8yQXNEcyt1OWhlYXN4OGFzek96MDN2RHlNMWYwSU1haDJlcDE5Z01KdVkvbnhmU2hrcE1ITUl2Q1UvSGdXODU2cXhyd1BBYTh3ZTBSTWhmK2YyUnBDNWJZSVRPUHlNeXpIV28yUm8vTk9ZWFl4R1BnYWc2a2hWRlBxRDh6Qjc1cUJaZVFJam1SdUtCRlh1ckI1RlhzNFhxTStCdm15c21yYStDaGlqa2pRN3BwRWtuZVJWRld1ekd3MkdXbFlqaWtUTDFBd1JTNG0rOEtKSjc2NGlYN2ZPMi9KRG5UbndmZm9vZjNUVDAvdkUvdjM3VDZreXgvZlZmVXErNkRKdmt2bmk5M1gwVjlZL20yRTRFbm9idm9sNHQ5ZGRrS0VZUG04aFcvTUp6RUxWN0JjT2xFOHhpVW81M0RyS3Y5UzFIb3VyNFRYVzFiTnBjNjR3Q29Nb1ppRXljSzZERlE3MTRtZTVDUVEzczgycVh0MDNWQ0xUM3hJV2xZaXVtdEhkNUk3V3MyeFBwYlFqT2h1aytxY3FDcFZGYTVNR1JiZzEwLzBhZEROdmNyOUZ1d0ZoM2RyNENQMjh3c1lOZ1Yxejh1ajlMb2VYcXRFdkVkQ3NiUTVxSkpUQjNTSHM5RmpmTWlOV2M5Qkk0bFU1ZlR4Tjh0QkVTbWF2OFdWT2hQTlZQcE9wQjQwejQxQlpNWTRUTW1TcVN0YnQ1R2t4RjNWclVlY0UzY25WOXRwUC9odXJaUTE0c016TUtPV3E0YzFZOHJVZ2tVVEYwMmNQSlgvWXVDMXVZL1JoV21GaGROQXh1TTUxd1lOZFY4WmQydk1tTzllWjN2Skh6MG1lNm44ZjZsMVdFbU5RaE90VVdoU2F4UlMvZU9wV0lUbDhTcmNFSzVDMzFDV21oSk1YVG9PdWNFNlI0UStjVjYwUkRLM0E4RmlyVVZYOUl4eVltbXNnamxFc2tJOFRRd3I1TU9jMTdyUDlYN241WitCeitNN0lpZytCTTRWdDkvYjFZNDZrT09kM1hkaXF0MjllL1FwRDN1ZldIbXdPRG5HM1pDZDk0ekhTLzF6Skw0STVNc3hQMit6K0NJbFJ4Q1BjMUg1QTZGRVBJczUrdFJLc2x0VTk0UXZqUmp3MVI5WkdFWnJwWlBDMVZsaFdKSHRIMGFjS21GTEZkdUlzNUE4UFlBdnVsSUlnaTc4a1RpRzRxaDVXeEx3UGlhdUxUd05Ga01DTmZ2UXd4a1o1bVFLVGhpTWZ2M3BNZm9hcER6K0dSaURZVjdZdVNNbjc4TCs3cTEzVHg0NWJ3R2ZTTmZMUUg5Z2VRaEN3Y0MvYmttSFBrQlg3emJPNmZBTHVuYjgyUDlmend0LzNsLzNQOW5HTzJDYVgweC9XNVBTakRvYzUyV2xaMGJFY0htVm5CcWhlQVowTXAwVGVJZks2WXVodWtoZGtxbXVuVDZnbno1dmo2ckNtaUo3Y2J3UFNBVVptRkpFQXFDVTJ4TnVnMUUvbHJudW9FajN4V0RUQjArckp4NVlaYkx3MFdCVXlhSERCMFdIdStpWDk5Ly9CVytLTDFBN3REWUhWQVBMNEVwM2ZmZVU5OTZZYzR6Wmk0L2o4WkVZb1NBdVVzbGkwSGxxRkNMdTVBS0Q1RXErL1RtQzE5eFNqdUExUi9MVU9aQlA1QnhJMHdMOVNwMkNIMlNNeTdNY3JLQzM0dmpwU0N2ZDlUYk5rR2txb1ZwYTBNWTNMZ0NqZm5wVzlpT3E0dnFvb0lBdkljTThWTUtiNEdiMy9OdEhqdjRJOTdtNzRrSEh1OWM2NXM0b1puUXJrOGE1TzdBZS9Xb2xxNmZMZGxTdHVCNTZOS0Zib1N6eDN1cFJCTEd5Wkh0Q29kYTVML1U5TlBUUm4vYURSd2NlN1dkSHJTbHB1aGtlK2NVRE5CaHNPcm9sTXR6ZDVQOFE5eWJ3TVYzdi8vZzk1eTZUUkphWlRCWkJaQmxKRUUxSUpDbHFYMnBwQkcxdEVZa2xzWXZZTWdoQkxhWDJwYWdTYlZGTE1SbkVXdFRXRnRVb1NwVlNXa3RwYVlzV21aUC9XZTY5Yys5a2FEK2Z6L2YzK3ZmenlUVno1OXh6bjdNOTUzbk84enp2UitWTDFKNU0vUjdqWkw2MGh2RWxzek4ybWNXUVluNE9QbWY4SFBSUitMbnFpOStBbkJtUStBandqUno3OEQyTGoxQ3hrTEJ5aG9wb1hLaWFGMHQzcnFJelhPdlVGVFgvb1Vza3JwZlI2WDVFY29DYjZCQ1NidGlmandjTTFiR2lDT0p3SUhaNDJna1ZnVDRWL0Nqd0hOeU92MXRsbk1yT2JyaXVDcFpReWFpSFEvQ3N4SndNWG94VUdhR1pVczZsRStid0JrTnZQWDEyRTFYamg1TFBPN2R2MzRrSDZkNFArL2IvaUdkUnVHTnA4YXkzdGxidzgxRDJFZktkN0NPWS9yYW9TSHdiMCsvN0hQcFZMZGNKUXdab09KODJVSldhZFlreldpWGQ3R05wR1V3V1BqRVpyM3dDUytFRkRDU29zVEQzMmJiQlBuMWYvOUJZaGJlOFgxYmtOek9EYitiNGd2UXgvanZlRmN3QkdkRDc2VTYrS2JxQlhoOGovS3pCYzFGOFBsaWN1UFFidFVmUGRMTUhVQ0ZJWi9KNHNWZURhc3ltU0IzUWh5RjEyT09OeE1jQVgvU0o1MHZ0WnM3STFFUGlkV1FrSGtoeUVKYUZwVlpMWkRnQW5zQWk5RitidnhINUxZZWh5SE1CT0ZtY3Z3V2NYSUE4WVBYbGNKZWpIZjE3QUE4NWhtSCtSdjZhT1l4cy9mZkNhNklmM3VOVW00YVNDVURQc0VNOGE3SjBGQ1ZwSVpraHVTRTgzcjVEQ0x3UnZ1aWdSLzl6bTRhUzIwYTcwekdMbU9wNkYyaUppU2Fiby9EYTdBbHpGcURMZDc1Q1owV1krOTNtZzkrZStIemJ0c043UGp1dzhsd3VsRUNWVTNlQWoxQnYyTGJZR1B1TUkxY3VucFRtN040d2YrWENBVXRtemxpN1lacGt1L3lON0c5eG42N3hsbTdXdUZ2bkVKZGhwSWRla2p3ZUpJTm1ERWtuWkFvV3JQbjVVdGxSZkNFT0tpU0FPMUswUGFzQm5IUHJQdVUvbjh2eFdZa0tWcENIbG85cGZXZHE0ZS9YcWI5cjJ4ZDRPT21QdURoOTlqTlhKeFdhNzBPelhRclhyWTU1WnQvTmwycEZMWjNvRTB4ZG9NaVcrQnBhSm0rSnovR3pVWDJmWEgxYTVOOS9vVHhnVWtVZmxISVo1NHVXajJZeGsxcS9FTnh1eXF2cHVtdnNSby9TT1lTbzBEZi9QaGNnN05sVUFtdm1PTTYrc21oUjhDdGVYdDVKQVYxejRwTWMzODJDU3hiejI1NjFMVmhvRVByd1FuYnZJVUlDeC9CZWo0cWJ4SHV5WDBvcVI1VC9nSGlORHdybVdDRGU3czNjVUx5cEc0b2hudXpnV3IrVHloVjhVNnEvMEJPRmZJNEZrZVJYNG9tU1VoVjRnRTdJaHY2dU9xNEsxa08zZzQ3QXM4cTQwQ3NBb1BJcnRxdW9ISERYcW9qVjBKNG5UOUd1OCtmQnEwK2ZnSGFsNkdSWlcrQngvaXp3UUkvUG5rZFArZDFzUHJyNnBKU2dEOFRoMUMrb2hTWmVVOGZyWEhjNFFKT1dRTXFmZkRTT29HeXJvMUJCaVR5ZWJpWDVmQ09ZUDlkejJMTURaTGVEWXJ1bnUxQkR2RVBMdWFDRlpSVGJxSm1iM1lFZW83bXVSN3NmcEh1Ylg3ejJZSWJOYmRmSUQyR1pOZnZBMEFkL1d1MTdjbzcxSjlNYkxnOE4vZVpYc0JnTjIxc1VHZ3J0bUFiY0paS044b1EyYnRhWmJ2SlJOZGpWRzhuRlc0cktwaVpsdHdkMVlUc3JmTlg2MUVQZTZ1bDJqOStHMzRzK01EU202N3ZyZi9SZUphckgxVXZMczlUbWkyVk01emc0NmFBRG9kSXkxM1A0a3o4MDVKU2dSb0E0WG5Hdy9ER1dDZGZLOHNZYmJxaFNkd1hveVRFQmc3QWNyUmdQWHd5T3pic1ZPYnhnSDBYaVFNSGtNNVU0Ykk0WlZPSm83NWdoU3h4MFBXSVpRL3lONW13aGlGaTkzT3pOT2tGV2QzU2g3c0Njd1pQSjdEcmlEYTVwNWxWYThacFVwRzBpZWljcTVGb1pyWHlhMWNvbjYrVWpSMTNhcDZvTVIraHQ0WVphWjE3Vi81Nm1XRmQ2WEdnaGErMERyTDkvU2ZYM1REZSttT3JSUkVYbFBZU21RaU1KcVZ6My9PZG82T2FZYU9iSFJRN2NsSjNkbjBTL1JDUXhrOVVHS0lMd3UzK0FXSFQrajkvUURSR08rUGJBZ2R1TzkySC8yd2NPZk12ZmtjNERpSXJRTDcraU8raUR2eTlMeFVkQjlKMCtPVFh2Z0pxZmxlQSt2VkIrVi9vQ3l5NkJuSVY3M3czbjBDbHFPa1F4Wi9naUU1RjlzTlpHb0xlMytSejB3VnFibncvSXN4ZVNTeHE1WENVL0Zmck1KejhSaEc3N05ueFhaL0R5ZDBWdmRMRlJ5RzY0VkdQRGJOR2RPNjcwaGVLSWkzNjNXb0ZmUlhkY05kb3h4VEVRRDJwcTUrZjY1T0srNllQblcxUEt5NE1VenVJMnE1R09pZUh0eTROdFgxcXJpeDNTOUk1RWp0Q3Q0a1FMWUtjV1ZKMEJEQmc4TWVMNkZOQnovcnRBdWdYMlcxRlBzQjd0MzNWd3h4cVFBL1Bqajg4cnZZbTU3K3Z3citKVkMreE9iSFpxMTIzRjZNYjdmblhKUlAzUk9tcnlWd1ZVWENjbVdkOG0yVUhzVldnVWxzNTd5T0FLTVpuZ3I1cnlqRnlLRXVYb0N3ekJUVUN3bXF5UDJQWmdwek1POVBUaWQ4U285K095aWIyaHNLMTQ1ZmxBb2VHUmZocytQYkJ4dzRHRC9CL293Ym1JRytoSEVINTlGV2dBSnRVSWZxMmQ5SFplc1BuYUlURXRLL3RhVWNTMjMzN2JGdkhCRDR4ZmJjVGpVWW5pZ3dWai9lNU5OM2dJeW9qb2dzc3FHd0U3TXRObERQUHdxOHlNOG5yN1VLSXpqUnZoRFNwampZcGdvUjRSRzhIY0U5ZXkwd2RQdWJBSHJRUHBNeFl2blliL2paKzlZT1Z5OUl2UWNPR0MxeWRWQzVpZnNYZ0YrQU9OSE5pMzUrRCtzRTlHbnd6Q056N0NqV2lDNmRmNzdsZUFOSFB2dTg4M2NWeXh3cFg4MmJLWG1GOE01SkxRWWFFRDdROVZKOVRWcUhxSmFIVkFqdXFBRWsxdnEyNXhaTXNUWEhSQ1BMZ3A1Z2g1eDdQd3hDNkRkNXEzdXVaVThvZUZJenlIbDUwZDVBbm1lR1oxZ0YzUmtPeWh2ejRDTTh0aVVRWm9nZzZEajJESGMraDZMejdiaWZOTzUyZGJLcXRVdy90T0dmVTdtS1h4NWZIVzdzcTZYT1p1UWQ5MCtxQnlObXczUWVvQVlNSWMxb1FaVHFZcDF3UXJhSVFCTEJWVUFJM09vdG1obkJwaGpFNGxORmo0Q3d1czg5R0loVHc0aElZdkJQMFdXaGVCZm92UlVQQVp2d2c4Uk43a1Q0UjFvQ2VLQXQrVFA4ZGp4M21SNllYOXkzL2pQNlMrYm4wMGVxRXJQS1BPVlNURUpPdUl6MWNJWDZ3QjZtTDNLbXFBeEh6RHordmJjOENnRzNzM1BNSDYzNllwYzViUFhieHUzYnpDR2UrTVdUY2NTcitzMzFQS1YwbWJGRmw5YXQ4bEgzKzhVc3FhTnJyUGtMNEQrMlgwSERHMnB6UjkwMnJhdHJWNExuOVBmU1MxK3A5YkUrWS82SDllTHZvZjM4OXFsUndIc1A0bk5IeDJuQjhGeTk0UkdwYk5oVXplcHU4bDJCdmdsbnordEpCaGJ4aGxMQkMyemdRalhSZkQvMHNjUVNqcWNBUjNrQVNxTUkvQ0NlNGdxVlhoeUgrRktuaDQvYmh4YThIY0JSQzFBN2ZoTWoycTRFV1IwRm9idCtjeWpjOXQ2NllmLzN2ZDFHU0VzYUFwU0VnT0FmeGxLMHBlYW91RlVjUDcwUzQ5aTJhaHcrajZFSEFGbU1FUGJLNWkzaW9tVVRwZWQ0TXRxVnVUT3NRdEoxR3ROVjVDSGlUeWhLZzBCb2JnRjVXb2pEQURiNE1QSkxCNWlWVkNPVytpM2xMK3FnMzhJa3pYWUZDMmxDOEVaVk1wZzlQT3NlRnUvRHAwVE1OOXFqRVBsbXJNQTQralI2NEhIc2R0SGdjOVlONk9YSTlDRHpLY0htUTRQWW84OEhEeTJoNlVBMEdveU05L2IzWHNzUkpwWHg2K3F1Qm5ONzVVQ3EzNitKTVhrdmZjK0JQMlNqNUY1Zlg0ZmF0UWxpRFM5NzFPMzBmeHU0V09YQ2plODUySDZLNmVPaTV1T3VRdzFZOGl1ZnE1SUJZb1djdXBHem54aWRJNUc4SDQvSkxCVUh5NjlzcnZmM3h2LzFXQXptemw3NTRBOGIvVnZnZnFmck5aelZKTzZLdEw4RXFlNjVPakxqdko2TUtjTlQ0NVc5RFlmRFNObitqMHlWR3dZS2dQWHk4cUUrU2lMREZEcXN5RmNTOWhEVnpPeGtzRkhFWGEwZUZUMEJtcWcwMVFmQ3QwN202cSs0SzN6aEJPZkV5MHR0aDZKQjJNN1dVaXFNdDQyd29ZZjZEcVlzYk1zbEU2Y1A0SW5ZTis3cW05U1QwdCtaWmVEZmFjL21wM2c0d2ErVkU5a25lZkV2S1hMVTdwR0ZJdExXbngwakt3WUhGQ3g5Q3FyOVZmc2hBR0VKRTJKQWc4UVh6bHF1Z0VLZ3Y4RTEydEhJemFnRDFCbFlubi90ZEFyQnhRdHM4LzhPN1JZNzhFbWZrMi9zR29ySlQxWHdMdXRCMjAvOUxadkVVSGhYWjBqYlZ4dzM5MDRvVGI0M25wT2NmelZHeFlTNWJOY0N3cWZJTTVlQ3gvSHNzSFBVRnordDdobUk3VitMM3FlWVZ1cDljNWhTdE0wQzRDVDNjV2tnajljUVVXVy9EYlYxdGJMMnAxNWxUK095dmJMbWxxQlorSGhPNjdEUHpSYjV0bWdHckIwRmRacytJSjJ2Wkd6L1B2Y2owZDRPZ2FBblR2NG8wMGdFdDNTRkVOL0dnRlY2eFBMeWtONXM4L084N2tOY0FWb1lQU3E1VEhkblh6UHQwODFUbEIvZmZuRk1HTW5LbWV3NTkrN2FTb3JBN3FBWm9UcWlEVytqaGhKLzdvZWs3aEtxWDgxK2NVWnJmbkZCWlFDcEwzblRtekQ3Mk9QaWFmMzVrMWV6Wm1ydmtIbDYvNGpEK0g4bEdWZHdiMm42L0svV0puVEdQRmN3cUZTcDNqNnYrVGM0cHdoZHg4Uml0OGh2ZUVZa0l0cHRyRXFIWHNaSDJLNmVXdnkvUzJjRVB0LzhVNVJRVjZYR2doODIwRTNpUE80ajBpUXJHOTYrUWcxWFhHdzlXYjgzbmJoRDAwbUtxMm9mRXUvclNxYkVtVVE2aVJRRk5pTUNOUGlRTlFITDExS0JULy9QRGMweWZudHQ0VzRkQ1BDOVpzNFhsVUhWeUg0aGIrOXR0V2FlbEpkUHFYMm5mUjZUT2ZTTlBldTdkTnpCWTMvVVQxbkkzbGR5VXpqVW1JVU9Ka2ROeEN4NlYweG5KVkE5SzJBZ1Q3eXhnK0xtWmpQVUpVUkRJNWVwRzEzUmhtS05ZRFcwYUFaRThnbEg0SEpQVHM0aGxVNW9WT1dLMWdpd3BGbEhvZGhLSFQ5MmxvVEpVYnFMTFFVUFZlbFlHSUlFSHo0b3Z4WE5HY01UeGZBbFNnZmV3ODRGaUNEQjJNcDRIM2wxMGV6UlhrUWNBT0dwSnBLb2dJa29HTUw3YVNVL0Jwd0RoaS9GZTcwTU94WTBFWGRIckdEQ0lpZ2gzb05YQWtkTzJvZVR2UnZsNkZZTzhVVlkvN1Y3bkIvaUduRndmS2Y4YjcrQ1c4Yjhkd2IrdHpoVlNVMGF2akw5VjFJaWJ4QVkycFFXWDBtSGk3WHd6eEQ0aXBnR05mblI3RDZMMEJSTDI3RUVlQWhHd3h4S05FYTJsL0RtNnZBbkhmRG4xRkllN1hMSWhvRk9icjF6cWtXeDhHZHI5bmp4VWtDbWZSVmdwMjcwMWdjdnFLWGxQR3dNY3k2djNabkt0WDJUNU16d0lJdmh5NExtT1EzbVg0Y2w2QzZpYzBIUGZsSmJwK2UvN3ZNcDY5R3NQQXJSYXZQZUI1a2VSbklQQzJXS21FcjFTVS9qNytHRUx3RTZvR29Sc3A4T1lXdkhhTGYrWlVyRThxdDNaVjhNa3B4cmxFTU9mL2szeHJKQThBNmdCaTZiT3BsQy9VNERocER2VzFDK01HUEU4TDlYQmhkM2Jnd1NtdzMzcWZRYjhYK3MyWVNBWVd2YnNNMWJGU0VvbU9wVzVzL0FuQ21ML1ppN3FnVjVmYlkySDA4QUZ3STBpZVBadHViMms3NWk4b29mclhFZlRqZ0J2QUgvemcrQVUxbTViVmF6SnVENVpIcFBkeGU0aWZUTFliUHFkVHlYU0kybXE0cGRNcmhvSng2T2ErVCtsLzVneFRqZWc4eVh2UG5NR05vU3JRUWR5T1diTm13emxnSzJzSmpIRjhoNW1hMGdLeXJnbCsrS1gvS1QrRmYrWC9wL2twM2tDSHRma3B0bTYxZ2liQ1ZmU2hTMzZLcXpsbno4cnJWRENLbitOMWVrZjJtK21GVnlhTkdGYjladGlaeENubFRBTHp4WU1NYzl2YkZjUHlsb3BoMmExYkNzT3dESERpTjY1RlJiSysrL28veVljNmtEZjFKRWtySDBMaU9xRExPZWQwbXpIUnNVVnJyV2dWa3dxZkhTYytIWXFjK2duZWJ3ZUpOaTVjNStldHM1cnBuRExkUW5HcjUrRUdyMkJ5cXF5ZGlkVTBxTzU2UzZQbWd6VG8rK0t4eFhYaWR1WnZPMjlkWWkxY1BXSDV4QWtyUk51enUyZXZEQmswYU1pVnMwTGdzN3RGbjN4UzVQeVgwYitxL0s1NEF6Y20zSzJmK3ZPUjgvNXY2UmR2bkZ3NytNTmFkZFlPK2ZCWS9yU2hJK2RaWitVT240V1hTNnRqcHpONzk4NDhmUXp1ZDdSYXVHclZRdWUvOUZ5MzNDSGJ1UWdmR09BbVQ0MHFrL3Q3K2pITHVZdkxrcDhxcVJPOEhlYnlBL1hNd0xNaUozQW0yMlZMUmVVRXNBODZvWmpGU2tvd1R5QmZpWEZNR0lDK0p1WXhZVURPalJ1SWQ5b1dZZmtOdkNaK2xFSm9HMFpyMnFCd0Ftb0pOMnE5Zm95dWJNSGs2b25sbzJ2V2Y5WWdNdldkRGNwRyswQVNrNStQSGJNU1lBcVFKR3NnczQ2K3Z3cHJiTmxnUEpyaE9JQThGZ3dkdUFUUHFZdmw5NlJDOFRoWFMvRmdySVhKck9VV1hpSWFmNGxXcHBFU09LZzd6L1ZuT1hpWXg0TklVd1dKZWkzS1g5KzRjQXJDYkRiYWFsRDI5bnlIM1VURnBaZng4azdBNE9LNDYrLzRqVHJ1amxBY2U5RVRxNVYvS1ZMcnZsc2pKNXU2NzhxdXZkbU9Cc1QrQ3JqMWVGMU53L0pJak5JSHRLVnVwWEFxelNsOW9PRFE2OFFSVTdEQVR1ckpTYUZnbEMwUTNyb2RWMmU0Q0tQSlVQMWxXUzB4dWFLb29zWnVFMkVtaHA3Rmd1clB2QjU4SXdzdDY5WUxFSHlONnZJZmI1WWxtb3UvaTAveHh0YmpDcWhNSlpkcm03RGtzdU11azJnaWJ5RnZ6RVVnOGE0UlBxTitEWDVLOU02L2NYRFNNaEZPOG1DYW5rMmc0VmMrZXBsTkJRYTM4QlNxQjBUd0ZuN2xIL2svZlZJQWcvT2d1Y0FSRDBHWnhDd01LSXI2WDdTR2gxaE9LMm9UcThTWmREWkt0L0ZncXBPZ1ZqZXlDN3lIS2pPNEVtYXNTRmlNeFFETE5sdnRpd3JBMFVIZ1dJSGpDSmkwdklZVUJkS0pQUXl0by9yRFoyQ2cxVXBrdEYrd1RQT05uSE9yUUhPeTdOYSsvQzlPbHJVcW5sM3lrUFA5RkFmeUdsbEFOaXN3eEhWeUNzMkVBa0kvTDdmRnpOWUg3bWJRRjJ3Q0xVZ2ZiNkw5dlJWTnhEUENRcm9idHVhSFBPMmtkRHJyK0xLbHVOdHh1NzZVejQ3TWVBVGtkdEVUUkxleW1sc0g3b3J0VXRXN1NreUtxNlFIQkFiVVptZWdWOWF1NE9lM0M0OFNhQTY2QUU4eVJJdnBjQzFFRjdGNldpcVAxbWR3SEI0bmVjell1RGxtc2xFajdWdU4yM2NUajFzbzFqNkcvQk9pa2hySFFyN1FjQmZTQ2s4ZmljVkdrem52cVYvTWxhbDBVcDFtLzlHWitRbktkQ05BR3FYSWI3SFVaQkJENDNOeFV5TlczL2d1RzNVU2hxSzByTzl1V04vYjlJR1gxYkIrMHdwWXd3ejZPV3FDZ204T3dMV09YcCtlUmROQXdicnBSc2RndUxMU2pMVm9HdThObXpqYjVvSEhyaHFXRUliODAybTlib1RVMHlTUEFObXlRTnJtb1ZjY2dpbWVYeWh0bTk2Mm5DUzNqY1REV3BLMFRRc0ZJTkVjc2ZyU0dRbnQ1ZDlIZTcrK1pGMjBwcVZYdnFIOWh3dEFTY0FUeDlNajMzd0ticVBLNE5NelI0NnNuVzVFTmNCMXIrbHJqOEF1WUFwcDB3V084NUR3ZUVYaEhXcWhHNjhVeXBBcnVLaFVPUGhXSXZ6cEZ5VnV6MjR3VTE1dG9MemFZR1JRZnJyVW0wSFV0VGFjL2hwTk9YbE4vV2JzZmt4OUFmMmVuTUttTFI1ZGtNWUhCVllZMzVJUEZvMUxxbzlxV3EyQ054MW1QSmdWQmxtWXNZWjh6VjVTejlGVHREbDY0ZUdHQk1GWElqSHVOYmlhU3Ivb2dpMHQrSXZGclFEb2R1QjFuV1RudkMzeStaMDIxNE1mbmRzMHpOWVdScThSOUJwRms4ZnJ3VmhjWjRJdit5NTNpRW51Tm5PRUdLbk9pSjRyWm8xTFNFUTlNWmU2R01DbVMwMHlRZkJNME00TllmcWFJMGV5RjlkREFWaW9xVXluemhUY0gyUFFBUDYwSVlPcnd5VnhlMWwvMU1ITnFhUHpDdlZ5V2RmYU14TzdwVW9kMG1oTHZDN0x0QlJKdTZLT3NUaFcweFYxakxhRVVsdENmRE9meVFrTEV0WWsyQklPSlpRbVNCbk5USFVUbWlWMFNzaEtHSkhBZnZISXN6OUlBSG0ybDNCeG95MU9VVnQySEl6N09vNmkzTWFGeGNYSE5ZMFRNbXhKaE92UnNDM204eXpEakpFSVA3ckFYQXpmRVVsT05OekxGd0UvWitLOFJlajZwWmJwblljMmZhblhra1h6bTIwN2MvTFl0R21mN2Q1dVF3ZkJhaGt3MTNaaTUvQXR0YU8zei96MFl2T216ZnNFZDR0WTJudm9tSTltdmJka3dLSVpCU3R5Z0NBajZrS3VOKzdUb1ZJQTdkUGJidlpnT3VHVVBsWHdYZ2pYMElKNkJla3NUZlk2RnJvcDE0blg5cWZkTDdZTzh5S1N1elZZMjRXc2M2OGxQRWlvbE5Fc2drc3dKb1FudUhhenM0d3hyNW01WWhuUGthNGpvTzE2ZVRUa0VaQjdWK012ODl5aE1Lc2pzUHpqb2hYdm9zdWd4c0hidWYxR2prWGxoMTlLN3pTMGFWejYwc1h6YXkzYnNXM0xXNXZaQU1BZUEzcDN5aDZ3WW1iYVpFdjFTYjBXYk5TTVFsNW1UdFlBM3A4T0FQR2Jaamh3L2hLWVRzK1k1RmhyL0gyZERsT1M0Y2NNZndGK2pQWmMyKzViVGNHU0lSQXhDbHlNRmxlR3dNaThHRFZHaDlPUC94R1ozeDZrTURFTW9mK21LM2hrbVM4L2dUaXM4UlBLcHJ1QjZDZmVhbTNiTTNlMWJjMmMvbXE4WXBPVzI5blJUYTRvMWFhbE9UdXhWMlVKeDZ2RzY5ckJ1MWlJS1RhL2NoeWVCT2paUGg1ME14VytVK0lBUWVWbkorRUV4dUZhMFg0Uk9scEFmdjhIYS9hSkVCNkFodjBVbWw4NUQ2LzNBTFg2Wllzb2JyM0RMNyt6UVJRMzNHRzZleWlXWjc4V2oySnA5aFdOTFZjWENlZnF2a3NFSTRNdTNRNTFXVThoZ2I5WVJ5SkJ2MWgyaFdHaGVKZE5xRE43YURWUXFYbG1EV1ROUThGVHVmTHNiSDdQd2dsZ1VQc1J6N0lvMkNNZ0VYeENwSkRLQlNvMFVLYm8xalNuQm5jeEdueGRhVERyZzQrSkRHMjNTTkY3YXhkMEMwc09EUGFLQ0tqWE9SUjluNFdtRlFDL3drTFllVkt1cjArRzZOV3NlOWtPbXZPTjlvZWhzWDgwdEZCL2w3NUNJc1BSQ3lBNDg4U0hxWW9hVnlnU3VrbnVQc2p5cVBmbFM3R3VSakxhazB3cEpLTjlkYlZzQWVyZ1dVYzhacVM1MjR3R3JwZllsMkhFb0E0ZVRZU09SaHF6VHU0TG82bk1WRkNlSjl5VWlNOVd2SUlOb2hzTTFlZ21VRW5BVEJQbWFwMzBxOUVPMGtnRnRsakNSWXdHeVJCb1NZcU9pY1pMSkNVNUpTa3hNQ2c0eUJSVFB5WTZCdCtYRE1RQklUZ29HTjlQVGtuR3EyWGx6QXY1bDk1ZXZuem05L2tYWnE3TXQvWmZuNytwLytqUjJSdnpQKzZmVDViSzF1WG1pUVdtbFZ2cGN0bjJ2aW5mR3JCOEczSHdYRERPYkIxbktsaHc3LzV2Q3lhYUpvdzNqMXR3bjJPNEp4UHd1dGxQMjVhcThZR3Q0SzJnRWJ6SjhVTTFyWFpLblgyMWUxOU4zRHlSdHF3eHFLKzJETGNHdDFqVEpQeWoydFJBbUc4dEh2SFdXM2syNjFiOHo0aXRxRmRtNm1UcnhOU3NySTRGMXNLT21kTkgrYisxNGtIRS9SWFQvUE5HbXFldXdHdHB4VlF6ckw1LzhpQ3oxUm93Y1BMK2lEMVRCZ1pZeDVrSFQ5bERlUUk1eThzeDFPZml1R1pjRys1YlRVUjZoZHdXOWV2eHNiWkFJNW5LdmlRWXdSN3BTd1BRSStQdGxYd3BXRU9nL2tqY1YrK3pIRk5LMGg3SGxkcWIxaU9JV3ZoU01yOWVVYjF0OWZpTUhYNzF3dXJCUEx0ZmZmeEwwL3JrbC9wRjliZlZKNy9VRDZzUDgyejFpQitGcmI2eHVMRVRiaHZmTEc2bStZcHJiMTVxYXg1dmE2VnNUbmEvVmhTY09pVlp0ZHJJNTNIMWs4TkFJRkVaWEkvbDhKNWxEclJFMXFCQ3Q0WEN3T0VsRlVPR1I3Z3ViVHovN1ZicmpwZmlkNHpkZHY3Y0pzbTZoQnc4V2xkTnpuLzMzZnk4c01ub3o0WnRPNlpQeXUwRWpNTlI1TXVOWjR2cm9IanprdU96NzI4TkhqaHc4SzN2WWROTE4wWFlhOWQ2eDJjZmwzeFNCTDVETVVXZmxId01tNjdmQmRxL3VhcExjLyt3bkhFZm9LSzRjWE9tMC9HWlczNVhQQ3YrS28vUGNUZUlBZjlxZkNKOS81dnhzUmVSUzI0OWtFY0hoUTFQRWJuazFnZi9ha3pzelFQSjZhaHVVUDdGZURRR2lZSC9ZanlHU3U4Zk8vN0JzSFd4c1d1SGZuanM2Q3BwNkRSeWtKby9iOVNRYWRPR3ZGdDlDbnJZc0YwcUhvODBZTXhGRVM4M2ZrZG9ETVVMcDlEOTB4Y3k4WDhYVGdQVHFRdDRQRDVlZ2U2L3QzN1Z3b2NQRjY1YS94NHdyZmdZREg1elZlZm0vdFZ6eG4rSTF0RFJnT3pjVy9xRE0yQmQ0U00zNXp5NmFBaDZxT1VLZDZrM1pSZ2tQdFkrMzRCNzE4OUFRdk1OSkV1Um9ha0JTMUNZRlFKTnAyS3RTU2kxRjBxNDFId0o1TzJJbDVxUzlNVis1SVpmR0RWNCtPdEJNdWxCWUZKRWNBVG1IT0kvSFVWRFQvZ25SRHR5K1doM1IrclNCNTA3anh6NSt6K2RxME4ycms0eGxtdHlKVzRRdzJpWDZLQWNYYmRKMWlVSFNXODBKWmQ0dFhNeXlhV2NYTGFSZkJsdSt5ZVRkZ2U1Yk1PZFJMd3g4YndsWHcrU1N6bStrT05CNzFLN24zL1k4N29zaFhYWlA1N2VneThCZkFqUjlseDQxZDB4dnBqWnVmUFVxZWo3ZnpqTUI5dzB0RWpZakdYUEVDVVhzUzVpUmQxWmdOTVQyMTNVSjNRVktnbXlqNHpiSUorQjBpQ0lSZ0RldDE1SDkwSHRQMzhGb1FJY2NlSFRnN2R1SGV5SUZvRjBJK2dKdkNoTXc5UHZKZHN4ZFBIVy9WL1Fkd3l6YkJIRkxOUFRXR0gzK3k5b2RPZE1pR21jbVgvNDZwUHpXMjRKY01pR0NldHQyemEwd3dUMk1vSFlId2dVR1QySlJidHI3eThqK1ZBb0Zrd1R6b3ovaDFtaFRrM0g3eEFOVWJ6RkhKVWkwcjlFSG4rSHpVRkVNcnF5ZCthUDZHb1NpTHFNZmtnQmxwUFRmZ2RSRGJHc2JQc2tjeE1xQnZNMjk5NE1abS9PMmd3R29wNmJlMjhpWTFYMmtYQ28zRTk4ak9lM1A4a0JVY3pyOHFMZ1dST0JtWkxEUEFLZzRXS2pDU2VHN3NQUEZJckI1VjJsUUN5djF1SHMza2JNb2IyTjJnZUpNRVRqam90TnV0b1NhdEQ4cVJicW1vMzFwcVN5bGNPQnNWUHVwRjZwYlJ1aVB5ZUhpYU0rSEo5VDNiOTU1MVZ2a3R3T284VTQ5SXJVQjh0NEhwd2RpSHdzV2Y2SmdjRUd4K2paVFJxSWw2ZlBHUmRIeW4yTXkrVXE1WGlPbG90SmljRjBYMnZRQkx3anhsRmU1L0hVR3gwRkg0bmJPSll5cENtWHhtVnl1VndoUWR4L0k5N1dQOTQyR25OMFRYZmpHYXZORTJON2d4cGMzekFXOTRJNkdhOC9zVkhnYS9GUXpmMDZwYmJSUmx0OWNpMHUwTngvcGRUV3lsajhtcTVqbUkrNkN1SGgrdDM4RDcvL3A5OWQ2eXNyaDhLSXpLdzhBUTZzbDVBUUIzNkdZbDVXMWtnQkRxcWJtQkRYbVg0alArSnY4ZWdiM1ZkSGQ5MmpqamVoa0pmVkowOGt2OWFyaTI3aXI1bjBhM3o5ZW5VYjAyOGpSVGdJZjRzWC9wVFNCZ3hJazJJYk5xaUQ3a29kQitMUGRSbzBqRVdlenMrT0o1cjdQMG1kY25JNjRjOE42b2hWbEdlZlg1N3diNCtudFZBL01GQTh6Z21jSitkTFQ2NnJjeGJNeStOSjlnd3NSdGlxeGR0aTRvbFpxbEo4UmQyTHNub2pXWFZpTUY1emZBeGViaUJGREl6Q2F5NUpCQ2xSd1pJSURHSk1GQi9EcDVoQnNObkFvOWhLNHpOYk4vQWVsOVVHVnZjQnFXajlzekUrYUR2b3lhK0VvSG1yS0ZSZWhubnNvZFlnT3RhMHBQbHhQdE8wdE1XeFYzelJGdEJIK05BWGRFRnJrTW03b08rcmpjZ0ZiRFd1YUJWY1hEYlB0S0wxRi9BbkNOcTBSdWZMYmtDMDcxWEE0cWNQb210aVZ5VTIzQmpEWXNOTkJzNVBlTFg4dWt1TStGcDBUV2loeEJHUXNpU09nSlRsRStXeVNqeUIzaDdiLzBYMldOWHlhdmVIYml5ei8vOFlZeFZiYkQ5Sy8yRE9lYkxuRm5UaCtlWlhrODc4NnYyL3RlSjVGbGl4dldNY3NjQ0s3WE8yYnkvYkl0dGZJY1hEV0lESHdJam5iQXMzMGV4cVVETUhlZmxNMWdWRFNPL2RSOXdnQ0hGWUdRczJ4RWlXcUlpRWxKaVU0QlIycUFVUzhzR2puNTlOTWhobWRGZzRhQ21hQ2lZTmFqK3l3MFF4ZmNkT05CVm1PRDRTYlhjT0hSNXRrTjV0dGJaZVR0alVWdlBGWHUvTTJTUExTY3hYSCt1VHRiaCtiankzZE1jSmRDUzhYR2VTdHllSmdiZWJBanhacEpKT2tQRjBCVWhYV3lHam1nWXpKM1NMeHVtY05BNnJ6K0p3ZzJGdzZxQWVCU00zSjF1ei9aSTNqejV5MmJwMjliaGwwYlZXanU3WE9pOTFhQ2RRL3VkQ1Q0KzNXazV0MUxXVDQydngwb2FlZmRHWHlIRWFDS042T2Y3dWtSTS90OFdNc1o4UnVZSEU0MFlZL0oweEQvOG1GdzJ4OVVvYVZTR0tPcVFrQ2hFT3ozejRWNzdZRHBDa0c2QXY4WmZHODdheHVOaWwvbitJbDNPdG56bThKUEtOSFplc01DYWZ4VlNBSG9UK1dEbVhqbzhpOTdpMTZ0cTlvUkxRcWZXdkVZZzNGYkhHZWJqa1NRVU03RGFSSllhSDg5RkgrUXNXOEVNZGxVQUdQT0pvREkva3dKazVqcXNjb0lkMlRhanZad2MzcDhicSszM1krMzNpWFVJbENGaUE1SnBUcE1MNys2TmQxbzgrZ2lzZFYwQTc4Qmg1Z2NjNTRJY0JhQmJKSllSdUNlMG83bFEzTlp1bjdtaEFOUTBGdXZBQ2M2RE1DendyK0lMN3U5Q1NHTTZaQXFBTXNCWUxsRFJFNTRBUFNQN2xPd21zL3dUOGVlRWN6VXJrK0IzOWlINjZnVTRJc01lemc3ZnZPT0taMzBFUitwUGZUSEZZblhUcTFwQjZDaGZnUXFkL2dKTk9MejJkSmxjNkU0VEFJRWhBQVZPU294bWRmRVBIbGZtM1FUVlE4bG40OHVrUVh0NCtuMFpnb3RWM2JreERmMFZsUk82emJ0dnVlS0xFNkFTalZZWkFpZ3Q1ak9ac0hDdjUwZnZWMENySmorUlFCait6KzZJbmk0dEVyeFBjR0h6L09Mc1Bpc3BMOFAzKzZBMFNONGp2MzVUdko1WFRYRXBvbFZpVitrckdzZnRFTVNNK2FtaVZVSXZXZjRmZDV5MVU5OWhKY2xMaExnelFlVWZxZEZhM0xneXExNExaaStabk1NZmI0ODFFUjhNWFhab0tJSmlwT1lLNnBoQWZCazlvWWQ0Q0xBNk94c0lKUzFBcXVMOE10ZW1Wc3pBL2YyRk9QekJKdEJId0hMZ2RYUWZWSGFuNDIwQlFCY3RIeXpITkJKTzhLZTdRQUFWTFIrZTdwUXZmK1FlYWQyU2FjODBrZHM5Y2FDYkJYbVlTN0dVdU1zT1IvNklOQkVXRXRRRnZXN2dOUG1nOW1MTWFiZStROC9hNGNXL252QVlpaElhT3g0NVM4T0MzMzFoUTMrKy9nMnNjS1ArTDQwUkkxOVEwTi9xZTdzaFU1NDJocGdIdzVUMDFDUFphMDRNdTVORExrMmZ3cVRxUERZRkc0eGhLN1diZzY0eElsRGRma20xZWpreUUvbC9rWDc2Y0Qwem8vdWV3OFV6b1dBK253M2x3aStOMTRmMmNyVnR6MEZpNFduUTBjRVRRR01WS21FODlsaXJqTm8zU25QenEzRGdEM0kySnMwM1F5TnJrMGdUNFB6UUI3Snh0M2JEQkNscWgvWlBBb2prUXBZRWYrRm5Rei9HN2NESG4wcVVjeDJwd1ZFU1ZIYnRGaG5YT2NkSmdLaitNZHVQTm9ETUc2ZHFnK3BwNFFObmliOC8wSU9OQ1lnY0xQZVo3Nk1lRjJQeTFzOHNIZURnYkVaSGtKSjhmLzBVK0NvSjlYTG9maXoyT3Z0cStUOFR6cVM3RjVNNzlweGpJZjZLYmtzd0NJZjhya3VIMTllUFFDT2pwRXRIS244dlJoclRLZktvZDVWT3hNcDlxeVdKM2lic3A1VlAzWkQ1Vm40N05mbzR6SEtMNzhCUTNIa0k2UHZVYzd5cHZMeTF1NERidUlNRU52T29XUXhBYVhWTFp1UmlPSXVpK0tRZUFna1QrRmI2ekl6cWY0Rkh4QXZ3azUya0pYTzNvSys5TGVHeW0wdjE3c3B1WVdSMnZlZzdkakZkeG1GZmg0WVV5NVhrN2lDSk9XQlpwd0h6OEdqanlQeVE3R0w0S2E2QTNXT1RxbStEbkFXVXZzZWhWMnQvYjBYMER5ZjlhbVdnek1xSzR6cEZYVFV1azgrZmhUTUd5RDV2ZTJ1YVN6SmZrV3RmSG43Z1JBYWdZOE1OR25SQ3drV1ZkNDF1NlNBRXh6bnlGVkJhUVpsSHNnSFNWZHQwaHBNN1h5aG45WlF4U2FTZThudE9oNnhQanUxNXVvYkN3ZW1tQVNnVGZycjhISW1SeDROcXU5U3hPRiticDVRRXRSa05CK1UxeHFYaUVxODI5VE5ITzQvRlVxS2lCVVM5UjhnV3ZSUzFxQ0M5UnNzT054VWw2QnhPc3o4UnB5b1h3Y1VSZGlJbWptMEtRMFZhNzFGWTdIbXZxN0lpVDJKL3IrNGRCbWlPTUkzNmkwVERKUkZNZkJPS1JNV0FGQVFUNEUvQndHY2haWERyb1FKYzJxN3VpVzJqN3MyTVNYTDRiK0Y1THpJeGRXSFRSYnIveWxyWGh0UGFPTGlzV2o1KzJiRXJoNGlvV1MzZ0VlQWZFbjBhZ2l3aXowTStuU2hGQ05oL2YzaUJxTytCK0FYSG8zRDMweUladXBQdWI0QnViMEtNTzdZSEhPdUR6NmUrUFNBelUyUEs3d21Tc0w5WEdjcjRjTlVBN1JLY2l1VjFKcXFmV2Mvc3QzclhmYk1tbDlwQmtubllYbjZ4Mmw5cFhMQ2tTTlZZd1dCbVNpb01CWDVQb051TG9rTWduT2ZNd0pEWUJ3dVRYbDdWSW1kejZXL1J3L3hLcDkrUWpIOWRvSFRZOGY5MnNtUnZmVEgwcE82VW9wMHUzck54c3FVMmFkN1dxNGVHZzllUFVyMEFsRVdhZVhaVjJFdjFkeVR2MXp2ekJuejFFejQ0TkxQenVOVjlmY0dqSWtoTzdGdzJmK25sS2c4OEl6aHVXRXoraE1WWFJzang0aGNxSmZkRHJKQVljMzI4ajMzK1QzbjhKODFsTmpuQjgveUhsdjNYUktoS1RqZm52Ny9MOVNSWHpCNUk4S1N6L2xiOEVGdEExSi8rTzk2Q09iakROZEVjaEtvNWNLOHhyN1lJSGtNSEZ0WWtYS2xGL1h4K2EreEJ6MkVBTGMzMUt3cC9oVUhEa0hmVFMxdHRTUG5RY1JuSHZ3Smw4cmJMek9aVWM5MkJWSVllUFpmWjVPVCtYU2NsdHFOT2JkUDc5bENON3VjNFc3U0d5RHBTK1ZTVzhReGhMS2RhN0tNc2RMSmNYb1pTdi9kajYrREthemZKNWdlZ0NOUHVLZ0xMQnloeitJc25weGNlVzFhU1ljTGovRDlMK2J5VHZjM3RZN0RYdS8wdWsvMG5zTmJrUHo5SDJXTkFIMGxEY3Z5WWxBbGUzLytsa0U1VXpRNk5yTkxCSm40ekhtMEtiK0RGL2Nhb0tPcEhrd0E2VXkrL0VzMGZGazJ1Zm5mMnNxaE5SRG5DaDZLRHdHNDFWVG5lenQxWHNjSmttVGsrVHI1NG1MMnE1OU5GcTU0dzBsYkIyNkJ3OGlxNHBZZVA4K2V6c3NnVnE0RGlKSDhOOSs1anFXTi9LZmZ1QTl1MXczTGNPT3JjZnkzMzdsdzRYTDVScnAvSCtjeXVQcXdwM0lCTlhBK05ka25VUzR5dUxBYk9ZSk5WdmdScU5nbW5zZjNLS0RKV1htZlJ5emkvV2NkWWUzYmJuSk5mdnB3RG0rWGtJZnowQ0F3Y3gyTHhPSFFIb2pqYnpIbjRFUGcvVHVoekwyVi9RSEJIdDNKd2FVVXlDQ2pIeG5zQlBkcktWU2wxTzRLaDdjTVNMU0Uza3Y3QzJiaGRlZmNEQnJKejgxczFtRFlpSWJFK0Q1ZjBrWWVNNnNYdHZGakxmc29rSW90QTEzdUJMSXVjQjhha1VGbW14Qm5YOHdEMHFsc1FCMlZWYkJ5MlpLQ01tYUdPMU5sajdIeGgyLzZGMSsyNEtOZWdZV0szNjJYdG9HRmk4WjAzMWFvNk9UTmRlemVMTU1NL3FRUGZaV3VWM3hJVjRudzNuYWlsUlA3cGpUWVVxZXlBRC93bWtucnVCdXBNMHNtWTRmWUFvWGxUUlducEZzcFhHQVJyZkhKeVNKR2ZaVktJdmduMEJVQnk4K0dKMEV4MS9kN1VBTTNQNlNTRHhwZ05VTDJ2MTYvMEpoenJFdERybG1NbTMvdmIwb1IrRFFRZGdYT2xYdkZBY05Na1RCb0ZLSUIxdFFwY0dyN2lLN3JSSTZkSGdOYjV6N1Ird2N2ejlKUTZXLzQzM3lZNFU4eU5hYWFPTzJhbHQ5T2Q4NWZnU2dZSmxXdlRjbDN1Um13RFpDUEVXR0FlU1NCT1RtWmxLem1sR0dzaFRoeSs4QVVMN1NmUm43cWljNXMycmNPV2JQdi9KSVJ4ZVBXTDF5NG1OOXkyWXZzTVB3dkhyQTBHZG13bEI3eFYwR21RKy9xVHNtNXpRWFkrYk5PelNyQVB2T0xsQ3JENzNBQm5IV3FnVkdUZi9hRGhZWHJmZmxuOWNYbDcrTitwRjJvcnZENUgzcWovS0Q3ckprMHl4aGVtWi96RVpEL2FpZ2tmdG81ejFVN3dwZXRiL3MxeG1ETU1NcWliNktyRzJPOUVwWVFPVmlRZTVRU2pYV2Y1MWlXVnBuL3RyeFUxL0YwRjBPOWJBaEZpS1VzNXJaUkhNUndTTlhHeUpVTEdEOEM2SWQ4WTdpbHlNanVmbkY4T1lXWkFQaDFnMHZxa1JqZHZqNVRFQ0xwRHhwajVFZi9JM3FXeU0rWWNzWnVweVNPcjhTblNoYjBvMDZmWUEzb2U1bFhGNG5zUlREMlVYUVZpbXNlNlh2NVljaWxnK0E4SWY5aDRZTjI0RzJMd0F3cTdtS3llbklsUWpJM0xuNkMwYlZMUWpPczdYbUU0SVRsQy9NaitoWWZsMWZMODJ1aWEwcEh6N0YzYWZyMTkrbldLSWQ2QVk0c0hjYS8rRTZha29LTTZkQ1cvNDJ5RXcwL2hoRnloYnV0Zm80N3NqYU1KTy9oWHJCL09ySjRYNitqWU43TllINjN1NGE5K0Fueno1aTBSeDl4TXJUUmtELzZLS0g4bVIySUUvVC90NThqL0ZhYnFselE0QzVSRGtIWmtnRnhDOUR4d0VSTzhEaFlEb2ZZRG9mYUFJWUwxUDN3QVNsQnp3cjlvVGhMZlFEK2FIMWNmdGFSTFVyUS9XVXhoMDBiTmh6dmEwSXdNazI4MDZPZlYxUERiTjZkZ1FHMWx6cDc2T3h5YUIzaWQ3OERMZEhseFgzWU5YNi9iZ0ZNVXVKOUh5QkJXSTFDTytUZXZaaU4vN1BpMS9WMzd2WEhyZmRZMVRMSGV5eHJrYU11YlhMUVh6V1kzQnBSaUlvZ09YYWNYaWEwZW5raEoxeFJCblhsOVdqNlRVd3czbXRyTWNEVVlSMTBNczlUNnFmeVNyNzVoU0h6ZTRHY1V4cUd2QTlkbnFza3grcEp5SjR3eGhsTmEzbGR3TzBuZ2E3NzdCaVlWT2FhOHAwMzVVb1YzU1l5WTRGRndGWEdZbVI2bXZJUnFVL0Q0VHkrK0tZZUl4NnRuYjNNMktVUHd2dDN0alFUbldWU1UzdURqemduQ0dLVW9CTlJtU0tGbmk1Z1QvbEJpeW1jRXRvQ1pvajByK3d2em1nQkRyUUZOT2RJeDU5Zno1MDQ4QlgvYm0zK0l4dEF4ZDJvQXVvdW5nRFJBekp2MFJxTjh5dWNmTEhaKytBMTc1VlV5NmhtNFJtdDh1djhlWENXbVU1dlRuWmZxaUZoWURKeU0rNittMm0xbjJZRDM1eE1OQ2p6K2krQ1ZIRTJSVUprWFExaVRUMWdUQkdpZUJEM3AwNFBPZllKbHVqM0xNV0Mra29YTTNVMjZqMDVyOXFZeDM3ayswMzZXTGVCK2FJYytaM2FBbVJiUVFPUzJpQlNsTDJ5c2V4V1Zuc2puVEk0Q1VqRENRa2hFc2VOTzVaMG5LbnNVTkJtdlpQS3dpK2lnWnBwVTYyZDVsVS9ZdVhMWTV3MGVvWnNCN2w2MGFDVFJSeWxJY2VrTlZaaytndE00Q1EwalplTEVtTGh0dnROVlJ5MUpzUXJMdkVoc0RvVFhNVEVzYWRDVUJOeExYV1lubTVHbnV4dXFxK0wxdGwwQVYvQnl2VjBvcW9BMFFOSmhnNEI2b25oOElIYkY4TmtRdGJ2eUd5ci9haHg2SU1HLy9zZzlLdGhlUEUxdUxPUm1PMytHTmM0ZC9rUEhvZDI1ZytXcEhvakUwL3JFYTVsMDY5cnM5QUhnTHNXNEoreWRLZWtOSEVxR2szYVVIQ0ozYWkrN0xsSHkyZlRCL1doeVE0Ymp2OGRPcFExZS8rMUthdlh2RDNCMGJCeWk0OU5KVE5YZEdIckNBOW1RTiswZ2VlcHlBSWhVbklJK2JVbjdmcFF6RHQ1ZlVlZ1p6NVVxK0pBOWR2aVMxUHB0Y0h4N0RERG96VEFadFNRVlhuc3dMNHV0TjYveWF6WXR3MFF1WERDZkJha3FkTENmMVVUbG5HYTV6QUozRDRRWmVVMUtMVlE4ajlMbEZZYVFUeTk0QThGcUlrTjk1RjNSbTY4YkxkZDJ3ZDE3RFpTUFpPenZWWlpneHZLWWtMa2R4bHczVmNIc3Z5M1dlQjBOSnlXakt2Nk1aRWlhcmsySWZrWGFBTWxabks5cU9hTm8zU2trbG53a2R0Mi9rTVRuSnhpMVlDdEJqTjZ4VHNCdTR2RmNmYVV0d3pyd29rbHJQWU81alpVMEh1SzVwVnA5TnJXK3doWTViRllPMnBGcG5CelhYU2krUURESkl5VENlbEF6VHJuMVc1ME81VGx5V3MzTVNMVXZ5eU9uTFVwMlkwdnF0VE9zWlJtdGxzUktMRXdoVXkxS2NOanJISHN0OGd0SmEyZUNsS1VueWxXQ1pJSWFXeTJON1B6ZFhzVTBTR3pmRHVURksvTmhzVHNsdkltSWVhSXdHMzN0d3hoaXVqckJLNW05TEdDMmhkSjZFYXVtbU9HQ2lEVC96alBqc2NIOEs5ZVJuR2pPZUdHcW84RXdWTEVlMm84L2tSWExHYUg3THFsYVl1dEVjT2RtaSt6ZnV0eHloSWY3OWVrMzYrNGN6Nk8vVDVOOGI0ZWUvMVp6bGpPWTN5MmM1SGZqZk5XYzVvK0Z4eW8va2ZBQllMc2h5ZzZhdHc4N1EyV3ZVMkYrVEtDUFk2aXpaN1FYaUZFdVBkRHhMN2MxOVFCNHgwSkFFSnZpU1JMRnF5UUhWaGxKd2NUNTZFM1ZkQ0M2Y1BveGFMUVFyd01xRnFOVlJ1TnZSRms1MVRJSzdjK0FpeHlJNDNER2M2UXd5SHFBTHZjOC9TNnRJTDNSSGIrcS9vN2ZHYWRCN0RqcUZUczBEdlV0UG9sMXo4YzlSODlDdUw4RGZ5QU44aFJMQjN6bmdNbW9EOXFJYTdEejlOWXJId2pEZ1c3czVmVkJSeVRrZXlDZit2TjVIZ1hPRlZ5TnhsaVNEZWpMQnZtRUEzUHlLZkZUdDV0T25OOEV3dEhqSGp1MDcrZll3NTJtblh6N2RmOHRSRlJidW1qWjdMNTREdVlUSDBET0lWeFhhSkErcVEwWW9PWXZkNG9YYkRaeUhFazlyTEk3UUhaRFpUZkp2dW5PSXV2VmtDb20wbjBKMU1aSVMwK0FMTERFS3piQU9JemkvWVB4MEFZUlhIeFZ1Z2NKM3EvNWtEU0NrNHlac0I2Qm9ibWY3bXdQV3BoNytPcHUxaE5LZVczNUhTcFVxYzVGY29wS0Q3UGtvbWpRUnF5dTZnMTNpcWRkMWlENFBxMzhZemRWYUxZeWFKbmpkZVFyeG9IbEpoNTRwVWZ6R1pLck1HTHlBUlZMeUdnSVo2b0tkUThTQnBOenZqdzc3S05rS0J2ZGV0azRBa1dGakluRnpIeDBjc1RRaXFYakM0ZS9oejdVV2oxNWR0R3IxcVBkcVF4NEdBQjZrOUhnZGpuM1dmUElzK051WjNsOE1CWVY3MHRGRGRCUDJIZHhuRUlqNEUxaTZEMFdPcndPUDNoN1kwei9DUkd5djViZkY0M2c4NnlpWWc3cmxTd0ZBWEdNR3hXcStNa1Nsb0Q5aDBYWkpvRURnUCt5UnRXUUR0ejVhVlkybkRBVzRONUw5bGJHV0lPa05lSG54N0lNYmR0cExEcUlWWU1COXgrekNVZjNCd0c0TDFndkFFajQyc2dZVUh1NWRVR1FBRTJldXlWbjY3bHVMY283c0xkeFRxOGJXS1duOUN5RGdEdmIrY3VqVWt2Um42RHkvYWpOWi8zSGxOd1dDT2FTMmtRWjl1eHJUdFBDNGRrOGpDUWF5aDd3VVdSR3EyaGFwaStlMzE2TEkxWFhyUmFrREswOWIzQlFxYmNVbzdZNXh4cEhDTDBDVHRNbXpCVmlqeG9USVNDRDhzSFp5b1RqWmVoYWVuanhyK2R2b3FRUzhQN3ZZdDFmbUcrZGJ0WUxiUDBoZDIzSFEvRmN2M09CenAzVHVsdGwvY05lTWNmM1dMK2hTRUZuTjJwM3l1TDdvZS82NHVJMkw0blp6RlkyZEtwUVNWS09LZk1WZ041R2ZWOG5ucHI1cHZsaEYzK1lMOHV6bDVPTG5DMGJhNTVQTFFYTEJENHpjOGJYdlZWS29VUDQ5VDRrWHBSNGQ5M0VKbmNkRHNONTJWZDJIVFNHc0x6Z1B5a1hlWWs2eVVFUFU4eVpMUUhBaWYzeHdsOVpSVVdHZnJQeDIzZkdkTzNlaG4wSFZPMDluakorWkwvVTFvWHNnMkNmcXJkYlRaN3lmWGZUMmdwWFpYeDBkdmF0MnBHM2FyRHBSYkMvSVE5ZjUrVFJXZnBTbW45d0d4enQ5VjZoTkRUaTdMa3J1T3RjbUJsWnNJbjdROHJ3bXF2TWl4ZGxFbU1qUHh3MnNIK3o5bHJVY1hIMTM1dHRMMFNrSUVvNThrNVdWM2JPckYybWhvWExmeEt5TXdkazUvYk9IWmE5WjJtTnlSTldwV1gyOWFmdGFsTjgycE9IMUhLSFRScFY1VUFWL3FhSzB6MTArYjd1WGlaUHhGYldwKzZxNGFxTXlFNnV2WldJeVdCeEpGaFVDaE5PTWEwV0dqU1ZNNi9HQnBSOFpISjhmdlo1VWEvMFMwZlpzb3l1SDRvc1A4Yjg3U3RBb05EY2J2QXo2UWRrV2p2bVRSR3o2RVZ4dnJxTExnUTRpVE1WUTlIYXgwZWlEMEt2ci9PTHN3ZFc5R1lmU3dvbEg2SmswVzh0OE81UzlmRk1EVUNjdkI4NEMyZDJuTDhROE9Yd000VWZYdHM1ZkxmRm4wVXAwREgwMUJEd0NQdUNVSXd5MzhhUzl4OEZzVVBCSjEzdC80eGFTbkdKNGZLS3ByV2FxbS9HaG00N2JaTEF2R0N4NzFlQVFGdHk4WTF2VmcxWEpHcXhLVm5UVitlUnpQRUdZdTZyQ3pBWDltMkZrc09EQ1dqQ0VEU0Zwby9qb3dOSzFrc1BMYW9XUGRRTllzSytYUElDZ2xhT2ZhSE84RHJld3NYc1hqMTBJdGZYTWN1UGIrbno4ZkdXVzJpVW91TU9vMzdGTk9raitLWksya1FneWdsaHZ2eS9oeGdIOWxOV3NUcnU1aW9jeXpETG91ZHNoN3VMWWp4dllLbDhlWGt1WWMzakJYUlFvTkVTQjRLNHlzcDhPY0k0c2FlOHNyTXNzRkkvaHVkckNUVnkzYWpNeXVNTDY2ZmhHVlpxZ2hGb29RcWdqZ3h4WkRRTk5BZjZhL1VVU1lNbGY2QVJJL212dyttWTFXeTU0ODh0Nzk3N2NVQ0tBcXBYenErTDFoMzRQQkJsNEh1S05CUFNPaWVvZFlVSGZmWS8rL2dGOUIzZCsyR1Y3Lzhrck9sMjh5Y1pwREpieGpsQU16cVp1WXNGVmdBeXQ3Q3Y1QkZSMDJzWmJJSnRNSkpNNUZXbmswQ2k1QmNUWEFIYWNNWWIzcVRUYXgxYzR0ZTZ5NDg4enZkNk9qWXdiMzNydGhwSk9jUFNBQmhOZWJqVXFhZlZhMFBCRzdldWdZWGhZWnRWUTlOUld1eGc5WWJSR1lIa2xGSytmRUVVeTF0bVJWZUNKaW1iYUlKMC9qOTB2Q01yemdWcG4zYXdEV01QaEVDWTd5aUJiQk9HVWo1RkZZQkRiNStTVStiRUY4T1VRRFFmRDlMVXN2eTJzd0hOZVQ1LzMveWw5Yks2QzQyZ2kvdzdLdzN3V1QxVzhTQzFZalBoeHk1SzFIc1NpN0ppRzZmdDBmWmZ0R1dCTVVkclZ1OG9jWFlUbjZIV2F4N0dQRzk5Tkd0Qkl4bG9yMzFRTzk1Unp5Mmh5RjluNWtNck9mQjBWRWpqU3N3ZHpmU3JGdXVZcmJnUUMyUWNaeVl5Y1RpMTZiOW5NSmNCUzlqMTRTWVM1dHphZk8zdnF3cTVkbDYvOGNuYmYzVndvb004dU85QVg0SjBaOXBqWWJjTU9mM1BaSmszYnNIYkdqS1VERnE2Y3YySDNIT25reFN0TWx4MVMvaHYvczlEQlh3S0xPR1o3NnlEMmNOcGsrTkZDSEwxZkcrdThyenR0TWxqbnJjbk96MUVSemFsS3o4K05CcnlFT25BOE9TdEhSVFQvRUQwckovZTV6ZlErelhkSWM4N1daZGlaOENETE9SdkVjOHJaeW5KY3BsQzhnc3Qwa3N1YzU0SkptZHJPcy8wR3VNd3ZOTTk0UTRhdmljWDVURmFQZWtiVG5PYmdQZVZQTEtNc2QrM2JESU16U0FqUTF4T20xak1XZnNQb3FlSmF6eGRxUFdOaEc0YkxXOFcxSGttdFp6Q3dQL2VzaDlWblUrc2JES0k1TjZjOWN2OGUwL1Z2UCtFR3MwV2dZN3IrN1NmN1V6Sjd4aTdWTHRKSHVBaDZzM3k5ZXJ1SU5GYTJZNUF5MlhqUHdXWHFDQ0ZLR1ZiUFZxVWVmaUozQjZSU3U0Z2dNcnRJWmExZFJHZ3FEVlBzSXZ6RXNkN1VMaUxLZHBHWFM3VjFybGZyTE9DK0I2MUpTVjh5cnNRTlJEMWpLbjlDYWN4VzZ5d1lLSkNTY2JUT09DT0ZtM0hXK1ZpdGM0S3pUdEdsVGtybnk5Sk90YzRKTDZ6emtWcm5lTzRTU05iVnFXczdwck5FclhQOGdMOTBkYXB0SitOb1NKVEhNUWE4eWYwQU1renllSksrOTlYWXJjallpbi9JWXhzTjNoeFN6U1NQTUNrWlY5RitkVktsZFJ4M0diekJ4a20yWDRXNTBEcGJwWFhjSUxOdW5KcHEyKy9ocmRZNWlic0d4dXZxck9aUzUwbTF6a25ER3VqcWZFVlhaNXBhcHhYWDJlNUZkUnA4MVRxdHd6eGVVR2VBV21jK3JyUHpDOXQrVnEwemY1alJmZHZwT0RWUng0bmFGYlhqWkhRZEo0YzZUdDFHcDJySFNXZG5QSWkrcHZtUHFjMlBydGRkbkJlTjkvaWM1c0dpZGo1NmZ3b0hWUnZoTHRWRzJFZllxYXhqdlkyUXJ1TzJjaGtyVzhjYTdIVldUNEphRDlaeThOekRaZnhFRjF2ajd3bytPMGdmRlVCS1dCUkxvMUxQZk1vUGFzcjg0RGpqQi83RVprbENHSjFyZ3RpY3VsQiswRll1TzR2elp1ZjhNdUs3MCtiVWp0SzNYcTIzZ052TjFpKzFoWkl4ZEs1ZmI5cmViSVZPdm1BQ1hiK1J0TlpJbzYxV3FiUE5iMU9lVUZQbUNYS2RKbHFuU1Zzbm9iVUQ1UW1zemdrdnFMTUg1UWsxWlo2d2kvRUV0VTVkK3pHZEpXcWQ0OGYvcGF1empsSW5tUk9VSjlTVWVjSSttU2ZndVVGR3dLU3hCNU41UW5sQ1c4WVRKakdlTUlYdFJKSGFzZm9DQ3k2UDZOeXB3K1lGbjg3bWpzQkRwYjVsdU14UktVdkJXTWRsYW5NR1drWlF5eHhIWDRJTU9tZnJzTG5KWjNBQ3ZyK0M0RkpKbGZIOTErVDdkZWxjTGtDSHFmMUh4Zy9DMUQwdGR4QmJEdnFVMm9Gay9DQjhmMTc1MzZvOTZKUmlnOEx6OXlFWVJYMXdlQytGQm1vSGtzYkl0aWRTWmc1WGpaWVJlS1VNcStlSVVnOC9FWWlnTDdWUUNiSXRxNmJPcnBRakRWWHF3M056RmNWdzNSNHU4cTVsV2IzNzFIb0x1TDlBVDFLMk9xMjNPb0h2VS9rd3BiTy9XbThCTjUvamFWbGFyNjRzcmRlamtscnZoQmZVUytqTmxIYW85VTc0eDNxOTFIckhjNCt4TkthdFY5OFBsZW04N3lLWG5WZitXRmV2cGgvSXVCcmF5dU5LNXVsVE1OSWtqeThaQzFxL1BGNWtyQ2t2NlNLWFhjUlZOY2xqVHN1SzZyaTlVMzVYTEtPMnU1YXlYRlVKeTB4RXp0T1AvM2RFRmdTdFpLejFtWW9zNkZKUHVGcFBTNUFLZXBFeTBhNzEvS2pXMDVMN2t2SEthTmQ2ZGlqMWdENmlFZk5MTi9XUStRaGE2ZWRqaFhyaTFYclNRU1hRaFpTcEpialE4MEN0SjUyYnlabHBHVTMvb0dOaW1kU1QxVVBYVFJtbjlQRjN3a1gyckdZOWZZeU9DSHZvZW4xWnZ2K2tIT0g3NytGOTZnSzFTM1dYNzdlbjlYeU1hZGhEK2NUTGNsdktHWi93NTFYYjgzdVlsMTJnZktLN1hHWTI0eE1CemowRzF5TWxFaGthYzFrMlJyZVpEQjNPKzJ2cUVjcG9ib3MyY3BucE11Y1NmUFgxV05SNldvTGFUS2F2NWxyUEtiV2VsdHpuVEthdjdsclBMcVVlVFBPdnJGMnU5WkIyc1hxYzdhcFFUNEphVHpwM20rMmRZWUlMUFZmVWV0SzU2V3ozanhDZDlhQWpVcUtVek9xaC9YOWJHUmVoVE5qSG50V01DL1d0Sit1QytON1ROdDRIM1VtZG5yemE1OHkyZTBxeDdlSXkweXZvTmhGNGY5bEw1OE1yY3YwbGxFOWJVQzJhTDQwK1MrNkxnZVg5MWZmYWxQZmlQckZqK2NmTmUrbDg2Q1dYYWN2NlRmdGVXaytzV2s4NnR3VjBaTGtQWE9pL291WStTRzlKZXkxRWROclB5enNUZmlZVnFQeHNHenJMN2NLbGJEWGlWWjhERzl3cS9NWUhHTnZ3R1plNDF4T2JrWHU3NEZieEFidG40M0p5bm51dkR0cklyNkpXNHhaY2JMbXZTZUpheEJJOXJKa25CNDB3SE5hRlFvYVNoeUZkU0FBbXFUSW5jbFUwRmtaaUNST2N4OVZWUVNJZmFFblBmYlZwdm5BTnZJeSsyT3IrV1hxdVI1NEZ6bWNCT2VwT0JDYnlzSmlOdmdKMVMraXo1UzhCQ2ZENFdTTkg0YmlkVDBTeEo2VCtyOWJQYjQ3dUFhOVR1RTN0OGJ1QVZObjBLdjh5N25mdUVHekdrU2ZWdzk4QUF0WkJlSWlRQUQya3lzWm9Qb1gyYlFwSGZPUE5tak1ZUXAvQnVWL2c4ajYwUE9VVitGcm1MSy9VVFBNNk1wdHNlbmt5ZUF6OE1kMlZ1QkE5NVNUV1NtQTVQbGtUZ3RXR0pGb2Y5RzliMzlvUG5RVXhPL0Z3ZzloaWNrWkVNQVVvMXZwcmJpeW8veUw0MGNzMW95RExKQitoQkRPYUlvUUkxTW1LMm9NU0s3RHhaOHJpK1RPRHdGZzBtNDM5R3loTHFFZDkyOGRvenRSOTNiM3lmd2cwSVJaQmJlNXJFd1VyOThlRTFnSXlvVEt4SkRwQ3FJZGFqMFBkd0VieU53N3NRNjN4WHhaWWs4MFBIMEFvSDFDMmlKMWZ3V3BRNUQvamZDajJqeGZCL2pHVHVDVUNPa2c4UkpNV1piL3haamI1NDMwN1ptZDNiSjdXdDI4YUh1LzllQkN2Y211TjBad3BrUGhobXNBMk9nL3dmV0dBZWorRzNTZS9rM25FU1VUMk5ReWcyRll4WEJJZXVjN2NtOXk3bksxTFBJRVFxaEJyb1VZRDgwR2hMSG1WWGVKcG1KWW5PZUd6R1V2dDVpQWFsMVdERmNBclA4aFlIS3ZCQytLTnhRbWFyN0ZHV3dNS1Z0dXNGQ3NheGE5cWZnbzFGbmZVd1FyUmZxQzRHRXB2eU5oZlFOZER6dlRWTkF4TzkwMy9HNGdCd1h6YXFzTE80eU10RXp0UFhyMTZVcGRKbHNoeG5hYXNjdmlzS3B5OG12enhyL2Z0MWFOdjMvU2VmY0dsUHIxNjlPbVRucDcxTEpIYzY5ZXpSejlnYkE4L2J3LzZUOXJhc1dYTGpsc25wUlp1U1czWk1uVkxJVCtsY092V3d0UkpXN1pNS2p2VmZXSkJqOVQwOFJONnB2WW9vSi9HcDhOYjNRc0t1cWQybjFUWTdkbVBkWVdSZGZGWWpSWmFjTmVseW1ZSmF4TXFGMUI0RDFtb3VFeWgwQWhjb0dXSXczaW9DMzlTNTdmOEFPQ0djaCtDTW40ekhta1BMZ1JQNnNwNFBnRUxTQUtKdDBIQUlQUWRpQmtFbzFFQm1HQUdFMGo1YkZ6K2tWcGVvdVVUUVNCK0pIc1FpRUhmRFFJQi9HWTAzWXltZzJtRW50VjQzajBsdmptY1FPZVZBRTdUZWR5RUc4ZW5pVld4N090Skl5WmhmTjE2S2JpNzN5YjlOWTQwbVBHZFZGaVhUOFh6ejR0bHJSWGpkWWUyOXNraXlMQS9JSmRtNUdJa0YwbjBsTU5RdEdCV0xHTUFYMnIzOEpiVWcxc1NCUnBJZ0FBaVlnZ3d1U25HQUQvYXRHa1lxaXFBN3llZ0dpQlhxc3lucGg4Ky9CcWM2WGdiM0lWMUtlMFQ0RHZ3VjNFdjVoK3pPSnJjd3RXTXBXQ2syTU5OQk1pT1hNSk1JTTkra0Z6d3A1SDJYSHpaY2RWMDN3UkhrdDlIMnB1U3kzM3krM3h5dVUrZUtTU1hjUEwxQWZrRUJCclZZbEx5YVBob0xRL200SXJwa000RXhFeEttN1lndDMrdmprTkRSb2hiWnJUdStPNHFKSUQ3K1lOZWIrczR4VWZpOFFuRDZ6K0x5aFMxNkRud2x2SVAwV2laUjllbDUrVHZhWEk4dVlabzIvMzkrRmk3bng5Qmt5U1hwdmhDY216cDdEc1VKRjhiSE9oQjBQdElhWExKOWFlUWZqcVVvY29VV3IreVBnazJ6WXhDRGlaaWFQSXpvczZBNEFESmdObG5VbUlUa0VTaUMrbGZmUjNZRjhrYWd2L0FmSkFZeDRPeTE3M2F0QUhuejBqSFBqT2NzKy9iei9Nalpsa25McFRBZXRSYkFoK0ErNkZERGpmTHp2YTdhUTNOV1p0VGZPck8xMXVsSmJOc1JjWDRHNTJQZTdBTUdZajNEZ3ZXb2QvbG5FRmJTcy9vVXRYcnpNMXFNaTlndEhIcTNnbjBNZDkrK2oxRElDaTc5cEFxMVpnWEJuazBzcFI0MzlUUUZLcG1MSzdqNHV3VWFER3B3VHdVL05BaUdTUVc0cHdRSEJTY2FBS0tKNnlBZnZzdHRWbG9TZzMvNmwxalJ4WitVR25reEovUFdjRnJQMDBhWkZwYjlzbTU3VHQzN0RnbnBxRzdmUjFOQi9jUXBSNCt2Z3ZlaDU5dEdtcDFsSWkyY1RuTFFLQWo2OUNjZVo5Ulh5bWpNSTNJRk1SWHloakRid0Vmd1VaWWxtM0JiUzRmZzNjc2U5TklNcXNqUVFialBaMndMbklLejdGWUpic0dCZDEzOVR1Mng4YndzWGdmMEczNTN2b1p4Um5KOWhwTHR0Y1N2NWl3bVBnWUxCYkc2S0dJQTJrU3dDQ1NRY3dGV2trVCtVUkRnd2tRQmZtcjc3UStTaXdCVHdTLzJISGw1T1lHSStwN0pvOXBkQm5kMzRqL0EzNlhHK1EyODB6T2UvbVRMNkRGY1FWYVlLRDUrRDJUYWFDZkVVUStNdWRzeUlsNkNDeEd2OEZHOCszUFkzSklhQjJKaHhhbjRiYUg0dFkzNEJwamFkL1dNTjcyU254RmYwTEZKa1dRaVZYWmxId3hVamhpTTlST2wrSXF1cTlrR2RVMDJpTFV4Mm9haStNMUpTS014Y202TFpUbTFZbG1vZEE2UkVjeVgvVGJhS0orRzhXOEc4Nkd3dnpSNDFhdnNvNVpJTUR1M1RwMTZkdnY5WTdkUU9WVmt3dFhyNW8wWlhVZnZDMzI2ZHV6WjE4a0VqWXZlRW05WjJ5ZG1EclJOck8zMUxqYjVLNnBYU2QxYitSSW43UjE2NlNPaFZ1MkZKTGRzQ1BaRisvSkd3S1JRMy9sWDhiOVZoWExJejNkWUZScmdpYU5MR2hTdDZDQ1NXSmZIZENXVWM5bFBOa0JqR2lRY0MvZytaQkVjamdyN1lZR01sUE1MUHdnMElSWkxqd29GZTl1TUtGNXF3bkpNL01IdkhYMGsxSFRRSlA2TFZ0S1l3dThvWGovYkxUWlB5OGdBSUxpRTU4c3FGMk1kdmJxWHZTcDRGVm40SkE1TTlDcnNLMkQ3dG03T2M2am5uallHTW5WZThJWkxWeUJhQ2wzbUhqT0tMNVZIc1JWZGtHanExRnFENi9ObGhEdWp5eCttZEFTOHlNL0xsaUpMTlo1UHFtaU5jbEpoS1d2eXNFTU9ZYzRidklrY1R0Sk5PQk5IWHo4Q0had3NWRXpQUUlJajQzaExUeE42RzdHL3pQSjJEOUpFZnhUYVUzaU9xbHQ3ODNTMXU3dEhEZVh0MThOSm90QkFFM0dyQmFOaENHb0IvalljUXVjUTNYQXVkYVUxcVhsOTRRRlFrY3VrS3V1MEtwRElWWDlPbFY4SENJTitrUHQ2QlFIUVoyRVhVVTdmYVBvQWs2U1Vld2pXQ2J1RkVCMnd3aFRIQkRNM2ZablhrS25RY3N2dndiaERpNWxibXJtM201b1FmdTVEV0cxNUhkNnB6UUM3VzVmQjJub3hLMTR0RHVwd1N0TitOck5HNkM3b0hyOXhtU2NKcFUva2hxSmRzelpQdUtpNFF6OGJ6c1FTTFduVFh3YXA5ZkxmR1c5YkNoKzVwQjRDSmRkVi80RUxxSFBGTXZQbkhNK1F4ZTU4c3d3L013OWNSc3UrM0g1UFRpUFB2TVRlMGJnbk04b1BySDBtWUg0bVhUNnpFYk9LRC9UVUg1UHJ2TVpoYlBnMlFPNWZsZ2ZEeE4vNVFKa2p3ME5JQ1RGSkdNUk96N3hkcU9QUWZaWDFUcEYrYmc2UlFsWWgyQ3BBNWpYUTBvMGpER1RYTHFVZytLbEEzNEZKaENCZnZ1NkZEMzY4OEtZSTBrQ1FOOFZyUDQ4K3VpQ2pSc1BpNzkyUnpQUXhjdVAwSmZBLzhSdndOaTdpK0FBbHRlZWZzV1ZIKy9hYis2TjdVdXZVZmxyYTdtUHNKaGlGRWVwVkN0UVA3ckU1WnlSWnBzWEZUQ1N4VlpISlN2Lzg1OVM0eWRIcEk5b1hVM1JuOEpLWEpjM1Fiem40M1ZyQnVzdTFFOVhNaklYT0YzZG9pc3FHMWxSRWxsTEJQT0FDQ1dlZ0xndUFMNnFZeGYvNWJPMXNLZGp2UkJTTmc2Mmh5MGN3VG05ZUk0WE1uSWNKcWFUcm9OYitkdDhBSmFIL1FrZDJzMk9PVUh3dDhzKzVWdkNyVG1zZkROVmgwN0F3b1FleEZVbm9oRW9jUzkzbVJOb1JpbXNwbjhiS1ZuQXRBSlVLZXZQRmZkQjJOU3B3c0tubmVCaytoNmVtNEQxdjE4b2JqRFIvOGE3d1liU0liUG84SzVVcEVQSmsvQml1OW5veWJBNHRObHA3UkdTV2ZZYTFnbzFzYVgyT0RNVjFFTkpJaFFDZ0FnVmhVNTFxNkVRaUlFTUd0a1FHRVRpczVNaXlMYmtuNUlVVFFMZUFnMi9QRDFWOHJCdDI0YzdUai81KzZ1ZGo5cTJlMVJ5OGtuK3R0VWxWMEtyWE4xWlpIc3llZXNIMnkrSFJWN2FVYlFWUExxTXZuRnMydVFBY1pjN1hnYng1UnMySW5UbThyYkhhUGZ3MnNQUXpvZkZ4UTlCbTVHMVI0TVdqN2R4b1B3ZDFBR09rRjdDZTFHbXFnZlFEdkRDODFBek0reHJpUGhlRnd2eU8yeW1ReWJpTldvaU1PR21waWFZWVIraEN2aFo1SUkxOEpFa0pGMkhzeXk2WkN0T2Rnb21nYURXbW5uVmswSjlqRTBDdTJWOXREaWlsY1VZVWplODc5QWVjaERvMU5GaXZZL3NYcDVaa3FGd0JPWEQyYUM5WU9idjRURk54UHFaUFNpVWo5MWhDem9VaElscEZvUkpXRUF1SS9DRkRKWEdLNWhxOElvb29VTUg0dWtlWWlSQkdmWm1vYmh0dHRCRG9UQ2paRVRvNU5BRm9WZ1dDOVc0Z1pJdjBUUlBVbTFORlZpYnI2djVXdHRvU3lRdU5IaUlrNE9DR1NObndteE1IREJnanM0Lzk1ZmMrSUxtclp0bDkyemV2Tm00ZWg1MUM1cTFhTkYxY0pOV3pjZlY5V2UvOUc3Y3ZPbjRlZ2IyeS9DR3JacU5yOHQzYmRVUlZFNklDK25ZWmt6cjFKQTY5U3VEdE5ib0IzcXpidVUwZGpNNUdIUnFqZGZlVW00RmYwRTRpdlcvanB6ZHp4djNudEV2M0EvM250RVA1QkVSM3FoWGYveW8zbW4wSmdxcU55N2hiV1RJa3ZxTThFd1pqZUNKbEJtVGduZFlNMTcxNW1ENDJ4MTBlUk00N2ZocmFhT0pOMEhFUnBRTXhmZGY0VGNQUmw4UFJuL0dYaDhNNmcwR0liRjREL2lBZy94UC9DUGpBS3pWdmNITmFNWTFlQS96LzR6eU1zY2J5a21sbWhDUVlxcDNrcGdjZ1o5ZGlKLzlnVDRiZ2ZkbjU3T1AzVDBya0djRlZRWkp3WXppTk9aRklwWkNhajB2a3BzeUJhcTY4aXhxamNTSFdFQUVpTEVZUENsRCtpWUx2STl5c2xBL3ZpcjZ0b1pVQTEwQ3RTeFNsR2h6eERocXdRc3cvTTAzSGRjY1AzYnRTdmpmM1BKc0VNUFozSjZqR2l3cG1LL0Z2UDVxL1p6a00yZXRsRVlzUGZKcjhGb054cXQxTFVlU3VsV0llTkRsOXFPcW05dGtjVlFSSmwvTVJwZGt2UFlzZ3I1MnplT0JCMW5XSG5oWkY1SWI4UjVOeVkyNjVNWWFjc1BtY2NnRE13SE9BMVNJL1liRWxrMXpHU1pTUER6dFNnOGxaeFdtQ0N5Si9iUmp4NEdOTFdlL0d0QjRaTHZ4RXgwTzJNcHE1Uy8ybmYzSnA5VkRCNFJVbXpwK2R0K3lta0pETXE0dGNMdVBTUzlobmF3ZFBYOUpneDl3OG4ycHVmTStQMEJ6UDBlOUg4TzFJL2ZKY3lMK2hRdml1cU9SaHJ2aVZxek5WZU5xYzQyNDVsalhTK1ZlNXpLNFBsdzJONGdieHVWeFk3aEozRlJ1QmplYm04Y3Q0dDRGVlRtaTJQRHhCYmF4OFpWcEg3YkhmZGllN0xBTHUvQ3g5cmtMOEdYcEhIeHB2UVJmbXZLWTh5d3cydDZpNGlsUEhleThxSGc2cWRRV1htcC9FSTdYa0svUlZyZVVwSzU0RTZ0MXBmYnlHTHJ5OExaaGEyMjBOU20xdldLME5WVVpEdjR5c3RRMnZOUTJ1TlRXb3RUVzFHZ2JWV3JMTGJVTktiVzFMTFcxTjlvNnFMN3RhUjJJZzM4SFhGc1hveTIxMU5iQmFNc3B0ZlV0dGZVdXRYV2taUWVVMnZxVjJqSkxiV21ZbExGa1RNZmk1VkNLTDdheFJ0c2IrT1liSUsrRWU4UDRSdmdiL0VqYkhLT3RzTlEyMTJpYldtcGJhTFROS0xVdE1kcG1sdHFXR20yejZiYW1VYmdDemFaRVo2WXR2QzNyMVM4WkJFQ05aQ1dLZmlJNS9VakNDcjBwSXRBU0dFVnl3aWFCUUtiZHgxak1SQUtSLzREbXMxbFIveFZkbDB5MktNMW5Qbmx5OXNESmszTnlwclRjbjUxYnAyYmQ1RUc5MExRT3pacTFiOStpYVh0K2I2L0JuZE1IU2ZDTjVJU2FLVStPNWgwVmEzNmUrL2N3a0hSVXZBZVNjOHQ2VFVwSVNvd1hTMEdRSXgwRU9ucmh6ZHZMK1hsL1JzTlhHalRPS1BzOWovNW5pTXlsLzRGemZjZU42enNpYThLRUxMUWJSblhvRU5QRXo2Zk5TNitsZ2JhdDB0SmFqV2pkc1dOckxKelBTT3ZWT1ZXS2V5bTVUdG1Yb05HSnZMd1Q2SmdVQmtKSGI5dzRHdDNZV0ZheU1iWm1kQnprMjQrbS96MTVtYjJGUDFxelprdzRPbHMyNldsWjRKTko3QjhpNDRoY0w4ZDV3d1dQdmxqYXFjNUZjdEY0WGdkejl2RHFlQ3JDQ0h6aGZQQWxzQ281YXZma3hmckpLVTBBMHdERFFDSTdkTU1ENWdzQ2d5MkJpVHhlb3VSUHFNd2ZMR3RlMWtyd3ExS3piZStOaTkvK21PY1BnMGF4eVkwU2E2YzFPbkhpUkFmaWx5RklYY3JxbGRYanYvNDlxWEdWbUxjNlRsNDJkYXFVV0w5cFVrSnF0WlNlM2RNM09WNFR2T1lLaE4rOVFuQ01oYm5Pdk9GVStqZHF6M1NOTHNZSXZUVFBHUWgrb2wzeW9xRmF2RVE5NXowNWlYclplbEptVFArZkNPdUJudk5RRnRnNkQ2MUE3eTBBVzFIbWZMZ0ZYSE44NXJDRCs4Z0VPOEttVEFadGkzbExCMHlUTjBHWFYzZUlDbVJVY2tFU0pMTmVncVpBUzVMUlA0Vkl0aDJPYkxGK3VkbVJ4L05DemJ0b0xicTRadytJQXRPUFpXTytYWWgxRkUrYTE2MHE1amJPeGxiWVc3ejBMcmg4aFJSdEJMRW5CSkFvTkg5VGpLekJzM1VrZU40L2YrNlBCK2ZPLzI3ZC9OR0htejc1OE1OTk1BbmRSS1dnSGdnQnJmRmZBanFOYmdWYysvMzNhMmpwRDQ4ZVhtWHREeTkvQXY0V2QrQVoxRml2K2VrM0RWRnpicU5ORzJHSHZNaGMzUzBtTVNrSy9HMUZhOEJGZzlnNk5yME5xYjk4RGJvUHYrUmI0aDJ1QnRWekRQRXZnR1NzVzQ5M3dXRE11cW1EWHJ6cENycEkzekVYZFFDeDNFeWFJMExScGVqSUVSbFdoM2tkRmFnVlFoc0RFS3VSTzJkZUk5TG1BTkZyNG1pbW83VkdVOEQ3ZUNXWnFVUVE3NFRyTHZhQk9nWE43Tnk0VXhqWGN3cTZtSVU5VHUweElDMDV0WHB3MWZxV2xEb3RtOVJPZkx0MXB4NGg1dGQ5L1pQRGtuczFJTythaDFZQmlTdlEyUklBZ2NpVXJGYjgwMVd5Lzc4amZBOVBTa2R3T3kzY0RTSXdCTVVUdWNFZVpPWmp5VUdabjBKR014OC92ekMvZUwrbWZtbCttWDVTQmp0c3Qza3J2NWY0ZVlkNXgzdnpJKzJIekZpZ0x6SnZNMk5CMTg4Y1pvNDM4eGtsQkpDNEVIK3dseE0wNVNKY3hENlpYRXJKMTBOQitGTVJ2cFQ0QllVRnhRZVI4a0c1UVlYNHc0NmlvRzFFQUM4bnNuY3B1VXpHNWNpaGR3aTFuSVdxN3k4TnZSYjZJSlNudjRVNzc0WmZDMzhRanUrR010OXorU1JQM1N2TXRHUEpwSStwbnh5Y0hKUVNsSndFajBCcDViUVpLdzJ3VjgrK3ZYdjF5MmpWNUsyWGFpYTNTRytkTXZ1bG1KZEZtNVErZW5TNjFEU3RVeE1BMi9mTmFCam4xN1lmQUprQU5LN0wrdlE2UEdBZ0VlamgzQnpTcDBiYXAvaWZGL1pvU2FIZmZMOGlQejdQWGs3TUJTNzkyOHlUZFhCVGIyR2t2ZENJdXpqTm1Ha2tYV3dNTThZYmNjOFdHVWxjbmhFL1NyeVcxVTArUkdON2QybDhURklURUpPVUhHMUpvY3phRDhBU0tDMmIrdFl5QSt6Ukl6TTkvV0xYZHFJd3ZMTmgyckxlSFFCdWR2Y1JJN3BMalY5TGZjVTBSSWlNbHFLakdyL1d2SEVUS1lXMitTbzhJK1hqTmdkdzQwbGpBMWliL3c5YVMrU1hnRkpjNFk3TWdOd0FtT2ZVdFhDZHRQRk5qYVF2cEF3M0xTUlpFT0dYVUhwL3hzeFZCcGpScTIvdjNzTnorUFZwdURVOVJvN3NJVFhwbU5iNGMvRkxLZ3VQRW42Q2o2V0RuQWVXNGZhUlF3OC90aGFJS2tPb2c1UkdnNFpHUTVpQkpMVVNNckFpcytPK2Q3azNIbzlNNzF6dlFtODhIdHV3WXFPc2lnejdmVzhpOStMTGp2dCs1WDZrbkYrdVg2RWZLZWRIeXRIT0llWDhTRGsvcGc3NVV5VXB5RG1iZzY0RlBRamk2VzhoenJzaDEwSWVoT0M3UWN5N0dCZ3NNZmovVVlrcGRISWJvdW5reHJ5RFR1N0hNUC9MTC9JaDhCbjA5WnV2SkkrcUdSblg3TTFHZGNmSFJNWUx2MGc3ZDByM0xyVkk3dzVoazFvK3pRY0EwQTNDK3JWWTMvQ2xFbWJjWEdYdU5kSTNubXg4WDl3bk5MbTlPaFBWY2JPWk5IT1NFWnVTR0J6RDVBYzJGdzJCQ3FGb3hrT1Era3JHcStMb3Q3dTB4Q1R1M1N2ZEd6MUNESTJ1R2RXK2M4dG16UXoxU1o2UGhYVHMrbUQ2dkxuMkd2bzg0Lzk1NU1qaGRpWE5iNVhDS3NWWGFscUpPTVdvWFNsYVloSXhSZFAzN1pzR2dXRTAralI3NTB4TXpDZWZTUGQ2M2NMOTB4ZjN6NWZ5KzlzUWM2eDNQTVVoODQ1bngyUzRXam5iRUg2bFJCVmR6T1JGbWtqQlUvTnV6ekRQZU0rbW52VGRpU0o3TzBnMFdNRGcwY0FBcCszYk54M0NIMmFWNUlqZjNpTXZCL20zbUQxNHJMQVgvaUF0b3V0dkJubXJ5blBzQndVOG82NFNVQUlkOS9GVTFxT0FHU3VaZEEvSXBITmRoNVZzM29lOFM3MnZlVC93RnZQc21ZVEZwQmxKWEozTVp3STBhekVnTENBK29HbEFXa0JtZ051MVNFWVo2NnZpdW5uejEwdXdkNytoQXdlOE5XWS9YSUxYNHVBWk13ZEpiYnYzYk9OMWxtR1dMeE5LUUxJVS9HSS9KSE5Lb2lIUXNxeGIyNXI1WXRPTGwyYmlma2pDOG1BNmxyME1XQ0pzbzdIeUs5S1hMcUJRTmRjQ0ZsQUk0bDJ0akY3VWY0WW51VXN0NUY5K2dPT0lkU0w0Yml5NFVPQVlCWDU5S0lHNnFGU1krMndVV0FwejhFNjdBY3QrditQMysxSWtoTEZ1WkZKRi90R2RoZ0I5NkhpSU1aeFpObmVraFdTR1lKMDRNd1RyeDJFaDhTRXdZOGY4a0NKOGkvMHpVcXNsMnozOFdNUjVvaWxDcHk3Sm1XZGlMRkdLZnJNQmpENXhMU2RqNk5Sdjk2QURvTVgwUlhNbitxQURaY3ZlWDc2eVRKajczc3IwMmFHQks3TlhyWVZocVBXb29YM3loY3hoZzRaazRYRXBMTDh2VkJKV2NhRll2MzJoYkt1WTRYVDlxY09YRkJpaURwc21CSG1ZYzJOYkUzZ28vbkh5SzFRT3dGZGYzeGRoN3FiVkt6N2QvOTdxalNCUDJuMFVlSjcvOHh6d1BMcExtclBnbTNVUE41eVpzNURsUFJmTWVBdzhzWlRWNkFValFIcmRTeTg0NmlRNzBvME1YWXYySURYcGJRQnp2d0JCNkpjdjBGMFF1UFRNbWFYQ1hQUkg2VGRuMEVPaFp0a3JGejQ4KzhFRk9uL0pQRGhJOVpLZUd1eDYxMzdTblp4TE9odTMzWXVsUHZHS3QyZDZrY0gzaXZmU2c5ZXJ5T2YwangvbzJBMkx5dTd3d1k0K3NDMnNnMTd1TDh6TlJvTmtXZzdRL2hqMmdoVmg5eENnRnVVL2pKekx6UGNnZ29aSHBnZVpjQjVGSG5qNmhYbkVrMzhPZW55TmIrclR3dWdRYnhYSE0wcmNBQUlXSHVUb0MxK0Z3WTQ3aExBM21hNUE1bE1jbmsvaDNFQ3Vvc3FtMFdKc2ZxWFVvWUlvTlA1NmhVWWJmaGpHVXpqOE1MeHJoeEhJZ3JDME1OeHJPb3pQS0FYcG1wcXgvWUI4aU1SczNjVDNUSWlMdmJYNUIzUVBtQzUrZTBPQXVaNXJQbHAzNnZRbms5ZUhvd3RnemZ2TmhwRnBkeFo0N1ZvakNoTW5uZnZvNGZxenpXcURvQng1M0lXWDZiaS80V2JjZFkxejZ5bUhSNEdvbmdWNEdDcmJqYmozdFFmTkZOSldEVlFXWHJZNnNxeFd1TVlLUFIxL0NYTWRQOEl3WmU2Qk1Fd0RyL2c1MFNGMmZTMnRMQkdFNWVmam92UzV0UEw3ZkdmOHhham9yYlNvOHB3YVUrOVYrdi9WZHVWaFVSemJ2cXU2cHdFSisrYUFCaEJSUVpFb29zR1lLMG9TdVdMUVJHVVJBVGZjbFVXRmtTZ29Lc2d5Z2lnYVJVVU03bEZnUkV4OHhnMDBhbUlrYWx4djlEUFJHM1BOalQ2ajJXUjZYaTNkVGZjd2V2TWw5LzB6TVBPZHFhazZkYzc1VlhXZCtoMThkVjZWWmRQdUVReThycnRjMDNoWnc2YnE4K2VXYy9yV3ozYzA3OS9PTDg1YWxjVklmZVM4U1p5Y1lNRW15VW1UeFpBdFY0U1Y3NENUMHBnTjNud3diMVlteEJid2JjVWNRdHFLWit3dTFPbnl3WkVpS1BoQUo3Z2FhbzNmSWVYOUJPMDB4aStNdFJxNWYrd2sxRCtOOU9UV29zK29qNlA4YVkwT0h6alUrSlp1Q25JLzJvNm1IL3JQUVhvK29ab0xNaHFMenlja01uRlZ5Z2MrazJaSUVXYXJGcHBYaWdhRkNjUVJPSkdqYVBpUUIzdlg2bmhoNmxnaG1kZHQzczNlZlRhUDNRZGIzMkZQZ3RiQlpLS3A3aE9JalViOEtSdkY2eGRJMWkvV2hHV1ovallZZ0V3eUljczRGTzB1NFZFK2l6MFBXMFBSelBlRDdEbTZSc0crSG81ODNmeVpoUVZ2Zi9FekMzS1lTaDJZY2V1dXhvdHc0WmVyMTRSZmdQWFZxOEEyNitUdVhjZU83OTU5SEp5L0liUUM3c1pQMTRCR2VIWU5ORFExTlR4cGJEcDVpUFpyTmZjKzZwZEwydzE5Y3BJbjlVcytyMlBKZVIxT2pWQlNNdHFZMTFkekpSWEpGRkdtZlNmNzl6MCsrc1JyYThkYTZ1bUVyYThmSEc0SURMVGNYUkhmN05IOGVhSTllNktDK1UvcXI1VHJRZDdJNVdjWklCYUhhM0JFMFJiNWlwY1NiQmd2OGJCUm5RSWtsWW9UYVZiY1BkeEVsaEpjTkU2c0YrZWpBLy9UZEhIU3BPa0pOdmFMWCtMemRFSWxpRmhYVUxCTytBUVlCWmJUNzZtYVZPVFh1V1JHVnQ5UkhpNGRKL2FiUDMxK1NscHFxZzdiNGd3VWM1NGkzWGVYUmtLVUxZMkVKTkVTelhlMmVlNnRjbFk5SFoxSkxsaG54M3AvMVVqNjRXT3dVSFVPbkNzK0p5T1BWbVFhUkhaeDZmRnJwNzlyT25NSHJUVzJyVjVmdWV6c2xjOSsvdks0OEF5OWJ5N2VkQUQ0eFV3TENTdlRsK3c2Vk1PbmxXVEd4YVdFaEswcFdsMnpzNEZma1pVcFBmODdSZGFnd1JiOFM3WnlzK3cvb0VqVlprOEptVHBoQmJ1WTYvSHNHdGNqaGNha1RjaC9FbEc3VGt4L0MvRlpGVFBsQllZNlREc1J5a2RGcVY4dVVYaHkrU3ZoU2RablZWWG5rTE1hVDl5NGNZSmxXNDJsTzNlV3NpejkzWUhJM2hMSitpSG9QOFZxeGVrNmlrN2ljVG9JZ1NIdXZEdlFMUkVDRmdnQlMxdWlock5IbjgwajhURWF4Y2ZqNkQ4M0tUNnEybGFGQjhJKzRXZ2VFcFUyTGxhbEEyUVBRMWltVVE5Y1FseklLL0JqdS90WmthWDhubzY4eDQ4TEhycnhYamR5aGRQemZuZmc3WXp6aEU5emdMdHVJWnZaV3Jnd204MUVjWFB0c0dHdHM4V1krWjdwQWVkRzhqNHpMVlRCSkFsNnhNbThITVJxUExqZ0RpbkpRMHJaNE5OUEpkbU1BOTVhNEFXbjRxalg0QlpJRWt1OEhPdDhTRGFlbnhwaXFiOGhzL1dqZFZ1bEJYNDdGayt3dDdobVoxV2wva0FhMVB4MjlQUVBlVm5GUlNibTdESGhSMlRESnpkVUdRN3ZLMmExVzNKV2J0dGV3Ty81NXNyUmFRZDdkZjg0NStTdDZ5ZjQ0cnJxZFJ2VzBIa1BRdlB1aWNadnpmU3hzSW9tVDlETjdjM0FjRmJTazNOQXVLV2hINWhiS0VSa0NjTldRbGU0ME5oUlNBQjc0VGU0L1Nqa0o5ZUpYYjNGdEcvU0VzWWFPQWFLR1RjSzF6SFlhT2lQRHNDbk9JUVo0eDU4MHBvQnJ4di96cjQ3WmNvbzlscktDUHlNQ3NXYVcvOFYvT0hGdXU1NEZ0VFB6TmxiM3g4NzhhL3ZqeDk3b051dTE5ZnMwSmZVZ01vemQrK2VBYkduNzkwN0RkYlYxbFVJdXlvTTlldW9qcEVPUUFYcWswYnlhYkxNYWdlLytGbDVpNHFKVEhwSWpoWnhWcUgrb0NMckVoak9kWFdZNWt2YlRVYTZUVWJ0ZWtwK1JZaUMydTFCbFV0bnFDVm5IeXhsZW5KU24wNDRrZUxpSHFTQUFMNnBFUXFrMHg2bE9RSVBYemJaeUlDRHMwY3RtSityUi9aM3FhN21rMlVGd2xFSUowNEIrMmNYRDV1WlV6S0xYM1htd3crbU54WUp6VHp1NjJRMEx6bW9yNEZTRFN5UzlkVU9mYlUyUGVpbW1PeUdEYVZhdkRVaDIyTnhaNHcveWxCT2xZRWxGR3pQSXlOUkpUaUszQ1JBM2pVclZyTkszckcyQWJPelUrS256cnhWdisxZnlLMDJMbHEydG5obGRmV3lSWGxMMDlhbVFmNW1kZDE1Tmo2bTJNOW4xWXpOaGcrcitXa0Z1VE1XcEU1SlQ1bTBLSHNTWDFLN2kyQTV4b3Fma1EvZ1BQNFJGaEJRZGl6STJkQjZqdXJEZFZJR0UrQ3F0QVpyVzJpV3dJL0JSRXJnWnoxdTM5WVo5MEk0Y29ueE9EakRlNEhwS1lJUnNNUFo4TmFic0FDR1VydEpSM09oUi8zeGxtb0JxSHhlTG5jQ1ZBa3dCbTlTcjg1Z2JRL0VIYVRHMjVwa050RVA3RlVzYi9oc1g1VWc1NFhUd2xoTVllUXVLaDVLZXNjWis2VnZ3SlhHT3ozN3ZKZTQ2N05QdjloMUcybTdZbEY1Y2RHaTdCVXZRd2JxWndzWi9yMVo5a3k5NFdMMVp0NXF6c0x5NHB3MXc5K2thODRDTko1RzRnZmRtVGdMcUNsVnljS3hXQkdnRGZhdWpFaURaMnVQS1kxVXViR3U1c3NrUlM2Q2RQSkpJMFJYRnpRQU4yazBNQ0t5OURWdFdIcDA4ZUUrTmJNYW1yNXRxTHNQUU5Yc2FxOXRPVXUzRkhHYk8zcE85SFE5V3JGMXlJaW0ycHJ6dnphRFYwLzhabXhKaU9wVTBWU1pzYlFFY3o2am1LeEZPT1RKeEx5bzBnZnMrQWQ5R1k5YnF4ekxDMXliMDdicXdOZkw1MndzM3ZGaEt0VDhmUEhJbmZYNVFpcUVQNDZIbmRlZEdWK3cvYU9OZkdQcnRVYmRMKzhMQXpVa1R5NE42YjhPNmQ4RHJWV0RtVm0wejZReVFEdi9EcklobFZXRGtIOEg0UjFkVUhDUTJTcVY5UXJDbzNJSThxS0dydUlQZFhPczcyNitESmM4T1ZSa0hDSnVLNjM5OEdwUCtiOCtkZnpzdk8vM2YveG9SZHFrOUp1N3E2K00zYU5iVWx1N2JPRU92NHFaOHpkc21qOWpEVHRsZkhHWHJoV1R0eGdNVzZaVWRPMVNOTDZpWnJ0eDJOVGx5NmZPV3JJRWxpVm1aVXlha0ptSjdDNFpqYnRNdEx1eGlyclQ1bmFuUWpjclZ6dktqV3Jnck96TWpjN096T2o4OFJNcGVvMkJBbEZiS1FUTS9oNHFEUTE4czJKZjMrckVneTNmTmhqdVAvMTRxRDdDL2JVRjc2UnQ5dG4yWGs1VjhaamEvT3J3Tjg3dDJISG44VW1oK3VBL1BUdE8xTHFCaHZGREk4by9xWjJYK1Q2T0NYSG9KWjd0aFRBcVRJRlJ6aFl4Q2hlOFVwL2xja3FZaXArekZnQjR6Q3JSQTdXTEZzdXdGclhyS2EzOWlTMmJ0MXV2aGMvQktFTUF6b2pCeGcwdEc3Y2h3QU1uWXozSHBCMlFTY05hNDZmZ3RiZjdSNCtNVFpvQytjM0xGNjFLbW5ZRmdwM2pnT2V3K09EdzZERkQrWWxGQzlPanNpY2VJVmcxei9RVW5rSjlEbVR5RlZqbC9GeXNha3pXcG1wenRXeGlZNjRXUDdGbDB4c2N0TjRJckJvdmFHOXJINkwzOVIzaEN3QUxxZ0VML2hYQWdvZUdEWTRjc1hQRnduMGFtREoxekxpVXhNVHM3TGl4NCtLaUprK0dmTFZ1K1VZWU5UQko2ejV4Mkp6c0JYUDV3YU5HRElsNk0vNnQ4TmVpaGcza2szUUxjRHdkZzV6YWx2VnRoMWZPTDhBcitFZnhTblhoTEdQRGh0bkN1eHpZbHk1TUJuMTRMZURHN2RrVEFmc1p2d1hsdU9nOVlKYWl1YmlDK3FMR0ttZExXS1ZRY1J0SWVWc1QxSkt4eWxyQ0txakdLbWlPVlZiUHhhcjMrNEo3UW5abjM3akJpOVpWVk9iczFNREpVOGRPU1U0ZU8zcWNLMGdDVGNtUDNEdER0blJSZHRtY1dieFZSR1JjN0tpazNvRmtiZm9VL2tCOFFZMVR6cFp3Q2xyQXFRYkczaEVYeXZXQ2FweUMveG1uY0phVkNxZkF0ZjR6QXQwRHhvUk95T3U2SUdwcDJaNzg1ZnRPTEl4T2RVcU5pWitWeVBaeWRvcDFkRmlRTkxWWFNLRXVvM1JQd2RYbGU0WDBRWDF0a25WSmZ4OFZ5NGd4QTVhaXVWSG53SmhiQ2NtQlVWMUdSSjIwQjUyQlgyZy9rZ01EUy9VTFo2MmVJd3lDQStEcHFtOVA1ZWFlQnU2ekVtZ09kcTZvTTRvdE9nVzJ0UE5IR1ZzYWs0TlNnM0tEMk1RR2h5QnZoQytOdVVHbFFWVkJ5QTI5WUh1Z0lYOEkwRUExME1DL0FEVHc4dHZoVWVQMjV4VWRTQmdaRVYyVHE2c2VNLytkZUoxdTNPaDB6OG1SbzZiTkdEbHNNaHo5ZXBMV2ErcVF1ZG5aYzRlbWVHbVRYcCtXa1NINEQzbjMzU0ZEbzZQQmdZSEQzaHcwS0RLU3JuSFNrUjR1aWJZelhvRTE1clpUejBBTFdOT0F6MExSNGxtQ0hLaUdIUGdDeUpGdUU3ZURuUEtFVEw4NWcxZFc3aWxZdHYrandyNHorcmdHamgzODlrelgxTkd4TTVOR3podzdOYkJYeVlLTXlsMzVEeGR2ZG5LS2M3WUgzVjRON0o2WU9UTnlSQklkVTVucEtZb3p2ZHJ0MVp3dDdkWFUxNlE3bWsyT0lvOVEvUmlPdGQxZldscTdmMVZaN1p6MGlSUG5wazJja0FhOENqZHZMbnhRVUZWVkFKSm16MDc2WWNMczJST3dQUytHKytFZGNnK2hKNzZIWUxpTm9NZmdnRjlHc25pamovOExSaS90THlqQU84Wk5jQXE5b01BeWRkd3NPSUt2WkRqR2tlbUV6MlBzZzVFM2hOdGM0RzV6RHprVHg2Rlc4WGx0cnZpU1lhakNMdy94MjJRTzczaTRaQTdObGplSG9LL3R1cVM5WTUybi9NWmErYkY4UUl0RHJJZVZuMVcvL3JMakQxQ0VMbkJtS1hzcVdaY1FQamcrZm5CNHdoc2hYZjM2OXZYckdzSlg4cWUvR0JJZlB5UThKaWE4YTk4Ky90MzY5VVB6azhPbHdueTBEc1c4QjY5WTRLS1hLVTZCOG5aZWh4WVUrRkZIWEVMY1dId2FiT1htQjk2YnV2M0NJT1BTOGU4V2N5VWd6RTA0b1QvOWVTR3hnVkZvclJ0RCtPN1ZXR1AvSi9aRzBOYkMzaWhVMmh1bDM3dVhaWXlCVlhuR09iQVRId0srU2hIS1FOb2JiR3VyUC9zR3dHZG9SMHdQdUU2b0w5NjRibkM3MFQ1dlh5UmpUWjEzaTRnemVFNWNXdjc0bHNqWmpWendVRUE3eHBtV2QyQ3o4WU1CQTFha0hiNTM2MWJESXcyY3RiUDRnK3B0cTR2WCtzSTFiT2RVNDI5OUJyQ3NpYm4ydGZEcjJWUDhtazNOaHo4NEZUK082Qlh6NGZRbWV3ZzExdGovZis2SjZEZ1lMZWpIcVBkRTY2TEt3N3pEMHFLM2ZUWG9jSHJ6M2FmTlo0Vm40T1hkQ3cvNkhsOVhYcnRIYzZxTHp5U2ZsMXZQTDQxT0VoNWZ2eXJjQjcyQUJxUzJncjhaTitaTW52WGw0M3ZiYTYvUXZFUGtZQWZJblNVbDVwaGJpOFc4eXc2QXRmSWI0QW53M1FMMndJM3Z1dHRtZGVqeDA3blcrK3dhelhEaHZ2R29VSlNkRGViQldNQlRQeDRrREdjZmM5RWtvK050WmkzOXZaN29KM3BLeWZFa0h4NnpZdlIwckF0dXFRdFczVjNDSDBaSWJ0SGdFT0VkZ2FCYmVmcnJaTjFSTEMyaHVQMWhlUGtWc3F6dGFoMUJtRmNkNjhOVVRkWVBWODJBSDNsbUwvSTlFSUpWN1BpY0VxYmsrcjd1SHI1QWtoUE5UTTM1d0Q3ZTIrdVZmKzd2SHVuckUvQldXT1BCTDRXNzM1Mi9OeS9CcDh1cnZXTW0zSzN2RnRrRmpEWTIySG5hdmpOM2E2WGh4cklTWWZtMm5FWFYxVGs1VzltcnZUT0h1cTg2MWFHRGRuQkEvNTdscTNJdWJ0Tk4xQWU2RHduNlc0Si8wUHA0OS9XbmJXMWF2UUIwejRtT1NWc1RHemNaNWllVmxTVzVwNVNYcHhCOTV5R2JmUjNaTE1YNkdRcXN0My94UHRJUWpGNysraTZTUERmL0ErRE91WlprRnRRSVR5OWVFWDZ0WHBsWjlQakU4WjlIZnJGaDA1blRXemVkRFRoVVVGeFhYMUo0Z0F2THJPOFJjRHkzK2RMRlUwdVBCZlNveXp6UzhtV3J2bWpmdnFMU2JSK3d3M0oyYmwyeHRMSVMrZXAwMHdQMmllaXJ5bjJrdWEvK0YvYVJrRndRZGRiU2NtTHRRQjNhNzJnT1BURDM5QlBHZE9TU0lEeTU4ZmJtU1BlSUZkUHphdjBQVnVvUGZUanExb1hHeENuQTd0Smw0QzM4Vy9oZEdHMFV2dmQrT2NXM0U3VEtuNVI1NGViOTdWdHZTdWRYN08va21aZUxkTjVtOGZ5cXJZNko2a1lRYTE2d1hENmtVaDlLSFQ1Mi9mb3huTjJ5cW54MUtmcmJJSXpnOUo5WGJ6dVhzbjV1MmtaUzkrTUIxdy81c0RPS0hCTXMxQlJWTWQ2bzZzSXJLcTJRN0hHN0R2aHNUUlhSTzZodTg1RmxMYm1oUjh0OXVJU3dMcUtEMFN0NTBJM1Y5MjRxTzNuelpyUCsyQ3RCbVJPblp4b0RObS9KM2Q3WmMxUGhsaXJRZjRNQitQN2toa3Q1R0NwQm1QRWI0MTFnYW43dzNhR1JIekltNGRrRndxUEc3WWU0dGhJUFlnbXYxTDlwSG94ek4zWVp1Zkc2ejVSbVNzYzUvTWM4TU4rR0IzWU8vSi9KUTd5eTlPZStJNTEzb2UrVUV4N0lmVkYza1U0TmpDMitEb1ZmZkd6bCsxUWtQd3ZYdTJLWHlMeG1uY3g0ZTZuTVAyUVp6S0htVGpoSnpXVWVTVEpnTEZPR2ZBVHp5N0lhdGN4RFdRWnpsamtUVGxET1RLWkpsT0dabVNrdUttWlZxWTRZa2VQOTViYmltUitaMFZqU0RmY0pWMGYya2pta3FLdzhSblkvOHp2ekp1UEtHRHc1bHRBZU83YmdWNThXaVp0R2lNUTVWVWcrajl3cHlnWUxUYy9RNXlTSGlPaHF1YWlyclpLdVpMNU1Ldk1QV1NZVEpFbTZNcE41Sk1yd1lPd01UNlVFMHliVEpNa3dNLy9tb21JbkZmVmdPb1dBdGlmcDAwcmFKOU4wMmljRjV5WithR1FrZlZwSjJzcnNTbnBrTFVvUU8vc1N5YlNTUHEyazgyZnFRK2VQWnlWZVFCUHFFK3hKK2tSL2E2YUpaMGl2ckRGM0owNkcwTFFvK2kvT3RWN2lZcFBtV3RZRHlUOGd2N2xLMU9kNXBwY1pEeWVWK1VHV3lRVEZURGZLOGFlVzRSbEpCbURtcDBEQ3FXZmVqa21XU1dDS21TNlVVODlNNXBJb2czUSt5MC9GNWlseHY1RnpYOHpweUs0UisvMDc1WFJVOEJkU21hOWxtVXp3RWVXUGREZVgrVjlKQnZXN0NlMnVMTWsweSszTVJMTkpxc2U1YzdoNm5EdGV2RW82SitlRG1xdElkcjM0bTRtTUU2bnAxOGFqUi8zcmtPekw2VXdoNWRGN1NXUG15ODlrMzRwbE5qQlI1djR1NkRnOWlURkxDSmZmT1BnREkrblFsc3hYbnRpSEhEcGZ2cXl0VXMrMlpMN3l4SEVYMHZueU1aUFIzSkJsNHNCb2NVNDVzM2FnTEJQRFZGTDc2ZExXRHNrOXhQeTFKSDd5SU9aTjRoMWFGcGo3MmlIWjE5SW5FWTNZYWRyNTR6UFpaMk16b3A3anMrY2szMGQ5RHFFK1pOZG04N3NFSGM1RHBESlliOEJEOGQzSGN2c3g3NUYrT2luYko3bDVSRy81b3Q3eXFFNzgxSGJlbTdlVlpXS1JuUk11VVg4ekdhTGJmTEdmSTJnN3ZncGZFSHJqUEVBcTQyakZUZ1hqaGJPaVBsOGxQbHNnOW1FVEkwWXZ5Y1pNSlNoTytCUGZwN0Vrd2RTTityNlZ6RlZxV290aytoS2QwMWlTYnBKNGdHVWVVaHpiSUVkMFR0dUpOUTJrZG1ndHh5VEdTZENCV0tMUGxiaW1IeGpYU0hXRlkxNHdtUXNTODBEY00wL0tNc3kyNlhNazBrTlh6VzBrVTBqSFF0aERrWlNMYUIxa3ZnYmd2RGdrVXlUcXdVYTRpTG1JY1Q0YTVoeG1pMmxNOVRmaGIzWVFQWVRPcVJDR2M5YW9EUDR1ODcxd1daeHIrWE1uM0daWDltdUorVUk2QVJleHlFd1d6VldvMFk3aDhjMWd3cWV4UzhabXZlaHYrOXJqalJDRzg4dW9EQm5EQXFrZjZMdVA1UmdkdzV4alZGWW54OFJQNWZpYnpwVFNPTlpKWXhaL2JlWFlHc3RVVVp0ckY2TTd5akxqVWN3TXhIR00yR1dkdjVJem5lUlRrVEdWaVdNS3BtUHEwVGJ2ZUV6MlpFeGxvbTUva2Nka1Q4WlVSdjFvQkJsUkFLdVlkNUxqUkdMVWFySDlPVFJHOVdKdHBQYUpEUEcxMVJTamRZR1VJZGhHMFk0UWlYT2xxQXhaSjB3bjZ3VDZYU2kxai9SYVJPT1NvdjFJWkJ2eUdvM015VXVrLzJUdHB2bFJXcnVCbUFrZGFRUlh4QUdLQ1k5azNFaGdQcUljdm02YzNENlYrVWpHalhUbUNPVnBkZEdZeWJUSzdjUXluek1qS1A2b1pmaHVza3c4OEdVSXo3OFhsc0c1TVcyMVU2bXNqU3c3SG5SSGVFWmtyYWxzRy8vNUpvUWZpV1Q4YThRNG1FTStKL2xIWkd3Vm9rOUcwdmppeWJwSmZhSTQ5MERFT1RRMzA5Mm9qcXpiZEVSbGprb3l6TXpYN1hGUDdBaHEydEdMQkZpTzVMd1FXM3RmdElXaDFOYnMyekNUeXB5VFpKQVBldEErMlhKbU1vOUZHVFJ2eWNUdUhGZ3JsZDFaeDNLYkhVVjdZVmR6a3hqbS93QkFMVHZDZUp4allHUmdZQURpc2c4MXp2SDhObDhaNURrWVFPQnk3WlcxTVBvWHo5K3JuRG9jU1VBdUJ3TVRTQlFBWjBRTkVRQUFBSGljWTJCa1lPQkkrbnVWZ1lIVDV4ZlB2MFJPSFFhZ0NESmdFUVFBaGJFRlF3QUFBSGljalZjTGNCWFZHZjUyenptN0Y2UU1vQ09GZ2tDcEtDOEZMWUpGaFFZWUFpUm9CRWRvZUVoNEJBSVlrSVF4RUV5aGlOZ2tJTkdFZHhKQ0pKZGFLTXFBUVNKeE9rQkJxeTJkdG9qajJCZGFpNlh5VUtsV1ovdjloOTE0dVVQRU8vUE50M2ZQN3A3Ly9mL0h1UUQ3Y3k2RWVBdVZiaHFLOUdjWXBuT1JaODdnVWYxdlpEcVRrT2YrRkNWdUNkcXBtZWlzVjJLTXN4cmozTkhvNy93TGRhb3ZidEsvd0ZOOHA0SElJYVlUSTRpZHhBWWluWmhCVEhSZXdpWm5QNTlwejN0TFVhNXZScUdxd1ZoL0xMSjFnSzc2VXpTYWJsaHBocUpSYnlHMjhuOEJ5a3djalc0dm5OTFpTRGVkZUg4Z0dyMlB1YmFieUVLaHZraWVqa0l6bkRMOERsUDFxK2hycHFCT2Y0eXVmaS9jclQvRVlQMHV1dWxqbU9wOGhPM3FGdlFqUTQxSHVzcUQ0NDdDWkoxT0dmS3dsVEpOSStmcUxwamtia09LenVkMUhpcWRFOWpsbkE1SzFYOVFKZGQrZStyRyswU21mWS92dUFmNC8zck1kdVBvd2YrYjFCbjA4VnJqeCtRN2lPN0VUOXhhREhjTzR5VnlDN01FYTYzdEQyT2R6c1FTWFlaaDVqam02OStncjlPQUtuMFMyYW9STmQ1TXpGVS94MVBxZVN6VmsxRW90dmR5TUV2bElFZDVXS3Z2dzBOcUdCWlRuMFh1VU9SeDd4cjFKaDUwTG1FSHY1L2xCSGhZYmVMNzFWamhkVUMxMTRYWWd4SjFDUE9zM2E4Q2Z4VGFpaStzSHhMZzlnb3UwUmV2RTRyWDc5RE93eU0vSkVQM3cyVHJGL29pRWRZWGgvQ3kzb1AxMXU1WGdYZVlNU0srb0I4UzRSd0xqanJIc0pIOEIyS25ybU84ZmUySEsxR0NWUHBQcmpjbFFueWhpN0ROc3VpYkhzWmZBbHZkdVgrenpCZzFMWkVyK3ROdnVkWStJdU0xV09KWllxcFpacXlMUG1ZbE92QzczV2pqUTlTemxFeTlnM0t4djlpQTloL0dPTHlSZkl6MmlIdnJjRXJ0d3k3SkVlZVBRWW5raWNTcWZoZzF6SmNYK1d5VjVBMTVoYkNieldlRmQ1SDdvTDNiRmgzRmozYnZKTlo1d1RtekNmc2x6cTFmYWR0azlnc3d6NStCS1pLRGtnY2hGNFQ4cE0xTDVrYXp6SnkxZVNQOCs1RGp1TUhHQzMzMmJWbnlYWEpPWXN6Nk44eDd5YjFrcGkzcTNNcmdpQ2xIc1Y1Q1hSYnhHd2RZbzJpL0tBNGtEeVFXSlk1dExDWEphNStWdUp5SFRMVUExV280VnF0cEtIYitpYTNNOFJkYzhINGhjOVZnbGJzVzljQlhyWWxxNE10ZmtlZVRCNURudUQ1ZVUzL0NkdGxYOHRZZytNUnJoYmJ1R25Reml6SFlEQTNLVFFZbXVMT0NQVkd0MURrNGFKNUZYeHRiMUVsaVIrU1VXaW4rTjdkalJGUW5kUUh5YlY3dTVQVkYrMytJNkNEMk1mV1lLRFhTck9INnZYaGM4dHJhYlRuamVpTG1TZ3k0czZ6L045dDdyK0pGcVcwMng3aXV2c1FvR3ljVjFGR2VrNWpMdzEyMkRzbHpOOW9jemRTSGtXR2ZHMmxyYXFidEEveW1LY1JDUFJ4RHplTW84TjdEU3VyNGl0M3JjaDV2bG52Nkk4YlE2T0NrTnhxRG9scGtQdUVlWW9OUktCRy9pTjVXZHVaQWJDdCtHS3RCZzVlTGdkWVdVcU1NN2phMTdCRzBINi8zTnRud2RkWUpmczl2aWZiNjE4elIzZUh6OGw0bGVsb2J4c01hRjlyUDFnSHBNL0xOODlSRDdMY1ArODA0OW9iWnFQZUxVZS9kRVh6bTdjWkIvUUgybWxSczgxTnhVcDltVFpNNmswMHV3RTQxbFQ2dndBQ0pJYTg3T3VudnNGY1dvZGJpWnE0dFJ5OXppcjFVL29zOUxyUHRVK285OUpNWU43OUZydlFZdllacktYalVtNGhhYnk2cVdKKzZleTdmVFNWR1lvRzNuRHlCdlM2cXAvbkIrM2Iva2V6MWpHbmI0MWhUcGM5NWY4WVB2TlA4WG41d3pzckJmY082V2V0M3hDKzlDc3J3UWZDVkhobjh3KytCdDgxRjdOQnZNbThIb1lQdjRZem40YmozSk90QUhTcGpPM0RTbjR1NHZnbjU2cStzRVJKbjlMWE5xVlhVNlN3NnEvT01rOHRzV3FTaE1EYUYrUmptbk4rRyswMUhxZDEzUFd0UUc5citkc2JRMzdDYStiT2RLR0lPNVJGMXdCZXRpSjQyNXNWV29ZeW1OZjJ3a2pKUHgxNjFuTFV3QjcycE8zUWxEcXIvb1VwOGIrMVAvNHNQN0p3aGVuK0lmZnBCMUpoK3dTWHQ0anB2TVRMTVNOeHA2elMvSDJ1REJ2TUdxbUszWXEvSEdtc3VVT2JYc0RqcUV4SWo0cWV3SHZWcFlzYUwrTXk3UVA4TlJtZUpHL0dkR1V1ZWhRM2t1T1NLMXhJOWRYM3czNGdseHB0a0Zka0dVVGJHcUkyVDdZeHRxZHVoYk5FM2Jmd3lodXdNbGRUbm92clcxSjgyWXBrZWpOVVJKOXRGYjhaamdzaStUUnoxZzlDblRjeTRsOWlUUExHeG1zeWhqSktIRW91U0x6Wm1TOUZSalViYnlFNU5YSTQwbWJXOElVanova0xPb0M5NjREYldqeXo2WjZIZmdCUnZBZTcwMytDTXVBVVYranllMXQ5bDdZdXp6bjJQODFVcSt5eHJWbVN6eUE1aUk1bnBvdjZSek0zTkNaYzUrUHliMTc4RlgzdCtHRVZ1MWR4Nk9BZXNKeDlsSG05c3JrK0gzTFhaOWFnWFhvdVQrMi9ZTzYvRmlYMzVhbXl5Z2d4OUF4RHJ5ZHdNbWZNRDNKYWNreWZ4SGpQZDdjZnJHaDVlVGx3K3c1aFYyT1A5REM4TE9PUDJrVjVzTVkyWWo5SHVER1M2YzRnTTFwcHNubTlXWUx4YmdUSzFqYm5iRFEzK1cremZjczdoK2NlZGhubkVUTFVGbGFvQzkvRjhrcTZtY083ZWlpNHluM3ZGT0dEbnZmNTR3UHlkTS9jQlpNYU9vRjZmd3lPbUhjcTlXanpCbUpublA0VDUzaEhPQ2RXWWJsS3dtM1ZtaUg0R3orc3BHQnJMdzFMWEQ0b3B4MHpkaWVlZ25zeVJXM2tHYUltQm5CdEtkUnJyeFdPTTQ3Tkk4YTlIaXVnWXV3MFRZZ013U2E3MWJOeEQyVlAxMDVUM1UzUjFnNkRhT1JHVU91OWpoUE1jMXFncUZLdGx4QXFpQUl0MEN5eFMrY0U2NnBIRnRjWE9VYzdkRzlsenBySEdyT0NacjR6Y20yaER2TUwvN3lBdU02VzZoUHZaTytMY0syN2VKV0pjUDg3MXQ0bG5lWjJGT2V6aHFmcHpiT0VjL2lPdkhjWlN6NlU2ZzNORmY0eGhUaGU3OTJLTU9zNTU2d3ZPQUdsODlqcjIrazQ4THhheGpuVEZBdjE5OXUwWUpxaTdhTXR4bEhNT3hxdlpXSzdtODkxenZKK1BJalVMQ3luM00rb1JMT05NdFVjQlQ3QStQTUM5R3NoMTZpSnphQ0R1MFkyY2JVdHBjOUhyQmZaRXptRzZMRGhySVhLS3pzMUI3TkE3dEVNSTlzSWp0TU1HOGduaWEvMlRJZm9uUXZSUC9uWWl5cTdjcHdsaSswUllQd1FseEhPaExHMUZuZ1MvYkJUZlJCRDVJbHdobi9ncWd2Z3NFV0tYeUlkWGdmV3A2QlA1TkVUc01PYjhIdzVYTFZjQUFIaWNkY0Z0VE5JSkF3QndEODJJak13akl6TkVSVVJFUkVSU1FrUlRNaUpFTWlJek11TklQU05EOGlFRkJNOHoza0hrek1nanpzeklPREpQZWZualhHdk90ZWFhWTY2NTVseGp6am5uSEhPdU9lZmNjNStlYjgvdkZ4WDFQL2lvMnFqNW4vZy9yWUUwb0ZIUUFtZ3ZtaFl0akpaSDI2STkwWE14c0pqeW1NRkQwRU0xaDREWXRGaCs3T0poeW1IT1lkRmh6K0h2WURTNDV3anhpUFRJRWdRUGtVTDhSNk9PaW81Nmo0Yml3SEcxY2NxNEw4Y2d4K3FPT1k4ZFFPdWg4OURkNDZUakRjZUJlRkE4TWI0NTNoTHZpcCtQLzNFaTRRVDVoRDhCa1NCT0NQMU0rTmtPUzRZSllUYlk4a24weWJLVGt5Y1BFcG1KNDZkZ3AycE96Y0dUNFExd0szenROT0cwN1BUNDZlMGtTQklyeWZSdjd4bmtHZE9aU0RJM1dYSVdjWloxTm95b1I3UWdkQWhyQ2pXRm0ySk5XVWdKcCt3ZzRjZ1c1QURTalZ4SDdxWFNVMW1wb2xSVnFqMTFPeTBtTFRFTmswWko0NlNKMGxiVEl1bWdkRmc2T3AyYXprNnZUNWVrYTlLM1VGR29CQlFLUlVaVm9nUW9Rd1lrSXprRG4wSFA0R1UwWm5qUk1EUWFYWWhtb3V2UXJlamV6UEpNVG1aRHBqU3pOOU9lNmM2Y3lWeklYTU5JTUQyWUFZd0xBMkRtTWQrekVyTXNXY05aazFseldkK3lOckZjckFncncrcXdRMWdQRnNET1laZXdHOWo5YkdnMk1wdVlYWjdOeTI3TVZtYXY0a1E0R1U2SEc4SjVjQjl3SWR3S2JnTzNud1BOUWVZUWM4cHplRG1OT1IwNXZUbURPV001TTNna1hvTzM0OTM0R2Z3Q1BvemZ5WTNLamN0RjVGSnlHYm5jWEdGdWUyNTNyaWwzSlRkQ0FCR2doQ1FDZ2NBZzhBZ2l3Z1Foa2dmS2crVWg4M0I1dER4T25panZBeEZCSkJETGlEVkVFVkZPdE9iRDg4ZnpQK1l2NW4vUDM4dy9JTVdUMGtna0VvUEVKd2xKcmFSdWtvM2tKTGxKTTZURkFuaUJwc0JlNEM2WUtWZ29DQmZza0NGa0pKbE1acEg1WkNHNW5hd2gyOGx1OGtmeUlubU52SHNPY2k3NUhQNmM5TnhPb2FCd3RpaXBTRmxrS1hJVmZTZ0tGYTBXL2FDQUtUQUtrb0tqRkZLYUtmT1VsZlB4NTh2T041N3ZQajk5ZnBPS29MS3BWdW9ZOVNOMW5ucFFqQzltRlF1TEI0dEhpc2VMcDRzL0ZTOFdmeS9lTE42bHhkUGdOQ1N0a2lhanFXZ2FtcVVrcmdSV2tsekNMT0dXMUphTWxMaExsa3RXNldsMExKMUlkOUJINlFlbGdsSnBxYTUwcU5SVCtxRTBWTHBSMWxBV3VoQjdRWFZodDV4VGJxK0FWVEFxMkJYZWlwbUtPUWFOd1dEWUdKR0w3SXRqRjc5V3dpdTdLL2N2Q1M3Tlh3cGYrc0VFTTVPWU9LYVZHYmtzdWl5N2JMb2NZWUZZTXRZcWEvTUs2QXJrU3NlVkRUYVZ6V2JYc3lYc1NmWjBWVndWckNxNVNsTFZVYlhCRVhLY25Ba093RG1vanEyR1ZpZFdJNnJSMWZocWNyV3llcjA2d3NWeHhkd3g3czVWeGxYSDFYQk5aYzNYYTlocnhHdU9hd2M4TksrRDE4MzdjVjE0M1hsOWdnL21zL2dEL0ZYKzVvM2tHNmdiMGh2T0c2NWFlbTFsYlUvdFhPM0J6Y3FiOXB2YmRlUTYreTN3TGNHdDFsczlnaGhCb2tBbVVBazBBb2RnOURiMGR1dnRwZHNidC9mcm9mWGMrb2s3Q1hla2Q1WWJCQTNmN21MdXl1NnVDbXVFSDMvQi9lSVgwVVViOThidVRkd0RHdkdObHNaUUU3d0ozMVRleEdtcWEvcmNYUGdyK05jdkxZS1czZnZNKzRQM3Y5eGZGeWVMQ2VMeUI3UUhuZ2V6RDc2MVVscUhXcmNmaWg0T1BKeVR4RW9ZRXJ0a1M3TFhGdHVXMElab3c3YVIyeXh0RVdtdGRQb1IvSkhra2ZLUjd0RmFlMW03czMzM1B6cFprZ3d0SThwb01xYU1LNnVWRGN1MlpRZVBJWTlySGpzZnV4LzdPNkFkRFIwakhlNU9SS2VtMDlicDdIUjFBcDN6Y3J4Y0x0ZkliZkt3Z3FuZ0tSb1VZa1dIb2xkaFZkZ1Zic1dNWWxHeHJvZ29kcFVRWmJLeVhibWszT29DZGNHNzhGM2xYZnd1VjlkbTE0RXFYb1ZXVVZRY2xWRFZvcEtxZENxSGFsTDFTZlZOdGFrR3FSUFZPSFdabXE5dVVjdlVQV3FIMnEvK3BGNVNyNm9qM1pYZHp1NjE3cTNmV0w5OTdhbnNBWDVuL3o3VGkrNDFQWWw1SW4reXBNRnJsSm92V3BxV29lVnFCZHBtYmJ0V283VnIzZG9aN1lJMnJOM1ZRWFZKT3JTdVVNZlUxZXVrT3AzT29adlVmZEt0NkxiMVlEMUNUOUpYNmdWNmlWNmpIOUpQNk9mMHkvcHQvWUVCWWtnMjRBMTBBOWZRYUZBYWJBYVhZY1lRTXF3YjlvMEpSb3lSWW1RWitVYWhzZFVvTjVxTVRxUFhPRzhNRzNkTlVCUEtSREZ4VENLVDNHUXlPVTBUcGxuVFY5TzZhYzhjWjRhYlVXYUNtV3BtbSt2TkVuT1BlY0RzTWdQbWVmT0tPV0xldDRBdFNSYWNwZEJTYnVGWkdpMGRGb1BGOFgrN0xCT1dhVXZJRXVtRDlxSDdLSDNjdnVZK1M5K0NGVzlsV25sV1VUK3VuOWJQNnhmMzkvWmIrMGY3SXphZXJjRzI5WWY4RDl0QXdvRG5LZndwK2FuaDZlWmc3Q0J5a0RKWU16ZysrUFZaMGpQaU05R3pIVHZISG5sT2ZWNzdYUFo4NHZubkljWVFkMGd3SkI0Uy83bmt3UDViNmhoMTdMeEF2ZUM5Nkg3aGYvSFpLWFZ1L2NYNWEyVVlQeXdlOXJ4TWZFbDhLWGtaSGlHTnRJOU12NEs4a3J5YWZMVXdHanZLRyswWW5YMGQ5WnIxZXNRRmNVbGRUdGZ5RzhnYndadWxNZkFZZlV3MzVuMGI5MWIzTnVTbXVJZmRlMyszLzczc0FYc2FQT0YzbUhlbWR6L0dNZVB1OTRudkJlKzczNjlOd0NjRUU3UC9FUDRSVFNJbTdWTXhVNVZUNDFQK3FkRFVwaGZraFhuUjNrSXYweXZ3U3IwRzc2QjN6RHZ0L2VJTmUzZDhzVDY0RCsrais3ZytvYS9kcC9FTitUeStENzZRYjkyMzU0L3pJL3hZUDlYUDl0ZjdKZjRlLzREZjVRZjhjLzRsLzRaL1B3QU5KQVZ3QVZxQUUyZ0lpQU9xZ0RYZ0NJd0hwZ09oUURpd0EwUUJDUUFLSUFNc1FBQTBBM0xBQkRnQk56QURmQWFXZ2ExZ1ZEQWhpQW5TZ3N4Z1hWQWM3QTdhZ3FOQmYzRDJ2KzBWaGxBQUFBQUFBUUFBQkJFQWx3QVdBRjhBQlFBQkFBQUFBQUFPQUFBQ0FBRWJBQU1BQVhpY2paTFBUdHRBRU1ZLzJ3RUVCRlJvaGJoMVR6MVV4UGtEdlFTSmdoQWdwSWhEcURqMTBDVXhpVVh3UnZaR0VaVjY2S1U4UW85VjM2QnYwR2ZvRTdUbkhucnJ2Wjgza3pSQWtXcHI3ZC9PN3M1OE03TUFsUGNCSGtiUFUrd0tleWppcmJDUE9Yd1VEckNPYjhJRkZMMkM4QXpXdkpmQ3M3VDNoZWZvLzZ2d1BHYTlYOEtMV1BBWGhZdDQ3TzhJTHlIMHZ3Z3Y0M253UXZnUlpvTkVlQVV6d1h2aFZSU0R6MVRsRmVZNTIzRUtjL2FvODQyd1QwODN3Z0VxK0NSYzRKNmZ3alBZOEZhRVo3SHVuUW5QWWRkN0p6elB2SDRJTCtLSjkxdTRpR2YrbXZBU1h2dE40V1c4OHI4TFA2TE9zWjRWTEFRRDRWV3NCemM0aEVFQ0M0VTJOUCthMUtLdGoydWtpTkZCMTYwZTBXWTQ2eUhpck1aY3F2emkwQ1JXdGJYVnFtWDYxMm5jNlZwMVpFeW5GNmxhcGNvTlRaNDY1N0FjQ28ySlJ6VE51YkZHTmZJaitiYUlDd082MXd5TFp0UVo5RFJoT216OVFXZDFFYlRKQXk1NGZkcDduVW8yLzF2SkdTT2x5TGljRjBiUmE4aFJjZjYzT0xZbjZkUG5XWlJtc1VsVU5heFdLdFd0NnJhNkg2dDBQMVpwa3ZXMHBKaFJsV3VBcFFMTmhrUzRjdlc0cE0zZzRrNGJ3b24wT0ZOYTJWUzNveXVkWGlweklUMElieGRRaW9NN1h2SjJYNDBYdzVZaDcxTnQ2Z1JaZnJVcnhFaHNYaHhMZTE0YzdIZlRPTE94VGhTRlJLbk5ESTE1dGkzdVM3Z3JZaEtLYlUxY01xbExyZXR1MEI1dm1PYSswZXoybVExYTdyYWhScUVWT285YlVaSkZiVFZJMmxHcWJEZFNlMzNkNGs5V050UzRKN1dRKy9PaVc0YXFvOHgzNk42UWdmOEdEeGtnWlMzS3JNYTBpSXlXQm81WmlnT2M0SlRmMGxoRTE5cCt2VndlRG9laGRzRkRrM2JLdlpHQXJOdzQzajg0T1Qwb09RSFRMWloyWWZwQy9QTW1QSFE1L3dCdkgrZ0JlSnh0MlFWWUc4bmZCL0NmaEZDc2R1N3VkejFpQk00am01YVdRbytXcTV3R1NDRnRTTGhJN2R6ZDNkM2QzZDN2L3VmdTd1NTM3MmJuQzFtNHQ4L1RmR2ZKekh4bVpuZVpaQ0VoNTkrL1h1cWwvK2VmWjRMOXdpU2s1S0VxOGxJMWphRWFxcVU2cXFjR0drdmphRHhOb0ltMEhDMVBLOUNLdEJLdFRLdlFxclFhclU1cjBKcTBGcTFONjlDNnRCNnRUeHZRaHJRUmJVeWIwS2EwR1cxT1c5QWsycElheVVkK0NsQ1FRdFJFWVdxbUZ0cUt0cVp0YUZ2YWpyYW5IU2hDVVlwUm5DeEswR1NhUXEwMGxhWlJHMDJuZHVxZ0diUWpkZEpNbWtWZHRCUE5wamswbCtiUnpyUUw3VXE3MGU2MEJ5WHBhcnFJRHFaRDZCNDZsVDZqUStsWU9vck9vU3ZvWWhZNmt0NmdnK2drK29GK3BHUG9ORHFjSHFKMzZIczZsNjZrbitrbitvVXVwR3ZvQ1hxTXJxVnU2cUhqN1pWNmlsTDBPRDFKejlIVDlBdzlTNS9UZkhxUm5xY1g2RHJxbysvb0JIcUZYcUtYcVorK3BLL3BDRnBBYVZwSUE1U2hMSjFQT2RxVEJpbFBCU3BSa1JiUll2cUNsdEF5V2twNzBUNjBOOTFPRjlCK3RDL3RUd2ZRVi9RTjNjbktIcTVpTDFmekdQcWIvdUVhcnVVNnJxZC9tYmlCeC9JNFpoN1BFM2dpTDhmTDh3cThJcS9FSy9NcXZDcXZSci9SNzd3NnI4RnI4bHE4TnEvRDYvSjZ2RDV2d0J2eVJyd3hiOEtiOG1iMEI3M0ttL01XUEltMzVFYjJzWjhESE9RUU4zR1ltN21GdDZJUDZFUGVtcmZoYlhrNzNwNTM0QWhIT2NaeHRqakJrM2tLdDlMMWRBTlA1V25jeHRPNW5UdDRCdS9JblR5VC9xUy82Q1A2bUdkeEYrL0VzM2tPeitWNXZEUHZ3cnZ5YnJ3Nzc4Rko3dVllN3VVVXorYys3dWMwM2NVTGVDRm5lSUErb1U4NVM1ZHlqZ2Q1VDg1emdZdGM0a1c4bUpmd1VsN0dlL0hldkEvdnkvdngvdlFhdlU5djBsdjBOcjFIcjlPN2ZBQWZ5QWZ4d1h3SUg4cUg4ZUY4QkIvSlIvSFJmQXdmeThmeDhYd0NuOGduOGNsOENsM09wL0pwZkRxZndXZnlXWHcybjhQbjhubDhQbC9BRi9KRmZERmZ3cGZ5Wlh3NW5jZFg4SlY4RlYvTjEvQzFmQjFmenpmd2pYd1QzOHkzOEsxOEc5L09kL0NkZkJmZnpmZnd2WFFXMzhmMzh3UDhJRC9FRC9Nai9DZy94by96RS93a1A4VlA4elA4TEQvSHovTUwvRDkra1YvaWwva1ZmcFZmNDlmNURYNlQzK0szK1IxK2w5L2o5L2tEL3BBLzRvLzVFLzZVUCtQUCtRditrci9pci9rYi9wYS80Ky81Qi82UmYrS2YrUmYrbFgvajMva1AvcFAvNHIvNUgvNVhTRmhFVkR4U0pWNnBsakZTSTdWU0ovWFNJR05sbkl5WENUSlJscFBsWlFWWlVWYVNsV1VWV1ZWV2s5VmxEVmxUMXBLMVpSMVpWOWFUOVdVRDJWQTJrbzFsRTlsVU5wUE5aUXVaSkZ0S28vakVMd0VKU2tpYUpDek4waUpieWRheWpXd3IyOG4yc29ORUpDb3hpWXNsQ1prc1U2UlZwc28wYVpQcDBpNGRNa04ybEU2WktiT2tTM2FTMlRKSDVzbzgyVmwya1YxbE45bGQ5cENrZEV1UDlFcEs1a3VmOUV0YUZzaEN5Y2lBWkNVbmc3S241S1VnUlNuSklsa3NTMlNwTEpPOVpHL1pSL2FWL1dSL09VQU9sSVBrWURsRURwWEQ1SEE1UW82VW8rUm9PVWFPbGVQa2VEbEJUcFNUNUdRNVJVNlYwK1IwT1VQT2xMUGtiRGxIenBYejVIeTVRQzZVaStSaXVVUXVsY3ZrY3JsQ3JwU3I1R3E1UnE2VjYrUjZ1VUZ1bEp2a1pybEZicFhiNUhhNVErNlV1K1J1dVVmdWxmdmtmbmxBSHBTSDVHRjVSQjZWeCtSeGVVS2VsS2ZrYVhsR25wWG41SGw1UWY0bkw4cEw4cks4SXEvS2EvSzZ2Q0Z2eWx2eXRyd2o3OHA3OHI1OElCL0tSL0t4ZkNLZnltZnl1WHdoWDhwWDhyVjhJOS9LZC9LOS9DQS95ay95cy93aXY4cHY4cnY4SVgvS1gvSzMvQ1AvS2ltcnFLcEhxOVNyMVRwR2E3Ulc2N1JlRzNTc2p0UHhPa0VuNm5LNnZLNmdLK3BLdXJLdW9xdnFhcnE2cnFGcjZscTZ0cTZqNitwNnVyNXVvQnZxUnJxeGJxS2I2bWE2dVc2aGszUkxiVlNmK2pXZ1FRMXBrNGExV1Z0MEs5MWF0OUZ0ZFR2ZFhuZlFpRVkxcG5HMU5LR1RkWXEyNmxTZHBtMDZYZHUxUTJmb2p0cXBNK2xHdWtsbmFSZmRTcmZSdzdvVDNVeTMwQ04wSUQxSWgrbHN1b29lMVRrNmwrNmwrM1FlM2EwNzZ5NzBxKzZxdStudXVvY210VnQ3NkdqdDFaVE8xejd0cDlQcFREcUR2cVZMNkVRNm15Nmo0K2hrT29YdTBEVGRyd3Qwb1daMFFMT2EwMEhkVS9OYTBLS1dkSkV1MWlXNlZKZnBYcnEzN3FQNzZuNjZ2eDZnQitwQmVyQWVvb2ZxWVhxNEhxRkg2bEY2dEI2angrcHhlcnllb0NmcVNYcXlucUtuNm1sNnVwNmhaK3BaZXJhZW8rZnFlWHErWHFBWDZrVjZzVjZpbCtwbGVybGVvVmZxVlhxMVhxUFg2blY2dmQ2Z04rcE5lclBlb3JmcWJYcTczcUYzNmwxNnQ5Nmo5K3A5ZXI4K29BL3FRL3F3UHFLUDZtUDZ1RDZoVCtwVCtyUStvOC9xYy9xOHZxRC8weGYxSlgxWlg5Rlg5VFY5WGQvUU4vVXRmVnZmMFhmMVBYMWZQOUFQOVNQOVdEL1JUL1V6L1Z5LzBDLzFLLzFhdjlGdjlUdjlYbi9RSC9Vbi9WbC8wVi8xTi8xZC85QS85Uy85Vy8vUmZ6M2tZWTk0MU9QeFZIbThubXJQR0UrTnA5WlQ1Nm4zTkhqR2VzWjV4bnNtZUNaV2w3THB4c1pJdkRveWtPeko1N0xWU1pQZVNIYyt0U2psVFRwUkhjbjE1YktwaGRWSmszV3hublMrcHpRd1A1TmFVdGRUS1R1OStSb2p5S2czM3BNc2Q5WnJJbTczbkN4V1c2QlNvQ3hEcFp5b3RYcHp4V1JQVHlwYnJFME5GNnN0RENCbDBtdVpIbE5PMUUxMkRhZHY5SEQ4alVoZi9lU2UzTUJBMG5SWjMrYzZxSnZpNnFHL1V2Wk02VTdtUGYzMmk3ZTFtTTcwcHJ4cEo2cGJNWWMwNXRCcTVwQTJ5OVdLMGFaTlN1dFVTUytvbStveUZsVEs5ZFBjbzFvNDRxQXZuMHBsTThsc2I3ckgyNWJzS1JWVDNvd1Q5VzN1ZWhuWGdiZk5MRTNHQ1UrYnZZYWVqUDNpYlRmdHM2Wjl1N3Q5MXQyKzNiVFBtcVhOSmdkemhXSStOOWlmVWl2YnA2bHNYM1VISnAvRDVEdk01SE5PTkhUMGw3Sjl5WHhwSUpNc0ZSdHk3aU52cHhsRDNveWgwejJHdkhzTW5XWU1lUk16VGF1Q0UzVXpYY3RZR0gyeW0veklnSGVXYVZ3MDZ6Q3JmQ0tMNVJQWlpVNWt5WnpJTHN5bGhMbDBtYm1VbktqcXlxZXpmVldsOG10RDE0aDVsZHhIMVYwNDRTWGNIN05kWTF6c0tzOTFsWmRXeXQ1NVpvYkxuS2lkVjdrRmxnMFhxeks1YkYraHFxTS9sODlXNVp6WEx1ZTFWSDQxczA0MDFrYktZelhkSkllTDFSSExaREpsMXJDamtFa1crazA1VnlrN3ZmaDl6Y2dXWkFRWk5Sa0lWeFY2K2hjbnpWRTBaaklScU9uTEp4ZWw3TlBZWGVQMDVwU2NWUzZYUFAyNTNFS25hcUF4TWNhZVZuY3FrMXRjVmN4bGM0V0czblFxbnlxa0M4NVJiU1F6Mko5MGlqWEpiSzZZeXFUU3lYcHJzSkMybDhENThSaXJpUGRiY3lqVmR3eWt5eWZRSEhTNUt0ZDJES1Q2VEtVSmFidjZDS3ZLc1R6UlZERlpOVGxwWDREVmNEeno3QitwN1ZUTjZyZExuakpVTlMwNU9KaTBiOFNCN3Q2a1RDOUplMG5tcEtzaHk0eTBkdmJucW1hbSt3YVNPaXRacXNZb2RFWi9XbVAyL3htRmRIMnJhd1RqVUdIb3VEWTVQUEg2bEh1NnFhSHBwb2VtdTN4cFpGTXpHYWU5cDdzOG1iN3laS3A2VTVsaXNocDllWmFWcDFSK3MraE1xZHhaMVVKblNobG5TdWJzUkdPU0xjbVN0SDE3Ty9QU2ZIL09XeWhQeWxmbGhCYnR1Y0hYUVh0ZVBmWi8rN0FxVjE3b2V2Y2FqeHMxelBxYyt5eVYzR2NwTjN5V3pERGlQcVFmMmVSa3NMRVI2VVA2a1FGa0VCbENEclVMSTV1UkxjZ0lNb3FNSWVOSUM1a3c2WVB2ZysrRDc0UHZnKytENzRQdmc0KzdLNGk3SzRpN0s0aTdLK2lENzRQdmcrK0RqKzBzNklmdmgrK0g3NGZ2aCsrSDc0ZnZoKytINzRmdmgrK0g3NGZ2aCsrSEg0QWZnQitBSDRBZmdCK0FINEFmZ0IrQUg0QWZnQitBSDRBZmdCK0FINEFmaEIrRUg0UWZoQitFSDRRZmhCK0VINFFmaEIrRUg0UWZoQitFSDRRZmhCK0NINElmZ2grQ0g0SWZnaCtDSDRJZmdoK0NINElmZ2grQ0g0SWZnaCtDM3dTL0NUNTJ2R0FUL0NiNFRmQ2I0RGZCYjRMZkJMOEpmaFA4SnZoTjhKdmdOOEVQd3cvREQ4TVB3dy9ERDhNUHd3L0REOE1Qd3cvREQ4TVB3dy9ERDhNUHcyK0czd3kvR1g0ei9HYjR6ZkNiNFRmRGJZYmJETGNaYmpQY1pyak5jSnZodHNCdGdkc0N0d1Z1Qzl3V3VDMXdXekR2RnZndDhGdmd0OEJ2Z2Q4Q3Z3VitDL3dJL0FqOENQd0kvQWo4Q1B3SS9BajhDUHdJL0FqOENQd0kvQWo4Q1B3SS9DajhLUHdvL0NqOEtQd28vQ2o4S1B3by9DajhLUHdvZkh5T0NFYmhSK0ZINGNmZ3grREg0TWZneCtESDRNZmd4K0RINE1mZ3grREg0TWZneCtESDRNZmd4K0ZqWHdwaVh3ckc0Y2ZoeCtFUDdWZHgrSEg0Y2ZoeCtISDRjZmh4K0hINGNmZ1dmQXUrQmQrQ2I4RzM0RnZ3TGZnV2ZBdStCZCtDYjhHMzRGdndMZmdKK0FuNENmZ0orQW40Q2ZnSitBbjRDZmdKK0FuNENmZ0orQW40Q2ZnSjQ0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGV3NzRldzc0ZXc3NGZNdnUrenpQanM5SmswKzVhZENlOXM1NE94ZDdHSjJlYXovbUluYW1ZUGZUU3FXVHhVTXUwaTZDK0Mvc3o5YmljOGM3L2JHVUkySWNQSVptUUxNb0tNSW1QSU9CTGpOZmU3ejRyQ2o4S1B3by9DajhLUHdvL0NqOEtQd28vQ2o4S1B3by9DajhLUHdvL0NqOEdQd1kvQmo4R1B3WS9CajhHUHdZL0JqOEdQd1kvQmo4R1B3WS9CajhHUHc0L0RqOE9QdzQvRGo4T1B3NC9EajhPUHc0L0RqOE9QdzQvRGo4T1B3N2ZnVy9BdCtCWjhDNzRGMzRKdndiZmdXL0F0K0JaOEM3NEYzNEp2d1UvQVQvaThjODJGdTlRSi9CUjZBbm9DZWdKNkFycTUyMzBKODJuSzMyanVFanQ5U0Q4eWdBd2lROGdtWkJqWmpHeEJScEJSazc1UVF5bmJtOG9YZW5MNVZHOTNwbUhQa3YwRnN2eGRQbDlJOVpvNi9wQjNJSjExbmlqWTMweXp2VFdwSlQzMkZ5Qzd0bmsvSEt6SkZrcURxWHc2bC9kazB2bWtkekJWc0w4d21YY2pVWTlWeXVlY0F4K0c2VE8vQk94c3Fra1ZpdW1CWkRIVlc1UExwbExwdnY1aWYzMnhQNTlDdVZBM1A3MW9xRnhmc0FlV0hYckQ5UUNrM0ZzaWFoYkh6Z0RTV1p5RVpYNGxKaExtVjZhZGNVOTdWMXViZDg2a3drRFBZSzNUcVZPc1daYks1eVpsc3FXQk1mWmduTUxZVERMZlowK3RUTnBmeU90N2x1YlRtVXk2cDN3dzNuMlFTYzB2MWczOW9KanVHZXM4RVJuK090L2dISllybG8vTW04UGYrcGVyUE5vWWJqQ3g4ck9oVnE1cXc0OE9YRDhiN3M3MFBseGxnbXVoOHVVdnhDbHZ4Sm11TjJvaVppSnV3aktSTURIWnhCUVRyU2FtbXBobW9zM0VkQlB0SmpwTTdHaWkwOFJNRTdOTWRKbll5Y1JzY3pLY1UrK3N2SGV1ZVdPZTY5U1VTODZwY1FyRnhUbDNJNmZhL0Z3cGo1SjkzWmg2aGZTU1NvTnkxN1hPSldTcVpkUG9ydHJwdHpSWTdYUmJHcXhCcjZYQk1hYlRjc0hwMDY3amRHblh3YlZqbDlDbFhjbjBhQmZNa08yQy9SVytVT2hPNW11R256RFY5Q1lMNldSdVNUcHBSbHdlbFJteGMvV1Z1M2NHYXZvdkY2djZKaVV6Ull6Y3FlNDR6a3JOTUZOeEhtZVVhelVNWFlmT2hWQm5uaU9iSmJDSy9hWnkrUUdmVTZxTE9GY0t5czdvblBMNFNPWFN3cHZPeGVtVXgwYUdkbDl6QnB6SGFFNXhYT1dKbW5QY0VPdEo5ZHFEU1pvK0xCZG11VEJyRkRiV0dnSFV0YnJhdGJyYXRZNXUxenF5WFh0bHpIVWRyajQ2WEgxMGpKNW9oMnVpSFNQNzYzTDEwZVhxbzJ2ME9McEd0cHRicVZ1UHZ4MWdVWjF6aERmTTQxRHpSc3pWZTJ4VTcvWGxqMUsreGdocU9vOXNUVGxlS2RkYmJzZXFPT01xZnpOQVJiZHJWWG9ZUDNuMHlreDJqZFlaZzcvUk9aamcvbE9CYVR0bGROdld5cXJXdDdxSDF1cnF0TlUxbEhHdEk4YzVmdXFvTGlkTUc2M1d0VlZXYlVMYmY5K3R6SzJtL0tRZjE0aXJUZnQvMnJTN1ZyVERQZXlPeXJBbmpuaUliOTd1ZFBYYStaOWVPMTNuYkticlRNOGNOY1dHbVNOdW41bVZaaE5tL2FmVFdhNU91MXlyM2VVZWRsZGwyTFZkdzdmdHhLNy96S0MreTNVdXhzOGVOYkR4YzBkZjhYTkhYdkh6S3JNYU4yL2tpYXliVnhub09IdDNIVWhtN1U4VHB0My9BZW0wMUJRQWVKd2R6ajBLd2pBWUJ1REV2eGFwYmFrT09raEZ4Q1ZnL0JsRUhBcHFjUlJ4RW9mT0NsSkJPMHJGQzNnRWo2QmtjZlFJZWhPUFVMKzN5OE9iN3lmSjB4QlBKcGppV2thd0Z3ODM4MTZkNmVLVnVlNVc0elJsOTJ1L1gwYktMU2VEVmdrcFB4MEtOMDBGMlhacmFkSkduV1phWTByWE5McTE0WiszMVpucUZ2bFJIY0FGZkVHanlFL0tNeWdGSUFiU29Ob0NoT0FHSGlBQnJzRWpiRVRZaUxBUktjdkVMdmdCMTZTNUFOekFCeVRBTTJrNEJHOGJEOWxVdTRNM3NHeHFTQkE0MUUzQXg4RmZnTVJSVmdnUHhNUWZ6Y0ZaT3dBQVwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaE1BQXdBUGNBQUFBQUFETXpNMlZsWlplWGw1aVltSm1abWFpb3FLdXJxN0N3c0x1N3U4TEN3c3JLeXM3T3pzL1B6OUxTMHRUVTFOWFYxZG5aMmVEZzRPSGg0ZVBqNCtUazVPYm01dWpvNk9ycTZ1dnI2Kzd1N3ZEdzhQTHk4dlB6OC9YMTlmYjI5dmYzOS9qNCtQbjUrZnI2K3Z2NysvejgvUDM5L2Y3Ky92Ly8vNUdSa1phV2xwcWFtazFOVFhSMGRJQ0FnSEp5Y3FtcHFkL2YzelEwTkRZMk5rTkRRMFJFUkVoSVNFbEpTVTlQVDFwYVdsdGJXM2w1ZVg5L2Y1dWJtNStmbjZDZ29LT2pvNlNrcEthbXBxZW5wN096czdTMHRMYTJ0cm01dWIrL3Y4SEJ3YzNOemREUTBOYlcxdGZYMTl6YzNPWGw1ZW5wNmUzdDdWTlRVeDBkSFNBZ0lDWW1Ka1ZGUlhwNmVuNStmb1NFaEpPVGs5SFIwVTVPVG9XRmhRRUJBUUlDQWdRRUJCUVVGQlVWRlJvYUdoc2JHeUlpSWlNakl5OHZMekF3TURFeE1USXlNbEZSVVZaV1ZsZFhWMlptWm1kbloyaG9hR3hzYkhGeGNYTnpjM1oyZG5oNGVIeDhmSWFHaG9lSGg0aUlpSldWbFo2ZW5xeXNyTEd4c2JlM3Q3aTR1THE2dXI2K3ZzUER3OFRFeE12THk4ek16TlBUMDlqWTJOcmEydHZiMjk3ZTN1TGk0dXpzN08vdjcvSHg4ZlQwOUV0TFMxSlNVcEtTa2g0ZUhpUWtKQ2NuSjBaR1JsUlVWSFYxZFh0N2UweE1USGQzZDd5OHZBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDSC9DMDVGVkZORFFWQkZNaTR3QXdFQUFBQWgvd3RKUTBOU1IwSkhNVEF4TWtnQUFBeElUR2x1YndJUUFBQnRiblJ5VWtkQ0lGaFpXaUFIemdBQ0FBa0FCZ0F4QUFCaFkzTndUVk5HVkFBQUFBQkpSVU1nYzFKSFFnQUFBQUFBQUFBQUFBQUFBUUFBOXRZQUlmOExTVU5EVWtkQ1J6RXdNVEpJQUFBTVNFeHBibThDRUFBQWJXNTBjbEpIUWlCWVdWb2dCODRBQWdBSkFBWUFNUUFBWVdOemNFMVRSbFFBQUFBQVNVVkRJSE5TUjBJQUFBQUFBQUFBQUFBQUFBRUFBUGJXQUNIL0MwbERRMUpIUWtjeE1ERXlTQUFBREVoTWFXNXZBaEFBQUcxdWRISlNSMElnV0ZsYUlBZk9BQUlBQ1FBR0FERUFBR0ZqYzNCTlUwWlVBQUFBQUVsRlF5QnpVa2RDQUFBQUFBQUFBQUFBQUFBQkFBRDIxZ0FoL3d0SlEwTlNSMEpITVRBeE1rZ0FBQXhJVEdsdWJ3SVFBQUJ0Ym5SeVVrZENJRmhaV2lBSHpnQUNBQWtBQmdBeEFBQmhZM053VFZOR1ZBQUFBQUJKUlVNZ2MxSkhRZ0FBQUFBQUFBQUFBQUFBQVFBQTl0WUFJZjhMU1VORFVrZENSekV3TVRKSUFBQU1TRXhwYm04Q0VBQUFiVzUwY2xKSFFpQllXVm9nQjg0QUFnQUpBQVlBTVFBQVlXTnpjRTFUUmxRQUFBQUFTVVZESUhOU1IwSUFBQUFBQUFBQUFBQUFBQUVBQVBiV0FDSC9DMGxEUTFKSFFrY3hNREV5U0FBQURFaE1hVzV2QWhBQUFHMXVkSEpTUjBJZ1dGbGFJQWZPQUFJQUNRQUdBREVBQUdGamMzQk5VMFpVQUFBQUFFbEZReUJ6VWtkQ0FBQUFBQUFBQUFBQUFBQUJBQUQyMWdBaC93dEpRME5TUjBKSE1UQXhNa2dBQUF4SVRHbHVid0lRQUFCdGJuUnlVa2RDSUZoWldpQUh6Z0FDQUFrQUJnQXhBQUJoWTNOd1RWTkdWQUFBQUFCSlJVTWdjMUpIUWdBQUFBQUFBQUFBQUFBQUFRQUE5dFlBSWY4TFNVTkRVa2RDUnpFd01USklBQUFNU0V4cGJtOENFQUFBYlc1MGNsSkhRaUJZV1ZvZ0I4NEFBZ0FKQUFZQU1RQUFZV056Y0UxVFJsUUFBQUFBU1VWRElITlNSMElBQUFBQUFBQUFBQUFBQUFFQUFQYldBQ0grTFUxaFpHVWdZbmtnUzNKaGMybHRhWEpoSUU1bGFtTm9aWFpoSUNoM2QzY3ViRzloWkdsdVptOHVibVYwS1FBaCtRUUVCUUQvQUN3QUFBQUFNQUF3QUFBSC80QW9nb09FaFlhSGlJbUtpNHlOam80bEpZK1RqVTFaVWxKWlRaU2Noa1ZWQUtFQVZVV2RwaENnb3FGVkVLYWNQS3FxUEs2SUp4c1VVQ09ESkRpeG9qZ2t0SVZSUFRrMk9Ec05KeWdqTEw2aExMckNnbEV2TWdIWUFUY0tnbGZQQUZmVGd6M1o1VG9ZS0ExVXZsUU40aWdiT3VYWk13bUNCbE9xVXdidktCUTI4N0w5RUhSQ1NRc3JWbG9vV2ZZT0NvNkEyQTRRT2hFaUJNTitKSFpBck1HazM2SUdOK2JKU0NISm95SUZPV1pnbzVHQ2cwbEdHQkw0T01BazJFdEVKa3pjYkFURnlBQVZSQ3pzVEFRQmk0Q2pBcTRzR1dvSWd3dWtTSzlVWUVyb0NGU29DS2dTN0hFVnFaYVNURTl3N1NyZ3ExWVVWc2xtUGV1MHE5U3pnck9LUWxVS2QxRFBuMEhyRnNxcE54R0lDUThpYUxnSTl3bUNGUU1JQUdGZzgyeUdJUU1pUjE3QmdQRFFFMGtrYXc2aTRld0hHSm9sRTRoUTZJUmxjUjJDaEpiOFlKQ0lDMDZjWEJEaGNRU0MxUU42VEJERTRjR0Mzd3NldU96bm9NQnFCQ0JRaUlBQUhEZ0UydTlFSURFdVdjZ1RRVkNhTjRmaVVjUVdCRUVNSk1rd0tJWjI0REZlanVqd2diRDU4d3ZTczRXL0FOM1pFVXpPTTVGMjFrTis0RXg0ME5jSUdVZ2dRUWI4OWFYZ2dsb0ZBZ0FoK1FRRkJRQXZBQ3dDQUFJQUp3QXJBQUFJL3dCUkNCeElzS0JCRXlZTUtseklzS0NFUFhUbzdKSFFzR0xGUVpFQ2FBd1FhWkRGandVVnJkbTRjWTBpa0NoWGtDUzU0b1hMbHpCanl2U1FZVU9KZ1NYbXJOdzQ1NlpBRVlzUU1UclJzSU9mTG5UczdEbUpvb1NjblJybDNEeWhnRTJaTVdoY1hGallvWUFiQVdBRjFJRWdVQVhVQUNvRTloa0RvQzBBTDF5Mkd2VHpOU3pZTzQ1UUlHS3hrd1VpRkJYU3VIWHJ4WVZCRDNmc2hvWERRR0FDU0NRaEpSQm9BTXhndDJvWUZjeEFSM0hZQkM4UHBZZ1RKOFdobDNrdXV4MlRxT0FHTzU3QkNvbzVZa1JNUFY1VUF6Q3pxS0NKUGJGYlVMQklTSXp1TmlNTUtxcWorQTJDaEJWSnRQaHltWXlDaFJDNndCSGdaZzRDRUNBMXROOElreHZNbVQ1RUZ6cGlBRWdRQmVnZ1J4RFNnOGRBaFlVbjBxUGNMNUREbGdTQU5MQUJmeWhaY0FBQkF3eEFnQUhERVZoUkIzd2tLT0VBQmpUaVlFT0dJRGhoZ29WY3lGQWdHMHI0QjN3ZUVnUmlpQU9NV0tKQkdhTFk0WW9GUVJoaWhUQWFaS0NHQ3paWVkwSCtBU2pnamd6bEIrUkhKWENBZ1FZaERGblFJeEVVc2dBaFcxeEE0bzRmR0xMQWxWY1dJdGVRRTJEcDVSWkpBa25DQTE1aVNZZ0dRNDdnUUpsWVlqQ2tDUkd3dVVBaEhDaUpBU0ZzUnVBVGtDWklnQ2VXaGp5aXBFQWxZSENJQXc5TUFONmdBNWt3QWdreE1TcnBwSlJXK2xGQUFDSDVCQVVGQUN3QUxBTUFBZ0FyQUNjQUFBai9BRkVJSEVpd1lNRVRKd3dxWE1pUUlZWWpQWG9jd2RDd29zV0JFSGdJMkNpQUI0U0xJQlZDMGNoeEl3OG9JVk1LTkZLeXBCR1ZDMGQwK0pCUW9Ja0JMVGtPTURGd0JCUUtHMnBhRk9FQVFSQURTVExZVkpGem93cWVKeHJzd0dFalI0OG9RNUVVR01CMWdKQW5Bb2swRlVCRW9JSWJBZElHa1BFQ2EwTUhXN3R5UlFBQ2hZVk1PVE5aUUlGQmg5cS9QUnFPUUNDM2E0OEpBcGZzS0xsamljQUVNLzZxMWJHQllZY2doYnMrR0ZnQmdTUkpDQ29NL0NGWnJRMEtERC9BeUR5QVFJU0NKVW9VUEZBNkxRNlVDMDhrWVIxRWcwVW1OV3J2SU5Fd3c1RENLeGdJWlZnaWhRekpOeHBZZklKZ1JXc2dESWhmNUpDQ1J0b1pPUlNBc1FReDRVRUVEY3N0a21oeXdFY0NpakRqR3h5aHZhRFBHREdnaUpCL1VMRW1MaDRSNUFFVEN4UzR3QU1jOERlUUFaTUE0Q0FBbEJRaDBBaE5HR2pnQS92eHAwU0REenBZU1JNb1pHQ2hoUmNvaUVtSEhYYUJnZ1FqR3VnRWZ5RllndUtEbDVUQVlvc0x2Q2hmakRNNldLT0lPSmJJMzRrOXFraGhpeGdxdU9HTUh3bzBvSVVJS2lnUWd4MUdTTkI5K1dVbzVRbitBZmlSbENIUkIrYVlaSlpwNXBsb3Bxbm1tbXkyNmVhYmNGNFVFQUFoK1FRRkJRQXBBQ3dEQUFJQUt3QW5BQUFJL3dCUkNCeElzS0RCZ3dnVEtqVFl3VkNnUUlZNkxKeEkwUUlmQWdNR0VPQmpnYUxIZ3h3T1pCdzU0QUNIanlnRmJzRklVdU9XbEFoTmpDQnhZdUNKQkMxSGNxb3BzTVNHREI1NFRpeUI0WkNEQnhOQUNMeVpNMk1Dbm9yMjJLSFR4WS9FaFNZa0VGckFkWUdoUndJYk5CM1FRQ0NFT2dMU0NuQlQ0R3BDREZ1N2NvMVFBc1VHR0RsaGJFRGg2STVhdFc3OEtEUVJRVzdYUWlkUlVEQkEwZ0FGZ1F6Zy9GVjd4MFBDRVE0TWQ4VXdzRkdoUDM4S05ScVlZTEphT2hrU2tuaWdlUUVoRFFWTm1DZ295SFJhTzNzVFRtaTlKY1JFQ2kxczc1bWQ4SU1odzRVdVVEU0I0TTNrT29vbVBvcFF5UFdXQzhRbmdrQXd4NDBBT0YwZ2VOVXN3UUdEQnQ4b1RWQVFCSWlCSTVqd0Q1YW9Hei9sQ1VSNjVMd29FS1AreHdTYUJDQmdBR3NNNHQ5RWh3UTRvSUJTU0hDZ1FwSXN1T0FlRHlJMFFod1NEcmhKZGhVT2RHR0dBbTdZb1VFUmdramhpQVVsbUdHREtCb0U0SUlGdG1qUWZmbnQxNStNQ00ySG80ZUU2SUdIQVJYc1NKQUdMWVRoQlFCZ25OR0hVREtTME1JWEFFUVpKUmtLQ0VtSUdGSm0yY1lJTytweFpKWlJtckhJam5tQUtlVVlpZXhvQUJobUFxQUdJenRXa0lhWlhyZ2dKQXA5akpHbEYxd29KK1FKQ3JCUnhoaG91T0RublNpSXNBZ2lqREJKVUVBQUlma0VCUVVBV3dBc0J3QURBQ2NBS3dBQUIvK0FLSUtEaElRakdSSVNHU09Galk2UGpSNU1DNVFMVEI2UW1ab2prNVdVVEl5YW9vVVlucDRZbzZtQ01hYVZNWVFuSHgyaHFvU3NyUXV2Z2hsSkJrRUlEaUsxZzFDNEMxQ0NUMElEekFNRlNNTERJaEN0RU1JZ0NNM05CUTdEZ2h3UG5nOGNnaE05MnMwSXRMVWlGMDVPRjlFb0Qrak5RUjNlZ3ljbmhSRUU5UU5nZk1nSFNVTVFnRW40RVhSMGdzRUtkRU15TElSRWdnR1FmeXNRUEptWTZZU0dDQThtZ09BNHpJUUprcG9zRUZFeHdBZ3lsSTJXWEJGQVV3QVdDREFKVlpoWms2WUxWRGxSSU9qWjgwalFFbHFJMXV5aEVDVlNwVFNaQmgwSzFXalFuVXAvQmhVa3MrZk5yWU5Vc25RSnRwQkpzQ1NZSFBDUkFDaFlEaW1oYUFRSU1DT0hBckFsVXNpWXkvZEdnNjFNYXZBZHZJTUV3Uk1oUWpSRmNXRHdZQnd2YTUxUTBzS0tsUlpLRlA1d3pOY0dCVzhHcGdBWURXQ0tBVUVKWm5BT29HUERzQVpVU0pPbThoZURqdFU5dkYyUkxmdUtJQVUzQnN0NEVXWFlDQmE4U2JOZ2RLTEJEaHcyY3ZRb1Bvd0VqdVNqY1JnV05BSUtoUTJMYS9IQURvREhWZ2hWa2xmQnViVklldEpWaXBSRjBTU0xGQ2xabXN3ZlZLTEV3a0FBSWZrRUJRVUFMd0FzQndBREFDY0FLd0FBQ1A4QVVRZ2NTTENnd1lNSUV5cGN5TENodzRjUUkwcGNlSUxFQ0JNVEg0S1k4TURCSVF3bE1pNThaR2lCeVFXRUpHQVVlYkJFaEpNbkNXRmdlWkJESVpnbkQ2MmtPUkFEenBNT1J2QWtxSUhRendVUFNBd2RHR0xMMFFsTENWNjRDZFBRaDZnRFRWellZclJRaEVkWUM0YlFnSUZEeUxBS1Q1eEFXM0JEQTBBSnRuQmdpNEtDQVFJREJoQTRZQUZ0SXdONUF3L2cweUZzSWNHQkNSakNhdUlQNHNDQkdEdCtQQ0F5MXNPUEZZZjkrNWd3V3J0NDlmS2w2eGF1WExvRDFTS3NZQUNQSGtKQ0g1cWdJQWdRQTBjSlQvUTVBd2FBbHpBdE5EZ0VnV0NPR3dGd3VrQkFxSUFNZ09mUHY3UlF1dEFFZ2pjQ3NtZXZvOGpnaURiUXc0dlpJY1NRUWd2dDZQZnNGTGpJVEhqb1h2UVFQREZpeE5xQmd0Q2p0N09oWUtJeDcwR1hoMEFuSEpKQ0hIR2tjTWg5Q2VpbkhSMFpGTVNJR2dFQ0FJWUJBaVVBU1FBY0JnQkpBZ0l4QUllREF0emhnVUV1ZUJGZ0doV2dnQWdMSFhiSUFpSW9PSEtIZzI3NGNkQUZYS2dJM1JoOUNLUkNqREdxSUJBRWRhRG5SZ0dGN2VnQ0dtT1V3WVlDYTVVZ0I1RWR5bkdXSW52WVFVY1hmalNKMEFtTUlMS0lDQU9WTUFlV0hNNXhGZ29sYkpDQkIvZEp0QUtiQWF3UWxpSnJZTGxHZDJFTkVrbU1rUXhDbHdSNzBFSEhIaEtnSnBBSjYwVVVFQUFoK1FRRkJRQXRBQ3dDQUFjQUt3QW5BQUFJL3dCUkNCeElzS0RCZ3dnVEtseklzS0hEaHhBalNweElzYUxGaXhnemF0eklzYVBIaGlSR2ZFUUlnUWNYRmp1V25NZ29Ba3FNR0ZCRURpeENDWUJOQUpNTVlPVHdZSUhQQlV3OENHeFM2ZWJOU1Vvc2l1ajUwMmNUa1YyTUdzVms4VUxUcGhsS1hKSjYwMUtJaWs2dS9wU2dsYXROcjJERitwU0FJcXBacWhXdHFzMkFnaWhYcEVxWk5uMHFrS2JSbkR2MUFoVTZzT1RKbENzeHRud1o4MkRJa1F3eEpQQnhvQWtKaUNjMFJIZ3dBWVJEQlRsbUJBaEFJd1VIaHlRWUFDRXdvQWVDSnd3YjNCaE5XMGFLRWd4UE1GZ3hvSGZ2SVhRVGt0aEJ1M2dOSmd3MUJQSE5QRW5pZzFCd0ZDOStvR0FKM0FRanNHYmVHOGFIaEJSc1RMR24vV05nQlFTU0pDR29NUEFCZDk5Qk9pVGNvR044Z0JrSkJDN1pJYUMvZ0pRQ1RkRERld01nSUJOQ1BkaW5Bd1lvV0pDSmYvNWxZZ0VLSUNEd1hnRU9MQlRGQ3pJVWQ0TUNBaEVCSVlSRUNQU0VFTXdWZ0lRSURFWFJRdzQyNExCREF5dVpvTUtJL3FsZ2drQVpKR0ZBRUFoc3dXSkRKMnhBUVdNQ21UQUFqdjBOc0tOQUozelF3WUVXR2NHa0FFWkFCZ1VQT1BJQUJXUW9sQVFoRHhDQUtSQUdSL1RRd3hFTW1qblFDYzlGRkJBQUlma0VCUVVBS1FBc0FnQUhBQ3NBSndBQUNQOEFVUWdjS1BBRUkwU0xSQkJjeUxDaHc0WVhYS0FaVTRhTmdoTVBNMm9rZUlHTEZ3QWdBWXpwczdIa1F4Y2ZRNEpNVThHa3k0R00xS2dNQ2NiQXk1ZUp4c3dNbWVlbXkwVm1kZ0x3b3NlbnlSRnRoSW9oWk5Ta0FqSXp2N1FnMGJUa2lUNW53QXdOMDBKRFZaY1ZET0RSUTJqRTE0MGxTcHg5R2FQQUN6bDZFR0ZjbTNIUW1nQjRBMmhLUVBlaEJDbDU4Mm82MUxmaG5zQ0JKUlZlYUdJVDRyeHh6QzRXMlBneDNzaVRCeDYyckRpendMK1BCM3NlYURmdzN0RUUyNzZOT3hmMXdMU3VNenBpQUVnUUJSTTNRMmpBd0VGdFNRaGQ0QWh3TXdjQkNKTW1MbXdodEtCUWhFY2JGZFVSUUozNkd3UzROMTRvdEtCN2QwTWZNcHJVMkZPOWZBc0tHME5zOGM1K1FzWU5kc3FYRjhRNCswQU56TmwzZjBEVllRWTY4bFhIbDBDTkZQTEhINFUwTWhBRytubm5nR1FOZVhCSGdBTEF3WUJBRkJnd3dJWURHSUFlQ2h4dzEyQUU5alhraHhzQjN1RUlDaHZBd0NHSE1HeUFRZ2tSTkVnSUJocDFVQUNLMWRVQmdVQU52UGhpQXdJOVlnaDdoRWhRb2tNZCtORUZIWGJzb1VoQkNRakpZUUp6Z1REQkF3NGNnb0Z2RzUzZ1FRWWJnSGxDbFZZT3dFbHJKNUF3d3BKTmJVR0FsUVJzZ1JvSEIxaDVBQWV1V2NESG5BTVF3SWNGc2FIUWdTR0JCR0pJQjRYU0ZSQUFPdz09XCI7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuXHJcbmltcG9ydCBpY29ucyBmcm9tICdzb3VyY2UvdXRpbC9pY29ucyc7XHJcbmltcG9ydCB7d2FybmluZ0Z1bmN9IGZyb20gJ3NvdXJjZS91dGlsL3V0aWxzJztcclxuaW1wb3J0IGNvbnN0cyBmcm9tICdzb3VyY2UvdXRpbC9jb25zdHMnO1xyXG5pbXBvcnQgRW52IGZyb20gJ3NvdXJjZS91dGlsL2Vudic7XHJcblxyXG5pbXBvcnQgYWpheCBmcm9tICdzb3VyY2UvdXRpbC9hamF4JztcclxuaW1wb3J0IGZzIGZyb20gJ3NvdXJjZS91dGlsL2ZpbGVzeXMnO1xyXG5cclxuaW1wb3J0IFwic291cmNlL3V0aWwvY2hyb25vXCI7XHJcbmltcG9ydCBcInNvdXJjZS91dGlsL2dlc3R1cmVcIjtcclxuaW1wb3J0IFwic291cmNlL3V0aWwvZGV2aWNlcmVhZHlcIjtcclxuaW1wb3J0IFwic291cmNlL3V0aWwvc2V0dGluZ3NcIjtcclxuaW1wb3J0IFwic291cmNlL3V0aWwvYXBpXCI7XHJcbmltcG9ydCBcInNvdXJjZS9jb21wb25lbnQvRGlhbG9nXCI7XHJcblxyXG5pbXBvcnQgdGhlbWUgZnJvbSAnc291cmNlL3V0aWwvdGhlbWUnO1xyXG5pbXBvcnQgQmFja2dyb3VuZEltYWdlIGZyb20gJ3NvdXJjZS9jb21wb25lbnQvQmFja2dyb3VuZEltYWdlJztcclxuaW1wb3J0IEJ1dHRvbiBmcm9tICdzb3VyY2UvY29tcG9uZW50L0J1dHRvbic7XHJcbmltcG9ydCBDYXJkIGZyb20gJ3NvdXJjZS9jb21wb25lbnQvQ2FyZCc7XHJcbmltcG9ydCB7Q2VudGVyQ29udGVudCwgQWxpZ25Db250ZW50fSBmcm9tICdzb3VyY2UvY29tcG9uZW50L0NvbnRlbnRBbGlnbmVycyc7XHJcbmltcG9ydCBDaGVja2JveCBmcm9tICdzb3VyY2UvY29tcG9uZW50L0NoZWNrYm94JztcclxuaW1wb3J0IEN1c3RvbUV2ZW50cyBmcm9tIFwic291cmNlL2NvbXBvbmVudC9DdXN0b21FdmVudHNcIjtcclxuaW1wb3J0IEZvcm0gZnJvbSAnc291cmNlL2NvbXBvbmVudC9Gb3JtJztcclxuaW1wb3J0IEdyaWQgZnJvbSAnc291cmNlL2NvbXBvbmVudC9HcmlkJztcclxuaW1wb3J0IHtJY29uLCBJY29uQnV0dG9ufSBmcm9tICdzb3VyY2UvY29tcG9uZW50L0ljb24nO1xyXG5pbXBvcnQgSW1hZ2UgZnJvbSAnc291cmNlL2NvbXBvbmVudC9JbWFnZSc7XHJcbmltcG9ydCBJbnB1dCBmcm9tICdzb3VyY2UvY29tcG9uZW50L0lucHV0JztcclxuaW1wb3J0IFBpbmJvYXJkIGZyb20gJ3NvdXJjZS9jb21wb25lbnQvUGluYm9hcmQnO1xyXG5pbXBvcnQgUHJvZ3Jlc3MgZnJvbSAnc291cmNlL2NvbXBvbmVudC9Qcm9ncmVzcyc7XHJcbmltcG9ydCBTY3JlZW4gZnJvbSAnc291cmNlL2NvbXBvbmVudC9TY3JlZW4nO1xyXG5pbXBvcnQgU2xpZGVyIGZyb20gJ3NvdXJjZS9jb21wb25lbnQvU2xpZGVyJztcclxuaW1wb3J0IFNwaW5uZXIgZnJvbSAnc291cmNlL2NvbXBvbmVudC9TcGlubmVyJztcclxuaW1wb3J0IFRhYnMgZnJvbSAnc291cmNlL2NvbXBvbmVudC9UYWJzJztcclxuaW1wb3J0IFRvZ2dsZSBmcm9tICdzb3VyY2UvY29tcG9uZW50L1RvZ2dsZSc7XHJcblxyXG5pbXBvcnQge0NTU30gZnJvbSAnc291cmNlL3V0aWwvc3R5bGVzaGVldCc7XHJcbmltcG9ydCBjb21wb25lbnRTdHlsZVNoZWV0IGZyb20gJ3NvdXJjZS91dGlsL2FwcCc7XHJcblxyXG53aW5kb3cuRG9yaWMgPSB7XHJcbiAgICBCYWNrZ3JvdW5kSW1hZ2UsXHJcbiAgICBCdXR0b24sXHJcbiAgICBDYXJkLFxyXG4gICAgQ2VudGVyQ29udGVudCxcclxuICAgIEFsaWduQ29udGVudCxcclxuICAgIENoZWNrYm94LFxyXG4gICAgQ3VzdG9tRXZlbnRzLFxyXG4gICAgRm9ybSxcclxuICAgIEdyaWQsXHJcbiAgICBJY29uLFxyXG4gICAgSWNvbkJ1dHRvbixcclxuICAgIEltYWdlLFxyXG4gICAgSW5wdXQsXHJcbiAgICBQaW5ib2FyZCxcclxuICAgIFByb2dyZXNzLFxyXG4gICAgU2NyZWVuLFxyXG4gICAgU2xpZGVyLFxyXG4gICAgU3Bpbm5lcixcclxuICAgIFRhYnMsXHJcbiAgICBUb2dnbGVcclxufTtcclxud2luZG93LlJlYWN0ID0gUmVhY3Q7XHJcbndpbmRvdy5SZWFjdERPTSA9IFJlYWN0RE9NO1xyXG53aW5kb3cuRG9yaWNVdGlsID0ge1xyXG4gICAgQ1NTLFxyXG4gICAgd2FybmluZ0Z1bmMsXHJcbiAgICBFbnZcclxufTtcclxuXHJcbndpbmRvdy5hamF4ID0gYWpheDtcclxud2luZG93LmZzID0gZnM7XHJcblxyXG5NYXRoLnJhbmQgPSAoYSwgYiA9IG51bGwpID0+IHtcclxuICAgIGlmIChiID09PSBudWxsKSB7XHJcbiAgICAgICAgYiA9IGE7XHJcbiAgICAgICAgYSA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGIgLSBhICsgMSkpICsgYTtcclxufTtcclxuXHJcbndpbmRvdy5jYmxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XHJcbndpbmRvdy5jYmVyciA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcclxuIiwiY29uc3QgYWpheCA9ICh1cmwsIG9wdGlvbnMgPSB7fSkgPT4gbmV3IFByb21pc2UoXHJcbiAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBoZWFkZXJzID0ge30sXHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSAwLFxyXG4gICAgICAgICAgICB0eXBlID0gbnVsbCxcclxuICAgICAgICAgICAgb25Qcm9ncmVzcyA9ICgpID0+IHt9LFxyXG4gICAgICAgICAgICB0b2tlbiA9IG51bGxcclxuICAgICAgICB9ID0gb3B0aW9ucztcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgbGV0IHtwb3N0ID0gbnVsbH0gPSBvcHRpb25zO1xyXG5cclxuICAgICAgICBsZXQgY29udGVudFR5cGUgPSBudWxsO1xyXG4gICAgICAgIGxldCBtZXRob2Q7XHJcblxyXG4gICAgICAgIGlmICh0b2tlbiAhPT0gbnVsbCAmJiB0b2tlbi51c2VkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0b2tlbi5iaW5kVG8ocmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocG9zdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtZXRob2QgPSBcIlBPU1RcIjtcclxuICAgICAgICAgICAgaWYgKEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHBvc3QpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcG9zdCA9IEpTT04uc3RyaW5naWZ5KHBvc3QpO1xyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0eXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgICAnbG9hZCcsXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCB8fCAocmVxdWVzdC5zdGF0dXMgPj0gMjAwICYmIHJlcXVlc3Quc3RhdHVzIDwgMzAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXF1ZXN0LnJlc3BvbnNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcclxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0aW1lb3V0XCIsIHJlamVjdCk7XHJcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4gcmVzb2x2ZShudWxsKSk7XHJcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgb25Qcm9ncmVzcyk7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QudGltZW91dCA9IHRpbWVvdXQ7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2hlYWRlciwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiXCIpO1xyXG4gICAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCIqLypcIik7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXF1ZXN0LnNlbmQocG9zdCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG5hamF4LmNhbmNlbFRva2VuID0gKCkgPT4ge1xyXG4gICAgbGV0IHJlcXVlc3QgPSBudWxsO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2FuY2VsKCkge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgdXNlZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QgIT09IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBiaW5kVG8ocmVxKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gcmVxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFqYXg7XHJcbiIsImltcG9ydCBcInNvdXJjZS91dGlsL2FwcFwiO1xyXG5cclxuQXBwLkFQSSA9IGJhc2VVUkwgPT4gKHtcclxuICAgIHJlcXVlc3Q6ICh1cmwsIG9wdGlvbnMpID0+IGFqYXgoYCR7YmFzZVVSTH0ke3VybH1gLCBvcHRpb25zKSxcclxuICAgIGFzeW5jIHJlcXVlc3RKU09OKHVybCwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFqYXgoYCR7YmFzZVVSTH0ke3VybH1gLCBvcHRpb25zKTtcclxuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXN1bHQucmVzcG9uc2UpO1xyXG4gICAgfSxcclxuICAgIGdldFVSTDogdXJsID0+IGAke2Jhc2VVUkx9JHt1cmx9YFxyXG59KTtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XHJcbmltcG9ydCB7Um91dGVyLCBSb3V0ZSwgaGFzaEhpc3Rvcnl9IGZyb20gJ3JlYWN0LXJvdXRlcic7XHJcblxyXG5pbXBvcnQge2NyZWF0ZVN0eWxlU2hlZXQsIGdlbkNTU30gZnJvbSAnc291cmNlL3V0aWwvc3R5bGVzaGVldCc7XHJcblxyXG5pbXBvcnQgUm9ib3RvRm9udCBmcm9tICdzb3VyY2UvZGF0YS11cmkvcm9ib3RvLWxpZ2h0LndvZmYuc291cmNlJztcclxuaW1wb3J0IElvbmljRm9udCBmcm9tICdzb3VyY2UvZGF0YS11cmkvaW9uaWNvbnMud29mZi5zb3VyY2UnO1xyXG5cclxuaW1wb3J0IFwic291cmNlL3V0aWwvZGV2aWNlcmVhZHlcIjtcclxuXHJcbmNvbnN0IGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaGVhZFwiKTtcclxuY29uc3Qgcm9ib3RvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5jb25zdCBhcHBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuY29uc3QgZm9udHMgPSBuZXcgU2V0KCk7XHJcblxyXG5jb25zdCBjb21wb25lbnRTdHlsZVNoZWV0ID0gY3JlYXRlU3R5bGVTaGVldCgpO1xyXG5sZXQgaW5pdENhbGxlZCA9IGZhbHNlO1xyXG5sZXQgcm91dGVzID0gPFJvdXRlIHBhdGg9XCIvXCIgY29tcG9uZW50PXsoKSA9PiA8ZGl2PlJlYWR5ITwvZGl2Pn0gLz47XHJcbmxldCByb3V0ZXJDb21wb25lbnQ7XHJcblxyXG5yb2JvdG8uc2V0QXR0cmlidXRlKFwiZGF0YS1uYW1lXCIsIFwiZG9yaWMtY29yZS1zdHlsZVwiKTtcclxuaGVhZC5hcHBlbmRDaGlsZChyb2JvdG8pO1xyXG5cclxuYXBwU3R5bGUuc2V0QXR0cmlidXRlKFwiZGF0YS1uYW1lXCIsIFwiZG9yaWMtYXBwLXN0eWxlXCIpO1xyXG5oZWFkLmFwcGVuZENoaWxkKGFwcFN0eWxlKTtcclxuXHJcbmNvbnN0IGluaXRpYWxpemUgPSBhc3luYyAoKSA9PiB7XHJcbiAgICBpZiAoaW5pdENhbGxlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpbml0Q2FsbGVkID0gdHJ1ZTtcclxuICAgIGF3YWl0IGRldmljZVJlYWR5O1xyXG5cclxuICAgIGNvbnN0IHdyYXBwZXIgPSAoXHJcbiAgICAgICAgPFJvdXRlciBoaXN0b3J5PXtoYXNoSGlzdG9yeX0+XHJcbiAgICAgICAgICAgIDxSb3V0ZSBnZXRDaGlsZFJvdXRlcz17KGxvY2F0aW9uLCBsb2FkKSA9PiBsb2FkKG51bGwsIHJvdXRlcyl9IC8+XHJcbiAgICAgICAgPC9Sb3V0ZXI+XHJcbiAgICApO1xyXG4gICAgZG9jdW1lbnQuYm9keS5pbm5lckhUTUwgPSBgPGRpdiBpZD1cImFwcC1jb250YWluZXJcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwcHg7IGxlZnQ6IDBweDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgb3ZlcmZsb3c6IGhpZGRlblwiPjwvZGl2PmA7XHJcbiAgICBjb21wb25lbnRTdHlsZVNoZWV0Ll9faW5pdChyb2JvdG8pO1xyXG4gICAgcm91dGVyQ29tcG9uZW50ID0gUmVhY3RET00ucmVuZGVyKFxyXG4gICAgICAgIHdyYXBwZXIsXHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNhcHAtY29udGFpbmVyXCIpXHJcbiAgICApO1xyXG59O1xyXG5jb25zdCBuYXZSZXBsYWNlID0gdXJsID0+IHJvdXRlckNvbXBvbmVudC5yb3V0ZXIucmVwbGFjZSh1cmwpO1xyXG5jb25zdCBuYXZQdXNoID0gdXJsID0+IHJvdXRlckNvbXBvbmVudC5yb3V0ZXIucHVzaCh1cmwpO1xyXG5jb25zdCBuYXZQb3AgPSAoKSA9PiByb3V0ZXJDb21wb25lbnQucm91dGVyLmdvQmFjaygpO1xyXG5cclxud2luZG93LlJvdXRlID0gUm91dGU7XHJcbndpbmRvdy5BcHAgPSB7XHJcbiAgICBhc3luYyBzdGFydChhcHBSb3V0ZXMpIHtcclxuICAgICAgICBhd2FpdCBpbml0aWFsaXplKCk7XHJcbiAgICAgICAgcm91dGVzID0gYXBwUm91dGVzO1xyXG4gICAgICAgIG5hdlJlcGxhY2UoXCIvXCIpO1xyXG4gICAgICAgIEFwcC5zdHlsZVNoZWV0Ll9faW5pdChhcHBTdHlsZSk7XHJcbiAgICAgICAgQXBwLnN0eWxlU2hlZXQgPSBjcmVhdGVTdHlsZVNoZWV0KCk7XHJcbiAgICB9LFxyXG4gICAgYWRkRm9udChuYW1lLCBkZWYpIHtcclxuICAgICAgICBpZiAoZm9udHMuaGFzKG5hbWUpID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHJcbiAgICAgICAgZm9udHMuYWRkKG5hbWUpO1xyXG4gICAgICAgIGVsZW0uZGF0YXNldC5mb250TmFtZSA9IG5hbWU7XHJcbiAgICAgICAgZWxlbS5pbm5lckhUTUwgPSBnZW5DU1Moe1wiQGZvbnQtZmFjZVwiOiBkZWZ9KTtcclxuXHJcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChlbGVtKTtcclxuICAgIH0sXHJcbiAgICBzdHlsZVNoZWV0OiBjcmVhdGVTdHlsZVNoZWV0KCksXHJcbiAgICBuYXY6IHtcclxuICAgICAgICBwdXNoOiBuYXZQdXNoLFxyXG4gICAgICAgIHBvcDogbmF2UG9wLFxyXG4gICAgICAgIHJlcGxhY2U6IG5hdlJlcGxhY2VcclxuICAgIH1cclxufTtcclxuXHJcbmNvbXBvbmVudFN0eWxlU2hlZXQuYWRkU3R5bGVzKHtcclxuICAgIFwiKlwiOiB7XHJcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcclxuICAgIH0sXHJcbiAgICBcImh0bWwsIGJvZHlcIjoge1xyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICBtYXJnaW46IDBcclxuICAgIH0sXHJcbiAgICBib2R5OiB7XHJcbiAgICAgICAgZm9udEZhbWlseTogXCJSb2JvdG9cIixcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjVmNWY1J1xyXG4gICAgfVxyXG59KTtcclxuQXBwLmFkZEZvbnQoJ3JvYm90bycsIHtcclxuICAgIGZvbnRGYW1pbHk6IGBcIlJvYm90b1wiYCxcclxuICAgIHNyYzogYHVybChcIiR7Um9ib3RvRm9udH1cIikgZm9ybWF0KFwid29mZlwiKWAsXHJcbiAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxyXG4gICAgZm9udFN0eWxlOiBcIm5vcm1hbFwiXHJcbn0pO1xyXG5BcHAuYWRkRm9udCgnaW9uaWMnLCB7XHJcbiAgICBmb250RmFtaWx5OiBgXCJJb25pY1wiYCxcclxuICAgIHNyYzogYHVybChcIiR7SW9uaWNGb250fVwiKSBmb3JtYXQoXCJ3b2ZmXCIpYCxcclxuICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXHJcbiAgICBmb250U3R5bGU6IFwibm9ybWFsXCJcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnRTdHlsZVNoZWV0O1xyXG4iLCJpbXBvcnQgcmVnZXggZnJvbSAneHJlZ2V4cCc7XHJcblxyXG5jb25zdCBjaHJvbm9TcGVjaWFsID0ge1xyXG4gICAgJ3llc3RlcmRheScoZGF0ZSkge1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIDEpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgICcxIHdlZWsgYWdvJyhkYXRlKSB7XHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gNyk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGNocm9ub1VuaXRSZWdleCA9IHJlZ2V4KFwiKD88b2Zmc2V0PihcXFxcK3xcXFxcLSlcXFxcZCspICg/PHVuaXQ+XFxcXHcrKVwiKTtcclxuY29uc3QgdW5pdEZ1bmN0aW9uID0ge1xyXG4gICAgbWlsbGlzZWNvbmQoZGF0ZSwgbWlsbGlzZWNvbmRzKSB7XHJcbiAgICAgICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIG1pbGxpc2Vjb25kcyk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgc2Vjb25kKGRhdGUsIHNlY29uZHMpIHtcclxuICAgICAgICBkYXRlLnNldFNlY29uZHMoZGF0ZS5nZXRTZWNvbmRzKCkgKyBzZWNvbmRzKTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0sXHJcbiAgICBtaW51dGUoZGF0ZSwgbWludXRlcykge1xyXG4gICAgICAgIGRhdGUuc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSArIG1pbnV0ZXMpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIGhvdXIoZGF0ZSwgaG91cnMpIHtcclxuICAgICAgICBkYXRlLnNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSArIGhvdXJzKTtcclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0sXHJcbiAgICBkYXkoZGF0ZSwgZGF5cykge1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIGRheXMpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIHdlZWsoZGF0ZSwgd2Vla3MpIHtcclxuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyB3ZWVrcyAqIDcpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIG1vbnRoKGRhdGUsIG1vbnRocykge1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkID0gZGF0ZS5nZXRNb250aCgpICsgbW9udGhzO1xyXG4gICAgICAgIGRhdGUuc2V0TW9udGgoZXhwZWN0ZWQpO1xyXG4gICAgICAgIGlmIChkYXRlLmdldE1vbnRoKCkgIT09IGV4cGVjdGVkKSB7XHJcbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZSgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9LFxyXG4gICAgeWVhcihkYXRlLCB5ZWFycykge1xyXG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgeWVhcnMpO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSxcclxuICAgIGRlY2FkZShkYXRlLCBkZWNhZGVzKSB7XHJcbiAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBkZWNhZGVzICogMTApO1xyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBzdGFydE9mID0ge1xyXG4gICAgc2Vjb25kKGRhdGUpIHtcclxuICAgICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcclxuICAgIH0sXHJcbiAgICBtaW51dGUoZGF0ZSkge1xyXG4gICAgICAgIHN0YXJ0T2Yuc2Vjb25kKGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0U2Vjb25kcygwKTtcclxuICAgIH0sXHJcbiAgICBob3VyKGRhdGUpIHtcclxuICAgICAgICBzdGFydE9mLm1pbnV0ZShkYXRlKTtcclxuICAgICAgICBkYXRlLnNldE1pbnV0ZXMoMCk7XHJcbiAgICB9LFxyXG4gICAgZGF5KGRhdGUpIHtcclxuICAgICAgICBzdGFydE9mLmhvdXIoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRIb3VycygwKTtcclxuICAgIH0sXHJcbiAgICB3ZWVrKGRhdGUpIHtcclxuICAgICAgICBzdGFydE9mLmRheShkYXRlKTtcclxuICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBkYXRlLmdldERheSgpKTtcclxuICAgIH0sXHJcbiAgICBtb250aChkYXRlKSB7XHJcbiAgICAgICAgc3RhcnRPZi5kYXkoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXREYXRlKDEpO1xyXG4gICAgfSxcclxuICAgIHllYXIoZGF0ZSkge1xyXG4gICAgICAgIHN0YXJ0T2YubW9udGgoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRNb250aCgwKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZW5kT2YgPSB7XHJcbiAgICBzZWNvbmQoZGF0ZSkge1xyXG4gICAgICAgIGRhdGUuc2V0TWlsbGlzZWNvbmRzKDk5OSk7XHJcbiAgICB9LFxyXG4gICAgbWludXRlKGRhdGUpIHtcclxuICAgICAgICBlbmRPZi5zZWNvbmQoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRTZWNvbmRzKDU5KTtcclxuICAgIH0sXHJcbiAgICBob3VyKGRhdGUpIHtcclxuICAgICAgICBlbmRPZi5taW51dGUoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRNaW51dGVzKDU5KTtcclxuICAgIH0sXHJcbiAgICBkYXkoZGF0ZSkge1xyXG4gICAgICAgIGVuZE9mLmhvdXIoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRIb3VycygyMyk7XHJcbiAgICB9LFxyXG4gICAgd2VlayhkYXRlKSB7XHJcbiAgICAgICAgZW5kT2YuZGF5KGRhdGUpO1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArICg2IC0gZGF0ZS5nZXREYXkoKSkpO1xyXG4gICAgfSxcclxuICAgIG1vbnRoKGRhdGUpIHtcclxuICAgICAgICBlbmRPZi5kYXkoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyAxKTtcclxuICAgICAgICBkYXRlLnNldERhdGUoMCk7XHJcbiAgICB9LFxyXG4gICAgeWVhcihkYXRlKSB7XHJcbiAgICAgICAgZW5kT2YubW9udGgoZGF0ZSk7XHJcbiAgICAgICAgZGF0ZS5zZXRNb250aCgxMSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHVuaXRDb252ZXJzaW9uID0ge1xyXG4gICAgJ21pbGxpc2Vjb25kJzogJ21pbGxpc2Vjb25kJyxcclxuICAgICdtaWxsaXNlY29uZHMnOiAnbWlsbGlzZWNvbmQnLFxyXG4gICAgJ21zJzogJ21pbGxpc2Vjb25kJyxcclxuXHJcbiAgICAnc2Vjb25kJzogJ3NlY29uZCcsXHJcbiAgICAnc2Vjb25kcyc6ICdzZWNvbmQnLFxyXG4gICAgJ3MnOiAnc2Vjb25kJyxcclxuXHJcbiAgICAnbWludXRlJzogJ21pbnV0ZScsXHJcbiAgICAnbWludXRlcyc6ICdtaW51dGUnLFxyXG4gICAgJ21pbic6ICdtaW51dGUnLFxyXG5cclxuICAgICdob3VyJzogJ2hvdXInLFxyXG4gICAgJ2hvdXJzJzogJ2hvdXInLFxyXG4gICAgJ2hyJzogJ2hvdXInLFxyXG5cclxuICAgICdkYXknOiAnZGF5JyxcclxuICAgICdkYXlzJzogJ2RheScsXHJcbiAgICAnbmknOiAnZGF5JyxcclxuICAgICdoaSc6ICdkYXknLFxyXG4gICAgJ+aXpSc6ICdkYXknLFxyXG5cclxuICAgICd3ZWVrJzogJ3dlZWsnLFxyXG4gICAgJ3dlZWtzJzogJ3dlZWsnLFxyXG4gICAgJ3NodXUnOiAnd2VlaycsXHJcbiAgICAn44GX44KF44GGJzogJ3dlZWsnLFxyXG4gICAgJ+mAsSc6ICd3ZWVrJyxcclxuXHJcbiAgICAnbW9udGgnOiAnbW9udGgnLFxyXG4gICAgJ21vbnRocyc6ICdtb250aCcsXHJcblxyXG4gICAgJ3llYXInOiAneWVhcicsXHJcbiAgICAneWVhcnMnOiAneWVhcicsXHJcblxyXG4gICAgJ2RlY2FkZSc6ICdkZWNhZGUnLFxyXG4gICAgJ2RlY2FkZXMnOiAnZGVjYWRlJ1xyXG59O1xyXG5jb25zdCBjaHJvbm9JbmZvID0ge1xyXG4gICAgZGF5czogW1xyXG4gICAgICAgICdTdW5kYXknLFxyXG4gICAgICAgICdNb25kYXknLFxyXG4gICAgICAgICdUdWVzZGF5JyxcclxuICAgICAgICAnV2VkbmVzZGF5JyxcclxuICAgICAgICAnVGh1cnNkYXknLFxyXG4gICAgICAgICdGcmlkYXknLFxyXG4gICAgICAgICdTYXR1cmRheSdcclxuICAgIF0sXHJcbiAgICBtb250aHM6IFtcclxuICAgICAgICAnSmFudWFyeScsXHJcbiAgICAgICAgJ0ZlYnJ1YXJ5JyxcclxuICAgICAgICAnTWFyY2gnLFxyXG4gICAgICAgICdBcHJpbCcsXHJcbiAgICAgICAgJ01heScsXHJcbiAgICAgICAgJ0p1bmUnLFxyXG4gICAgICAgICdKdWx5JyxcclxuICAgICAgICAnQXVndXN0JyxcclxuICAgICAgICAnU2VwdGVtYmVyJyxcclxuICAgICAgICAnT2N0b2JlcicsXHJcbiAgICAgICAgJ05vdmVtYmVyJyxcclxuICAgICAgICAnRGVjZW1iZXInXHJcbiAgICBdXHJcbn07XHJcbmNvbnN0IGNocm9ub0Zvcm1hdCA9IHtcclxuICAgIG1zOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiBkYXRlLmdldE1pbGxpc2Vjb25kcygpLFxyXG4gICAgICAgIHBhZGRlZDogZGF0ZSA9PiBgMDAke2RhdGUuZ2V0TWlsbGlzZWNvbmRzKCl9YC5zbGljZSgtMylcclxuICAgIH0sXHJcbiAgICBzZWNvbmQ6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IGRhdGUuZ2V0U2Vjb25kcygpLFxyXG4gICAgICAgIHBhZGRlZDogZGF0ZSA9PiBgMCR7ZGF0ZS5nZXRTZWNvbmRzKCl9YC5zbGljZSgtMilcclxuICAgIH0sXHJcbiAgICBtaW51dGU6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IGRhdGUuZ2V0TWludXRlcygpLFxyXG4gICAgICAgIHBhZGRlZDogZGF0ZSA9PiBgMCR7ZGF0ZS5nZXRNaW51dGVzKCl9YC5zbGljZSgtMilcclxuICAgIH0sXHJcbiAgICBob3VyOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiBkYXRlLmdldEhvdXJzKCksXHJcbiAgICAgICAgcGFkZGVkOiBkYXRlID0+IGAwJHtkYXRlLmdldEhvdXJzKCl9YC5zbGljZSgtMiksXHJcbiAgICAgICAgXCIxMlwiOiBkYXRlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaG91ciA9IGRhdGUuZ2V0SG91cnMoKSAlIDEyO1xyXG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIjEycGFkZGVkXCI6IGRhdGUgPT4gYDAke2Nocm9ub0Zvcm1hdC5ob3VyWycxMiddKGRhdGUpfWAuc2xpY2UoLTIpXHJcbiAgICB9LFxyXG4gICAgd2Vla2RheToge1xyXG4gICAgICAgIGJhc2U6IGRhdGUgPT4gZGF0ZS5nZXREYXkoKSxcclxuICAgICAgICBzaG9ydDogZGF0ZSA9PiBjaHJvbm9JbmZvLmRheXNbZGF0ZS5nZXREYXkoKV0uc2xpY2UoMCwgMyksXHJcbiAgICAgICAgZnVsbDogZGF0ZSA9PiBjaHJvbm9JbmZvLmRheXNbZGF0ZS5nZXREYXkoKV1cclxuICAgIH0sXHJcbiAgICBkYXRlOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiBkYXRlLmdldERhdGUoKSxcclxuICAgICAgICBwYWRkZWQ6IGRhdGUgPT4gYDAke2RhdGUuZ2V0RGF0ZSgpfWAuc2xpY2UoLTIpXHJcbiAgICB9LFxyXG4gICAgbW9udGg6IHtcclxuICAgICAgICBiYXNlOiBkYXRlID0+IGRhdGUuZ2V0TW9udGgoKSArIDEsXHJcbiAgICAgICAgc2hvcnQ6IGRhdGUgPT4gY2hyb25vSW5mby5tb250aHNbZGF0ZS5nZXREYXRlKCldLnNsaWNlKDAsIDMpLFxyXG4gICAgICAgIGZ1bGw6IGRhdGUgPT4gY2hyb25vSW5mby5tb250aHNbZGF0ZS5nZXREYXRlKCldXHJcbiAgICB9LFxyXG4gICAgeWVhcjoge1xyXG4gICAgICAgIGJhc2U6IGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpICUgMTAwLFxyXG4gICAgICAgIGZ1bGw6IGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpXHJcbiAgICB9LFxyXG4gICAgdG9kOiB7XHJcbiAgICAgICAgYmFzZTogZGF0ZSA9PiAoZGF0ZS5nZXRIb3VycygpIDwgMTIgPT09IHRydWUpID8gXCJBTVwiIDogXCJQTVwiXHJcbiAgICB9XHJcbn07XHJcbmNocm9ub0Zvcm1hdC5kYXkgPSBjaHJvbm9Gb3JtYXQuZGF0ZTtcclxuY29uc3QgY2hyb25vQ2hlY2tVbml0ID0gdW5pdCA9PiB7XHJcbiAgICBpZiAodW5pdENvbnZlcnNpb24uaGFzT3duUHJvcGVydHkodW5pdCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgdW5pdDogJHt1bml0fWApO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyogLUF4ZWxEb2MtXHJcbm1vZHVsZSBnbG9iYWwge1xyXG4gICAgQGZ1bmN0aW9uIGNocm9ubyB7XHJcbiAgICAgICAgQGRlc2MgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB7Y2hyb25vfS5cclxuICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgIEBhcmcgZGF0ZVRpbWUgW0RhdGVdXHJcbiAgICAgICAgICAgICAgICBUaGlzIGlzIHNvbWUgbG9uZyBkZXNjcmlwdGlvbiBvZiB0aGUgdGhpbmdcclxuICAgICAgICAgICAgICAgIHt5ZWFyLCBtb250aH0gZGVzdHJ1Y3R1cmluZz9cclxuICAgICAgICAgICAgICAgIFt0aXRsZV15ZWFyW3RpdGxlXVxyXG4gICAgICAgIH1cclxuICAgICAgICBAcmV0dXJuIGNocm9ub1xyXG5cclxuICAgICAgICBAZnVuY3Rpb24gZGlmZiB7XHJcbiAgICAgICAgICAgIEBkZXNjIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGN1bGF0ZSB0aGUgYW1vdW50IG9mIHRpbWUgdG8gYWRkIHRvIHRoZSBmaXJzdCBhcmd1bWVudCBpbiBvcmRlciB0byBnZXQgdGhlIHNlY29uZCBhcmd1bWVudC5cclxuICAgICAgICAgICAgQGFyZ3Mge1xyXG4gICAgICAgICAgICAgICAgQGFyZyBzdGFydERhdGUgW2Nocm9ub10gVGhlIGRhdGUgdG8gc3RhcnQgZnJvbS5cclxuICAgICAgICAgICAgICAgIEBhcmcgdGFyZ2V0RGF0ZSBbY2hyb25vXSBUaGUgZGF0ZSB0byBnZXQgdG8uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQHJldHVybiBvYmplY3RcclxuICAgICAgICB9XHJcbiAgICAgICAgQGZ1bmN0aW9uIG5vdyB7XHJcbiAgICAgICAgICAgIEBkZXNjIFJldHVybnMgdGhlIGN1cnJlbnQgZGF0ZSBhcyBhIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEBhcmdzIHt9XHJcbiAgICAgICAgICAgIEByZXR1cm4gY2hyb25vXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBmdW5jdGlvbiBwYXJzZSB7XHJcbiAgICAgICAgICAgIEBkZXNjIFBhcnNlcyBhIGRhdGUgc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBjaHJvbm8gb2JqZWN0IHJlcHJlc2VudGVkIGJ5IGl0LlxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIGRhdGVTdHJpbmcgW3N0cmluZ10gVGhlIHN0cmluZyB0byBwYXJzZS5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAcmV0dXJuIGNocm9ub1xyXG4gICAgICAgIH1cclxuICAgICAgICBAZnVuY3Rpb24gcGFyc2VNUyB7XHJcbiAgICAgICAgICAgIEBkZXNjIFBhcnNlcyBhIGRhdGUgc3RyaW5nIGdlbmVyYXRlZCBieSBDIyBjb2RlIGFuZCByZXR1cm5zIHRoZSBjaHJvbm8gb2JqZWN0IHJlcHJlc2VudGVkIGJ5IGl0LlxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIGRhdGVTdHJpbmcgW3N0cmluZ10gVGhlIHN0cmluZyB0byBwYXJzZS5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAcmV0dXJuIGNocm9ub1xyXG4gICAgICAgIH1cclxuICAgICAgICBAZnVuY3Rpb24gdHJpZ2dlciB7XHJcbiAgICAgICAgICAgIEBkZXNjIEZpcmVzIGEgZnVuY3Rpb24gYWZ0ZXIgYSBzcGVjaWZpZWQgdGltZS5cclxuICAgICAgICAgICAgQGFyZ3Mge1xyXG4gICAgICAgICAgICAgICAgQGFyZyBkZWxheSBbbnVtYmVyXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0LlxyXG4gICAgICAgICAgICAgICAgQGFyZyBmdW5jIFtmdW5jdGlvbl0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQHJldHVybiBjaHJvbm9UcmlnZ2VyXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9iamVjdCBjaHJvbm8ge1xyXG4gICAgICAgIEBwcm9wIGRhdGVPYmplY3Qge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgRGF0ZSBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIERhdGVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEBwcm9wIHVuaXhUaW1lc3RhbXAge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSB1bml4IHRpbWVzdGFtcCBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBAcHJvcCBtaWxsaXNlY29uZHMge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSBtaWxsaXNlY29uZHMgb2YgdGhlIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuICAgICAgICBAcHJvcCBzZWNvbmRzIHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyB0aGUgc2Vjb25kcyBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBwcm9wIG1pbnV0ZXMge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSBtaW51dGVzIG9mIHRoZSBjaHJvbm8gb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBudW1iZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgQHByb3AgaG91cnMge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSBob3VycyBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEBwcm9wIHdlZWtkYXkge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSB3ZWVrZGF5IG9mIHRoZSBjaHJvbm8gb2JqZWN0LlxyXG4gICAgICAgICAgICBAdHlwZSBudW1iZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgQHByb3AgZGF0ZSB7XHJcbiAgICAgICAgICAgIEBkZXNjIEdldHMgdGhlIGRhdGUgb2YgdGhlIGNocm9ubyBvYmplY3QuIFRoaXMgbnVtYmVyIGlzIGFkanVzdGVkIHRvIHRoZSByYW5nZSAoMC0zMCkgdW5saWtlIHRoZSBub3JtYWwgRGF0ZSBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuICAgICAgICBAcHJvcCBtb250aHMge1xyXG4gICAgICAgICAgICBAZGVzYyBHZXRzIHRoZSBtb250aHMgb2YgdGhlIGNocm9ubyBvYmplY3QuXHJcbiAgICAgICAgICAgIEB0eXBlIG51bWJlclxyXG4gICAgICAgIH1cclxuICAgICAgICBAcHJvcCB5ZWFyIHtcclxuICAgICAgICAgICAgQGRlc2MgR2V0cyB0aGUgeWVhciBvZiB0aGUgY2hyb25vIG9iamVjdC5cclxuICAgICAgICAgICAgQHR5cGUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBAZnVuY3Rpb24gc2hpZnQge1xyXG4gICAgICAgICAgICBAZGVzYyBTaGlmdHMgdGhlIGRhdGUgZm9yd2FyZCBvciBiYWNrd2FyZCBpbiB0aW1lLlxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIG9mZnNldCBbTnVtYmVyXSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc2hpZnQgdGhlIGRhdGUuXHJcbiAgICAgICAgICAgICAgICBAYXJnIHVuaXQgW1N0cmluZ10gVGhlIHVuaXRzIHRvIHNoaWZ0IGJ5LiBWYWxpZCB2YWx1ZXMgYXJlOiAnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInLCAnZGVjYWRlJy5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIGR1cmF0aW9uIFtvYmplY3RdIEFuIG9iamVjdCB0aGF0IHdpbGwgc2hpZnQgdGhlIGRhdGUuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQHJldHVybiBjaHJvbm9cclxuICAgICAgICB9XHJcbiAgICAgICAgQGZ1bmN0aW9uIHN0YXJ0T2Yge1xyXG4gICAgICAgICAgICBAZGVzYyBNb3ZlcyB0aGUgZGF0ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNwZWNpZmllZCB1bml0LlxyXG4gICAgICAgICAgICBAYXJncyB7XHJcbiAgICAgICAgICAgICAgICBAYXJnIHVuaXQgW3N0cmluZ10gVGhlIHVuaXQgdG8gbW92ZSB0byB0aGUgc3RhcnQgb2YuIFZhbGlkIHZhbHVlcyBhcmU6ICdzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhcicuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQHJldHVybiBjaHJvbm9cclxuICAgICAgICB9XHJcbiAgICAgICAgQGZ1bmN0aW9uIGZvcm1hdCB7XHJcbiAgICAgICAgICAgIEBkZXNjIEZvcm1hdHMgdGhlIGNocm9ubyBvYmplY3QgdXNpbmcgdGhlIHNwZWNpZmllZCBzdHJpbmcuXHJcbiAgICAgICAgICAgIEBhcmdzIHtcclxuICAgICAgICAgICAgICAgIEBhcmcgZm9ybWF0IFtzdHJpbmddIFRoZSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZm9ybWF0IHRoZSBkYXRlIHNob3VsZCBiZSBwdXQgaW50by5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBAcmV0dXJuIHN0cmluZ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvYmplY3QgY2hyb25vVHJpZ2dlciB7XHJcbiAgICAgICAgQHByb3Agc3RhdHVzIHtcclxuICAgICAgICAgICAgQGRlc2MgVGhlIHN0YXR1cyBvZiB0aGUgdHJpZ2dlci5cclxuICAgICAgICAgICAgQHR5cGUgc3RyaW5nXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBAZnVuY3Rpb24gY2FuY2VsIHtcclxuICAgICAgICAgICAgQGRlc2MgQ2FuY2VscyB0aGUgdHJpZ2dlciBpZiBpdCBoYXNuJ3QgZmlyZWQgeWV0LlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4qL1xyXG5jb25zdCBjaHJvbm8gPSAoYXJnID0gbnVsbCkgPT4ge1xyXG4gICAgY29uc3QgaW50ZXJuYWxEYXRlID0gKCgpID0+IHtcclxuICAgICAgICBpZiAoYXJnID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKERhdGUucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYXJnKSA9PT0gdHJ1ZSB8fCAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShhcmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFyZy5fX2Nocm9ubyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJnLmRhdGVPYmplY3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgYXJnID0gYXJnLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGlmIChjaHJvbm9TcGVjaWFsLmhhc093blByb3BlcnR5KGFyZykgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaHJvbm9TcGVjaWFsW2FyZ10obmV3IERhdGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhhcmcsIGNocm9ub1VuaXRSZWdleCk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge29mZnNldCwgdW5pdH0gPSBtYXRjaDtcclxuXHJcbiAgICAgICAgICAgICAgICBjaHJvbm9DaGVja1VuaXQodW5pdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuaXRGdW5jdGlvblt1bml0Q29udmVyc2lvblt1bml0XV0obmV3IERhdGUoKSwgcGFyc2VJbnQob2Zmc2V0KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShhcmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qge3llYXIgPSAxOTcwLCBtb250aCA9IDAsIGRhdGUgPSAwLCBob3VycyA9IDAsIG1pbnV0ZXMgPSAwLCBzZWNvbmRzID0gMCwgbWlsbGlzZWNvbmRzID0gMH0gPSBhcmc7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXRlICsgMSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcyk7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgX19jaHJvbm86IHRydWUsXHJcbiAgICAgICAgZ2V0IGRhdGVPYmplY3QoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShpbnRlcm5hbERhdGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHVuaXhUaW1lc3RhbXAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0VGltZSgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldCBtaWxsaXNlY29uZHMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0TWlsbGlzZWNvbmRzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2Vjb25kcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXRTZWNvbmRzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgbWludXRlcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXRNaW51dGVzKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgaG91cnMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0SG91cnMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCB3ZWVrZGF5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLmdldERheSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IGRhdGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0RGF0ZSgpIC0gMTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBtb250aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS5nZXRNb250aCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHllYXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQocHJvcHMpIHtcclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgICAgeWVhciA9IGludGVybmFsRGF0ZS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICAgICAgbW9udGggPSBpbnRlcm5hbERhdGUuZ2V0TW9udGgoKSxcclxuICAgICAgICAgICAgICAgIGRhdGUgPSBpbnRlcm5hbERhdGUuZ2V0RGF0ZSgpIC0gMSxcclxuICAgICAgICAgICAgICAgIGhvdXJzID0gaW50ZXJuYWxEYXRlLmdldEhvdXJzKCksXHJcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gaW50ZXJuYWxEYXRlLmdldE1pbnV0ZXMoKSxcclxuICAgICAgICAgICAgICAgIHNlY29uZHMgPSBpbnRlcm5hbERhdGUuZ2V0U2Vjb25kcygpLFxyXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gaW50ZXJuYWxEYXRlLmdldE1pbGxpc2Vjb25kcygpXHJcbiAgICAgICAgICAgIH0gPSBwcm9wcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjaHJvbm8obmV3IERhdGUoeWVhciwgbW9udGgsIGRhdGUgKyAxLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaGlmdChvZmZzZXQsIHVuaXQpIHtcclxuICAgICAgICAgICAgbGV0IG5ld0RhdGU7XHJcbiAgICAgICAgICAgIG5ld0RhdGUgPSBuZXcgRGF0ZShpbnRlcm5hbERhdGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiAob2Zmc2V0Lmhhc093blByb3BlcnR5KCdfX2Nocm9ub19kdXJhdGlvbicpICYmIG9mZnNldC5fX2Nocm9ub19kdXJhdGlvbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIG9mZnNldCA9IG9mZnNldC5hc09iamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3VuaXQsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvZmZzZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hyb25vQ2hlY2tVbml0KHVuaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGUgPSB1bml0RnVuY3Rpb25bdW5pdENvbnZlcnNpb25bdW5pdF1dKG5ld0RhdGUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hyb25vKG5ld0RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKG9mZnNldCwgY2hyb25vVW5pdFJlZ2V4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgKHtvZmZzZXQsIHVuaXR9ID0gbWF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNocm9ub0NoZWNrVW5pdCh1bml0KTtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBwYXJzZUludChvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjaHJvbm8odW5pdEZ1bmN0aW9uW3VuaXRDb252ZXJzaW9uW3VuaXRdXShuZXdEYXRlLCBvZmZzZXQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RhcnRPZih1bml0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkRGF0ZSA9IG5ldyBEYXRlKGludGVybmFsRGF0ZSk7XHJcblxyXG4gICAgICAgICAgICBzdGFydE9mW3VuaXRdKGFkanVzdGVkRGF0ZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2hyb25vKGFkanVzdGVkRGF0ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmRPZih1bml0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkRGF0ZSA9IG5ldyBEYXRlKGludGVybmFsRGF0ZSk7XHJcblxyXG4gICAgICAgICAgICBlbmRPZlt1bml0XShhZGp1c3RlZERhdGUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNocm9ubyhhZGp1c3RlZERhdGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZm9ybWF0KGZvcm1hdFN0cmluZyA9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdFN0cmluZyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZm9ybWF0U3RyaW5nID09PSAndXRjJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFsRGF0ZS50b1VUQ1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRTdHJpbmcgPT09ICdsb2NhbGUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxEYXRlLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRTdHJpbmcucmVwbGFjZShcclxuICAgICAgICAgICAgICAgIC9cXHsoXFx3KykoXFwvKFxcdyspKT9cXH0vZyxcclxuICAgICAgICAgICAgICAgIChmdWxsLCBwcm9wLCBza2lwLCB0eXBlID0gJ2Jhc2UnKSA9PiBjaHJvbm9Gb3JtYXRbcHJvcF1bdHlwZV0oaW50ZXJuYWxEYXRlKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbERhdGUudG9TdHJpbmcoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIGludGVybmFsRGF0ZS50b0pTT04oKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwie21vbnRofS17ZGF5fS17eWVhci9mdWxsfSB7aG91ci9wYWRkZWR9OnttaW51dGUvcGFkZGVkfTp7c2Vjb25kL3BhZGRlZH1cIi5yZXBsYWNlKFxyXG4gICAgICAgICAgICAgICAgL1xceyhcXHcrKShcXC8oXFx3KykpP1xcfS9nLFxyXG4gICAgICAgICAgICAgICAgKGZ1bGwsIHByb3AsIHNraXAsIHR5cGUgPSAnYmFzZScpID0+IGNocm9ub0Zvcm1hdFtwcm9wXVt0eXBlXShpbnRlcm5hbERhdGUpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuY2hyb25vLmRpZmYgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xyXG4gICAgY29uc3QgaW50ZXJuYWxEYXRlID0gbmV3IERhdGUoc2Vjb25kLnVuaXhUaW1lc3RhbXAgLSBmaXJzdC51bml4VGltZXN0YW1wKTtcclxuICAgIGNvbnNvbGUubG9nKHNlY29uZC51bml4VGltZXN0YW1wIC0gZmlyc3QudW5peFRpbWVzdGFtcCk7XHJcbiAgICBjb25zb2xlLmxvZyhpbnRlcm5hbERhdGUpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBpbnRlcm5hbERhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXHJcbiAgICAgICAgc2Vjb25kczogaW50ZXJuYWxEYXRlLmdldFNlY29uZHMoKSxcclxuICAgICAgICBtaW51dGVzOiBpbnRlcm5hbERhdGUuZ2V0TWludXRlcygpLFxyXG4gICAgICAgIGhvdXJzOiBpbnRlcm5hbERhdGUuZ2V0SG91cnMoKSxcclxuICAgICAgICBkYXlzOiBpbnRlcm5hbERhdGUuZ2V0RGF0ZSgpIC0gMSxcclxuICAgICAgICBtb250aHM6IGludGVybmFsRGF0ZS5nZXRNb250aCgpLFxyXG4gICAgICAgIHllYXJzOiBpbnRlcm5hbERhdGUuZ2V0RnVsbFllYXIoKSAtIDE5NzBcclxuICAgIH07XHJcbn07XHJcbmNocm9uby5ub3cgPSAoKSA9PiBjaHJvbm8oRGF0ZS5ub3coKSk7XHJcbmNocm9uby5wYXJzZSA9IHN0cmluZyA9PiBjaHJvbm8oRGF0ZS5wYXJzZShzdHJpbmcpKTtcclxuY2hyb25vLnBhcnNlTVMgPSBzdHJpbmcgPT4gY2hyb25vKERhdGUucGFyc2Uoc3RyaW5nLnJlcGxhY2UoXCJUXCIsIFwiIFwiKSkpO1xyXG5jaHJvbm8udHJpZ2dlciA9IChkZWxheSwgZnVuYywgLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgc3RhdHVzID0gJ2ZpcmVkJztcclxuICAgICAgICAgICAgZnVuYyguLi5hcmdzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlbGF5XHJcbiAgICApO1xyXG4gICAgbGV0IHN0YXR1cztcclxuXHJcbiAgICBzdGF0dXMgPSAnd2FpdGluZyc7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxsZWQnO1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHN0YXR1cygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5jaHJvbm8ud2FpdCA9IHdhaXQgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUobnVsbCksIHdhaXQpKTtcclxuXHJcbndpbmRvdy5jaHJvbm8gPSBjaHJvbm87XHJcbi8vIGV4cG9ydCBkZWZhdWx0IGNocm9ubztcclxuIiwiZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgdGhlbWU6IHtcclxuICAgICAgICBibHVpc2g6ICcjNDI4NWY0JyxcclxuICAgICAgICBncmF5Qkc6IFwiI2QwZDBkMFwiXHJcbiAgICB9LFxyXG4gICAgY3NzOiB7XHJcbiAgICAgICAgYmFja2dyb3VuZFRyYW5zaXRpb246IFwiYmFja2dyb3VuZC1jb2xvciAyNTBtcyBsaW5lYXJcIlxyXG4gICAgfVxyXG59O1xyXG4iLCJpbXBvcnQgRW52IGZyb20gJ3NvdXJjZS91dGlsL2Vudic7XHJcblxyXG4vKipcclxuICAgIEB0eXBlIFByb21pc2VcclxuICAgIEBuYW1lIGRldmljZVJlYWR5XHJcbiAgICBAZGVzYyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgZGV2aWNlcmVhZHkgZXZlbnQgaGFzIGZpcmVkIGluIGNvZG92YS5cclxuICAgICAgICBVc2VmdWwgZm9yIHBsdWdpbnMgdGhhdCBhcmUgd3JpdHRlbiBhbmQgaW5jbHVkZWQgb3V0c2lkZSBvZiBDb3JpbnRoaWFuLlxyXG4qL1xyXG5pZiAod2luZG93LmRldmljZVJlYWR5ID09PSB1bmRlZmluZWQpIHtcclxuICAgIHdpbmRvdy5kZXZpY2VSZWFkeSA9IG5ldyBQcm9taXNlKFxyXG4gICAgICAgIHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoRW52LmFwcCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZXJlYWR5XCIsICgpID0+IHJlc29sdmUodHJ1ZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn1cclxuIiwiLyoqXHJcbiAgICBAdHlwZSBPYmplY3RcclxuICAgIEBuYW1lIEVudmlyb25tZW50XHJcbiAgICBAZGVzYyBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cclxuICAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbW9iaWxlXHJcbiAgICAgICAgVHJ1ZSBpZiB0aGUgY3VycmVudCBwYWdlIGlzIG9uIGEgbW9iaWxlIHBsYXRmb3JtIChtb2JpbGUgYnJvd3NlciwgY29yZG92YSwgZXRjLikuXHJcbiAgICBAcHJvcGVydHkge0Jvb2xlYW59IGFwcFxyXG4gICAgICAgIFRydWUgaWYgdGhlIGN1cnJlbnQgcGFnZSBpcyBpbnNpZGUgb2YgY29yZG92YS5cclxuKi9cclxuXHJcbmNvbnN0IGV2ZW50U3VwcG9ydCA9ICgoKSA9PiB7XHJcbiAgICBsZXQgcGFzc2l2ZSA9IGZhbHNlO1xyXG4gICAgbGV0IG9uY2UgPSBmYWxzZTtcclxuICAgIGNvbnN0IGV2dENoZWNrZXIgPSB7XHJcbiAgICAgICAgZ2V0IHBhc3NpdmUoKSB7XHJcbiAgICAgICAgICAgIHBhc3NpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBvbmNlKCkge1xyXG4gICAgICAgICAgICBvbmNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbnVsbCwgZXZ0Q2hlY2tlcik7XHJcbiAgICByZXR1cm4ge3Bhc3NpdmUsIG9uY2V9O1xyXG59KSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICBtb2JpbGU6IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTW9iaWxlXCIpICE9PSAtMSxcclxuICAgIGFwcDogdHlwZW9mIGNvcmRvdmEgIT09ICd1bmRlZmluZWQnLFxyXG4gICAgZXZlbnRzOiBldmVudFN1cHBvcnRcclxufSk7XHJcbiIsImltcG9ydCBcInNvdXJjZS91dGlsL2RldmljZXJlYWR5XCI7XHJcblxyXG5jb25zdCBhcHBGaWxlU3lzdGVtID0gbmV3IFByb21pc2UoXHJcbiAgICBhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZGV2aWNlUmVhZHk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RmlsZVN5c3RlbSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXF1ZXN0RmlsZVN5c3RlbShcclxuICAgICAgICAgICAgTG9jYWxGaWxlU3lzdGVtLlBFUlNJU1RFTlQsXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIGZzID0+IHJlc29sdmUoZnMucm9vdCksXHJcbiAgICAgICAgICAgIGVycm9yID0+IHJlamVjdChlcnJvcilcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4pO1xyXG5jb25zdCB0ZW1wRmlsZVN5c3RlbSA9IG5ldyBQcm9taXNlKFxyXG4gICAgYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGRldmljZVJlYWR5O1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdEZpbGVTeXN0ZW0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVxdWVzdEZpbGVTeXN0ZW0oXHJcbiAgICAgICAgICAgIExvY2FsRmlsZVN5c3RlbS5URU1QT1JBUlksXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIGZzID0+IHJlc29sdmUoZnMucm9vdCksXHJcbiAgICAgICAgICAgIGVycm9yID0+IHJlamVjdChlcnJvcilcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4pO1xyXG5cclxuY29uc3QgcHJvdG9TZXBhcmF0ZXIgPSBcIjo6XCI7XHJcbmNvbnN0IGZzVHlwZSA9IHtcclxuICAgIGZpbGU6IFwiZ2V0RmlsZVwiLFxyXG4gICAgZGlyOiBcImdldERpcmVjdG9yeVwiXHJcbn07XHJcbmNvbnN0IGdldEluZm8gPSBuYW1lID0+IHtcclxuICAgIGNvbnN0IGluZm8gPSBuYW1lLnNwbGl0KHByb3RvU2VwYXJhdGVyKTtcclxuXHJcbiAgICBpZiAoaW5mby5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gW251bGwsIGluZm9bMF1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZm87XHJcbn07XHJcbmNvbnN0IGlzRmlsZSA9IG5hbWUgPT4gbmFtZS5zbGljZSgtMSkgIT09ICcvJztcclxuY29uc3QgZ2V0TmFtZSA9IG5hbWUgPT4ge1xyXG4gICAgaWYgKGlzRmlsZShuYW1lKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtMSk7XHJcbiAgICAgICAgcmV0dXJuIG5hbWUuc2xpY2UobmFtZS5sYXN0SW5kZXhPZignLycpICsgMSkgKyAnLyc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5hbWUuc2xpY2UobmFtZS5sYXN0SW5kZXhPZignLycpICsgMSk7XHJcbn07XHJcbmNvbnN0IGdldFBhdGggPSBuYW1lID0+IHtcclxuICAgIGlmIChpc0ZpbGUobmFtZSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLTEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuYW1lLnNsaWNlKDAsIG5hbWUubGFzdEluZGV4T2YoJy8nKSArIDEpO1xyXG59O1xyXG5jb25zdCBnZXRUeXBlID0gbmFtZSA9PiB7XHJcbiAgICBpZiAoaXNGaWxlKG5hbWUpID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZzVHlwZS5maWxlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZzVHlwZS5kaXI7XHJcbn07XHJcblxyXG5jb25zdCByZXNvbHZlVVJMID0gdXJsID0+IG5ldyBQcm9taXNlKFxyXG4gICAgcmVzb2x2ZSA9PiByZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMKHVybCwgcmVzb2x2ZSwgKCkgPT4gcmVzb2x2ZShudWxsKSlcclxuKTtcclxuXHJcbmNvbnN0IGdldCA9IChuYW1lLCBvcHRpb25zID0gbnVsbCkgPT4gbmV3IFByb21pc2UoXHJcbiAgICBhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgW3Byb3RvY29sLCBmdWxsUGF0aF0gPSBnZXRJbmZvKG5hbWUpO1xyXG5cclxuICAgICAgICBpZiAocHJvdG9jb2wgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShhd2FpdCByZXNvbHZlVVJMKGZ1bGxQYXRoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IGF3YWl0ICgocHJvdG9jb2wgPT09ICdhcHAnKSA/IGFwcEZpbGVTeXN0ZW0gOiB0ZW1wRmlsZVN5c3RlbSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgcm9vdFt0eXBlXShcclxuICAgICAgICAgICAgICAgIGZ1bGxQYXRoLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHJlc29sdmUsXHJcbiAgICAgICAgICAgICAgICByZWplY3RcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbmNvbnN0IGV4aXN0cyA9IG5hbWUgPT4gbmV3IFByb21pc2UoXHJcbiAgICBhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgW3Byb3RvY29sLCBwYXRoXSA9IGdldEluZm8obmFtZSk7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldFR5cGUobmFtZSk7XHJcbiAgICAgICAgY29uc3Qgcm9vdCA9IGF3YWl0ICgocHJvdG9jb2wgPT09ICdhcHAnKSA/IGFwcEZpbGVTeXN0ZW0gOiB0ZW1wRmlsZVN5c3RlbSk7XHJcblxyXG4gICAgICAgIHJvb3RbdHlwZV0oXHJcbiAgICAgICAgICAgIHBhdGgsXHJcbiAgICAgICAgICAgIHtjcmVhdGU6IGZhbHNlfSxcclxuICAgICAgICAgICAgKCkgPT4gcmVzb2x2ZSh0cnVlKSxcclxuICAgICAgICAgICAgZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gMSB8fCBlcnIuY29kZSA9PT0gMTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG4pO1xyXG5jb25zdCBnZXROYXRpdmVVUkwgPSBhc3luYyAobmFtZSwgaXNGaWxlKSA9PiB7XHJcbiAgICBjb25zdCBbcHJvdG9jb2xdID0gZ2V0SW5mbyhuYW1lKTtcclxuXHJcbiAgICBpZiAocHJvdG9jb2wgIT09IG51bGwpIHtcclxuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgZ2V0KG5hbWUsIHtjcmVhdGU6IGZhbHNlfSk7XHJcbiAgICAgICAgcmV0dXJuIGZpbGUubmF0aXZlVVJMO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuYW1lO1xyXG59O1xyXG5cclxuY29uc3QgcmVhZEZ1bmN0aW9ucyA9IHtcclxuICAgIHRleHQ6ICdyZWFkQXNUZXh0JyxcclxuICAgIGJpbmFyeTogJ3JlYWRBc0JpbmFyeVN0cmluZycsXHJcbiAgICB1cmw6ICdyZWFkQXNEYXRhVVJMJyxcclxuICAgIGFycmF5YnVmZmVyOiAncmVhZEFzQXJyYXlCdWZmZXInXHJcbn07XHJcbmNvbnN0IHJlYWRmaWxlID0gKG5hbWUsIHR5cGUpID0+IG5ldyBQcm9taXNlKFxyXG4gICAgYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgZ2V0KG5hbWUsIHtjcmVhdGU6IGZhbHNlfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWRGdW5jID0gcmVhZEZ1bmN0aW9uc1t0eXBlXTtcclxuXHJcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xyXG4gICAgICAgICAgICBlbnRyeS5maWxlKGZpbGUgPT4gcmVhZGVyW3JlYWRGdW5jXShmaWxlLCAndXRmLTgnKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbmNvbnN0IGdldEZpbGVXcml0ZXIgPSBlbnRyeSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBlbnRyeS5jcmVhdGVXcml0ZXIocmVzb2x2ZSwgcmVqZWN0KSk7XHJcbmNvbnN0IHdyaXRlRmlsZSA9IChmaWxlRW50cnksIGRhdGEsIG1vZGUpID0+IG5ldyBQcm9taXNlKFxyXG4gICAgYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpbGVXcml0ZXIgPSBhd2FpdCBnZXRGaWxlV3JpdGVyKGZpbGVFbnRyeSk7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVEYXRhID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBmaWxlV3JpdGVyLm9ud3JpdGVlbmQgPSAoKSA9PiByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICBmaWxlV3JpdGVyLndyaXRlKGRhdGEpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChtb2RlID09PSAndHJ1bmNhdGUnICYmIGZpbGVXcml0ZXIubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGZpbGVXcml0ZXIuc2VlaygwKTtcclxuICAgICAgICAgICAgZmlsZVdyaXRlci5vbndyaXRlZW5kID0gd3JpdGVEYXRhO1xyXG4gICAgICAgICAgICBmaWxlV3JpdGVyLnRydW5jYXRlKDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAnYXBwZW5kJykge1xyXG4gICAgICAgICAgICAgICAgZmlsZVdyaXRlci5zZWVrKGZpbGVXcml0ZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3cml0ZURhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG5jb25zdCByZWFkZGlyID0gbmFtZSA9PiBuZXcgUHJvbWlzZShcclxuICAgIGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGNvbnN0IFtwcm90b2NvbF0gPSBnZXRJbmZvKG5hbWUpO1xyXG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGdldChuYW1lLCB7Y3JlYXRlOiBmYWxzZX0pO1xyXG4gICAgICAgICAgICBsZXQgZGlyUmVhZGVyID0gZW50cnkuY3JlYXRlUmVhZGVyKCk7XHJcblxyXG4gICAgICAgICAgICBkaXJSZWFkZXIucmVhZEVudHJpZXMoXHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzID0+IHJlc29sdmUoZW50cmllcy5tYXAoZW50cnkgPT4gYCR7cHJvdG9jb2x9JHtwcm90b1NlcGFyYXRlcn0ke2VudHJ5LmZ1bGxQYXRofWApKSxcclxuICAgICAgICAgICAgICAgIHJlamVjdFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG5jb25zdCByZW1vdmVFbnRyeSA9IChuYW1lLCBmdW5jdGlvbk5hbWUpID0+IG5ldyBQcm9taXNlKFxyXG4gICAgYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgZ2V0KG5hbWUpO1xyXG4gICAgICAgIGVudHJ5W2Z1bmN0aW9uTmFtZV0oXHJcbiAgICAgICAgICAgICgpID0+IHJlc29sdmUodHJ1ZSksXHJcbiAgICAgICAgICAgIHJlamVjdFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbik7XHJcbmNvbnN0IG1vdmVFbnRyeSA9IChzb3VyY2UsIGRlc3QpID0+IG5ldyBQcm9taXNlKFxyXG4gICAgYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRlc3ROYW1lID0gZ2V0TmFtZShkZXN0KTtcclxuICAgICAgICBjb25zdCBkZXN0UGF0aCA9IGdldFBhdGgoZGVzdCk7XHJcbiAgICAgICAgY29uc3QgW3NvdXJjZUVudHJ5LCBkZXN0RGlyRW50cnldID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICBnZXQoc291cmNlKSxcclxuICAgICAgICAgICAgZ2V0KGRlc3RQYXRoKVxyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICBzb3VyY2VFbnRyeS5tb3ZlVG8oXHJcbiAgICAgICAgICAgIGRlc3REaXJFbnRyeSxcclxuICAgICAgICAgICAgZGVzdE5hbWUsXHJcbiAgICAgICAgICAgICgpID0+IHJlc29sdmUodHJ1ZSksXHJcbiAgICAgICAgICAgIHJlamVjdFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbik7XHJcbmNvbnN0IGNvcHlFbnRyeSA9IChzb3VyY2UsIGRlc3QpID0+IG5ldyBQcm9taXNlKFxyXG4gICAgYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRlc3ROYW1lID0gZ2V0TmFtZShkZXN0KTtcclxuICAgICAgICBjb25zdCBkZXN0UGF0aCA9IGdldFBhdGgoZGVzdCk7XHJcbiAgICAgICAgY29uc3QgW3NvdXJjZUVudHJ5LCBkZXN0RGlyRW50cnldID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICBnZXQoc291cmNlKSxcclxuICAgICAgICAgICAgZ2V0KGRlc3RQYXRoKVxyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICBzb3VyY2VFbnRyeS5jb3B5VG8oXHJcbiAgICAgICAgICAgIGRlc3REaXJFbnRyeSxcclxuICAgICAgICAgICAgZGVzdE5hbWUsXHJcbiAgICAgICAgICAgICgpID0+IHJlc29sdmUodHJ1ZSksXHJcbiAgICAgICAgICAgIHJlamVjdFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbik7XHJcblxyXG5sZXQgcm9vdFVSTDtcclxuKGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IGFwcFJvb3QgPSBhd2FpdCBhcHBGaWxlU3lzdGVtO1xyXG4gICAgY29uc3QgdGVtcFJvb3QgPSBhd2FpdCB0ZW1wRmlsZVN5c3RlbTtcclxuXHJcbiAgICByb290VVJMID0ge1xyXG4gICAgICAgIGFwcDogYXBwUm9vdCxcclxuICAgICAgICB0ZW1wOiB0ZW1wUm9vdFxyXG4gICAgfTtcclxufSkoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGFzeW5jIGZpbGVSZWFkKG5hbWUsIHR5cGUgPSAndGV4dCcpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgcmVhZGZpbGUobmFtZSwgdHlwZSk7XHJcbiAgICB9LFxyXG4gICAgYXN5bmMgZGlyUmVhZChuYW1lKSB7XHJcbiAgICAgICAgaWYgKGlzRmlsZShuYW1lKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgZGlyUmVhZCBvbiBhIGZpbGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhd2FpdCByZWFkZGlyKG5hbWUpO1xyXG4gICAgfSxcclxuICAgIGFzeW5jIGZpbGVXcml0ZShuYW1lLCBkYXRhLCBtb2RlID0gJ3RydW5jYXRlJykge1xyXG4gICAgICAgIGNvbnN0IFtwcm90b2NvbF0gPSBnZXRJbmZvKG5hbWUpO1xyXG4gICAgICAgIGxldCBlbnRyeTtcclxuXHJcbiAgICAgICAgaWYgKHByb3RvY29sID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBub3QgYmUgd3JpdGluZyB0byBleHRlcm5hbCBmaWxlcyBkaXJlY3RseVwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVudHJ5ID0gYXdhaXQgZ2V0KG5hbWUsIHtjcmVhdGU6IHRydWV9KTtcclxuICAgICAgICBpZiAoaXNGaWxlKGVudHJ5LmZ1bGxQYXRoKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRpcmVjdG9yeSBleGlzdHMgd2l0aCB0aGF0IG5hbWUgYWxyZWFkeVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdLCB7dHlwZTogJ3RleHQvcGxhaW4nfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhd2FpdCB3cml0ZUZpbGUoZW50cnksIGRhdGEsIG1vZGUpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGFzeW5jIGZpbGVDcmVhdGUobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBnZXQobmFtZSwge2NyZWF0ZTogdHJ1ZX0pO1xyXG4gICAgfSxcclxuICAgIGFzeW5jIGRpckNyZWF0ZShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldChuYW1lLCB7Y3JlYXRlOiB0cnVlfSk7XHJcbiAgICB9LFxyXG4gICAgYXN5bmMgZmlsZVJlbW92ZShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlbW92ZUVudHJ5KG5hbWUsICdyZW1vdmUnKTtcclxuICAgIH0sXHJcbiAgICBhc3luYyBkaXJSZW1vdmUobmFtZSwgcmVjdXJzaXZlID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSAocmVjdXJzaXZlID09PSB0cnVlKSA/IFwicmVtb3ZlUmVjdXJzaXZlbHlcIiA6IFwicmVtb3ZlXCI7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlbW92ZUVudHJ5KG5hbWUsIGZ1bmN0aW9uTmFtZSk7XHJcbiAgICB9LFxyXG4gICAgZmlsZUV4aXN0czogZXhpc3RzLFxyXG4gICAgZGlyRXhpc3RzOiBleGlzdHMsXHJcbiAgICBhc3luYyBmaWxlTW92ZShzb3VyY2UsIGRlc3QpIHtcclxuICAgICAgICBpZiAoaXNGaWxlKHNvdXJjZSkgIT09IGlzRmlsZShkZXN0KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmlsZXMgY2FuIG9ubHkgYmUgbW92ZWQgaW50byBvdGhlciBmaWxlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IG1vdmVFbnRyeShzb3VyY2UsIGRlc3QpO1xyXG4gICAgfSxcclxuICAgIGFzeW5jIGZpbGVDb3B5KHNvdXJjZSwgZGVzdCkge1xyXG4gICAgICAgIGlmIChpc0ZpbGUoc291cmNlKSAhPT0gaXNGaWxlKGRlc3QpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWxlcyBjYW4gb25seSBiZSBtb3ZlZCBpbnRvIG90aGVyIGZpbGVzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXdhaXQgY29weUVudHJ5KHNvdXJjZSwgZGVzdCk7XHJcbiAgICB9LFxyXG4gICAgYXN5bmMgZGlyTW92ZShzb3VyY2UsIGRlc3QpIHtcclxuICAgICAgICBpZiAoaXNGaWxlKHNvdXJjZSkgIT09IGlzRmlsZShkZXN0KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGlyZWN0b3JpZXMgY2FuIG9ubHkgYmUgbW92ZWQgaW50byBvdGhlciBmaWxlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IG1vdmVFbnRyeShzb3VyY2UsIGRlc3QpO1xyXG4gICAgfSxcclxuICAgIGFzeW5jIGRpclRyZWUobmFtZSwgZmlsZXMgPSBbXSkge1xyXG4gICAgICAgIGNvbnN0IGxpc3QgPSBhd2FpdCBmcy5kaXJSZWFkKG5hbWUpO1xyXG5cclxuICAgICAgICBmb3IoY29uc3QgZW50cnkgb2YgbGlzdCkge1xyXG4gICAgICAgICAgICBmaWxlcy5wdXNoKGVudHJ5KTtcclxuICAgICAgICAgICAgaWYgKGlzRmlsZShlbnRyeSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBmcy5kaXJUcmVlKGVudHJ5LCBmaWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmaWxlcztcclxuICAgIH0sXHJcbiAgICB1cmwoZmlsZU5hbWUpIHtcclxuICAgICAgICBjb25zdCBbcHJvdG9jb2wsIGZ1bGxQYXRoXSA9IGdldEluZm8oZmlsZU5hbWUpO1xyXG4gICAgICAgIHJldHVybiBgJHtyb290VVJMW3Byb3RvY29sXS5uYXRpdmVVUkx9JHtmdWxsUGF0aH1gO1xyXG4gICAgfSxcclxuICAgIGFzeW5jIGVudHJ5KHVybCkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBnZXQodXJsLCB7Y3JlYXRlOiBmYWxzZX0pO1xyXG4gICAgfVxyXG59O1xyXG4iLCJpbXBvcnQgRW52IGZyb20gXCJzb3VyY2UvdXRpbC9lbnZcIjtcclxuXHJcbmNvbnN0IGFkZEV2ZW50TGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyLCBvcHRzID0gZmFsc2UpIHtcclxuICAgIGlmIChFbnYuZXZlbnRzLnBhc3NpdmUgPT09IGZhbHNlICYmIHR5cGVvZiBvcHRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIG9wdHMgPSBvcHRzLmNhcHR1cmUgfHwgZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoRW52LmV2ZW50cy5wYXNzaXZlID09PSB0cnVlICYmIHR5cGVvZiBvcHRzID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICBvcHRzID0ge2NhcHR1cmU6IG9wdHN9O1xyXG4gICAgfVxyXG4gICAgdGhpczo6YWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0cyk7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhgYWRkaW5nOiAke3R5cGV9LCBzdXBwb3J0OiBwYXNzaXZlKCR7RW52LmV2ZW50cy5wYXNzaXZlfSkub25jZSgke0Vudi5ldmVudHMub25jZX0pYCk7XHJcbn07XHJcblxyXG5jb25zdCBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XHJcbmNvbnN0IHNjaGVkdWxlID0gKHRpbWUsIGZ1bmMpID0+IHNldFRpbWVvdXQoZnVuYywgdGltZSk7XHJcblxyXG5jb25zdCBmaW5kUHJlc3NUYXJnZXQgPSBub2RlID0+IHtcclxuICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIG5vZGUgIT09IHVuZGVmaW5lZCAmJiBub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtbm8tcHJlc3NcIikgIT09IG51bGwpIHtcclxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub2RlIHx8IGRvY3VtZW50LmJvZHk7XHJcbn07XHJcbmNvbnN0IHRvdWNoRGF0YSA9ICh7cGFnZVg6eCwgcGFnZVk6eSwgaWRlbnRpZmllcjppZCwgdGFyZ2V0fSwge21vdXNlVHJpZ2dlcmVkID0gZmFsc2V9LCB0YXJnZXRPdmVycmlkZSA9IG51bGwpID0+IE9iamVjdC5mcmVlemUoe1xyXG4gICAgcG9zaXRpb246IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgIHgsIHlcclxuICAgIH0pLFxyXG4gICAgdGltZTogRGF0ZS5ub3coKSxcclxuICAgIHRhcmdldDogdGFyZ2V0T3ZlcnJpZGUgfHwgdGFyZ2V0LFxyXG4gICAgcHJlc3NUYXJnZXQ6IGZpbmRQcmVzc1RhcmdldCh0YXJnZXRPdmVycmlkZSB8fCB0YXJnZXQpLFxyXG4gICAgaWQsXHJcbiAgICBtb3VzZVRyaWdnZXJlZFxyXG59KTtcclxuXHJcbmNvbnN0IHBvbGFyVmVjdG9yID0gKHtwb3NpdGlvbjoge3g6eDEsIHk6eTF9fSwge3Bvc2l0aW9uOiB7eDp4MiwgeTp5Mn19KSA9PiB7XHJcbiAgICBsZXQgYW5nbGU7XHJcbiAgICBsZXQgbWFnbml0dWRlO1xyXG5cclxuICAgIGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKTtcclxuICAgIGFuZ2xlICo9IDE4MCAvIE1hdGguUEk7XHJcbiAgICBhbmdsZSA9IChhbmdsZSArIDQ1MCkgJSAzNjA7XHJcblxyXG4gICAgbWFnbml0dWRlID0gTWF0aC5zcXJ0KFxyXG4gICAgICAgICh4MiAtIHgxKSAqKiAyICtcclxuICAgICAgICAoeTIgLSB5MSkgKiogMlxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFuZ2xlLFxyXG4gICAgICAgIG1hZ25pdHVkZVxyXG4gICAgfTtcclxufTtcclxuXHJcbmNvbnN0IGFuZ2xlRGlmID0gKGZpcnN0QW5nbGUsIHNlY29uZEFuZ2xlKSA9PiB7XHJcbiAgICBjb25zdCBhYnNEaWYgPSBNYXRoLmFicyhmaXJzdEFuZ2xlIC0gc2Vjb25kQW5nbGUpICUgMzYwO1xyXG4gICAgaWYgKGFic0RpZiA+IDE4MCkge1xyXG4gICAgICAgIHJldHVybiAzNjAgLSBhYnNEaWY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWJzRGlmO1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlRXZlbnQgPSAoZXZlbnRUeXBlLCBkZXRhaWwgPSBudWxsLCBldmVudFByb3BzID0ge30pID0+IHtcclxuICAgIGxldCBldmVudDtcclxuXHJcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XHJcbiAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnRUeXBlLCB0cnVlLCB0cnVlLCBkZXRhaWwpO1xyXG5cclxuICAgIGZvcihsZXQga2V5IG9mIE9iamVjdC5rZXlzKGV2ZW50UHJvcHMpKSB7XHJcbiAgICAgICAgZXZlbnRba2V5XSA9IGV2ZW50UHJvcHNba2V5XTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXZlbnQ7XHJcbn07XHJcblxyXG5jb25zdCByZWdpc3RlciA9ICh0eXBlLCBjcmVhdGVDYWxsYmFja3MpID0+IHtcclxuICAgIGxldCB7c3RhcnQgPSAoKSA9PiB7fSwgbW92ZSA9ICgpID0+IHt9LCBlbmQgPSAoKSA9PiB7fX0gPSBjcmVhdGVDYWxsYmFja3Moe3BvbGFyVmVjdG9yLCBhbmdsZURpZn0pO1xyXG5cclxuICAgIHJlZ2lzdGVyZWRIYW5kbGVycy5wdXNoKHR5cGUpO1xyXG4gICAgcmVnaXN0ZXJlZENhbGxiYWNrc1t0eXBlXSA9IHtzdGFydCwgbW92ZSwgZW5kfTtcclxuICAgIHRvdWNoVmFyc1t0eXBlXSA9IHt9O1xyXG59O1xyXG5cclxuY29uc3QgZWRpdGFibGVUYWdOYW1lcyA9IFtcImlucHV0XCIsIFwidGV4dGFyZWFcIiwgXCJzZWxlY3RcIl07XHJcblxyXG5sZXQgZW5hYmxlZDtcclxubGV0IHRvdWNoRGF0YVN0YXJ0O1xyXG5sZXQgdG91Y2hEYXRhTGFzdDtcclxubGV0IHRvdWNoVmFycztcclxubGV0IHJlZ2lzdGVyZWRIYW5kbGVycztcclxubGV0IHJlZ2lzdGVyZWRDYWxsYmFja3M7XHJcblxyXG5lbmFibGVkID0gdHJ1ZTtcclxudG91Y2hEYXRhU3RhcnQgPSB7fTtcclxudG91Y2hEYXRhTGFzdCA9IHt9O1xyXG50b3VjaFZhcnMgPSB7fTtcclxucmVnaXN0ZXJlZEhhbmRsZXJzID0gW107XHJcbnJlZ2lzdGVyZWRDYWxsYmFja3MgPSB7fTtcclxuXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgXCJ0b3VjaHN0YXJ0XCIsXHJcbiAgICBldnQgPT4ge1xyXG4gICAgICAgIGxldCB7Y2hhbmdlZFRvdWNoZXN9ID0gZXZ0O1xyXG4gICAgICAgIGlmIChlbmFibGVkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGFuZ2VkVG91Y2hlczo6Zm9yRWFjaCh0b3VjaCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0b3VjaERhdGEodG91Y2gsIGV2dCk7XHJcblxyXG4gICAgICAgICAgICB0b3VjaERhdGFTdGFydFtkYXRhLmlkXSA9IGRhdGE7XHJcbiAgICAgICAgICAgIHRvdWNoRGF0YUxhc3RbZGF0YS5pZF0gPSBkYXRhO1xyXG5cclxuICAgICAgICAgICAgZGF0YS5wcmVzc1RhcmdldC5zZXRBdHRyaWJ1dGUoXCJwcmVzc2VkXCIsIFwiXCIpO1xyXG5cclxuICAgICAgICAgICAgcmVnaXN0ZXJlZEhhbmRsZXJzLmZvckVhY2goaGFuZGxlck5hbWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHJlZ2lzdGVyZWRDYWxsYmFja3NbaGFuZGxlck5hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgIHRvdWNoVmFyc1toYW5kbGVyTmFtZV1bZGF0YS5pZF0gPSB7fTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIuc3RhcnQoe3RvdWNoOiBkYXRhLCB2YXJzOiB0b3VjaFZhcnNbaGFuZGxlck5hbWVdW2RhdGEuaWRdfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGZhbHNlXHJcbik7XHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgXCJ0b3VjaG1vdmVcIixcclxuICAgIGV2dCA9PiB7XHJcbiAgICAgICAgbGV0IHtjaGFuZ2VkVG91Y2hlc30gPSBldnQ7XHJcbiAgICAgICAgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzOjpmb3JFYWNoKHRvdWNoID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRvdWNoRGF0YSh0b3VjaCwgZXZ0KTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRUb3VjaCA9IHRvdWNoRGF0YVN0YXJ0W2RhdGEuaWRdO1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0UG9zaXRpb24gPSB0b3VjaERhdGFMYXN0W2RhdGEuaWRdO1xyXG4gICAgICAgICAgICBjb25zdCBvdmVyYWxsVmVjdG9yID0gcG9sYXJWZWN0b3IoZGF0YSwgc3RhcnRUb3VjaCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpZlZlY3RvciA9IHBvbGFyVmVjdG9yKGRhdGEsIGxhc3RQb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICByZWdpc3RlcmVkSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyTmFtZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gcmVnaXN0ZXJlZENhbGxiYWNrc1toYW5kbGVyTmFtZV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJzID0gdG91Y2hWYXJzW2hhbmRsZXJOYW1lXVtkYXRhLmlkXTtcclxuXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm1vdmUoe3RvdWNoOiBkYXRhLCB2YXJzLCBvdmVyYWxsVmVjdG9yLCBkaWZWZWN0b3J9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZmFsc2VcclxuKTtcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICBcInRvdWNoZW5kXCIsXHJcbiAgICBldnQgPT4ge1xyXG4gICAgICAgIGxldCB7Y2hhbmdlZFRvdWNoZXN9ID0gZXZ0O1xyXG4gICAgICAgIGlmIChlbmFibGVkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGFuZ2VkVG91Y2hlczo6Zm9yRWFjaCh0b3VjaCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0b3VjaERhdGEodG91Y2gsIGV2dCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VG91Y2ggPSB0b3VjaERhdGFTdGFydFtkYXRhLmlkXTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0VGFnTmFtZSA9IGRhdGEudGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJhbGxWZWN0b3IgPSBwb2xhclZlY3RvcihkYXRhLCBzdGFydFRvdWNoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBzb21ldGhpbmdFZGl0YWJsZTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnROb2RlO1xyXG5cclxuICAgICAgICAgICAgZGF0YS5wcmVzc1RhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJwcmVzc2VkXCIpO1xyXG5cclxuICAgICAgICAgICAgc29tZXRoaW5nRWRpdGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBkYXRhLnRhcmdldDtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5nZXRBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb21ldGhpbmdFZGl0YWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSBkb2N1bWVudCB8fCBjdXJyZW50Tm9kZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiAoZWRpdGFibGVUYWdOYW1lcy5pbmRleE9mKHRhcmdldFRhZ05hbWUpID09PSAtMSAmJiBzb21ldGhpbmdFZGl0YWJsZSA9PT0gZmFsc2UgJiYgZXZ0LmNhbmNlbGFibGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKGV2dC5jYW5jZWxhYmxlID09PSB0cnVlICYmIGVkaXRhYmxlVGFnTmFtZXMuaW5kZXhPZih0YXJnZXRUYWdOYW1lKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZWdpc3RlcmVkSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyTmFtZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gcmVnaXN0ZXJlZENhbGxiYWNrc1toYW5kbGVyTmFtZV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJzID0gdG91Y2hWYXJzW2hhbmRsZXJOYW1lXVtkYXRhLmlkXTtcclxuXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmVuZCh7dG91Y2g6IGRhdGEsIHZhcnMsIHN0YXJ0VG91Y2gsIG92ZXJhbGxWZWN0b3J9KTtcclxuICAgICAgICAgICAgICAgIHRvdWNoVmFyc1toYW5kbGVyTmFtZV1bdG91Y2guaWRdID0gbnVsbDtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0b3VjaERhdGFTdGFydFt0b3VjaC5pZF0gPSBudWxsO1xyXG4gICAgICAgICAgICB0b3VjaERhdGFMYXN0W3RvdWNoLmlkXSA9IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgZmFsc2VcclxuKTtcclxuXHJcbigoKSA9PiB7XHJcbiAgICBpZiAoRW52Lm1vYmlsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvcHlQcm9wTGlzdCA9IFsncGFnZVgnLCAncGFnZVknLCAnc2NyZWVuWCcsICdzY3JlZW5ZJywgJ2FsdEtleScsICdjdHJsS2V5JywgJ3NoaWZ0S2V5JywgJ21ldGFLZXknLCAnY2xpZW50WCcsICdjbGllbnRZJywgJ2xheWVyWCcsICdsYXllclknLCAneCcsICd5J107XHJcbiAgICBjb25zdCBjcmVhdGVUb3VjaCA9IChldnQsIHRhcmdldCkgPT4gY29weVByb3BMaXN0LnJlZHVjZShcclxuICAgICAgICAoc3ludGhUb3VjaCwgcHJvcGVydHlOYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIHN5bnRoVG91Y2hbcHJvcGVydHlOYW1lXSA9IGV2dFtwcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICByZXR1cm4gc3ludGhUb3VjaDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtpZGVudGlmaWVyOiAtMSwgdGFyZ2V0LCBzb3VyY2VFbGVtZW50OiB0YXJnZXR9XHJcbiAgICApO1xyXG4gICAgY29uc3QgY3JlYXRlVG91Y2hMaXN0ID0gKGV2dCwgdGFyZ2V0KSA9PiAoe1xyXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzOiB7XHJcbiAgICAgICAgICAgIDA6IGNyZWF0ZVRvdWNoKGV2dCwgdGFyZ2V0KSxcclxuICAgICAgICAgICAgbGVuZ3RoOiAxXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBsZXQgY3VycmVudEVsZW1lbnQ7XHJcbiAgICBsZXQgbW91c2VJc0Rvd247XHJcblxyXG4gICAgY3VycmVudEVsZW1lbnQgPSBudWxsO1xyXG4gICAgbW91c2VJc0Rvd24gPSBmYWxzZTtcclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICBcIm1vdXNlZG93blwiLFxyXG4gICAgICAgIGV2dCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChldnQuYnV0dG9uICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVFdmVudChcclxuICAgICAgICAgICAgICAgIFwidG91Y2hzdGFydFwiLFxyXG4gICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5jcmVhdGVUb3VjaExpc3QoZXZ0LCBldnQudGFyZ2V0KSxcclxuICAgICAgICAgICAgICAgICAgICBtb3VzZVRyaWdnZXJlZDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgbW91c2VJc0Rvd24gPSB0cnVlO1xyXG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IGV2dC50YXJnZXQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICBcIm1vdXNlbW92ZVwiLFxyXG4gICAgICAgIGV2dCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtb3VzZUlzRG93biA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGNyZWF0ZUV2ZW50KFxyXG4gICAgICAgICAgICAgICAgXCJ0b3VjaG1vdmVcIixcclxuICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4uY3JlYXRlVG91Y2hMaXN0KGV2dCwgY3VycmVudEVsZW1lbnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlVHJpZ2dlcmVkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXZ0LnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdpbnB1dCcgfHwgZXZ0LnRhcmdldC50eXBlICE9PSAncmFuZ2UnKSB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICApO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgXCJtb3VzZXVwXCIsXHJcbiAgICAgICAgZXZ0ID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2dC5idXR0b24gIT09IDAgfHwgbW91c2VJc0Rvd24gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjcmVhdGVFdmVudChcclxuICAgICAgICAgICAgICAgIFwidG91Y2hlbmRcIixcclxuICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4uY3JlYXRlVG91Y2hMaXN0KGV2dCwgY3VycmVudEVsZW1lbnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlVHJpZ2dlcmVkOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBtb3VzZUlzRG93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICk7XHJcbn0pKCk7XHJcblxyXG5yZWdpc3RlcihcclxuICAgIFwidGFwXCIsXHJcbiAgICAoKSA9PiAoe1xyXG4gICAgICAgIHN0YXJ0ICh7dmFyc30pIHtcclxuICAgICAgICAgICAgdmFycy52YWxpZCA9IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb3ZlICh7dmFycywgb3ZlcmFsbFZlY3Rvcn0pIHtcclxuICAgICAgICAgICAgaWYgKG92ZXJhbGxWZWN0b3IubWFnbml0dWRlID4gMjApIHtcclxuICAgICAgICAgICAgICAgIHZhcnMudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5kICh7dmFycywgc3RhcnRUb3VjaCwgdG91Y2gsIG92ZXJhbGxWZWN0b3J9KSB7XHJcbiAgICAgICAgICAgIGlmIChvdmVyYWxsVmVjdG9yLm1hZ25pdHVkZSA+IDIwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXJzLnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhcnMudmFsaWQgPT09IHRydWUgJiYgKHRvdWNoLnRpbWUgLSBzdGFydFRvdWNoLnRpbWUpIDwgNTAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRUb3VjaC50YXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbnVsbCAmJiB0b3VjaC5tb3VzZVRyaWdnZXJlZCA9PT0gZmFsc2UgJiYgKCdibHVyJyBpbiBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VG91Y2gudGFyZ2V0LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3RhcnRUb3VjaC50YXJnZXQuZGlzcGF0Y2hFdmVudChcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFdmVudChcInRhcFwiLCBudWxsLCB7dG91Y2h9KVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbik7XHJcblxyXG5yZWdpc3RlcihcclxuICAgIFwiaG9sZFwiLFxyXG4gICAgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNyZWF0ZUNhbGxiYWNrRm9yVG91Y2ggPSB0b3VjaCA9PlxyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0c1t0b3VjaC5pZF0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdG91Y2gudGFyZ2V0LmRpc3BhdGNoRXZlbnQoXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRXZlbnQoXCJob2xkXCIsIG51bGwsIHtwb3NpdGlvbjogdG91Y2gucG9zaXRpb259KVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBsZXQgdGltZW91dHM7XHJcblxyXG4gICAgICAgIHRpbWVvdXRzID0ge307XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQgKHt0b3VjaH0pIHtcclxuICAgICAgICAgICAgICAgIHRpbWVvdXRzW3RvdWNoLmlkXSA9IHNjaGVkdWxlKDEwMDAsIGNyZWF0ZUNhbGxiYWNrRm9yVG91Y2godG91Y2gpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbW92ZSAoe3RvdWNoLCBvdmVyYWxsVmVjdG9yfSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJhbGxWZWN0b3IubWFnbml0dWRlID4gMjApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dHNbdG91Y2guaWRdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0c1t0b3VjaC5pZF0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbmQgKHt0b3VjaH0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0c1t0b3VjaC5pZF0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dHNbdG91Y2guaWRdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0c1t0b3VjaC5pZF0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuKTtcclxuXHJcbndpbmRvdy5nZXN0dXJlID0ge3JlZ2lzdGVyfTtcclxuIiwiY29uc3QgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XHJcblxyXG5jb25zdCBpY29ucyA9IHtcclxuXCJpb24taW9uaWNcIjogYyg2MTc3MSksXHJcblwiaW9uLWFycm93LXVwLWFcIjogYyg2MTcwOCksXHJcblwiaW9uLWFycm93LXJpZ2h0LWFcIjogYyg2MTcwNSksXHJcblwiaW9uLWFycm93LWRvd24tYVwiOiBjKDYxNjk5KSxcclxuXCJpb24tYXJyb3ctbGVmdC1hXCI6IGMoNjE3MDIpLFxyXG5cImlvbi1hcnJvdy11cC1iXCI6IGMoNjE3MDkpLFxyXG5cImlvbi1hcnJvdy1yaWdodC1iXCI6IGMoNjE3MDYpLFxyXG5cImlvbi1hcnJvdy1kb3duLWJcIjogYyg2MTcwMCksXHJcblwiaW9uLWFycm93LWxlZnQtYlwiOiBjKDYxNzAzKSxcclxuXCJpb24tYXJyb3ctdXAtY1wiOiBjKDYxNzEwKSxcclxuXCJpb24tYXJyb3ctcmlnaHQtY1wiOiBjKDYxNzA3KSxcclxuXCJpb24tYXJyb3ctZG93bi1jXCI6IGMoNjE3MDEpLFxyXG5cImlvbi1hcnJvdy1sZWZ0LWNcIjogYyg2MTcwNCksXHJcblwiaW9uLWFycm93LXJldHVybi1yaWdodFwiOiBjKDYyMDU0KSxcclxuXCJpb24tYXJyb3ctcmV0dXJuLWxlZnRcIjogYyg2MjA1MyksXHJcblwiaW9uLWFycm93LXN3YXBcIjogYyg2MjA1NiksXHJcblwiaW9uLWFycm93LXNocmlua1wiOiBjKDYyMDU1KSxcclxuXCJpb24tYXJyb3ctZXhwYW5kXCI6IGMoNjIwNDYpLFxyXG5cImlvbi1hcnJvdy1tb3ZlXCI6IGMoNjIwNTEpLFxyXG5cImlvbi1hcnJvdy1yZXNpemVcIjogYyg2MjA1MiksXHJcblwiaW9uLWNoZXZyb24tdXBcIjogYyg2MTczNCksXHJcblwiaW9uLWNoZXZyb24tcmlnaHRcIjogYyg2MTczMyksXHJcblwiaW9uLWNoZXZyb24tZG93blwiOiBjKDYxNzMxKSxcclxuXCJpb24tY2hldnJvbi1sZWZ0XCI6IGMoNjE3MzIpLFxyXG5cImlvbi1uYXZpY29uLXJvdW5kXCI6IGMoNjE5NjUpLFxyXG5cImlvbi1uYXZpY29uXCI6IGMoNjE5NjYpLFxyXG5cImlvbi1kcmFnXCI6IGMoNjE3NDQpLFxyXG5cImlvbi1sb2ctaW5cIjogYyg2MjExMCksXHJcblwiaW9uLWxvZy1vdXRcIjogYyg2MjExMSksXHJcblwiaW9uLWNoZWNrbWFyay1yb3VuZFwiOiBjKDYxNzI5KSxcclxuXCJpb24tY2hlY2ttYXJrXCI6IGMoNjE3MzApLFxyXG5cImlvbi1jaGVja21hcmstY2lyY2xlZFwiOiBjKDYxNzI4KSxcclxuXCJpb24tY2xvc2Utcm91bmRcIjogYyg2MTczNyksXHJcblwiaW9uLWNsb3NlXCI6IGMoNjE3MzgpLFxyXG5cImlvbi1jbG9zZS1jaXJjbGVkXCI6IGMoNjE3MzYpLFxyXG5cImlvbi1wbHVzLXJvdW5kXCI6IGMoNjE5NzUpLFxyXG5cImlvbi1wbHVzXCI6IGMoNjE5NzYpLFxyXG5cImlvbi1wbHVzLWNpcmNsZWRcIjogYyg2MTk3NCksXHJcblwiaW9uLW1pbnVzLXJvdW5kXCI6IGMoNjE5NjApLFxyXG5cImlvbi1taW51c1wiOiBjKDYxOTYxKSxcclxuXCJpb24tbWludXMtY2lyY2xlZFwiOiBjKDYxOTU5KSxcclxuXCJpb24taW5mb3JtYXRpb25cIjogYyg2MTc3MCksXHJcblwiaW9uLWluZm9ybWF0aW9uLWNpcmNsZWRcIjogYyg2MTc2OSksXHJcblwiaW9uLWhlbHBcIjogYyg2MTc2MyksXHJcblwiaW9uLWhlbHAtY2lyY2xlZFwiOiBjKDYxNzYyKSxcclxuXCJpb24tYmFja3NwYWNlLW91dGxpbmVcIjogYyg2MjM5OCksXHJcblwiaW9uLWJhY2tzcGFjZVwiOiBjKDYyMzk5KSxcclxuXCJpb24taGVscC1idW95XCI6IGMoNjIwNzYpLFxyXG5cImlvbi1hc3Rlcmlza1wiOiBjKDYyMjI4KSxcclxuXCJpb24tYWxlcnRcIjogYyg2MTY5NyksXHJcblwiaW9uLWFsZXJ0LWNpcmNsZWRcIjogYyg2MTY5NiksXHJcblwiaW9uLXJlZnJlc2hcIjogYyg2MTk4MCksXHJcblwiaW9uLWxvb3BcIjogYyg2MTk1MyksXHJcblwiaW9uLXNodWZmbGVcIjogYyg2MTk4NSksXHJcblwiaW9uLWhvbWVcIjogYyg2MTc2NCksXHJcblwiaW9uLXNlYXJjaFwiOiBjKDYxOTgzKSxcclxuXCJpb24tZmxhZ1wiOiBjKDYyMDczKSxcclxuXCJpb24tc3RhclwiOiBjKDYyMDMwKSxcclxuXCJpb24taGVhcnRcIjogYyg2MTc2MSksXHJcblwiaW9uLWhlYXJ0LWJyb2tlblwiOiBjKDYyMjM3KSxcclxuXCJpb24tZ2Vhci1hXCI6IGMoNjE3NTcpLFxyXG5cImlvbi1nZWFyLWJcIjogYyg2MTc1OCksXHJcblwiaW9uLXRvZ2dsZS1maWxsZWRcIjogYyg2MjI5MiksXHJcblwiaW9uLXRvZ2dsZVwiOiBjKDYyMjkzKSxcclxuXCJpb24tc2V0dGluZ3NcIjogYyg2MjEyNSksXHJcblwiaW9uLXdyZW5jaFwiOiBjKDYyMTM4KSxcclxuXCJpb24taGFtbWVyXCI6IGMoNjIwNzUpLFxyXG5cImlvbi1lZGl0XCI6IGMoNjIxNDMpLFxyXG5cImlvbi10cmFzaC1hXCI6IGMoNjIwMzQpLFxyXG5cImlvbi10cmFzaC1iXCI6IGMoNjIwMzUpLFxyXG5cImlvbi1kb2N1bWVudFwiOiBjKDYxNzQzKSxcclxuXCJpb24tZG9jdW1lbnQtdGV4dFwiOiBjKDYxNzQyKSxcclxuXCJpb24tY2xpcGJvYXJkXCI6IGMoNjE3MzUpLFxyXG5cImlvbi1zY2lzc29yc1wiOiBjKDYyMjgzKSxcclxuXCJpb24tZnVubmVsXCI6IGMoNjIyMzUpLFxyXG5cImlvbi1ib29rbWFya1wiOiBjKDYyMDU5KSxcclxuXCJpb24tZW1haWxcIjogYyg2MTc0NiksXHJcblwiaW9uLWVtYWlsLXVucmVhZFwiOiBjKDYyNDAzKSxcclxuXCJpb24tZm9sZGVyXCI6IGMoNjE3NTMpLFxyXG5cImlvbi1maWxpbmdcIjogYyg2MTc0OCksXHJcblwiaW9uLWFyY2hpdmVcIjogYyg2MTY5OCksXHJcblwiaW9uLXJlcGx5XCI6IGMoNjE5ODIpLFxyXG5cImlvbi1yZXBseS1hbGxcIjogYyg2MTk4MSksXHJcblwiaW9uLWZvcndhcmRcIjogYyg2MTc1NCksXHJcblwiaW9uLXNoYXJlXCI6IGMoNjE5ODQpLFxyXG5cImlvbi1wYXBlci1haXJwbGFuZVwiOiBjKDYyMTQ3KSxcclxuXCJpb24tbGlua1wiOiBjKDYxOTUwKSxcclxuXCJpb24tcGFwZXJjbGlwXCI6IGMoNjE5NjcpLFxyXG5cImlvbi1jb21wb3NlXCI6IGMoNjE3NDApLFxyXG5cImlvbi1icmllZmNhc2VcIjogYyg2MjA2MCksXHJcblwiaW9uLW1lZGtpdFwiOiBjKDYyMTE0KSxcclxuXCJpb24tYXRcIjogYyg2MTcxMSksXHJcblwiaW9uLXBvdW5kXCI6IGMoNjE5NzcpLFxyXG5cImlvbi1xdW90ZVwiOiBjKDYyMjc5KSxcclxuXCJpb24tY2xvdWRcIjogYyg2MTczOSksXHJcblwiaW9uLXVwbG9hZFwiOiBjKDYyMDM3KSxcclxuXCJpb24tbW9yZVwiOiBjKDYxOTYzKSxcclxuXCJpb24tZ3JpZFwiOiBjKDYxNzU5KSxcclxuXCJpb24tY2FsZW5kYXJcIjogYyg2MTcxOSksXHJcblwiaW9uLWNsb2NrXCI6IGMoNjIwNjIpLFxyXG5cImlvbi1jb21wYXNzXCI6IGMoNjIwNjcpLFxyXG5cImlvbi1waW5wb2ludFwiOiBjKDYyMTE5KSxcclxuXCJpb24tcGluXCI6IGMoNjIxMTgpLFxyXG5cImlvbi1uYXZpZ2F0ZVwiOiBjKDYyMTE1KSxcclxuXCJpb24tbG9jYXRpb25cIjogYyg2MTk1MSksXHJcblwiaW9uLW1hcFwiOiBjKDYxOTU1KSxcclxuXCJpb24tbG9jay1jb21iaW5hdGlvblwiOiBjKDYyNjc2KSxcclxuXCJpb24tbG9ja2VkXCI6IGMoNjE5NTIpLFxyXG5cImlvbi11bmxvY2tlZFwiOiBjKDYyMDM2KSxcclxuXCJpb24ta2V5XCI6IGMoNjIxMDIpLFxyXG5cImlvbi1hcnJvdy1ncmFwaC11cC1yaWdodFwiOiBjKDYyMDUwKSxcclxuXCJpb24tYXJyb3ctZ3JhcGgtZG93bi1yaWdodFwiOiBjKDYyMDQ4KSxcclxuXCJpb24tYXJyb3ctZ3JhcGgtdXAtbGVmdFwiOiBjKDYyMDQ5KSxcclxuXCJpb24tYXJyb3ctZ3JhcGgtZG93bi1sZWZ0XCI6IGMoNjIwNDcpLFxyXG5cImlvbi1zdGF0cy1iYXJzXCI6IGMoNjIxMzMpLFxyXG5cImlvbi1jb25uZWN0aW9uLWJhcnNcIjogYyg2MjA2OCksXHJcblwiaW9uLXBpZS1ncmFwaFwiOiBjKDYyMTE3KSxcclxuXCJpb24tY2hhdGJ1YmJsZVwiOiBjKDYxNzI2KSxcclxuXCJpb24tY2hhdGJ1YmJsZS13b3JraW5nXCI6IGMoNjE3MjUpLFxyXG5cImlvbi1jaGF0YnViYmxlc1wiOiBjKDYxNzI3KSxcclxuXCJpb24tY2hhdGJveFwiOiBjKDYxNzIzKSxcclxuXCJpb24tY2hhdGJveC13b3JraW5nXCI6IGMoNjE3MjIpLFxyXG5cImlvbi1jaGF0Ym94ZXNcIjogYyg2MTcyNCksXHJcblwiaW9uLXBlcnNvblwiOiBjKDYxOTcxKSxcclxuXCJpb24tcGVyc29uLWFkZFwiOiBjKDYxOTY5KSxcclxuXCJpb24tcGVyc29uLXN0YWxrZXJcIjogYyg2MTk3MCksXHJcblwiaW9uLXdvbWFuXCI6IGMoNjIwNDUpLFxyXG5cImlvbi1tYW5cIjogYyg2MTk1NCksXHJcblwiaW9uLWZlbWFsZVwiOiBjKDYyMDcyKSxcclxuXCJpb24tbWFsZVwiOiBjKDYyMTEzKSxcclxuXCJpb24tdHJhbnNnZW5kZXJcIjogYyg2MjcwOSksXHJcblwiaW9uLWZvcmtcIjogYyg2MjA3NCksXHJcblwiaW9uLWtuaWZlXCI6IGMoNjIxMDMpLFxyXG5cImlvbi1zcG9vblwiOiBjKDYyMTMyKSxcclxuXCJpb24tc291cC1jYW4tb3V0bGluZVwiOiBjKDYyNzA3KSxcclxuXCJpb24tc291cC1jYW5cIjogYyg2MjcwOCksXHJcblwiaW9uLWJlZXJcIjogYyg2MjA1OCksXHJcblwiaW9uLXdpbmVnbGFzc1wiOiBjKDYyMTM3KSxcclxuXCJpb24tY29mZmVlXCI6IGMoNjIwNjYpLFxyXG5cImlvbi1pY2VjcmVhbVwiOiBjKDYyMDc3KSxcclxuXCJpb24tcGl6emFcIjogYyg2MjEyMCksXHJcblwiaW9uLXBvd2VyXCI6IGMoNjIxMjEpLFxyXG5cImlvbi1tb3VzZVwiOiBjKDYyMjcyKSxcclxuXCJpb24tYmF0dGVyeS1mdWxsXCI6IGMoNjE3MTUpLFxyXG5cImlvbi1iYXR0ZXJ5LWhhbGZcIjogYyg2MTcxNiksXHJcblwiaW9uLWJhdHRlcnktbG93XCI6IGMoNjE3MTcpLFxyXG5cImlvbi1iYXR0ZXJ5LWVtcHR5XCI6IGMoNjE3MTQpLFxyXG5cImlvbi1iYXR0ZXJ5LWNoYXJnaW5nXCI6IGMoNjE3MTMpLFxyXG5cImlvbi13aWZpXCI6IGMoNjIwNDQpLFxyXG5cImlvbi1ibHVldG9vdGhcIjogYyg2MTcxOCksXHJcblwiaW9uLWNhbGN1bGF0b3JcIjogYyg2MjA2MSksXHJcblwiaW9uLWNhbWVyYVwiOiBjKDYxNzIwKSxcclxuXCJpb24tZXllXCI6IGMoNjE3NDcpLFxyXG5cImlvbi1leWUtZGlzYWJsZWRcIjogYyg2MjIxNCksXHJcblwiaW9uLWZsYXNoXCI6IGMoNjE3NTEpLFxyXG5cImlvbi1mbGFzaC1vZmZcIjogYyg2MTc1MCksXHJcblwiaW9uLXFyLXNjYW5uZXJcIjogYyg2MjI3OCksXHJcblwiaW9uLWltYWdlXCI6IGMoNjE3NjcpLFxyXG5cImlvbi1pbWFnZXNcIjogYyg2MTc2OCksXHJcblwiaW9uLXdhbmRcIjogYyg2MjI5NiksXHJcblwiaW9uLWNvbnRyYXN0XCI6IGMoNjIwNjkpLFxyXG5cImlvbi1hcGVydHVyZVwiOiBjKDYyMjI3KSxcclxuXCJpb24tY3JvcFwiOiBjKDYyNDAxKSxcclxuXCJpb24tZWFzZWxcIjogYyg2MjQwMiksXHJcblwiaW9uLXBhaW50YnJ1c2hcIjogYyg2MjY3NyksXHJcblwiaW9uLXBhaW50YnVja2V0XCI6IGMoNjI2NzgpLFxyXG5cImlvbi1tb25pdG9yXCI6IGMoNjE5NjIpLFxyXG5cImlvbi1sYXB0b3BcIjogYyg2MTk0OCksXHJcblwiaW9uLWlwYWRcIjogYyg2MTk0NSksXHJcblwiaW9uLWlwaG9uZVwiOiBjKDYxOTQ2KSxcclxuXCJpb24taXBvZFwiOiBjKDYxOTQ3KSxcclxuXCJpb24tcHJpbnRlclwiOiBjKDYxOTc4KSxcclxuXCJpb24tdXNiXCI6IGMoNjIxMzYpLFxyXG5cImlvbi1vdXRsZXRcIjogYyg2MjI3NCksXHJcblwiaW9uLWJ1Z1wiOiBjKDYyMTQyKSxcclxuXCJpb24tY29kZVwiOiBjKDYyMDY1KSxcclxuXCJpb24tY29kZS13b3JraW5nXCI6IGMoNjIwNjQpLFxyXG5cImlvbi1jb2RlLWRvd25sb2FkXCI6IGMoNjIwNjMpLFxyXG5cImlvbi1mb3JrLXJlcG9cIjogYyg2MjE0NCksXHJcblwiaW9uLW5ldHdvcmtcIjogYyg2MjI3MyksXHJcblwiaW9uLXB1bGwtcmVxdWVzdFwiOiBjKDYyMjc3KSxcclxuXCJpb24tbWVyZ2VcIjogYyg2MjI3MSksXHJcblwiaW9uLXhib3hcIjogYyg2MjIyMCksXHJcblwiaW9uLXBsYXlzdGF0aW9uXCI6IGMoNjIyMTgpLFxyXG5cImlvbi1zdGVhbVwiOiBjKDYyMjE5KSxcclxuXCJpb24tY2xvc2VkLWNhcHRpb25pbmdcIjogYyg2MjIzMSksXHJcblwiaW9uLXZpZGVvY2FtZXJhXCI6IGMoNjIwMzgpLFxyXG5cImlvbi1maWxtLW1hcmtlclwiOiBjKDYxNzQ5KSxcclxuXCJpb24tZGlzY1wiOiBjKDYxNzQxKSxcclxuXCJpb24taGVhZHBob25lXCI6IGMoNjE3NjApLFxyXG5cImlvbi1tdXNpYy1ub3RlXCI6IGMoNjE5NjQpLFxyXG5cImlvbi1yYWRpby13YXZlc1wiOiBjKDYyMTI0KSxcclxuXCJpb24tc3BlYWtlcnBob25lXCI6IGMoNjIxMzApLFxyXG5cImlvbi1taWMtYVwiOiBjKDYxOTU2KSxcclxuXCJpb24tbWljLWJcIjogYyg2MTk1NyksXHJcblwiaW9uLW1pYy1jXCI6IGMoNjE5NTgpLFxyXG5cImlvbi12b2x1bWUtaGlnaFwiOiBjKDYyMDM5KSxcclxuXCJpb24tdm9sdW1lLW1lZGl1bVwiOiBjKDYyMDQxKSxcclxuXCJpb24tdm9sdW1lLWxvd1wiOiBjKDYyMDQwKSxcclxuXCJpb24tdm9sdW1lLW11dGVcIjogYyg2MjA0MiksXHJcblwiaW9uLWxldmVsc1wiOiBjKDYyMTA0KSxcclxuXCJpb24tcGxheVwiOiBjKDYxOTczKSxcclxuXCJpb24tcGF1c2VcIjogYyg2MTk2OCksXHJcblwiaW9uLXN0b3BcIjogYyg2MjAzMSksXHJcblwiaW9uLXJlY29yZFwiOiBjKDYxOTc5KSxcclxuXCJpb24tc2tpcC1mb3J3YXJkXCI6IGMoNjE5ODcpLFxyXG5cImlvbi1za2lwLWJhY2t3YXJkXCI6IGMoNjE5ODYpLFxyXG5cImlvbi1lamVjdFwiOiBjKDYxNzQ1KSxcclxuXCJpb24tYmFnXCI6IGMoNjE3MTIpLFxyXG5cImlvbi1jYXJkXCI6IGMoNjE3MjEpLFxyXG5cImlvbi1jYXNoXCI6IGMoNjIyMzApLFxyXG5cImlvbi1wcmljZXRhZ1wiOiBjKDYyMTIyKSxcclxuXCJpb24tcHJpY2V0YWdzXCI6IGMoNjIxMjMpLFxyXG5cImlvbi10aHVtYnN1cFwiOiBjKDYyMDMzKSxcclxuXCJpb24tdGh1bWJzZG93blwiOiBjKDYyMDMyKSxcclxuXCJpb24taGFwcHktb3V0bGluZVwiOiBjKDYyNDA2KSxcclxuXCJpb24taGFwcHlcIjogYyg2MjIzNiksXHJcblwiaW9uLXNhZC1vdXRsaW5lXCI6IGMoNjI2NzkpLFxyXG5cImlvbi1zYWRcIjogYyg2MjI4MiksXHJcblwiaW9uLWJvd3RpZVwiOiBjKDYyNDAwKSxcclxuXCJpb24tdHNoaXJ0LW91dGxpbmVcIjogYyg2MjcxMCksXHJcblwiaW9uLXRzaGlydFwiOiBjKDYyNzExKSxcclxuXCJpb24tdHJvcGh5XCI6IGMoNjIyOTQpLFxyXG5cImlvbi1wb2RpdW1cIjogYyg2MjI3NiksXHJcblwiaW9uLXJpYmJvbi1hXCI6IGMoNjIyODApLFxyXG5cImlvbi1yaWJib24tYlwiOiBjKDYyMjgxKSxcclxuXCJpb24tdW5pdmVyc2l0eVwiOiBjKDYyMjk1KSxcclxuXCJpb24tbWFnbmV0XCI6IGMoNjIxMTIpLFxyXG5cImlvbi1iZWFrZXJcIjogYyg2MjA1NyksXHJcblwiaW9uLWVybGVubWV5ZXItZmxhc2tcIjogYyg2MjQwNSksXHJcblwiaW9uLWVnZ1wiOiBjKDYyMDcxKSxcclxuXCJpb24tZWFydGhcIjogYyg2MjA3MCksXHJcblwiaW9uLXBsYW5ldFwiOiBjKDYyMjc1KSxcclxuXCJpb24tbGlnaHRidWxiXCI6IGMoNjIxMDUpLFxyXG5cImlvbi1jdWJlXCI6IGMoNjIyMzIpLFxyXG5cImlvbi1sZWFmXCI6IGMoNjE5NDkpLFxyXG5cImlvbi13YXRlcmRyb3BcIjogYyg2MjA0MyksXHJcblwiaW9uLWZsYW1lXCI6IGMoNjIyMzQpLFxyXG5cImlvbi1maXJlYmFsbFwiOiBjKDYyMjMzKSxcclxuXCJpb24tYm9uZmlyZVwiOiBjKDYyMjI5KSxcclxuXCJpb24tdW1icmVsbGFcIjogYyg2MjEzNSksXHJcblwiaW9uLW51Y2xlYXJcIjogYyg2MjExNiksXHJcblwiaW9uLW5vLXNtb2tpbmdcIjogYyg2MjE0NiksXHJcblwiaW9uLXRoZXJtb21ldGVyXCI6IGMoNjIxMzQpLFxyXG5cImlvbi1zcGVlZG9tZXRlclwiOiBjKDYyMTMxKSxcclxuXCJpb24tbW9kZWwtc1wiOiBjKDYyMTQ1KSxcclxuXCJpb24tcGxhbmVcIjogYyg2MTk3MiksXHJcblwiaW9uLWpldFwiOiBjKDYyMTAxKSxcclxuXCJpb24tbG9hZC1hXCI6IGMoNjIxMDYpLFxyXG5cImlvbi1sb2FkLWJcIjogYyg2MjEwNyksXHJcblwiaW9uLWxvYWQtY1wiOiBjKDYyMTA4KSxcclxuXCJpb24tbG9hZC1kXCI6IGMoNjIxMDkpLFxyXG5cImlvbi1pb3MtaW9uaWMtb3V0bGluZVwiOiBjKDYyNTQyKSxcclxuXCJpb24taW9zLWFycm93LWJhY2tcIjogYyg2MjQxNSksXHJcblwiaW9uLWlvcy1hcnJvdy1mb3J3YXJkXCI6IGMoNjI0MTcpLFxyXG5cImlvbi1pb3MtYXJyb3ctdXBcIjogYyg2MjQyNCksXHJcblwiaW9uLWlvcy1hcnJvdy1yaWdodFwiOiBjKDYyNDE5KSxcclxuXCJpb24taW9zLWFycm93LWRvd25cIjogYyg2MjQxNiksXHJcblwiaW9uLWlvcy1hcnJvdy1sZWZ0XCI6IGMoNjI0MTgpLFxyXG5cImlvbi1pb3MtYXJyb3ctdGhpbi11cFwiOiBjKDYyNDIzKSxcclxuXCJpb24taW9zLWFycm93LXRoaW4tcmlnaHRcIjogYyg2MjQyMiksXHJcblwiaW9uLWlvcy1hcnJvdy10aGluLWRvd25cIjogYyg2MjQyMCksXHJcblwiaW9uLWlvcy1hcnJvdy10aGluLWxlZnRcIjogYyg2MjQyMSksXHJcblwiaW9uLWlvcy1jaXJjbGUtZmlsbGVkXCI6IGMoNjI0NjQpLFxyXG5cImlvbi1pb3MtY2lyY2xlLW91dGxpbmVcIjogYyg2MjQ2NSksXHJcblwiaW9uLWlvcy1jaGVja21hcmstZW1wdHlcIjogYyg2MjQ2MSksXHJcblwiaW9uLWlvcy1jaGVja21hcmstb3V0bGluZVwiOiBjKDYyNDYyKSxcclxuXCJpb24taW9zLWNoZWNrbWFya1wiOiBjKDYyNDYzKSxcclxuXCJpb24taW9zLXBsdXMtZW1wdHlcIjogYyg2MjYwMSksXHJcblwiaW9uLWlvcy1wbHVzLW91dGxpbmVcIjogYyg2MjYwMiksXHJcblwiaW9uLWlvcy1wbHVzXCI6IGMoNjI2MDMpLFxyXG5cImlvbi1pb3MtY2xvc2UtZW1wdHlcIjogYyg2MjQ2OCksXHJcblwiaW9uLWlvcy1jbG9zZS1vdXRsaW5lXCI6IGMoNjI0NjkpLFxyXG5cImlvbi1pb3MtY2xvc2VcIjogYyg2MjQ3MCksXHJcblwiaW9uLWlvcy1taW51cy1lbXB0eVwiOiBjKDYyNTYyKSxcclxuXCJpb24taW9zLW1pbnVzLW91dGxpbmVcIjogYyg2MjU2MyksXHJcblwiaW9uLWlvcy1taW51c1wiOiBjKDYyNTY0KSxcclxuXCJpb24taW9zLWluZm9ybWF0aW9uLWVtcHR5XCI6IGMoNjI1MzkpLFxyXG5cImlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZVwiOiBjKDYyNTQwKSxcclxuXCJpb24taW9zLWluZm9ybWF0aW9uXCI6IGMoNjI1NDEpLFxyXG5cImlvbi1pb3MtaGVscC1lbXB0eVwiOiBjKDYyNTMyKSxcclxuXCJpb24taW9zLWhlbHAtb3V0bGluZVwiOiBjKDYyNTMzKSxcclxuXCJpb24taW9zLWhlbHBcIjogYyg2MjUzNCksXHJcblwiaW9uLWlvcy1zZWFyY2hcIjogYyg2MjYyOSksXHJcblwiaW9uLWlvcy1zZWFyY2gtc3Ryb25nXCI6IGMoNjI2MjgpLFxyXG5cImlvbi1pb3Mtc3RhclwiOiBjKDYyNjQzKSxcclxuXCJpb24taW9zLXN0YXItaGFsZlwiOiBjKDYyNjQxKSxcclxuXCJpb24taW9zLXN0YXItb3V0bGluZVwiOiBjKDYyNjQyKSxcclxuXCJpb24taW9zLWhlYXJ0XCI6IGMoNjI1MzEpLFxyXG5cImlvbi1pb3MtaGVhcnQtb3V0bGluZVwiOiBjKDYyNTMwKSxcclxuXCJpb24taW9zLW1vcmVcIjogYyg2MjU3MCksXHJcblwiaW9uLWlvcy1tb3JlLW91dGxpbmVcIjogYyg2MjU2OSksXHJcblwiaW9uLWlvcy1ob21lXCI6IGMoNjI1MzYpLFxyXG5cImlvbi1pb3MtaG9tZS1vdXRsaW5lXCI6IGMoNjI1MzUpLFxyXG5cImlvbi1pb3MtY2xvdWRcIjogYyg2MjQ3NiksXHJcblwiaW9uLWlvcy1jbG91ZC1vdXRsaW5lXCI6IGMoNjI0NzMpLFxyXG5cImlvbi1pb3MtY2xvdWQtdXBsb2FkXCI6IGMoNjI0NzUpLFxyXG5cImlvbi1pb3MtY2xvdWQtdXBsb2FkLW91dGxpbmVcIjogYyg2MjQ3NCksXHJcblwiaW9uLWlvcy1jbG91ZC1kb3dubG9hZFwiOiBjKDYyNDcyKSxcclxuXCJpb24taW9zLWNsb3VkLWRvd25sb2FkLW91dGxpbmVcIjogYyg2MjQ3MSksXHJcblwiaW9uLWlvcy11cGxvYWRcIjogYyg2MjY2NyksXHJcblwiaW9uLWlvcy11cGxvYWQtb3V0bGluZVwiOiBjKDYyNjY2KSxcclxuXCJpb24taW9zLWRvd25sb2FkXCI6IGMoNjI0OTYpLFxyXG5cImlvbi1pb3MtZG93bmxvYWQtb3V0bGluZVwiOiBjKDYyNDk1KSxcclxuXCJpb24taW9zLXJlZnJlc2hcIjogYyg2MjYyMCksXHJcblwiaW9uLWlvcy1yZWZyZXNoLW91dGxpbmVcIjogYyg2MjYxOSksXHJcblwiaW9uLWlvcy1yZWZyZXNoLWVtcHR5XCI6IGMoNjI2MTgpLFxyXG5cImlvbi1pb3MtcmVsb2FkXCI6IGMoNjI2MjEpLFxyXG5cImlvbi1pb3MtbG9vcC1zdHJvbmdcIjogYyg2MjU1MyksXHJcblwiaW9uLWlvcy1sb29wXCI6IGMoNjI1NTQpLFxyXG5cImlvbi1pb3MtYm9va21hcmtzXCI6IGMoNjI0NDIpLFxyXG5cImlvbi1pb3MtYm9va21hcmtzLW91dGxpbmVcIjogYyg2MjQ0MSksXHJcblwiaW9uLWlvcy1ib29rXCI6IGMoNjI0NDApLFxyXG5cImlvbi1pb3MtYm9vay1vdXRsaW5lXCI6IGMoNjI0MzkpLFxyXG5cImlvbi1pb3MtZmxhZ1wiOiBjKDYyNTA5KSxcclxuXCJpb24taW9zLWZsYWctb3V0bGluZVwiOiBjKDYyNTA4KSxcclxuXCJpb24taW9zLWdsYXNzZXNcIjogYyg2MjUyNyksXHJcblwiaW9uLWlvcy1nbGFzc2VzLW91dGxpbmVcIjogYyg2MjUyNiksXHJcblwiaW9uLWlvcy1icm93c2Vyc1wiOiBjKDYyNDQ4KSxcclxuXCJpb24taW9zLWJyb3dzZXJzLW91dGxpbmVcIjogYyg2MjQ0NyksXHJcblwiaW9uLWlvcy1hdFwiOiBjKDYyNDI2KSxcclxuXCJpb24taW9zLWF0LW91dGxpbmVcIjogYyg2MjQyNSksXHJcblwiaW9uLWlvcy1wcmljZXRhZ1wiOiBjKDYyNjA1KSxcclxuXCJpb24taW9zLXByaWNldGFnLW91dGxpbmVcIjogYyg2MjYwNCksXHJcblwiaW9uLWlvcy1wcmljZXRhZ3NcIjogYyg2MjYwNyksXHJcblwiaW9uLWlvcy1wcmljZXRhZ3Mtb3V0bGluZVwiOiBjKDYyNjA2KSxcclxuXCJpb24taW9zLWNhcnRcIjogYyg2MjQ1NiksXHJcblwiaW9uLWlvcy1jYXJ0LW91dGxpbmVcIjogYyg2MjQ1NSksXHJcblwiaW9uLWlvcy1jaGF0Ym94ZXNcIjogYyg2MjQ1OCksXHJcblwiaW9uLWlvcy1jaGF0Ym94ZXMtb3V0bGluZVwiOiBjKDYyNDU3KSxcclxuXCJpb24taW9zLWNoYXRidWJibGVcIjogYyg2MjQ2MCksXHJcblwiaW9uLWlvcy1jaGF0YnViYmxlLW91dGxpbmVcIjogYyg2MjQ1OSksXHJcblwiaW9uLWlvcy1jb2dcIjogYyg2MjQ4MiksXHJcblwiaW9uLWlvcy1jb2ctb3V0bGluZVwiOiBjKDYyNDgxKSxcclxuXCJpb24taW9zLWdlYXJcIjogYyg2MjUyNSksXHJcblwiaW9uLWlvcy1nZWFyLW91dGxpbmVcIjogYyg2MjUyNCksXHJcblwiaW9uLWlvcy1zZXR0aW5nc1wiOiBjKDYyNjMxKSxcclxuXCJpb24taW9zLXNldHRpbmdzLXN0cm9uZ1wiOiBjKDYyNjMwKSxcclxuXCJpb24taW9zLXRvZ2dsZVwiOiBjKDYyNjU5KSxcclxuXCJpb24taW9zLXRvZ2dsZS1vdXRsaW5lXCI6IGMoNjI2NTgpLFxyXG5cImlvbi1pb3MtYW5hbHl0aWNzXCI6IGMoNjI0MTQpLFxyXG5cImlvbi1pb3MtYW5hbHl0aWNzLW91dGxpbmVcIjogYyg2MjQxMyksXHJcblwiaW9uLWlvcy1waWVcIjogYyg2MjU5NiksXHJcblwiaW9uLWlvcy1waWUtb3V0bGluZVwiOiBjKDYyNTk1KSxcclxuXCJpb24taW9zLXB1bHNlXCI6IGMoNjI2MTEpLFxyXG5cImlvbi1pb3MtcHVsc2Utc3Ryb25nXCI6IGMoNjI2MTApLFxyXG5cImlvbi1pb3MtZmlsaW5nXCI6IGMoNjI1MDUpLFxyXG5cImlvbi1pb3MtZmlsaW5nLW91dGxpbmVcIjogYyg2MjUwNCksXHJcblwiaW9uLWlvcy1ib3hcIjogYyg2MjQ0NCksXHJcblwiaW9uLWlvcy1ib3gtb3V0bGluZVwiOiBjKDYyNDQzKSxcclxuXCJpb24taW9zLWNvbXBvc2VcIjogYyg2MjQ4OCksXHJcblwiaW9uLWlvcy1jb21wb3NlLW91dGxpbmVcIjogYyg2MjQ4NyksXHJcblwiaW9uLWlvcy10cmFzaFwiOiBjKDYyNjYxKSxcclxuXCJpb24taW9zLXRyYXNoLW91dGxpbmVcIjogYyg2MjY2MCksXHJcblwiaW9uLWlvcy1jb3B5XCI6IGMoNjI0OTIpLFxyXG5cImlvbi1pb3MtY29weS1vdXRsaW5lXCI6IGMoNjI0OTEpLFxyXG5cImlvbi1pb3MtZW1haWxcIjogYyg2MjQ5OSksXHJcblwiaW9uLWlvcy1lbWFpbC1vdXRsaW5lXCI6IGMoNjI0OTgpLFxyXG5cImlvbi1pb3MtdW5kb1wiOiBjKDYyNjYzKSxcclxuXCJpb24taW9zLXVuZG8tb3V0bGluZVwiOiBjKDYyNjYyKSxcclxuXCJpb24taW9zLXJlZG9cIjogYyg2MjYxNyksXHJcblwiaW9uLWlvcy1yZWRvLW91dGxpbmVcIjogYyg2MjYxNiksXHJcblwiaW9uLWlvcy1wYXBlcnBsYW5lXCI6IGMoNjI1ODApLFxyXG5cImlvbi1pb3MtcGFwZXJwbGFuZS1vdXRsaW5lXCI6IGMoNjI1NzkpLFxyXG5cImlvbi1pb3MtZm9sZGVyXCI6IGMoNjI1MTcpLFxyXG5cImlvbi1pb3MtZm9sZGVyLW91dGxpbmVcIjogYyg2MjUxNiksXHJcblwiaW9uLWlvcy1wYXBlclwiOiBjKDYyNTc4KSxcclxuXCJpb24taW9zLXBhcGVyLW91dGxpbmVcIjogYyg2MjU3NyksXHJcblwiaW9uLWlvcy1saXN0XCI6IGMoNjI1NDgpLFxyXG5cImlvbi1pb3MtbGlzdC1vdXRsaW5lXCI6IGMoNjI1NDcpLFxyXG5cImlvbi1pb3Mtd29ybGRcIjogYyg2MjY3NSksXHJcblwiaW9uLWlvcy13b3JsZC1vdXRsaW5lXCI6IGMoNjI2NzQpLFxyXG5cImlvbi1pb3MtYWxhcm1cIjogYyg2MjQwOCksXHJcblwiaW9uLWlvcy1hbGFybS1vdXRsaW5lXCI6IGMoNjI0MDcpLFxyXG5cImlvbi1pb3Mtc3BlZWRvbWV0ZXJcIjogYyg2MjY0MCksXHJcblwiaW9uLWlvcy1zcGVlZG9tZXRlci1vdXRsaW5lXCI6IGMoNjI2MzkpLFxyXG5cImlvbi1pb3Mtc3RvcHdhdGNoXCI6IGMoNjI2NDUpLFxyXG5cImlvbi1pb3Mtc3RvcHdhdGNoLW91dGxpbmVcIjogYyg2MjY0NCksXHJcblwiaW9uLWlvcy10aW1lclwiOiBjKDYyNjU3KSxcclxuXCJpb24taW9zLXRpbWVyLW91dGxpbmVcIjogYyg2MjY1NiksXHJcblwiaW9uLWlvcy1jbG9ja1wiOiBjKDYyNDY3KSxcclxuXCJpb24taW9zLWNsb2NrLW91dGxpbmVcIjogYyg2MjQ2NiksXHJcblwiaW9uLWlvcy10aW1lXCI6IGMoNjI2NTUpLFxyXG5cImlvbi1pb3MtdGltZS1vdXRsaW5lXCI6IGMoNjI2NTQpLFxyXG5cImlvbi1pb3MtY2FsZW5kYXJcIjogYyg2MjQ1MiksXHJcblwiaW9uLWlvcy1jYWxlbmRhci1vdXRsaW5lXCI6IGMoNjI0NTEpLFxyXG5cImlvbi1pb3MtcGhvdG9zXCI6IGMoNjI1OTQpLFxyXG5cImlvbi1pb3MtcGhvdG9zLW91dGxpbmVcIjogYyg2MjU5MyksXHJcblwiaW9uLWlvcy1hbGJ1bXNcIjogYyg2MjQxMCksXHJcblwiaW9uLWlvcy1hbGJ1bXMtb3V0bGluZVwiOiBjKDYyNDA5KSxcclxuXCJpb24taW9zLWNhbWVyYVwiOiBjKDYyNDU0KSxcclxuXCJpb24taW9zLWNhbWVyYS1vdXRsaW5lXCI6IGMoNjI0NTMpLFxyXG5cImlvbi1pb3MtcmV2ZXJzZS1jYW1lcmFcIjogYyg2MjYyMyksXHJcblwiaW9uLWlvcy1yZXZlcnNlLWNhbWVyYS1vdXRsaW5lXCI6IGMoNjI2MjIpLFxyXG5cImlvbi1pb3MtZXllXCI6IGMoNjI1MDEpLFxyXG5cImlvbi1pb3MtZXllLW91dGxpbmVcIjogYyg2MjUwMCksXHJcblwiaW9uLWlvcy1ib2x0XCI6IGMoNjI0MzgpLFxyXG5cImlvbi1pb3MtYm9sdC1vdXRsaW5lXCI6IGMoNjI0MzcpLFxyXG5cImlvbi1pb3MtY29sb3Itd2FuZFwiOiBjKDYyNDg2KSxcclxuXCJpb24taW9zLWNvbG9yLXdhbmQtb3V0bGluZVwiOiBjKDYyNDg1KSxcclxuXCJpb24taW9zLWNvbG9yLWZpbHRlclwiOiBjKDYyNDg0KSxcclxuXCJpb24taW9zLWNvbG9yLWZpbHRlci1vdXRsaW5lXCI6IGMoNjI0ODMpLFxyXG5cImlvbi1pb3MtZ3JpZC12aWV3XCI6IGMoNjI1MjkpLFxyXG5cImlvbi1pb3MtZ3JpZC12aWV3LW91dGxpbmVcIjogYyg2MjUyOCksXHJcblwiaW9uLWlvcy1jcm9wLXN0cm9uZ1wiOiBjKDYyNDkzKSxcclxuXCJpb24taW9zLWNyb3BcIjogYyg2MjQ5NCksXHJcblwiaW9uLWlvcy1iYXJjb2RlXCI6IGMoNjI0MjgpLFxyXG5cImlvbi1pb3MtYmFyY29kZS1vdXRsaW5lXCI6IGMoNjI0MjcpLFxyXG5cImlvbi1pb3MtYnJpZWZjYXNlXCI6IGMoNjI0NDYpLFxyXG5cImlvbi1pb3MtYnJpZWZjYXNlLW91dGxpbmVcIjogYyg2MjQ0NSksXHJcblwiaW9uLWlvcy1tZWRraXRcIjogYyg2MjU1OCksXHJcblwiaW9uLWlvcy1tZWRraXQtb3V0bGluZVwiOiBjKDYyNTU3KSxcclxuXCJpb24taW9zLW1lZGljYWxcIjogYyg2MjU1NiksXHJcblwiaW9uLWlvcy1tZWRpY2FsLW91dGxpbmVcIjogYyg2MjU1NSksXHJcblwiaW9uLWlvcy1pbmZpbml0ZVwiOiBjKDYyNTM4KSxcclxuXCJpb24taW9zLWluZmluaXRlLW91dGxpbmVcIjogYyg2MjUzNyksXHJcblwiaW9uLWlvcy1jYWxjdWxhdG9yXCI6IGMoNjI0NTApLFxyXG5cImlvbi1pb3MtY2FsY3VsYXRvci1vdXRsaW5lXCI6IGMoNjI0NDkpLFxyXG5cImlvbi1pb3Mta2V5cGFkXCI6IGMoNjI1NDQpLFxyXG5cImlvbi1pb3Mta2V5cGFkLW91dGxpbmVcIjogYyg2MjU0MyksXHJcblwiaW9uLWlvcy10ZWxlcGhvbmVcIjogYyg2MjY0OSksXHJcblwiaW9uLWlvcy10ZWxlcGhvbmUtb3V0bGluZVwiOiBjKDYyNjQ4KSxcclxuXCJpb24taW9zLWRyYWdcIjogYyg2MjQ5NyksXHJcblwiaW9uLWlvcy1sb2NhdGlvblwiOiBjKDYyNTUwKSxcclxuXCJpb24taW9zLWxvY2F0aW9uLW91dGxpbmVcIjogYyg2MjU0OSksXHJcblwiaW9uLWlvcy1uYXZpZ2F0ZVwiOiBjKDYyNTc0KSxcclxuXCJpb24taW9zLW5hdmlnYXRlLW91dGxpbmVcIjogYyg2MjU3MyksXHJcblwiaW9uLWlvcy1sb2NrZWRcIjogYyg2MjU1MiksXHJcblwiaW9uLWlvcy1sb2NrZWQtb3V0bGluZVwiOiBjKDYyNTUxKSxcclxuXCJpb24taW9zLXVubG9ja2VkXCI6IGMoNjI2NjUpLFxyXG5cImlvbi1pb3MtdW5sb2NrZWQtb3V0bGluZVwiOiBjKDYyNjY0KSxcclxuXCJpb24taW9zLW1vbml0b3JcIjogYyg2MjU2NiksXHJcblwiaW9uLWlvcy1tb25pdG9yLW91dGxpbmVcIjogYyg2MjU2NSksXHJcblwiaW9uLWlvcy1wcmludGVyXCI6IGMoNjI2MDkpLFxyXG5cImlvbi1pb3MtcHJpbnRlci1vdXRsaW5lXCI6IGMoNjI2MDgpLFxyXG5cImlvbi1pb3MtZ2FtZS1jb250cm9sbGVyLWFcIjogYyg2MjUyMSksXHJcblwiaW9uLWlvcy1nYW1lLWNvbnRyb2xsZXItYS1vdXRsaW5lXCI6IGMoNjI1MjApLFxyXG5cImlvbi1pb3MtZ2FtZS1jb250cm9sbGVyLWJcIjogYyg2MjUyMyksXHJcblwiaW9uLWlvcy1nYW1lLWNvbnRyb2xsZXItYi1vdXRsaW5lXCI6IGMoNjI1MjIpLFxyXG5cImlvbi1pb3MtYW1lcmljYW5mb290YmFsbFwiOiBjKDYyNDEyKSxcclxuXCJpb24taW9zLWFtZXJpY2FuZm9vdGJhbGwtb3V0bGluZVwiOiBjKDYyNDExKSxcclxuXCJpb24taW9zLWJhc2ViYWxsXCI6IGMoNjI0MzApLFxyXG5cImlvbi1pb3MtYmFzZWJhbGwtb3V0bGluZVwiOiBjKDYyNDI5KSxcclxuXCJpb24taW9zLWJhc2tldGJhbGxcIjogYyg2MjQzMiksXHJcblwiaW9uLWlvcy1iYXNrZXRiYWxsLW91dGxpbmVcIjogYyg2MjQzMSksXHJcblwiaW9uLWlvcy10ZW5uaXNiYWxsXCI6IGMoNjI2NTEpLFxyXG5cImlvbi1pb3MtdGVubmlzYmFsbC1vdXRsaW5lXCI6IGMoNjI2NTApLFxyXG5cImlvbi1pb3MtZm9vdGJhbGxcIjogYyg2MjUxOSksXHJcblwiaW9uLWlvcy1mb290YmFsbC1vdXRsaW5lXCI6IGMoNjI1MTgpLFxyXG5cImlvbi1pb3MtYm9keVwiOiBjKDYyNDM2KSxcclxuXCJpb24taW9zLWJvZHktb3V0bGluZVwiOiBjKDYyNDM1KSxcclxuXCJpb24taW9zLXBlcnNvblwiOiBjKDYyNTkwKSxcclxuXCJpb24taW9zLXBlcnNvbi1vdXRsaW5lXCI6IGMoNjI1ODkpLFxyXG5cImlvbi1pb3MtcGVyc29uYWRkXCI6IGMoNjI1OTIpLFxyXG5cImlvbi1pb3MtcGVyc29uYWRkLW91dGxpbmVcIjogYyg2MjU5MSksXHJcblwiaW9uLWlvcy1wZW9wbGVcIjogYyg2MjU4OCksXHJcblwiaW9uLWlvcy1wZW9wbGUtb3V0bGluZVwiOiBjKDYyNTg3KSxcclxuXCJpb24taW9zLW11c2ljYWwtbm90ZXNcIjogYyg2MjU3MiksXHJcblwiaW9uLWlvcy1tdXNpY2FsLW5vdGVcIjogYyg2MjU3MSksXHJcblwiaW9uLWlvcy1iZWxsXCI6IGMoNjI0MzQpLFxyXG5cImlvbi1pb3MtYmVsbC1vdXRsaW5lXCI6IGMoNjI0MzMpLFxyXG5cImlvbi1pb3MtbWljXCI6IGMoNjI1NjEpLFxyXG5cImlvbi1pb3MtbWljLW91dGxpbmVcIjogYyg2MjU2MCksXHJcblwiaW9uLWlvcy1taWMtb2ZmXCI6IGMoNjI1NTkpLFxyXG5cImlvbi1pb3Mtdm9sdW1lLWhpZ2hcIjogYyg2MjY3MCksXHJcblwiaW9uLWlvcy12b2x1bWUtbG93XCI6IGMoNjI2NzEpLFxyXG5cImlvbi1pb3MtcGxheVwiOiBjKDYyNjAwKSxcclxuXCJpb24taW9zLXBsYXktb3V0bGluZVwiOiBjKDYyNTk5KSxcclxuXCJpb24taW9zLXBhdXNlXCI6IGMoNjI1ODQpLFxyXG5cImlvbi1pb3MtcGF1c2Utb3V0bGluZVwiOiBjKDYyNTgzKSxcclxuXCJpb24taW9zLXJlY29yZGluZ1wiOiBjKDYyNjE1KSxcclxuXCJpb24taW9zLXJlY29yZGluZy1vdXRsaW5lXCI6IGMoNjI2MTQpLFxyXG5cImlvbi1pb3MtZmFzdGZvcndhcmRcIjogYyg2MjUwMyksXHJcblwiaW9uLWlvcy1mYXN0Zm9yd2FyZC1vdXRsaW5lXCI6IGMoNjI1MDIpLFxyXG5cImlvbi1pb3MtcmV3aW5kXCI6IGMoNjI2MjUpLFxyXG5cImlvbi1pb3MtcmV3aW5kLW91dGxpbmVcIjogYyg2MjYyNCksXHJcblwiaW9uLWlvcy1za2lwYmFja3dhcmRcIjogYyg2MjYzNSksXHJcblwiaW9uLWlvcy1za2lwYmFja3dhcmQtb3V0bGluZVwiOiBjKDYyNjM0KSxcclxuXCJpb24taW9zLXNraXBmb3J3YXJkXCI6IGMoNjI2MzcpLFxyXG5cImlvbi1pb3Mtc2tpcGZvcndhcmQtb3V0bGluZVwiOiBjKDYyNjM2KSxcclxuXCJpb24taW9zLXNodWZmbGUtc3Ryb25nXCI6IGMoNjI2MzIpLFxyXG5cImlvbi1pb3Mtc2h1ZmZsZVwiOiBjKDYyNjMzKSxcclxuXCJpb24taW9zLXZpZGVvY2FtXCI6IGMoNjI2NjkpLFxyXG5cImlvbi1pb3MtdmlkZW9jYW0tb3V0bGluZVwiOiBjKDYyNjY4KSxcclxuXCJpb24taW9zLWZpbG1cIjogYyg2MjUwNyksXHJcblwiaW9uLWlvcy1maWxtLW91dGxpbmVcIjogYyg2MjUwNiksXHJcblwiaW9uLWlvcy1mbGFza1wiOiBjKDYyNTEzKSxcclxuXCJpb24taW9zLWZsYXNrLW91dGxpbmVcIjogYyg2MjUxMiksXHJcblwiaW9uLWlvcy1saWdodGJ1bGJcIjogYyg2MjU0NiksXHJcblwiaW9uLWlvcy1saWdodGJ1bGItb3V0bGluZVwiOiBjKDYyNTQ1KSxcclxuXCJpb24taW9zLXdpbmVnbGFzc1wiOiBjKDYyNjczKSxcclxuXCJpb24taW9zLXdpbmVnbGFzcy1vdXRsaW5lXCI6IGMoNjI2NzIpLFxyXG5cImlvbi1pb3MtcGludFwiOiBjKDYyNTk4KSxcclxuXCJpb24taW9zLXBpbnQtb3V0bGluZVwiOiBjKDYyNTk3KSxcclxuXCJpb24taW9zLW51dHJpdGlvblwiOiBjKDYyNTc2KSxcclxuXCJpb24taW9zLW51dHJpdGlvbi1vdXRsaW5lXCI6IGMoNjI1NzUpLFxyXG5cImlvbi1pb3MtZmxvd2VyXCI6IGMoNjI1MTUpLFxyXG5cImlvbi1pb3MtZmxvd2VyLW91dGxpbmVcIjogYyg2MjUxNCksXHJcblwiaW9uLWlvcy1yb3NlXCI6IGMoNjI2MjcpLFxyXG5cImlvbi1pb3Mtcm9zZS1vdXRsaW5lXCI6IGMoNjI2MjYpLFxyXG5cImlvbi1pb3MtcGF3XCI6IGMoNjI1ODYpLFxyXG5cImlvbi1pb3MtcGF3LW91dGxpbmVcIjogYyg2MjU4NSksXHJcblwiaW9uLWlvcy1mbGFtZVwiOiBjKDYyNTExKSxcclxuXCJpb24taW9zLWZsYW1lLW91dGxpbmVcIjogYyg2MjUxMCksXHJcblwiaW9uLWlvcy1zdW5ueVwiOiBjKDYyNjQ3KSxcclxuXCJpb24taW9zLXN1bm55LW91dGxpbmVcIjogYyg2MjY0NiksXHJcblwiaW9uLWlvcy1wYXJ0bHlzdW5ueVwiOiBjKDYyNTgyKSxcclxuXCJpb24taW9zLXBhcnRseXN1bm55LW91dGxpbmVcIjogYyg2MjU4MSksXHJcblwiaW9uLWlvcy1jbG91ZHlcIjogYyg2MjQ4MCksXHJcblwiaW9uLWlvcy1jbG91ZHktb3V0bGluZVwiOiBjKDYyNDc5KSxcclxuXCJpb24taW9zLXJhaW55XCI6IGMoNjI2MTMpLFxyXG5cImlvbi1pb3MtcmFpbnktb3V0bGluZVwiOiBjKDYyNjEyKSxcclxuXCJpb24taW9zLXRodW5kZXJzdG9ybVwiOiBjKDYyNjUzKSxcclxuXCJpb24taW9zLXRodW5kZXJzdG9ybS1vdXRsaW5lXCI6IGMoNjI2NTIpLFxyXG5cImlvbi1pb3Mtc25vd3lcIjogYyg2MjYzOCksXHJcblwiaW9uLWlvcy1tb29uXCI6IGMoNjI1NjgpLFxyXG5cImlvbi1pb3MtbW9vbi1vdXRsaW5lXCI6IGMoNjI1NjcpLFxyXG5cImlvbi1pb3MtY2xvdWR5LW5pZ2h0XCI6IGMoNjI0NzgpLFxyXG5cImlvbi1pb3MtY2xvdWR5LW5pZ2h0LW91dGxpbmVcIjogYyg2MjQ3NyksXHJcblwiaW9uLWFuZHJvaWQtYXJyb3ctdXBcIjogYyg2MjMxMCksXHJcblwiaW9uLWFuZHJvaWQtYXJyb3ctZm9yd2FyZFwiOiBjKDYyMjIzKSxcclxuXCJpb24tYW5kcm9pZC1hcnJvdy1kb3duXCI6IGMoNjIzMDEpLFxyXG5cImlvbi1hbmRyb2lkLWFycm93LWJhY2tcIjogYyg2MjE1NCksXHJcblwiaW9uLWFuZHJvaWQtYXJyb3ctZHJvcHVwXCI6IGMoNjIzMDkpLFxyXG5cImlvbi1hbmRyb2lkLWFycm93LWRyb3B1cC1jaXJjbGVcIjogYyg2MjMwOCksXHJcblwiaW9uLWFuZHJvaWQtYXJyb3ctZHJvcHJpZ2h0XCI6IGMoNjIzMDcpLFxyXG5cImlvbi1hbmRyb2lkLWFycm93LWRyb3ByaWdodC1jaXJjbGVcIjogYyg2MjMwNiksXHJcblwiaW9uLWFuZHJvaWQtYXJyb3ctZHJvcGRvd25cIjogYyg2MjMwMyksXHJcblwiaW9uLWFuZHJvaWQtYXJyb3ctZHJvcGRvd24tY2lyY2xlXCI6IGMoNjIzMDIpLFxyXG5cImlvbi1hbmRyb2lkLWFycm93LWRyb3BsZWZ0XCI6IGMoNjIzMDUpLFxyXG5cImlvbi1hbmRyb2lkLWFycm93LWRyb3BsZWZ0LWNpcmNsZVwiOiBjKDYyMzA0KSxcclxuXCJpb24tYW5kcm9pZC1hZGRcIjogYyg2MjE1MSksXHJcblwiaW9uLWFuZHJvaWQtYWRkLWNpcmNsZVwiOiBjKDYyMjk3KSxcclxuXCJpb24tYW5kcm9pZC1yZW1vdmVcIjogYyg2MjE5NiksXHJcblwiaW9uLWFuZHJvaWQtcmVtb3ZlLWNpcmNsZVwiOiBjKDYyMzc3KSxcclxuXCJpb24tYW5kcm9pZC1jbG9zZVwiOiBjKDYyMTY3KSxcclxuXCJpb24tYW5kcm9pZC1jYW5jZWxcIjogYyg2MjMxOCksXHJcblwiaW9uLWFuZHJvaWQtcmFkaW8tYnV0dG9uLW9mZlwiOiBjKDYyMzc0KSxcclxuXCJpb24tYW5kcm9pZC1yYWRpby1idXR0b24tb25cIjogYyg2MjM3NSksXHJcblwiaW9uLWFuZHJvaWQtY2hlY2ttYXJrLWNpcmNsZVwiOiBjKDYyMzI1KSxcclxuXCJpb24tYW5kcm9pZC1jaGVja2JveC1vdXRsaW5lLWJsYW5rXCI6IGMoNjIzMjIpLFxyXG5cImlvbi1hbmRyb2lkLWNoZWNrYm94LW91dGxpbmVcIjogYyg2MjMyMyksXHJcblwiaW9uLWFuZHJvaWQtY2hlY2tib3gtYmxhbmtcIjogYyg2MjMyMSksXHJcblwiaW9uLWFuZHJvaWQtY2hlY2tib3hcIjogYyg2MjMyNCksXHJcblwiaW9uLWFuZHJvaWQtZG9uZVwiOiBjKDYyMzM5KSxcclxuXCJpb24tYW5kcm9pZC1kb25lLWFsbFwiOiBjKDYyMzM4KSxcclxuXCJpb24tYW5kcm9pZC1tZW51XCI6IGMoNjIzNTYpLFxyXG5cImlvbi1hbmRyb2lkLW1vcmUtaG9yaXpvbnRhbFwiOiBjKDYyMzU4KSxcclxuXCJpb24tYW5kcm9pZC1tb3JlLXZlcnRpY2FsXCI6IGMoNjIzNTkpLFxyXG5cImlvbi1hbmRyb2lkLXJlZnJlc2hcIjogYyg2MjM3NiksXHJcblwiaW9uLWFuZHJvaWQtc3luY1wiOiBjKDYyMzg1KSxcclxuXCJpb24tYW5kcm9pZC13aWZpXCI6IGMoNjIyMTMpLFxyXG5cImlvbi1hbmRyb2lkLWNhbGxcIjogYyg2MjE2MiksXHJcblwiaW9uLWFuZHJvaWQtYXBwc1wiOiBjKDYyMzAwKSxcclxuXCJpb24tYW5kcm9pZC1zZXR0aW5nc1wiOiBjKDYyMTk5KSxcclxuXCJpb24tYW5kcm9pZC1vcHRpb25zXCI6IGMoNjIzNjUpLFxyXG5cImlvbi1hbmRyb2lkLWZ1bm5lbFwiOiBjKDYyMzQ3KSxcclxuXCJpb24tYW5kcm9pZC1zZWFyY2hcIjogYyg2MjE5NyksXHJcblwiaW9uLWFuZHJvaWQtaG9tZVwiOiBjKDYyMzUxKSxcclxuXCJpb24tYW5kcm9pZC1jbG91ZC1vdXRsaW5lXCI6IGMoNjIzMjkpLFxyXG5cImlvbi1hbmRyb2lkLWNsb3VkXCI6IGMoNjIzMzApLFxyXG5cImlvbi1hbmRyb2lkLWRvd25sb2FkXCI6IGMoNjIxNzMpLFxyXG5cImlvbi1hbmRyb2lkLXVwbG9hZFwiOiBjKDYyMzkwKSxcclxuXCJpb24tYW5kcm9pZC1jbG91ZC1kb25lXCI6IGMoNjIzMjgpLFxyXG5cImlvbi1hbmRyb2lkLWNsb3VkLWNpcmNsZVwiOiBjKDYyMzI3KSxcclxuXCJpb24tYW5kcm9pZC1mYXZvcml0ZS1vdXRsaW5lXCI6IGMoNjIzNDMpLFxyXG5cImlvbi1hbmRyb2lkLWZhdm9yaXRlXCI6IGMoNjIzNDQpLFxyXG5cImlvbi1hbmRyb2lkLXN0YXItb3V0bGluZVwiOiBjKDYyMzgyKSxcclxuXCJpb24tYW5kcm9pZC1zdGFyLWhhbGZcIjogYyg2MjM4MSksXHJcblwiaW9uLWFuZHJvaWQtc3RhclwiOiBjKDYyMjA0KSxcclxuXCJpb24tYW5kcm9pZC1jYWxlbmRhclwiOiBjKDYyMTYxKSxcclxuXCJpb24tYW5kcm9pZC1hbGFybS1jbG9ja1wiOiBjKDYyMjk4KSxcclxuXCJpb24tYW5kcm9pZC10aW1lXCI6IGMoNjIzODcpLFxyXG5cImlvbi1hbmRyb2lkLXN0b3B3YXRjaFwiOiBjKDYyMjA1KSxcclxuXCJpb24tYW5kcm9pZC13YXRjaFwiOiBjKDYyMzk3KSxcclxuXCJpb24tYW5kcm9pZC1sb2NhdGVcIjogYyg2MjE4NSksXHJcblwiaW9uLWFuZHJvaWQtbmF2aWdhdGVcIjogYyg2MjM2MCksXHJcblwiaW9uLWFuZHJvaWQtcGluXCI6IGMoNjIzNzEpLFxyXG5cImlvbi1hbmRyb2lkLWNvbXBhc3NcIjogYyg2MjMzMiksXHJcblwiaW9uLWFuZHJvaWQtbWFwXCI6IGMoNjIzNTUpLFxyXG5cImlvbi1hbmRyb2lkLXdhbGtcIjogYyg2MjM5NSksXHJcblwiaW9uLWFuZHJvaWQtYmljeWNsZVwiOiBjKDYyMzEzKSxcclxuXCJpb24tYW5kcm9pZC1jYXJcIjogYyg2MjMxOSksXHJcblwiaW9uLWFuZHJvaWQtYnVzXCI6IGMoNjIzMTcpLFxyXG5cImlvbi1hbmRyb2lkLXN1YndheVwiOiBjKDYyMzgzKSxcclxuXCJpb24tYW5kcm9pZC10cmFpblwiOiBjKDYyMzg4KSxcclxuXCJpb24tYW5kcm9pZC1ib2F0XCI6IGMoNjIzMTQpLFxyXG5cImlvbi1hbmRyb2lkLXBsYW5lXCI6IGMoNjIzNzIpLFxyXG5cImlvbi1hbmRyb2lkLXJlc3RhdXJhbnRcIjogYyg2MjM3OCksXHJcblwiaW9uLWFuZHJvaWQtYmFyXCI6IGMoNjIzMTIpLFxyXG5cImlvbi1hbmRyb2lkLWNhcnRcIjogYyg2MjMyMCksXHJcblwiaW9uLWFuZHJvaWQtY2FtZXJhXCI6IGMoNjIxNjMpLFxyXG5cImlvbi1hbmRyb2lkLWltYWdlXCI6IGMoNjIxODApLFxyXG5cImlvbi1hbmRyb2lkLWZpbG1cIjogYyg2MjM0NSksXHJcblwiaW9uLWFuZHJvaWQtY29sb3ItcGFsZXR0ZVwiOiBjKDYyMzMxKSxcclxuXCJpb24tYW5kcm9pZC1jcmVhdGVcIjogYyg2MjMzNCksXHJcblwiaW9uLWFuZHJvaWQtbWFpbFwiOiBjKDYyMTg3KSxcclxuXCJpb24tYW5kcm9pZC1kcmFmdHNcIjogYyg2MjM0MCksXHJcblwiaW9uLWFuZHJvaWQtc2VuZFwiOiBjKDYyMTk4KSxcclxuXCJpb24tYW5kcm9pZC1hcmNoaXZlXCI6IGMoNjIxNTMpLFxyXG5cImlvbi1hbmRyb2lkLWRlbGV0ZVwiOiBjKDYyMzM1KSxcclxuXCJpb24tYW5kcm9pZC1hdHRhY2hcIjogYyg2MjMxMSksXHJcblwiaW9uLWFuZHJvaWQtc2hhcmVcIjogYyg2MjIwMCksXHJcblwiaW9uLWFuZHJvaWQtc2hhcmUtYWx0XCI6IGMoNjIzODApLFxyXG5cImlvbi1hbmRyb2lkLWJvb2ttYXJrXCI6IGMoNjIzMTUpLFxyXG5cImlvbi1hbmRyb2lkLWRvY3VtZW50XCI6IGMoNjIzMzcpLFxyXG5cImlvbi1hbmRyb2lkLWNsaXBib2FyZFwiOiBjKDYyMzI2KSxcclxuXCJpb24tYW5kcm9pZC1saXN0XCI6IGMoNjIzNTMpLFxyXG5cImlvbi1hbmRyb2lkLWZvbGRlci1vcGVuXCI6IGMoNjIzNDYpLFxyXG5cImlvbi1hbmRyb2lkLWZvbGRlclwiOiBjKDYyMTc2KSxcclxuXCJpb24tYW5kcm9pZC1wcmludFwiOiBjKDYyMzczKSxcclxuXCJpb24tYW5kcm9pZC1vcGVuXCI6IGMoNjIzNjQpLFxyXG5cImlvbi1hbmRyb2lkLWV4aXRcIjogYyg2MjM0MSksXHJcblwiaW9uLWFuZHJvaWQtY29udHJhY3RcIjogYyg2MjMzMyksXHJcblwiaW9uLWFuZHJvaWQtZXhwYW5kXCI6IGMoNjIzNDIpLFxyXG5cImlvbi1hbmRyb2lkLWdsb2JlXCI6IGMoNjIzNDgpLFxyXG5cImlvbi1hbmRyb2lkLWNoYXRcIjogYyg2MjE2NCksXHJcblwiaW9uLWFuZHJvaWQtdGV4dHNtc1wiOiBjKDYyMzg2KSxcclxuXCJpb24tYW5kcm9pZC1oYW5nb3V0XCI6IGMoNjIzNDkpLFxyXG5cImlvbi1hbmRyb2lkLWhhcHB5XCI6IGMoNjIzNTApLFxyXG5cImlvbi1hbmRyb2lkLXNhZFwiOiBjKDYyMzc5KSxcclxuXCJpb24tYW5kcm9pZC1wZXJzb25cIjogYyg2MjM2OCksXHJcblwiaW9uLWFuZHJvaWQtcGVvcGxlXCI6IGMoNjIzNjYpLFxyXG5cImlvbi1hbmRyb2lkLXBlcnNvbi1hZGRcIjogYyg2MjM2NyksXHJcblwiaW9uLWFuZHJvaWQtY29udGFjdFwiOiBjKDYyMTY4KSxcclxuXCJpb24tYW5kcm9pZC1jb250YWN0c1wiOiBjKDYyMTY5KSxcclxuXCJpb24tYW5kcm9pZC1wbGF5c3RvcmVcIjogYyg2MjE5MiksXHJcblwiaW9uLWFuZHJvaWQtbG9ja1wiOiBjKDYyMzU0KSxcclxuXCJpb24tYW5kcm9pZC11bmxvY2tcIjogYyg2MjM4OSksXHJcblwiaW9uLWFuZHJvaWQtbWljcm9waG9uZVwiOiBjKDYyMTg4KSxcclxuXCJpb24tYW5kcm9pZC1taWNyb3Bob25lLW9mZlwiOiBjKDYyMzU3KSxcclxuXCJpb24tYW5kcm9pZC1ub3RpZmljYXRpb25zLW5vbmVcIjogYyg2MjM2MSksXHJcblwiaW9uLWFuZHJvaWQtbm90aWZpY2F0aW9uc1wiOiBjKDYyMzYzKSxcclxuXCJpb24tYW5kcm9pZC1ub3RpZmljYXRpb25zLW9mZlwiOiBjKDYyMzYyKSxcclxuXCJpb24tYW5kcm9pZC12b2x1bWUtbXV0ZVwiOiBjKDYyMzkyKSxcclxuXCJpb24tYW5kcm9pZC12b2x1bWUtZG93blwiOiBjKDYyMzkxKSxcclxuXCJpb24tYW5kcm9pZC12b2x1bWUtdXBcIjogYyg2MjM5NCksXHJcblwiaW9uLWFuZHJvaWQtdm9sdW1lLW9mZlwiOiBjKDYyMzkzKSxcclxuXCJpb24tYW5kcm9pZC1oYW5kXCI6IGMoNjIxNzkpLFxyXG5cImlvbi1hbmRyb2lkLWRlc2t0b3BcIjogYyg2MjMzNiksXHJcblwiaW9uLWFuZHJvaWQtbGFwdG9wXCI6IGMoNjIzNTIpLFxyXG5cImlvbi1hbmRyb2lkLXBob25lLXBvcnRyYWl0XCI6IGMoNjIzNzApLFxyXG5cImlvbi1hbmRyb2lkLXBob25lLWxhbmRzY2FwZVwiOiBjKDYyMzY5KSxcclxuXCJpb24tYW5kcm9pZC1idWxiXCI6IGMoNjIzMTYpLFxyXG5cImlvbi1hbmRyb2lkLXN1bm55XCI6IGMoNjIzODQpLFxyXG5cImlvbi1hbmRyb2lkLWFsZXJ0XCI6IGMoNjIyOTkpLFxyXG5cImlvbi1hbmRyb2lkLXdhcm5pbmdcIjogYyg2MjM5NiksXHJcblwiaW9uLXNvY2lhbC10d2l0dGVyXCI6IGMoNjIwMTkpLFxyXG5cImlvbi1zb2NpYWwtdHdpdHRlci1vdXRsaW5lXCI6IGMoNjIwMTgpLFxyXG5cImlvbi1zb2NpYWwtZmFjZWJvb2tcIjogYyg2MjAwMSksXHJcblwiaW9uLXNvY2lhbC1mYWNlYm9vay1vdXRsaW5lXCI6IGMoNjIwMDApLFxyXG5cImlvbi1zb2NpYWwtZ29vZ2xlcGx1c1wiOiBjKDYyMDA1KSxcclxuXCJpb24tc29jaWFsLWdvb2dsZXBsdXMtb3V0bGluZVwiOiBjKDYyMDA0KSxcclxuXCJpb24tc29jaWFsLWdvb2dsZVwiOiBjKDYyMjg3KSxcclxuXCJpb24tc29jaWFsLWdvb2dsZS1vdXRsaW5lXCI6IGMoNjIyODYpLFxyXG5cImlvbi1zb2NpYWwtZHJpYmJibGVcIjogYyg2MTk5NyksXHJcblwiaW9uLXNvY2lhbC1kcmliYmJsZS1vdXRsaW5lXCI6IGMoNjE5OTYpLFxyXG5cImlvbi1zb2NpYWwtb2N0b2NhdFwiOiBjKDYyNjk2KSxcclxuXCJpb24tc29jaWFsLWdpdGh1YlwiOiBjKDYyMDAzKSxcclxuXCJpb24tc29jaWFsLWdpdGh1Yi1vdXRsaW5lXCI6IGMoNjIwMDIpLFxyXG5cImlvbi1zb2NpYWwtaW5zdGFncmFtXCI6IGMoNjIyODkpLFxyXG5cImlvbi1zb2NpYWwtaW5zdGFncmFtLW91dGxpbmVcIjogYyg2MjI4OCksXHJcblwiaW9uLXNvY2lhbC13aGF0c2FwcFwiOiBjKDYyNzA0KSxcclxuXCJpb24tc29jaWFsLXdoYXRzYXBwLW91dGxpbmVcIjogYyg2MjcwMyksXHJcblwiaW9uLXNvY2lhbC1zbmFwY2hhdFwiOiBjKDYyNzAwKSxcclxuXCJpb24tc29jaWFsLXNuYXBjaGF0LW91dGxpbmVcIjogYyg2MjY5OSksXHJcblwiaW9uLXNvY2lhbC1mb3Vyc3F1YXJlXCI6IGMoNjIyODUpLFxyXG5cImlvbi1zb2NpYWwtZm91cnNxdWFyZS1vdXRsaW5lXCI6IGMoNjIyODQpLFxyXG5cImlvbi1zb2NpYWwtcGludGVyZXN0XCI6IGMoNjIxMjkpLFxyXG5cImlvbi1zb2NpYWwtcGludGVyZXN0LW91dGxpbmVcIjogYyg2MjEyOCksXHJcblwiaW9uLXNvY2lhbC1yc3NcIjogYyg2MjAxMyksXHJcblwiaW9uLXNvY2lhbC1yc3Mtb3V0bGluZVwiOiBjKDYyMDEyKSxcclxuXCJpb24tc29jaWFsLXR1bWJsclwiOiBjKDYyMDE3KSxcclxuXCJpb24tc29jaWFsLXR1bWJsci1vdXRsaW5lXCI6IGMoNjIwMTYpLFxyXG5cImlvbi1zb2NpYWwtd29yZHByZXNzXCI6IGMoNjIwMjUpLFxyXG5cImlvbi1zb2NpYWwtd29yZHByZXNzLW91dGxpbmVcIjogYyg2MjAyNCksXHJcblwiaW9uLXNvY2lhbC1yZWRkaXRcIjogYyg2MjAxMSksXHJcblwiaW9uLXNvY2lhbC1yZWRkaXQtb3V0bGluZVwiOiBjKDYyMDEwKSxcclxuXCJpb24tc29jaWFsLWhhY2tlcm5ld3NcIjogYyg2MjAwNyksXHJcblwiaW9uLXNvY2lhbC1oYWNrZXJuZXdzLW91dGxpbmVcIjogYyg2MjAwNiksXHJcblwiaW9uLXNvY2lhbC1kZXNpZ25lcm5ld3NcIjogYyg2MTk5NSksXHJcblwiaW9uLXNvY2lhbC1kZXNpZ25lcm5ld3Mtb3V0bGluZVwiOiBjKDYxOTk0KSxcclxuXCJpb24tc29jaWFsLXlhaG9vXCI6IGMoNjIwMjcpLFxyXG5cImlvbi1zb2NpYWwteWFob28tb3V0bGluZVwiOiBjKDYyMDI2KSxcclxuXCJpb24tc29jaWFsLWJ1ZmZlclwiOiBjKDYxOTkzKSxcclxuXCJpb24tc29jaWFsLWJ1ZmZlci1vdXRsaW5lXCI6IGMoNjE5OTIpLFxyXG5cImlvbi1zb2NpYWwtc2t5cGVcIjogYyg2MjAxNSksXHJcblwiaW9uLXNvY2lhbC1za3lwZS1vdXRsaW5lXCI6IGMoNjIwMTQpLFxyXG5cImlvbi1zb2NpYWwtbGlua2VkaW5cIjogYyg2MjAwOSksXHJcblwiaW9uLXNvY2lhbC1saW5rZWRpbi1vdXRsaW5lXCI6IGMoNjIwMDgpLFxyXG5cImlvbi1zb2NpYWwtdmltZW9cIjogYyg2MjAyMSksXHJcblwiaW9uLXNvY2lhbC12aW1lby1vdXRsaW5lXCI6IGMoNjIwMjApLFxyXG5cImlvbi1zb2NpYWwtdHdpdGNoXCI6IGMoNjI3MDIpLFxyXG5cImlvbi1zb2NpYWwtdHdpdGNoLW91dGxpbmVcIjogYyg2MjcwMSksXHJcblwiaW9uLXNvY2lhbC15b3V0dWJlXCI6IGMoNjIwMjkpLFxyXG5cImlvbi1zb2NpYWwteW91dHViZS1vdXRsaW5lXCI6IGMoNjIwMjgpLFxyXG5cImlvbi1zb2NpYWwtZHJvcGJveFwiOiBjKDYxOTk5KSxcclxuXCJpb24tc29jaWFsLWRyb3Bib3gtb3V0bGluZVwiOiBjKDYxOTk4KSxcclxuXCJpb24tc29jaWFsLWFwcGxlXCI6IGMoNjE5OTEpLFxyXG5cImlvbi1zb2NpYWwtYXBwbGUtb3V0bGluZVwiOiBjKDYxOTkwKSxcclxuXCJpb24tc29jaWFsLWFuZHJvaWRcIjogYyg2MTk4OSksXHJcblwiaW9uLXNvY2lhbC1hbmRyb2lkLW91dGxpbmVcIjogYyg2MTk4OCksXHJcblwiaW9uLXNvY2lhbC13aW5kb3dzXCI6IGMoNjIwMjMpLFxyXG5cImlvbi1zb2NpYWwtd2luZG93cy1vdXRsaW5lXCI6IGMoNjIwMjIpLFxyXG5cImlvbi1zb2NpYWwtaHRtbDVcIjogYyg2MjY5MSksXHJcblwiaW9uLXNvY2lhbC1odG1sNS1vdXRsaW5lXCI6IGMoNjI2OTApLFxyXG5cImlvbi1zb2NpYWwtY3NzM1wiOiBjKDYyNjg3KSxcclxuXCJpb24tc29jaWFsLWNzczMtb3V0bGluZVwiOiBjKDYyNjg2KSxcclxuXCJpb24tc29jaWFsLWphdmFzY3JpcHRcIjogYyg2MjY5MyksXHJcblwiaW9uLXNvY2lhbC1qYXZhc2NyaXB0LW91dGxpbmVcIjogYyg2MjY5MiksXHJcblwiaW9uLXNvY2lhbC1hbmd1bGFyXCI6IGMoNjI2ODEpLFxyXG5cImlvbi1zb2NpYWwtYW5ndWxhci1vdXRsaW5lXCI6IGMoNjI2ODApLFxyXG5cImlvbi1zb2NpYWwtbm9kZWpzXCI6IGMoNjI2OTUpLFxyXG5cImlvbi1zb2NpYWwtc2Fzc1wiOiBjKDYyNjk4KSxcclxuXCJpb24tc29jaWFsLXB5dGhvblwiOiBjKDYyNjk3KSxcclxuXCJpb24tc29jaWFsLWNocm9tZVwiOiBjKDYyNjgzKSxcclxuXCJpb24tc29jaWFsLWNocm9tZS1vdXRsaW5lXCI6IGMoNjI2ODIpLFxyXG5cImlvbi1zb2NpYWwtY29kZXBlblwiOiBjKDYyNjg1KSxcclxuXCJpb24tc29jaWFsLWNvZGVwZW4tb3V0bGluZVwiOiBjKDYyNjg0KSxcclxuXCJpb24tc29jaWFsLW1hcmtkb3duXCI6IGMoNjI2OTQpLFxyXG5cImlvbi1zb2NpYWwtdHV4XCI6IGMoNjIxNDkpLFxyXG5cImlvbi1zb2NpYWwtZnJlZWJzZC1kZXZpbFwiOiBjKDYyMTQ4KSxcclxuXCJpb24tc29jaWFsLXVzZFwiOiBjKDYyMjkxKSxcclxuXCJpb24tc29jaWFsLXVzZC1vdXRsaW5lXCI6IGMoNjIyOTApLFxyXG5cImlvbi1zb2NpYWwtYml0Y29pblwiOiBjKDYyMTI3KSxcclxuXCJpb24tc29jaWFsLWJpdGNvaW4tb3V0bGluZVwiOiBjKDYyMTI2KSxcclxuXCJpb24tc29jaWFsLXllblwiOiBjKDYyNzA2KSxcclxuXCJpb24tc29jaWFsLXllbi1vdXRsaW5lXCI6IGMoNjI3MDUpLFxyXG5cImlvbi1zb2NpYWwtZXVyb1wiOiBjKDYyNjg5KSxcclxuXCJpb24tc29jaWFsLWV1cm8tb3V0bGluZVwiOiBjKDYyNjg4KVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgaWNvbnM7XHJcbiIsImNvbnN0IGdldFN0b3JhZ2UgPSAoc3RvcmFnZSkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZWFkKG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBzdG9yYWdlLmdldEl0ZW0obmFtZSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB3cml0ZShuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oXHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXMobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZS5nZXRJdGVtKG5hbWUpICE9PSBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlKG5hbWUpIHtcclxuICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKG5hbWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXIoKSB7XHJcbiAgICAgICAgICAgIHN0b3JhZ2UuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5cclxud2luZG93LkFwcFNldHRpbmdzID0gZ2V0U3RvcmFnZShsb2NhbFN0b3JhZ2UpO1xyXG53aW5kb3cuQXBwU2Vzc2lvbiA9IGdldFN0b3JhZ2Uoc2Vzc2lvblN0b3JhZ2UpO1xyXG4iLCJjb25zdCBjc3NOb01lYXN1cmVtZW50ID0gbmV3IFNldChbXHJcbiAgICBcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCIsXHJcbiAgICBcImJveEZsZXhcIixcclxuICAgIFwiYm94RmxleEdyb3VwXCIsXHJcbiAgICBcImJveE9yZGluYWxHcm91cFwiLFxyXG4gICAgXCJjb2x1bW5Db3VudFwiLFxyXG4gICAgXCJmaWxsT3BhY2l0eVwiLFxyXG4gICAgXCJmbGV4XCIsXHJcbiAgICBcImZsZXhHcm93XCIsXHJcbiAgICBcImZsZXhQb3NpdGl2ZVwiLFxyXG4gICAgXCJmbGV4U2hyaW5rXCIsXHJcbiAgICBcImZsZXhOZWdhdGl2ZVwiLFxyXG4gICAgXCJmbGV4T3JkZXJcIixcclxuICAgIFwiZm9udFdlaWdodFwiLFxyXG4gICAgXCJsaW5lQ2xhbXBcIixcclxuICAgIFwibGluZUhlaWdodFwiLFxyXG4gICAgXCJvcGFjaXR5XCIsXHJcbiAgICBcIm9yZGVyXCIsXHJcbiAgICBcIm9ycGhhbnNcIixcclxuICAgIFwic3RvcE9wYWNpdHlcIixcclxuICAgIFwic3Ryb2tlRGFzaG9mZnNldFwiLFxyXG4gICAgXCJzdHJva2VPcGFjaXR5XCIsXHJcbiAgICBcInN0cm9rZVdpZHRoXCIsXHJcbiAgICBcInRhYlNpemVcIixcclxuICAgIFwid2lkb3dzXCIsXHJcbiAgICBcInpJbmRleFwiLFxyXG4gICAgXCJ6b29tXCJcclxuXSk7XHJcbmNvbnN0IGNzc1ByZWZpeE5hbWVzID0gbmV3IFNldChbXHJcbiAgICAndHJhbnNmb3JtJyxcclxuICAgICd0cmFuc2Zvcm1PcmlnaW4nLFxyXG4gICAgJ2JveFNoYWRvdycsXHJcbiAgICAndHJhbnNpdGlvbicsXHJcbiAgICAnYW5pbWF0aW9uJyxcclxuICAgICdhbmltYXRpb25EZWxheScsXHJcbiAgICAnYW5pbWF0aW9uRGlyZWN0aW9uJyxcclxuICAgICdhbmltYXRpb25EdXJhdGlvbicsXHJcbiAgICAnYW5pbWF0aW9uRmlsbE1vZGUnLFxyXG4gICAgJ2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JyxcclxuICAgICdhbmltYXRpb25OYW1lJyxcclxuICAgICdhbmltYXRpb25QbGF5U3RhdGUnLFxyXG4gICAgJ2FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uJyxcclxuICAgICd1c2VyU2VsZWN0JyxcclxuICAgICdqdXN0aWZ5Q29udGVudCcsXHJcbiAgICAnYWxpZ25JdGVtcycsXHJcbiAgICAnZmxleFdyYXAnLFxyXG5dKTtcclxuY29uc3QgY3NzUHJlZml4ZXMgPSBbJy13ZWJraXQtJywgJy1tb3otJywgJy1tcy0nLCAnLW8tJywgJyddO1xyXG5cclxuY29uc3QgZ2V0Q1NTVmFsdWUgPSAocHJvcCwgdmFsdWUpID0+IHtcclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUoKTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAodmFsdWUgPT4gZ2V0Q1NTVmFsdWUocHJvcCwgdmFsdWUpWzBdKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGNzc05vTWVhc3VyZW1lbnQuaGFzKHByb3ApID09PSBmYWxzZSkge1xyXG4gICAgICAgIHZhbHVlICs9IFwicHhcIjtcclxuICAgIH1cclxuICAgIHJldHVybiBbdmFsdWVdO1xyXG59O1xyXG5cclxuY29uc3QgZ2VuQ1NTID0gKGRlZnMsIHRhYnMgPSAwKSA9PiB7XHJcbiAgICBjb25zdCBzcGFjZSA9ICdcXHQnLnJlcGVhdCh0YWJzKTtcclxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhkZWZzKS5yZWR1Y2UoXHJcbiAgICAgICAgKGNzcywgW3NlbGVjdG9yLCBjc3NQcm9wc10pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IE9iamVjdC5lbnRyaWVzKGNzc1Byb3BzKS5yZWR1Y2UoXHJcbiAgICAgICAgICAgICAgICAoY29udGVudEFycmF5LCBbcHJvcE5hbWUsIHByb3BWYWx1ZV0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpID09PSBmYWxzZSAmJiB0eXBlb2YgcHJvcFZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyA9IFtnZW5DU1Moe1twcm9wTmFtZV06IHByb3BWYWx1ZX0sIHRhYnMgKyAxKV07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRDU1NWYWx1ZShwcm9wTmFtZSwgcHJvcFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3NzUHJvcE5hbWUgPSBwcm9wTmFtZS5yZXBsYWNlKC9bQS1aXS9nLCBsZXR0ZXIgPT4gJy0nICsgbGV0dGVyLnRvTG93ZXJDYXNlKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzc1ByZWZpeE5hbWVzLmhhcyhwcm9wTmFtZSkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzID0gY3NzUHJlZml4ZXMubWFwKHByZWZpeCA9PiBgJHtzcGFjZX1cXHQke3ByZWZpeH0ke2Nzc1Byb3BOYW1lfTogJHt2YWx1ZVswXX07YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyA9IHZhbHVlLm1hcCh2YWx1ZSA9PiBgJHtzcGFjZX1cXHQke2Nzc1Byb3BOYW1lfTogJHt2YWx1ZX07YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbnRlbnRBcnJheSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubGluZXNcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFtdXHJcbiAgICAgICAgICAgICkuam9pbignXFxuJyk7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rvci5zbGljZSgwLCAxMCkgPT09IFwiQGtleWZyYW1lc1wiKSB7XHJcbiAgICAgICAgICAgICAgICBjc3MucHVzaChgJHtzcGFjZX1ALXdlYmtpdC1rZXlmcmFtZXMgJHtzZWxlY3Rvci5zbGljZSgxMSl9IHtcXG4ke2NvbnRlbnR9XFxuJHtzcGFjZX19YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3NzLnB1c2goYCR7c3BhY2V9JHtzZWxlY3Rvcn0ge1xcbiR7Y29udGVudH1cXG4ke3NwYWNlfX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNzcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIFtdXHJcbiAgICApLmpvaW4oJ1xcbicpO1xyXG59O1xyXG5jb25zdCBjcmVhdGVTdHlsZVNoZWV0ID0gKCkgPT4ge1xyXG4gICAgY29uc3Qgc3R5bGVzID0ge307XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFkZFN0eWxlcyhkZWZzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBkZWZdIG9mIE9iamVjdC5lbnRyaWVzKGRlZnMpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXNbc2VsZWN0b3JdID0gZGVmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfX2luaXQoc3R5bGVUYWcpIHtcclxuICAgICAgICAgICAgc3R5bGVUYWcuaW5uZXJIVE1MID0gZ2VuQ1NTKHN0eWxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuXHJcbmNvbnN0IENTUyA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgcmdiYTogKHIsIGcsIGIsIGEpID0+IGByZ2JhKCR7cn0sICR7Z30sICR7Yn0sICR7YX0pYCxcclxuICAgIHJnYjogKHIsIGcsIGIpID0+IENTUy5yZ2JhKHIsIGcsIGIsIDEpXHJcbn0pO1xyXG5cclxuZXhwb3J0IHtjcmVhdGVTdHlsZVNoZWV0LCBnZW5DU1MsIENTU307XHJcbiIsImNvbnN0IHRoZW1lID0ge1xyXG4gICAgZ2VuZXJhbDoge1xyXG4gICAgICAgIGJveFNoYWRvdzogJzAgMnB4IDJweCAwIHJnYmEoMCwgMCwgMCwgMC4xNCksIDAgMXB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC4xMiksIDAgM3B4IDFweCAtMnB4IHJnYmEoMCwgMCwgMCwgMC4yKSdcclxuICAgIH0sXHJcbiAgICBidXR0b246IHtcclxuICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgdGhlbWU7XHJcbiIsImNvbnN0IHdhcm5pbmdGdW5jID0gZXJyb3JNZXNzYWdlID0+XHJcbiAgICAoKSA9PiBjb25zb2xlLndhcm4oZXJyb3JNZXNzYWdlKTtcclxuXHJcbndpbmRvdy5yYW5nZSA9IHtcclxuICAgIGFycmF5KHN0YXJ0LCBlbmQgPSBudWxsLCBmID0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGFyciA9IFtdO1xyXG5cclxuICAgICAgICBpZiAoZiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgZiA9IGVuZDtcclxuICAgICAgICAgICAgICAgIGVuZCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmID0gaSA9PiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgICAgICBhcnIucHVzaChmKHN0YXJ0KSk7XHJcbiAgICAgICAgICAgIHN0YXJ0ICs9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfSxcclxuICAgICpnZW4oc3RhcnQsIGVuZCA9IG51bGwsIGYgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGYgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGYgPSBlbmQ7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZiA9IGkgPT4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICAgICAgeWllbGQgZihzdGFydCk7XHJcbiAgICAgICAgICAgIHN0YXJ0ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IHtcclxuICAgIHdhcm5pbmdGdW5jXHJcbn07XHJcbiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9pcy1pdGVyYWJsZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9tYXBcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2VudHJpZXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2ZyZWV6ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5c1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvdmFsdWVzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc2V0XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIik7XG5cbnZhciBfcHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9taXNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIG5ldyBfcHJvbWlzZTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgY2FsbE5leHQgPSBzdGVwLmJpbmQobnVsbCwgXCJuZXh0XCIpO1xuICAgICAgdmFyIGNhbGxUaHJvdyA9IHN0ZXAuYmluZChudWxsLCBcInRocm93XCIpO1xuXG4gICAgICBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Byb21pc2UyLmRlZmF1bHQucmVzb2x2ZSh2YWx1ZSkudGhlbihjYWxsTmV4dCwgY2FsbFRocm93KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsTmV4dCgpO1xuICAgIH0pO1xuICB9O1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9PYmplY3QkYXNzaWduID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfT2JqZWN0JGFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfT2JqZWN0JGNyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKVtcImRlZmF1bHRcIl07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IF9PYmplY3QkY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfT2JqZWN0JHNldFByb3RvdHlwZU9mID8gX09iamVjdCRzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pc0l0ZXJhYmxlMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9nZXQtaXRlcmF0b3JcIik7XG5cbnZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSkoKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9mcm9tID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9mcm9tMi5kZWZhdWx0KShhcnIpO1xuICB9XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX1N5bWJvbCA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sXCIpW1wiZGVmYXVsdFwiXTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9XG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpcztcblxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXCJyZWdlbmVyYXRvclJ1bnRpbWVcIikgPj0gMDtcblxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuXG5pZiAoaGFkUnVudGltZSkge1xuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XG59IGVsc2Uge1xuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxuICB0cnkge1xuICAgIGRlbGV0ZSBnLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBtb2R1bGUuZXhwb3J0cywgX19lc01vZHVsZTogdHJ1ZSB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfU3ltYm9sID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2xcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgX09iamVjdCRjcmVhdGUgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGVcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgX1Byb21pc2UgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIilbXCJkZWZhdWx0XCJdO1xuXG4hKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBfU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBfU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgZ2VuZXJhdG9yID0gX09iamVjdCRjcmVhdGUoKG91dGVyRm4gfHwgR2VuZXJhdG9yKS5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvciA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgaWYgKF9PYmplY3Qkc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIF9PYmplY3Qkc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IF9PYmplY3QkY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50YCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4gU29tZSBtYXkgY29uc2lkZXIgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgdG9vXG4gIC8vIGN1dGVzeSwgYnV0IHRoZXkgYXJlIGN1cm11ZGdlb25zLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gX1Byb21pc2UucmVzb2x2ZSh2YWx1ZS5hcmcpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHwgbWV0aG9kID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCkge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmRlbGVnYXRlICYmIG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIHRoaXMuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmICh0eXBlID09PSBcImJyZWFrXCIgfHwgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fCByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4vLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxudHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB1bmRlZmluZWQpOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLkFycmF5LmZyb207IiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZScpOyIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gKGNvcmUuSlNPTiAmJiBjb3JlLkpTT04uc3RyaW5naWZ5IHx8IEpTT04uc3RyaW5naWZ5KS5hcHBseShKU09OLCBhcmd1bWVudHMpO1xufTsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzLyQuY29yZScpLk1hcDsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmFzc2lnbjsiLCJ2YXIgJCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCl7XG4gIHJldHVybiAkLmNyZWF0ZShQLCBEKTtcbn07IiwidmFyICQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkLnNldERlc2MoaXQsIGtleSwgZGVzYyk7XG59OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LmVudHJpZXM7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5mcmVlemU7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy8kLmNvcmUnKS5PYmplY3Qua2V5czsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzLyQuY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuT2JqZWN0LnZhbHVlczsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzLyQuY29yZScpLlByb21pc2U7IiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy8kLmNvcmUnKS5TZXQ7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvJC5jb3JlJykuU3ltYm9sOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuLyQuY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuLyQud2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IChPID0gT2JqZWN0KGl0KSlbVEFHXSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgaGlkZSAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIHJlZGVmaW5lQWxsICA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZS1hbGwnKVxuICAsIGN0eCAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIHN0cmljdE5ldyAgICA9IHJlcXVpcmUoJy4vJC5zdHJpY3QtbmV3JylcbiAgLCBkZWZpbmVkICAgICAgPSByZXF1aXJlKCcuLyQuZGVmaW5lZCcpXG4gICwgZm9yT2YgICAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgJGl0ZXJEZWZpbmUgID0gcmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJylcbiAgLCBzdGVwICAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1zdGVwJylcbiAgLCBJRCAgICAgICAgICAgPSByZXF1aXJlKCcuLyQudWlkJykoJ2lkJylcbiAgLCAkaGFzICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBpc09iamVjdCAgICAgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBzZXRTcGVjaWVzICAgPSByZXF1aXJlKCcuLyQuc2V0LXNwZWNpZXMnKVxuICAsIERFU0NSSVBUT1JTICA9IHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBpc09iamVjdFxuICAsIFNJWkUgICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJ1xuICAsIGlkICAgICAgICAgICA9IDA7XG5cbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighJGhhcyhpdCwgSUQpKXtcbiAgICAvLyBjYW4ndCBzZXQgaWQgdG8gZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgaWRcbiAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3Npbmcgb2JqZWN0IGlkXG4gICAgaGlkZShpdCwgSUQsICsraWQpO1xuICAvLyByZXR1cm4gb2JqZWN0IGlkIHdpdGggcHJlZml4XG4gIH0gcmV0dXJuICdPJyArIGl0W0lEXTtcbn07XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uKHRoYXQsIGtleSl7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xuICBpZihpbmRleCAhPT0gJ0YnKXJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvcihlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgIGlmKGVudHJ5LmsgPT0ga2V5KXJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgc3RyaWN0TmV3KHRoYXQsIEMsIE5BTUUpO1xuICAgICAgdGhhdC5faSA9ICQuY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2Ype1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoREVTQ1JJUFRPUlMpJC5zZXREZXNjKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGRlZmluZWQodGhpc1tTSVpFXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxuICAgICAgLCBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZihlbnRyeSl7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZighdGhhdC5fZil0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZihwcmV2KXByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZihpbmRleCAhPT0gJ0YnKXRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uKEMsIE5BTUUsIElTX01BUCl7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgICAgIHRoaXMuX3QgPSBpdGVyYXRlZDsgIC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAsIGtpbmQgID0gdGhhdC5fa1xuICAgICAgICAsIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSl7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnICwgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGZvck9mICAgPSByZXF1aXJlKCcuLyQuZm9yLW9mJylcbiAgLCBjbGFzc29mID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yT2YodGhpcywgZmFsc2UsIGFyci5wdXNoLCBhcnIpO1xuICAgIHJldHVybiBhcnI7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJCcpXG4gICwgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmZhaWxzJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZS1hbGwnKVxuICAsIGZvck9mICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmZvci1vZicpXG4gICwgc3RyaWN0TmV3ICAgICAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuLyQuaXMtb2JqZWN0JylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgaWYoIURFU0NSSVBUT1JTIHx8IHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpe1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIH0gZWxzZSB7XG4gICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCBpdGVyYWJsZSl7XG4gICAgICBzdHJpY3ROZXcodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgIHRhcmdldC5fYyA9IG5ldyBCYXNlO1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRhcmdldFtBRERFUl0sIHRhcmdldCk7XG4gICAgfSk7XG4gICAgJC5lYWNoLmNhbGwoJ2FkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzJy5zcGxpdCgnLCcpLGZ1bmN0aW9uKEtFWSl7XG4gICAgICB2YXIgSVNfQURERVIgPSBLRVkgPT0gJ2FkZCcgfHwgS0VZID09ICdzZXQnO1xuICAgICAgaWYoS0VZIGluIHByb3RvICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpaGlkZShDLnByb3RvdHlwZSwgS0VZLCBmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgaWYoIUlTX0FEREVSICYmIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpKXJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2NbS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoJ3NpemUnIGluIHByb3RvKSQuc2V0RGVzYyhDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMS4yLjYnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vJC5hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuLyQuZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmlzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07IiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciAkID0gcmVxdWlyZSgnLi8kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGtleXMgICAgICAgPSAkLmdldEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gJC5nZXRTeW1ib2xzO1xuICBpZihnZXRTeW1ib2xzKXtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG4gICAgICAsIGlzRW51bSAgPSAkLmlzRW51bVxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKWtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi8kLmNvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vJC5jdHgnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiBrZXkgaW4gdGFyZ2V0O1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihwYXJhbSl7XG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgQyA/IG5ldyBDKHBhcmFtKSA6IEMocGFyYW0pO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICBpZihJU19QUk9UTykoZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSkpW2tleV0gPSBvdXQ7XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7IC8vIHdyYXBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCJ2YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi8kLmlzLWFycmF5LWl0ZXInKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuLyQudG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCl7XG4gIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3I7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgfVxufTsiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKVxuICAsIGdldE5hbWVzICA9IHJlcXVpcmUoJy4vJCcpLmdldE5hbWVzXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ2V0TmFtZXMoaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgaWYod2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScpcmV0dXJuIGdldFdpbmRvd05hbWVzKGl0KTtcbiAgcmV0dXJuIGdldE5hbWVzKHRvSU9iamVjdChpdCkpO1xufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07IiwidmFyICQgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuLyQucHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiAkLnNldERlc2Mob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi8kLmNvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTsiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07IiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuLyQuY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2goZSl7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZihyZXQgIT09IHVuZGVmaW5lZClhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vJC5wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vJC5oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gJC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuLyQubGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi8kLml0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG8gICAgICAgPSByZXF1aXJlKCcuLyQnKS5nZXRQcm90b1xuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgbWV0aG9kcywga2V5O1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRuYXRpdmUpe1xuICAgIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvKCRkZWZhdWx0LmNhbGwobmV3IEJhc2UpKTtcbiAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgLy8gRkYgZml4XG4gICAgaWYoIUxJQlJBUlkgJiYgaGFzKHByb3RvLCBGRl9JVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgICB9XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59OyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHNhZmUgPSB0cnVlOyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7fTsiLCJ2YXIgJE9iamVjdCA9IE9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6ICAgICAkT2JqZWN0LmNyZWF0ZSxcbiAgZ2V0UHJvdG86ICAgJE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgaXNFbnVtOiAgICAge30ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gIGdldERlc2M6ICAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBzZXREZXNjOiAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICBzZXREZXNjczogICAkT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsXG4gIGdldEtleXM6ICAgICRPYmplY3Qua2V5cyxcbiAgZ2V0TmFtZXM6ICAgJE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICBnZXRTeW1ib2xzOiAkT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgZWFjaDogICAgICAgW10uZm9yRWFjaFxufTsiLCJ2YXIgJCAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuLyQudG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgbWFjcm90YXNrID0gcmVxdWlyZSgnLi8kLnRhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuLyQuY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG52YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICB2YXIgcGFyZW50LCBkb21haW4sIGZuO1xuICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSl7XG4gICAgcHJvY2Vzcy5kb21haW4gPSBudWxsO1xuICAgIHBhcmVudC5leGl0KCk7XG4gIH1cbiAgd2hpbGUoaGVhZCl7XG4gICAgZG9tYWluID0gaGVhZC5kb21haW47XG4gICAgZm4gICAgID0gaGVhZC5mbjtcbiAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgZm4oKTsgLy8gPC0gY3VycmVudGx5IHdlIHVzZSBpdCBvbmx5IGZvciBQcm9taXNlIC0gdHJ5IC8gY2F0Y2ggbm90IHJlcXVpcmVkXG4gICAgaWYoZG9tYWluKWRvbWFpbi5leGl0KCk7XG4gICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG59O1xuXG4vLyBOb2RlLmpzXG5pZihpc05vZGUpe1xuICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xuLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG59IGVsc2UgaWYoT2JzZXJ2ZXIpe1xuICB2YXIgdG9nZ2xlID0gMVxuICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAtdG9nZ2xlO1xuICB9O1xuLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2Vcbn0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbHVzaCk7XG4gIH07XG4vLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuLy8gLSBzZXRJbW1lZGlhdGVcbi8vIC0gTWVzc2FnZUNoYW5uZWxcbi8vIC0gd2luZG93LnBvc3RNZXNzYWdcbi8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4vLyAtIHNldFRpbWVvdXRcbn0gZWxzZSB7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFzYXAoZm4pe1xuICB2YXIgdGFzayA9IHtmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCwgZG9tYWluOiBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW59O1xuICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gIGlmKCFoZWFkKXtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07IiwiLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyICQgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi8kLmlvYmplY3QnKTtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBhID0gT2JqZWN0LmFzc2lnblxuICAgICwgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiBhKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKGEoe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcbiAgICAsICQkICAgID0gYXJndW1lbnRzXG4gICAgLCAkJGxlbiA9ICQkLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRLZXlzICAgID0gJC5nZXRLZXlzXG4gICAgLCBnZXRTeW1ib2xzID0gJC5nZXRTeW1ib2xzXG4gICAgLCBpc0VudW0gICAgID0gJC5pc0VudW07XG4gIHdoaWxlKCQkbGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KCQkW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH1cbiAgcmV0dXJuIFQ7XG59IDogT2JqZWN0LmFzc2lnbjsiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgY29yZSAgICA9IHJlcXVpcmUoJy4vJC5jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi8kLmZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59OyIsInZhciAkICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0JylcbiAgLCBpc0VudW0gICAgPSAkLmlzRW51bTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNFbnRyaWVzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KGl0KVxuICAgICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaSAgICAgID0gMFxuICAgICAgLCByZXN1bHQgPSBbXVxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKXtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYyl7XG4gIGZvcih2YXIga2V5IGluIHNyYylyZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICByZXR1cm4gdGFyZ2V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5oaWRlJyk7IiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KXtcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59OyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBnZXREZXNjICA9IHJlcXVpcmUoJy4vJCcpLmdldERlc2NcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi8kLmFuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbih0ZXN0LCBidWdneSwgc2V0KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vJC5jdHgnKShGdW5jdGlvbi5jYWxsLCBnZXREZXNjKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvcmUgICAgICAgID0gcmVxdWlyZSgnLi8kLmNvcmUnKVxuICAsICQgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuLyQud2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgQyA9IGNvcmVbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkkLnNldERlc2MoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTsiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi8kJykuc2V0RGVzY1xuICAsIGhhcyA9IHJlcXVpcmUoJy4vJC5oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTsiLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLyQuYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIEQpe1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yLCBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSl0aHJvdyBUeXBlRXJyb3IobmFtZSArIFwiOiB1c2UgdGhlICduZXcnIG9wZXJhdG9yIVwiKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi8kLnRvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmRvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0bmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vJC5jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdG5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vJC5pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vJC50by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vJC5kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59OyIsInZhciBzdG9yZSAgPSByZXF1aXJlKCcuLyQuc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpXG4gICwgU3ltYm9sID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpLlN5bWJvbDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFN5bWJvbCAmJiBTeW1ib2xbbmFtZV0gfHwgKFN5bWJvbCB8fCB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07IiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59OyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGdldCAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmNvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59OyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuLyQuY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi8kLndrcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLyQuY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuLyQuaXMtYXJyYXktaXRlcicpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuLyQudG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuLyQuaXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZS8qLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCovKXtcbiAgICB2YXIgTyAgICAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgQyAgICAgICA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXlcbiAgICAgICwgJCQgICAgICA9IGFyZ3VtZW50c1xuICAgICAgLCAkJGxlbiAgID0gJCQubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSAkJGxlbiA+IDEgPyAkJFsxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpbmRleCAgID0gMFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihtYXBwaW5nKW1hcGZuID0gY3R4KG1hcGZuLCAkJGxlbiA+IDIgPyAkJFsyXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4Kyspe1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvcihyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vJC5hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5yZXF1aXJlKCcuLyQuY29sbGVjdGlvbicpKCdNYXAnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTsiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogcmVxdWlyZSgnLi8kLm9iamVjdC1hc3NpZ24nKX0pOyIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24oJGZyZWV6ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpe1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUoaXQpIDogaXQ7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vJC50by1vYmplY3QnKTtcblxucmVxdWlyZSgnLi8kLm9iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbigkZ2V0UHJvdG90eXBlT2Ype1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi8kLnRvLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuLyQub2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oJGtleXMpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi8kLnNldC1wcm90bycpLnNldH0pOyIsIiIsIid1c2Ugc3RyaWN0JztcbnZhciAkICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBMSUJSQVJZICAgID0gcmVxdWlyZSgnLi8kLmxpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgPSByZXF1aXJlKCcuLyQuZ2xvYmFsJylcbiAgLCBjdHggICAgICAgID0gcmVxdWlyZSgnLi8kLmN0eCcpXG4gICwgY2xhc3NvZiAgICA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vJC5pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgPSByZXF1aXJlKCcuLyQuYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi8kLmEtZnVuY3Rpb24nKVxuICAsIHN0cmljdE5ldyAgPSByZXF1aXJlKCcuLyQuc3RyaWN0LW5ldycpXG4gICwgZm9yT2YgICAgICA9IHJlcXVpcmUoJy4vJC5mb3Itb2YnKVxuICAsIHNldFByb3RvICAgPSByZXF1aXJlKCcuLyQuc2V0LXByb3RvJykuc2V0XG4gICwgc2FtZSAgICAgICA9IHJlcXVpcmUoJy4vJC5zYW1lLXZhbHVlJylcbiAgLCBTUEVDSUVTICAgID0gcmVxdWlyZSgnLi8kLndrcycpKCdzcGVjaWVzJylcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLyQuc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgYXNhcCAgICAgICA9IHJlcXVpcmUoJy4vJC5taWNyb3Rhc2snKVxuICAsIFBST01JU0UgICAgPSAnUHJvbWlzZSdcbiAgLCBwcm9jZXNzICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2VzcydcbiAgLCBQICAgICAgICAgID0gZ2xvYmFsW1BST01JU0VdXG4gICwgV3JhcHBlcjtcblxudmFyIHRlc3RSZXNvbHZlID0gZnVuY3Rpb24oc3ViKXtcbiAgdmFyIHRlc3QgPSBuZXcgUChmdW5jdGlvbigpe30pO1xuICBpZihzdWIpdGVzdC5jb25zdHJ1Y3RvciA9IE9iamVjdDtcbiAgcmV0dXJuIFAucmVzb2x2ZSh0ZXN0KSA9PT0gdGVzdDtcbn07XG5cbnZhciBVU0VfTkFUSVZFID0gZnVuY3Rpb24oKXtcbiAgdmFyIHdvcmtzID0gZmFsc2U7XG4gIGZ1bmN0aW9uIFAyKHgpe1xuICAgIHZhciBzZWxmID0gbmV3IFAoeCk7XG4gICAgc2V0UHJvdG8oc2VsZiwgUDIucHJvdG90eXBlKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICB0cnkge1xuICAgIHdvcmtzID0gUCAmJiBQLnJlc29sdmUgJiYgdGVzdFJlc29sdmUoKTtcbiAgICBzZXRQcm90byhQMiwgUCk7XG4gICAgUDIucHJvdG90eXBlID0gJC5jcmVhdGUoUC5wcm90b3R5cGUsIHtjb25zdHJ1Y3Rvcjoge3ZhbHVlOiBQMn19KTtcbiAgICAvLyBhY3R1YWwgRmlyZWZveCBoYXMgYnJva2VuIHN1YmNsYXNzIHN1cHBvcnQsIHRlc3QgdGhhdFxuICAgIGlmKCEoUDIucmVzb2x2ZSg1KS50aGVuKGZ1bmN0aW9uKCl7fSkgaW5zdGFuY2VvZiBQMikpe1xuICAgICAgd29ya3MgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYWN0dWFsIFY4IGJ1ZywgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxNjJcbiAgICBpZih3b3JrcyAmJiByZXF1aXJlKCcuLyQuZGVzY3JpcHRvcnMnKSl7XG4gICAgICB2YXIgdGhlbmFibGVUaGVuR290dGVuID0gZmFsc2U7XG4gICAgICBQLnJlc29sdmUoJC5zZXREZXNjKHt9LCAndGhlbicsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyB0aGVuYWJsZVRoZW5Hb3R0ZW4gPSB0cnVlOyB9XG4gICAgICB9KSk7XG4gICAgICB3b3JrcyA9IHRoZW5hYmxlVGhlbkdvdHRlbjtcbiAgICB9XG4gIH0gY2F0Y2goZSl7IHdvcmtzID0gZmFsc2U7IH1cbiAgcmV0dXJuIHdvcmtzO1xufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgc2FtZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oYSwgYil7XG4gIC8vIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgaWYoTElCUkFSWSAmJiBhID09PSBQICYmIGIgPT09IFdyYXBwZXIpcmV0dXJuIHRydWU7XG4gIHJldHVybiBzYW1lKGEsIGIpO1xufTtcbnZhciBnZXRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdO1xuICByZXR1cm4gUyAhPSB1bmRlZmluZWQgPyBTIDogQztcbn07XG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKXtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24oJCRyZXNvbHZlLCAkJHJlamVjdCl7XG4gICAgaWYocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCAgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKSxcbiAgdGhpcy5yZWplY3QgID0gYUZ1bmN0aW9uKHJlamVjdClcbn07XG52YXIgcGVyZm9ybSA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihyZWNvcmQsIGlzUmVqZWN0KXtcbiAgaWYocmVjb3JkLm4pcmV0dXJuO1xuICByZWNvcmQubiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHJlY29yZC5jO1xuICBhc2FwKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcmVjb3JkLnZcbiAgICAgICwgb2sgICAgPSByZWNvcmQucyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgIGlmKCFvaylyZWNvcmQuaCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gaGFuZGxlciA9PT0gdHJ1ZSA/IHZhbHVlIDogaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgaWYocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKXtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIGNoYWluLmxlbmd0aCA9IDA7XG4gICAgcmVjb3JkLm4gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdClzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcHJvbWlzZSA9IHJlY29yZC5wXG4gICAgICAgICwgaGFuZGxlciwgY29uc29sZTtcbiAgICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgICAgaWYoaXNOb2RlKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3Ipe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSByZWNvcmQuYSA9IHVuZGVmaW5lZDtcbiAgICB9LCAxKTtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHZhciByZWNvcmQgPSBwcm9taXNlLl9kXG4gICAgLCBjaGFpbiAgPSByZWNvcmQuYSB8fCByZWNvcmQuY1xuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIGlmKHJlY29yZC5oKXJldHVybiBmYWxzZTtcbiAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmKHJlYWN0aW9uLmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0aW9uLnByb21pc2UpKXJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHJlY29yZCA9IHRoaXM7XG4gIGlmKHJlY29yZC5kKXJldHVybjtcbiAgcmVjb3JkLmQgPSB0cnVlO1xuICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxuICByZWNvcmQudiA9IHZhbHVlO1xuICByZWNvcmQucyA9IDI7XG4gIHJlY29yZC5hID0gcmVjb3JkLmMuc2xpY2UoKTtcbiAgbm90aWZ5KHJlY29yZCwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcmVjb3JkID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocmVjb3JkLmQpcmV0dXJuO1xuICByZWNvcmQuZCA9IHRydWU7XG4gIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYocmVjb3JkLnAgPT09IHZhbHVlKXRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XG4gICAgICBhc2FwKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge3I6IHJlY29yZCwgZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29yZC52ID0gdmFsdWU7XG4gICAgICByZWNvcmQucyA9IDE7XG4gICAgICBub3RpZnkocmVjb3JkLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7cjogcmVjb3JkLCBkOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighVVNFX05BVElWRSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gIFAgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIHZhciByZWNvcmQgPSB0aGlzLl9kID0ge1xuICAgICAgcDogc3RyaWN0TmV3KHRoaXMsIFAsIFBST01JU0UpLCAgICAgICAgIC8vIDwtIHByb21pc2VcbiAgICAgIGM6IFtdLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICAgIGE6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgICAgczogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgICBkOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gZG9uZVxuICAgICAgdjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICBoOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gaGFuZGxlZCByZWplY3Rpb25cbiAgICAgIG46IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHJlY29yZCwgMSksIGN0eCgkcmVqZWN0LCByZWNvcmQsIDEpKTtcbiAgICB9IGNhdGNoKGVycil7XG4gICAgICAkcmVqZWN0LmNhbGwocmVjb3JkLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgcmVxdWlyZSgnLi8kLnJlZGVmaW5lLWFsbCcpKFAucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgUCkpXG4gICAgICAgICwgcHJvbWlzZSAgPSByZWFjdGlvbi5wcm9taXNlXG4gICAgICAgICwgcmVjb3JkICAgPSB0aGlzLl9kO1xuICAgICAgcmVhY3Rpb24ub2sgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlY29yZC5jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYocmVjb3JkLmEpcmVjb3JkLmEucHVzaChyZWFjdGlvbik7XG4gICAgICBpZihyZWNvcmQucylub3RpZnkocmVjb3JkLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3RlZCl7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6IFB9KTtcbnJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpKFAsIFBST01JU0UpO1xucmVxdWlyZSgnLi8kLnNldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi8kLmNvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlamVjdCAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCB0ZXN0UmVzb2x2ZSh0cnVlKSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiBQICYmIHNhbWVDb25zdHJ1Y3Rvcih4LmNvbnN0cnVjdG9yLCB0aGlzKSlyZXR1cm4geDtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vJC5pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICBQLmFsbChpdGVyKVsnY2F0Y2gnXShmdW5jdGlvbigpe30pO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKVxuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0XG4gICAgICAsIHZhbHVlcyAgICAgPSBbXTtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCB2YWx1ZXMucHVzaCwgdmFsdWVzKTtcbiAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoXG4gICAgICAgICwgcmVzdWx0cyAgID0gQXJyYXkocmVtYWluaW5nKTtcbiAgICAgIGlmKHJlbWFpbmluZykkLmVhY2guY2FsbCh2YWx1ZXMsIGZ1bmN0aW9uKHByb21pc2UsIGluZGV4KXtcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgZWxzZSByZXNvbHZlKHJlc3VsdHMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gZ2V0Q29uc3RydWN0b3IodGhpcylcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vJC5jb2xsZWN0aW9uJykoJ1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi8kLnN0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuLyQuaXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgJCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQnKVxuICAsIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi8kLmdsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaGFzJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vJC5kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuLyQuZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vJC5yZWRlZmluZScpXG4gICwgJGZhaWxzICAgICAgICAgPSByZXF1aXJlKCcuLyQuZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi8kLnNoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIHVpZCAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLnVpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQud2tzJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vJC5rZXlvZicpXG4gICwgJG5hbWVzICAgICAgICAgPSByZXF1aXJlKCcuLyQuZ2V0LW5hbWVzJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vJC5lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi8kLmlzLWFycmF5JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi8kLnRvLWlvYmplY3QnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi8kLnByb3BlcnR5LWRlc2MnKVxuICAsIGdldERlc2MgICAgICAgID0gJC5nZXREZXNjXG4gICwgc2V0RGVzYyAgICAgICAgPSAkLnNldERlc2NcbiAgLCBfY3JlYXRlICAgICAgICA9ICQuY3JlYXRlXG4gICwgZ2V0TmFtZXMgICAgICAgPSAkbmFtZXMuZ2V0XG4gICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXG4gICwgJEpTT04gICAgICAgICAgPSBnbG9iYWwuSlNPTlxuICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG4gICwgc2V0dGVyICAgICAgICAgPSBmYWxzZVxuICAsIEhJRERFTiAgICAgICAgID0gd2tzKCdfaGlkZGVuJylcbiAgLCBpc0VudW0gICAgICAgICA9ICQuaXNFbnVtXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIHVzZU5hdGl2ZSAgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX2NyZWF0ZShzZXREZXNjKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBzZXREZXNjKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdldERlc2MoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgc2V0RGVzYyhpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylzZXREZXNjKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogc2V0RGVzYztcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sLnByb3RvdHlwZSk7XG4gIHN5bS5fayA9IHRhZztcbiAgREVTQ1JJUFRPUlMgJiYgc2V0dGVyICYmIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKXNldERlc2MoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIHNldERlc2MoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSk7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV1cbiAgICA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICB2YXIgRCA9IGdldERlc2MoaXQgPSB0b0lPYmplY3QoaXQpLCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4pcmVzdWx0LnB1c2goa2V5KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnZXROYW1lcyh0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICB2YXIgYXJncyA9IFtpdF1cbiAgICAsIGkgICAgPSAxXG4gICAgLCAkJCAgID0gYXJndW1lbnRzXG4gICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICB3aGlsZSgkJC5sZW5ndGggPiBpKWFyZ3MucHVzaCgkJFtpKytdKTtcbiAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICB9O1xuICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbn07XG52YXIgYnVnZ3lKU09OID0gJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pO1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCF1c2VOYXRpdmUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYoaXNTeW1ib2wodGhpcykpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICByZXR1cm4gd3JhcCh1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gIGlzU3ltYm9sID0gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG4gIH07XG5cbiAgJC5jcmVhdGUgICAgID0gJGNyZWF0ZTtcbiAgJC5pc0VudW0gICAgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAkLmdldERlc2MgICAgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkLnNldERlc2MgICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gICQuc2V0RGVzY3MgICA9ICRkZWZpbmVQcm9wZXJ0aWVzO1xuICAkLmdldE5hbWVzICAgPSAkbmFtZXMuZ2V0ID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gICQuZ2V0U3ltYm9scyA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vJC5saWJyYXJ5Jykpe1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG59XG5cbnZhciBzeW1ib2xTdGF0aWNzID0ge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIHJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59O1xuLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXG4vLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXG4vLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3Jcbi8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxuLy8gMTkuNC4yLjggU3ltYm9sLnJlcGxhY2Vcbi8vIDE5LjQuMi45IFN5bWJvbC5zZWFyY2hcbi8vIDE5LjQuMi4xMCBTeW1ib2wuc3BlY2llc1xuLy8gMTkuNC4yLjExIFN5bWJvbC5zcGxpdFxuLy8gMTkuNC4yLjEyIFN5bWJvbC50b1ByaW1pdGl2ZVxuLy8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xuLy8gMTkuNC4yLjE0IFN5bWJvbC51bnNjb3BhYmxlc1xuJC5lYWNoLmNhbGwoKFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLCcgK1xuICAnc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgZnVuY3Rpb24oaXQpe1xuICB2YXIgc3ltID0gd2tzKGl0KTtcbiAgc3ltYm9sU3RhdGljc1tpdF0gPSB1c2VOYXRpdmUgPyBzeW0gOiB3cmFwKHN5bSk7XG59KTtcblxuc2V0dGVyID0gdHJ1ZTtcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTeW1ib2wnLCBzeW1ib2xTdGF0aWNzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhdXNlTmF0aXZlLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghdXNlTmF0aXZlIHx8IGJ1Z2d5SlNPTiksICdKU09OJywge3N0cmluZ2lmeTogJHN0cmluZ2lmeX0pO1xuXG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdNYXAnLCB7dG9KU09OOiByZXF1aXJlKCcuLyQuY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpfSk7IiwiLy8gaHR0cDovL2dvby5nbC9Ya0JyakRcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vJC5leHBvcnQnKVxuICAsICRlbnRyaWVzID0gcmVxdWlyZSgnLi8kLm9iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCl7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7IiwiLy8gaHR0cDovL2dvby5nbC9Ya0JyakRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgJHZhbHVlcyA9IHJlcXVpcmUoJy4vJC5vYmplY3QtdG8tYXJyYXknKShmYWxzZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhpdCl7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuLyQuZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU2V0Jywge3RvSlNPTjogcmVxdWlyZSgnLi8kLmNvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKX0pOyIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpO1xuSXRlcmF0b3JzLk5vZGVMaXN0ID0gSXRlcmF0b3JzLkhUTUxDb2xsZWN0aW9uID0gSXRlcmF0b3JzLkFycmF5OyJdfQ==
